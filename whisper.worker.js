(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // node_modules/onnxruntime-common/dist/ort-common.node.js
  var require_ort_common_node = __commonJS({
    "node_modules/onnxruntime-common/dist/ort-common.node.js"(exports2) {
      (() => {
        "use strict";
        var e = { d: (t2, r2) => {
          for (var n2 in r2)
            e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
        }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        } }, t = {};
        e.r(t), e.d(t, { InferenceSession: () => c, Tensor: () => g, env: () => i, registerBackend: () => o });
        const r = {}, n = [], o = (e2, t2, o2) => {
          if (!t2 || "function" != typeof t2.init || "function" != typeof t2.createSessionHandler)
            throw new TypeError("not a valid backend");
          {
            const i2 = r[e2];
            if (void 0 === i2)
              r[e2] = { backend: t2, priority: o2 };
            else {
              if (i2.priority > o2)
                return;
              if (i2.priority === o2 && i2.backend !== t2)
                throw new Error(`cannot register backend "${e2}" using priority ${o2}`);
            }
            if (o2 >= 0) {
              const t3 = n.indexOf(e2);
              -1 !== t3 && n.splice(t3, 1);
              for (let t4 = 0; t4 < n.length; t4++)
                if (r[n[t4]].priority <= o2)
                  return void n.splice(t4, 0, e2);
              n.push(e2);
            }
          }
        }, i = new class {
          constructor() {
            this.wasm = {}, this.webgl = {}, this.logLevelInternal = "warning";
          }
          set logLevel(e2) {
            if (void 0 !== e2) {
              if ("string" != typeof e2 || -1 === ["verbose", "info", "warning", "error", "fatal"].indexOf(e2))
                throw new Error(`Unsupported logging level: ${e2}`);
              this.logLevelInternal = e2;
            }
          }
          get logLevel() {
            return this.logLevelInternal;
          }
        }(), a = "undefined" != typeof BigInt64Array && "function" == typeof BigInt64Array.from, s = "undefined" != typeof BigUint64Array && "function" == typeof BigUint64Array.from, d = /* @__PURE__ */ new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array]]), f = /* @__PURE__ */ new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]);
        a && (d.set("int64", BigInt64Array), f.set(BigInt64Array, "int64")), s && (d.set("uint64", BigUint64Array), f.set(BigUint64Array, "uint64"));
        class h {
          constructor(e2, t2, r2) {
            let n2, o2, i2;
            if ("string" == typeof e2)
              if (n2 = e2, i2 = r2, "string" === e2) {
                if (!Array.isArray(t2))
                  throw new TypeError("A string tensor's data must be a string array.");
                o2 = t2;
              } else {
                const r3 = d.get(e2);
                if (void 0 === r3)
                  throw new TypeError(`Unsupported tensor type: ${e2}.`);
                if (Array.isArray(t2))
                  o2 = r3.from(t2);
                else {
                  if (!(t2 instanceof r3))
                    throw new TypeError(`A ${n2} tensor's data must be type of ${r3}`);
                  o2 = t2;
                }
              }
            else if (i2 = t2, Array.isArray(e2)) {
              if (0 === e2.length)
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              const t3 = typeof e2[0];
              if ("string" === t3)
                n2 = "string", o2 = e2;
              else {
                if ("boolean" !== t3)
                  throw new TypeError(`Invalid element type of data array: ${t3}.`);
                n2 = "bool", o2 = Uint8Array.from(e2);
              }
            } else {
              const t3 = f.get(e2.constructor);
              if (void 0 === t3)
                throw new TypeError(`Unsupported type for tensor data: ${e2.constructor}.`);
              n2 = t3, o2 = e2;
            }
            if (void 0 === i2)
              i2 = [o2.length];
            else if (!Array.isArray(i2))
              throw new TypeError("A tensor's dims must be a number array");
            const a2 = ((e3) => {
              let t3 = 1;
              for (let r3 = 0; r3 < e3.length; r3++) {
                const n3 = e3[r3];
                if ("number" != typeof n3 || !Number.isSafeInteger(n3))
                  throw new TypeError(`dims[${r3}] must be an integer, got: ${n3}`);
                if (n3 < 0)
                  throw new RangeError(`dims[${r3}] must be a non-negative integer, got: ${n3}`);
                t3 *= n3;
              }
              return t3;
            })(i2);
            if (a2 !== o2.length)
              throw new Error(`Tensor's size(${a2}) does not match data length(${o2.length}).`);
            this.dims = i2, this.type = n2, this.data = o2, this.size = a2;
          }
          static bufferToTensor(e2, t2) {
            if (void 0 === e2)
              throw new Error("Image buffer must be defined");
            if (void 0 === t2.height || void 0 === t2.width)
              throw new Error("Image height and width must be defined");
            const { height: r2, width: n2 } = t2, o2 = t2.norm;
            let i2, a2;
            i2 = void 0 === o2 || void 0 === o2.mean ? 255 : o2.mean, a2 = void 0 === o2 || void 0 === o2.bias ? 0 : o2.bias;
            const s2 = void 0 !== t2.bitmapFormat ? t2.bitmapFormat : "RGBA", d2 = void 0 !== t2.tensorFormat && void 0 !== t2.tensorFormat ? t2.tensorFormat : "RGB", f2 = r2 * n2, g2 = "RGBA" === d2 ? new Float32Array(4 * f2) : new Float32Array(3 * f2);
            let m2 = 4, c2 = 0, l2 = 1, w2 = 2, u = 3, p = 0, y = f2, b = 2 * f2, v = -1;
            "RGB" === s2 && (m2 = 3, c2 = 0, l2 = 1, w2 = 2, u = -1), "RGBA" === d2 ? v = 3 * f2 : "RBG" === d2 ? (p = 0, b = f2, y = 2 * f2) : "BGR" === d2 && (b = 0, y = f2, p = 2 * f2);
            for (let t3 = 0; t3 < f2; t3++, c2 += m2, w2 += m2, l2 += m2, u += m2)
              g2[p++] = (e2[c2] + a2) / i2, g2[y++] = (e2[l2] + a2) / i2, g2[b++] = (e2[w2] + a2) / i2, -1 !== v && -1 !== u && (g2[v++] = (e2[u] + a2) / i2);
            return new h("float32", g2, "RGBA" === d2 ? [1, 4, r2, n2] : [1, 3, r2, n2]);
          }
          static async fromImage(e2, t2) {
            const r2 = "undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement, n2 = "undefined" != typeof ImageData && e2 instanceof ImageData, o2 = "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap, i2 = "undefined" != typeof String && (e2 instanceof String || "string" == typeof e2);
            let a2, s2 = {};
            if (r2) {
              const r3 = document.createElement("canvas"), n3 = r3.getContext("2d");
              if (null == n3)
                throw new Error("Can not access image data");
              {
                let o3 = e2.naturalHeight, i3 = e2.naturalWidth;
                if (void 0 !== t2 && void 0 !== t2.resizedHeight && void 0 !== t2.resizedWidth && (o3 = t2.resizedHeight, i3 = t2.resizedWidth), void 0 !== t2) {
                  if (s2 = t2, void 0 !== t2.tensorFormat)
                    throw new Error("Image input config format must be RGBA for HTMLImageElement");
                  if (s2.tensorFormat = "RGBA", void 0 !== t2.height && t2.height !== o3)
                    throw new Error("Image input config height doesn't match HTMLImageElement height");
                  if (s2.height = o3, void 0 !== t2.width && t2.width !== i3)
                    throw new Error("Image input config width doesn't match HTMLImageElement width");
                  s2.width = i3;
                } else
                  s2.tensorFormat = "RGBA", s2.height = o3, s2.width = i3;
                r3.width = i3, r3.height = o3, n3.drawImage(e2, 0, 0, i3, o3), a2 = n3.getImageData(0, 0, i3, o3).data;
              }
            } else {
              if (!n2) {
                if (o2) {
                  if (void 0 === t2)
                    throw new Error("Please provide image config with format for Imagebitmap");
                  if (void 0 !== t2.bitmapFormat)
                    throw new Error("Image input config format must be defined for ImageBitmap");
                  const r3 = document.createElement("canvas").getContext("2d");
                  if (null != r3) {
                    const n3 = e2.height, o3 = e2.width;
                    if (r3.drawImage(e2, 0, 0, o3, n3), a2 = r3.getImageData(0, 0, o3, n3).data, void 0 !== t2) {
                      if (void 0 !== t2.height && t2.height !== n3)
                        throw new Error("Image input config height doesn't match ImageBitmap height");
                      if (s2.height = n3, void 0 !== t2.width && t2.width !== o3)
                        throw new Error("Image input config width doesn't match ImageBitmap width");
                      s2.width = o3;
                    } else
                      s2.height = n3, s2.width = o3;
                    return h.bufferToTensor(a2, s2);
                  }
                  throw new Error("Can not access image data");
                }
                if (i2)
                  return new Promise((r3, n3) => {
                    const o3 = document.createElement("canvas"), i3 = o3.getContext("2d");
                    if (!e2 || !i3)
                      return n3();
                    const a3 = new Image();
                    a3.crossOrigin = "Anonymous", a3.src = e2, a3.onload = () => {
                      o3.width = a3.width, o3.height = a3.height, i3.drawImage(a3, 0, 0, o3.width, o3.height);
                      const e3 = i3.getImageData(0, 0, o3.width, o3.height);
                      if (void 0 !== t2) {
                        if (void 0 !== t2.height && t2.height !== o3.height)
                          throw new Error("Image input config height doesn't match ImageBitmap height");
                        if (s2.height = o3.height, void 0 !== t2.width && t2.width !== o3.width)
                          throw new Error("Image input config width doesn't match ImageBitmap width");
                        s2.width = o3.width;
                      } else
                        s2.height = o3.height, s2.width = o3.width;
                      r3(h.bufferToTensor(e3.data, s2));
                    };
                  });
                throw new Error("Input data provided is not supported - aborted tensor creation");
              }
              {
                const r3 = "RGBA";
                let n3, o3;
                if (void 0 !== t2 && void 0 !== t2.resizedWidth && void 0 !== t2.resizedHeight ? (n3 = t2.resizedHeight, o3 = t2.resizedWidth) : (n3 = e2.height, o3 = e2.width), void 0 !== t2) {
                  if (s2 = t2, void 0 !== t2.bitmapFormat && t2.bitmapFormat !== r3)
                    throw new Error("Image input config format must be RGBA for ImageData");
                  s2.bitmapFormat = "RGBA";
                } else
                  s2.bitmapFormat = "RGBA";
                if (s2.height = n3, s2.width = o3, void 0 !== t2) {
                  const t3 = document.createElement("canvas");
                  t3.width = o3, t3.height = n3;
                  const r4 = t3.getContext("2d");
                  if (null == r4)
                    throw new Error("Can not access image data");
                  r4.putImageData(e2, 0, 0), a2 = r4.getImageData(0, 0, o3, n3).data;
                } else
                  a2 = e2.data;
              }
            }
            if (void 0 !== a2)
              return h.bufferToTensor(a2, s2);
            throw new Error("Input data provided is not supported - aborted tensor creation");
          }
          toImageData(e2) {
            var t2, r2;
            const n2 = document.createElement("canvas").getContext("2d");
            let o2;
            if (null == n2)
              throw new Error("Can not access image data");
            {
              const i2 = this.dims[3], a2 = this.dims[2], s2 = this.dims[1], d2 = void 0 !== e2 && void 0 !== e2.format ? e2.format : "RGB", f2 = void 0 !== e2 && void 0 !== (null === (t2 = e2.norm) || void 0 === t2 ? void 0 : t2.mean) ? e2.norm.mean : 255, h2 = void 0 !== e2 && void 0 !== (null === (r2 = e2.norm) || void 0 === r2 ? void 0 : r2.bias) ? e2.norm.bias : 0, g2 = a2 * i2;
              if (void 0 !== e2) {
                if (void 0 !== e2.height && e2.height !== a2)
                  throw new Error("Image output config height doesn't match tensor height");
                if (void 0 !== e2.width && e2.width !== i2)
                  throw new Error("Image output config width doesn't match tensor width");
                if (void 0 !== e2.format && 4 === s2 && "RGBA" !== e2.format || 3 === s2 && "RGB" !== e2.format && "BGR" !== e2.format)
                  throw new Error("Tensor format doesn't match input tensor dims");
              }
              const m2 = 4;
              let c2 = 0, l2 = 1, w2 = 2, u = 3, p = 0, y = g2, b = 2 * g2, v = -1;
              "RGBA" === d2 ? (p = 0, y = g2, b = 2 * g2, v = 3 * g2) : "RGB" === d2 ? (p = 0, y = g2, b = 2 * g2) : "RBG" === d2 && (p = 0, b = g2, y = 2 * g2), o2 = n2.createImageData(i2, a2);
              for (let e3 = 0; e3 < a2 * i2; c2 += m2, l2 += m2, w2 += m2, u += m2, e3++)
                o2.data[c2] = (this.data[p++] - h2) * f2, o2.data[l2] = (this.data[y++] - h2) * f2, o2.data[w2] = (this.data[b++] - h2) * f2, o2.data[u] = -1 === v ? 255 : (this.data[v++] - h2) * f2;
            }
            return o2;
          }
          reshape(e2) {
            return new h(this.type, this.data, e2);
          }
        }
        const g = h;
        class m {
          constructor(e2) {
            this.handler = e2;
          }
          async run(e2, t2, r2) {
            const n2 = {};
            let o2 = {};
            if ("object" != typeof e2 || null === e2 || e2 instanceof g || Array.isArray(e2))
              throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
            let i2 = true;
            if ("object" == typeof t2) {
              if (null === t2)
                throw new TypeError("Unexpected argument[1]: cannot be null.");
              if (t2 instanceof g)
                throw new TypeError("'fetches' cannot be a Tensor");
              if (Array.isArray(t2)) {
                if (0 === t2.length)
                  throw new TypeError("'fetches' cannot be an empty array.");
                i2 = false;
                for (const e3 of t2) {
                  if ("string" != typeof e3)
                    throw new TypeError("'fetches' must be a string array or an object.");
                  if (-1 === this.outputNames.indexOf(e3))
                    throw new RangeError(`'fetches' contains invalid output name: ${e3}.`);
                  n2[e3] = null;
                }
                if ("object" == typeof r2 && null !== r2)
                  o2 = r2;
                else if (void 0 !== r2)
                  throw new TypeError("'options' must be an object.");
              } else {
                let e3 = false;
                const a3 = Object.getOwnPropertyNames(t2);
                for (const r3 of this.outputNames)
                  if (-1 !== a3.indexOf(r3)) {
                    const o3 = t2[r3];
                    (null === o3 || o3 instanceof g) && (e3 = true, i2 = false, n2[r3] = o3);
                  }
                if (e3) {
                  if ("object" == typeof r2 && null !== r2)
                    o2 = r2;
                  else if (void 0 !== r2)
                    throw new TypeError("'options' must be an object.");
                } else
                  o2 = t2;
              }
            } else if (void 0 !== t2)
              throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
            for (const t3 of this.inputNames)
              if (void 0 === e2[t3])
                throw new Error(`input '${t3}' is missing in 'feeds'.`);
            if (i2)
              for (const e3 of this.outputNames)
                n2[e3] = null;
            const a2 = await this.handler.run(e2, n2, o2), s2 = {};
            for (const e3 in a2)
              Object.hasOwnProperty.call(a2, e3) && (s2[e3] = new g(a2[e3].type, a2[e3].data, a2[e3].dims));
            return s2;
          }
          static async create(e2, t2, o2, i2) {
            let a2, s2 = {};
            if ("string" == typeof e2) {
              if (a2 = e2, "object" == typeof t2 && null !== t2)
                s2 = t2;
              else if (void 0 !== t2)
                throw new TypeError("'options' must be an object.");
            } else if (e2 instanceof Uint8Array) {
              if (a2 = e2, "object" == typeof t2 && null !== t2)
                s2 = t2;
              else if (void 0 !== t2)
                throw new TypeError("'options' must be an object.");
            } else {
              if (!(e2 instanceof ArrayBuffer || "undefined" != typeof SharedArrayBuffer && e2 instanceof SharedArrayBuffer))
                throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
              {
                const r2 = e2;
                let n2 = 0, d3 = e2.byteLength;
                if ("object" == typeof t2 && null !== t2)
                  s2 = t2;
                else if ("number" == typeof t2) {
                  if (n2 = t2, !Number.isSafeInteger(n2))
                    throw new RangeError("'byteOffset' must be an integer.");
                  if (n2 < 0 || n2 >= r2.byteLength)
                    throw new RangeError(`'byteOffset' is out of range [0, ${r2.byteLength}).`);
                  if (d3 = e2.byteLength - n2, "number" == typeof o2) {
                    if (d3 = o2, !Number.isSafeInteger(d3))
                      throw new RangeError("'byteLength' must be an integer.");
                    if (d3 <= 0 || n2 + d3 > r2.byteLength)
                      throw new RangeError(`'byteLength' is out of range (0, ${r2.byteLength - n2}].`);
                    if ("object" == typeof i2 && null !== i2)
                      s2 = i2;
                    else if (void 0 !== i2)
                      throw new TypeError("'options' must be an object.");
                  } else if (void 0 !== o2)
                    throw new TypeError("'byteLength' must be a number.");
                } else if (void 0 !== t2)
                  throw new TypeError("'options' must be an object.");
                a2 = new Uint8Array(r2, n2, d3);
              }
            }
            const d2 = (s2.executionProviders || []).map((e3) => "string" == typeof e3 ? e3 : e3.name), f2 = await (async (e3) => {
              const t3 = 0 === e3.length ? n : e3, o3 = [];
              for (const e4 of t3) {
                const t4 = r[e4];
                if (t4) {
                  if (t4.initialized)
                    return t4.backend;
                  if (t4.aborted)
                    continue;
                  const r2 = !!t4.initPromise;
                  try {
                    return r2 || (t4.initPromise = t4.backend.init()), await t4.initPromise, t4.initialized = true, t4.backend;
                  } catch (n2) {
                    r2 || o3.push({ name: e4, err: n2 }), t4.aborted = true;
                  } finally {
                    delete t4.initPromise;
                  }
                }
              }
              throw new Error(`no available backend found. ERR: ${o3.map((e4) => `[${e4.name}] ${e4.err}`).join(", ")}`);
            })(d2), h2 = await f2.createSessionHandler(a2, s2);
            return new m(h2);
          }
          startProfiling() {
            this.handler.startProfiling();
          }
          endProfiling() {
            this.handler.endProfiling();
          }
          get inputNames() {
            return this.handler.inputNames;
          }
          get outputNames() {
            return this.handler.outputNames;
          }
        }
        const c = m;
        var l = exports2;
        for (var w in t)
          l[w] = t[w];
        t.__esModule && Object.defineProperty(l, "__esModule", { value: true });
      })();
    }
  });

  // node_modules/onnxruntime-node/dist/binding.js
  var require_binding = __commonJS({
    "node_modules/onnxruntime-node/dist/binding.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.binding = void 0;
      exports2.binding = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      __require(`../bin/napi-v3/${process.platform}/${process.arch}/onnxruntime_binding.node`);
    }
  });

  // node_modules/onnxruntime-node/dist/backend.js
  var require_backend = __commonJS({
    "node_modules/onnxruntime-node/dist/backend.js"(exports2) {
      "use strict";
      var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _OnnxruntimeSessionHandler_inferenceSession;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.onnxruntimeBackend = void 0;
      var binding_1 = require_binding();
      var OnnxruntimeSessionHandler = class {
        constructor(pathOrBuffer, options) {
          _OnnxruntimeSessionHandler_inferenceSession.set(this, void 0);
          __classPrivateFieldSet(this, _OnnxruntimeSessionHandler_inferenceSession, new binding_1.binding.InferenceSession(), "f");
          if (typeof pathOrBuffer === "string") {
            __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").loadModel(pathOrBuffer, options);
          } else {
            __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").loadModel(pathOrBuffer.buffer, pathOrBuffer.byteOffset, pathOrBuffer.byteLength, options);
          }
          this.inputNames = __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").inputNames;
          this.outputNames = __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").outputNames;
        }
        async dispose() {
          return Promise.resolve();
        }
        startProfiling() {
        }
        endProfiling() {
        }
        async run(feeds, fetches, options) {
          return new Promise((resolve2, reject2) => {
            process.nextTick(() => {
              try {
                resolve2(__classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").run(feeds, fetches, options));
              } catch (e) {
                reject2(e);
              }
            });
          });
        }
      };
      _OnnxruntimeSessionHandler_inferenceSession = /* @__PURE__ */ new WeakMap();
      var OnnxruntimeBackend = class {
        async init() {
          return Promise.resolve();
        }
        async createSessionHandler(pathOrBuffer, options) {
          return new Promise((resolve2, reject2) => {
            process.nextTick(() => {
              try {
                resolve2(new OnnxruntimeSessionHandler(pathOrBuffer, options || {}));
              } catch (e) {
                reject2(e);
              }
            });
          });
        }
      };
      exports2.onnxruntimeBackend = new OnnxruntimeBackend();
    }
  });

  // node_modules/onnxruntime-node/dist/index.js
  var require_dist = __commonJS({
    "node_modules/onnxruntime-node/dist/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_ort_common_node(), exports2);
      var onnxruntime_common_1 = require_ort_common_node();
      var backend_1 = require_backend();
      (0, onnxruntime_common_1.registerBackend)("cpu", backend_1.onnxruntimeBackend, 100);
    }
  });

  // node_modules/onnxruntime-web/dist/ort-web.min.js
  var require_ort_web_min = __commonJS({
    "node_modules/onnxruntime-web/dist/ort-web.min.js"(exports, module) {
      !function(t, e) {
        if ("object" == typeof exports && "object" == typeof module)
          module.exports = e(require_ort_common_node());
        else if ("function" == typeof define && define.amd)
          define([], e);
        else {
          var n = "object" == typeof exports ? e(require_ort_common_node()) : e(t.ort);
          for (var r in n)
            ("object" == typeof exports ? exports : t)[r] = n[r];
        }
      }(self, (__WEBPACK_EXTERNAL_MODULE__1670__) => (() => {
        var __webpack_modules__ = { 3474: (t, e, n) => {
          var _scriptDir, r = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t2) {
            function e2() {
              return $.buffer != C && H($.buffer), F;
            }
            function r2() {
              return $.buffer != C && H($.buffer), N;
            }
            function i() {
              return $.buffer != C && H($.buffer), L;
            }
            function o() {
              return $.buffer != C && H($.buffer), R;
            }
            function a() {
              return $.buffer != C && H($.buffer), j;
            }
            var s, u, c;
            t2 = t2 || {}, s || (s = void 0 !== t2 ? t2 : {}), s.ready = new Promise(function(t3, e3) {
              u = t3, c = e3;
            });
            var l, p, f, d, h, g, b = Object.assign({}, s), m = "./this.program", y = (t3, e3) => {
              throw e3;
            }, _ = "object" == typeof window, v = "function" == typeof importScripts, w = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, x = s.ENVIRONMENT_IS_PTHREAD || false, T = "";
            function S(t3) {
              return s.locateFile ? s.locateFile(t3, T) : T + t3;
            }
            if (w) {
              let e3;
              T = v ? n(908).dirname(T) + "/" : "//", g = () => {
                h || (d = n(1384), h = n(908));
              }, l = function(t3, e4) {
                return g(), t3 = h.normalize(t3), d.readFileSync(t3, e4 ? void 0 : "utf8");
              }, f = (t3) => ((t3 = l(t3, true)).buffer || (t3 = new Uint8Array(t3)), t3), p = (t3, e4, n2) => {
                g(), t3 = h.normalize(t3), d.readFile(t3, function(t4, r3) {
                  t4 ? n2(t4) : e4(r3.buffer);
                });
              }, 1 < process.argv.length && (m = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t3) {
                if (!(t3 instanceof ut))
                  throw t3;
              }), process.on("unhandledRejection", function(t3) {
                throw t3;
              }), y = (t3, e4) => {
                if (J())
                  throw process.exitCode = t3, e4;
                e4 instanceof ut || P("exiting due to exception: " + e4), process.exit(t3);
              }, s.inspect = function() {
                return "[Emscripten Module object]";
              };
              try {
                e3 = n(9925);
              } catch (t3) {
                throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), t3;
              }
              n.g.Worker = e3.Worker;
            } else
              (_ || v) && (v ? T = self.location.href : "undefined" != typeof document && document.currentScript && (T = document.currentScript.src), _scriptDir && (T = _scriptDir), T = 0 !== T.indexOf("blob:") ? T.substr(0, T.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", w || (l = (t3) => {
                var e3 = new XMLHttpRequest();
                return e3.open("GET", t3, false), e3.send(null), e3.responseText;
              }, v && (f = (t3) => {
                var e3 = new XMLHttpRequest();
                return e3.open("GET", t3, false), e3.responseType = "arraybuffer", e3.send(null), new Uint8Array(e3.response);
              }), p = (t3, e3, n2) => {
                var r3 = new XMLHttpRequest();
                r3.open("GET", t3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                  200 == r3.status || 0 == r3.status && r3.response ? e3(r3.response) : n2();
                }, r3.onerror = n2, r3.send(null);
              }));
            w && "undefined" == typeof performance && (n.g.performance = n(6953).performance);
            var O = console.log.bind(console), A = console.warn.bind(console);
            w && (g(), O = (t3) => d.writeSync(1, t3 + "\n"), A = (t3) => d.writeSync(2, t3 + "\n"));
            var E, I = s.print || O, P = s.printErr || A;
            Object.assign(s, b), b = null, s.thisProgram && (m = s.thisProgram), s.quit && (y = s.quit), s.wasmBinary && (E = s.wasmBinary);
            var D = s.noExitRuntime || false;
            "object" != typeof WebAssembly && it("no native wasm support detected");
            var $, k, C, F, N, L, R, j, M = false, U = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
            function V(t3, e3, n2) {
              var r3 = (e3 >>>= 0) + n2;
              for (n2 = e3; t3[n2] && !(n2 >= r3); )
                ++n2;
              if (16 < n2 - e3 && t3.buffer && U)
                return U.decode(t3.buffer instanceof SharedArrayBuffer ? t3.slice(e3, n2) : t3.subarray(e3, n2));
              for (r3 = ""; e3 < n2; ) {
                var i2 = t3[e3++];
                if (128 & i2) {
                  var o2 = 63 & t3[e3++];
                  if (192 == (224 & i2))
                    r3 += String.fromCharCode((31 & i2) << 6 | o2);
                  else {
                    var a2 = 63 & t3[e3++];
                    65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & t3[e3++]) ? r3 += String.fromCharCode(i2) : (i2 -= 65536, r3 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
                  }
                } else
                  r3 += String.fromCharCode(i2);
              }
              return r3;
            }
            function B(t3, e3) {
              return (t3 >>>= 0) ? V(r2(), t3, e3) : "";
            }
            function z(t3, e3, n2, r3) {
              if (!(0 < r3))
                return 0;
              var i2 = n2 >>>= 0;
              r3 = n2 + r3 - 1;
              for (var o2 = 0; o2 < t3.length; ++o2) {
                var a2 = t3.charCodeAt(o2);
                if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & t3.charCodeAt(++o2)), 127 >= a2) {
                  if (n2 >= r3)
                    break;
                  e3[n2++ >>> 0] = a2;
                } else {
                  if (2047 >= a2) {
                    if (n2 + 1 >= r3)
                      break;
                    e3[n2++ >>> 0] = 192 | a2 >> 6;
                  } else {
                    if (65535 >= a2) {
                      if (n2 + 2 >= r3)
                        break;
                      e3[n2++ >>> 0] = 224 | a2 >> 12;
                    } else {
                      if (n2 + 3 >= r3)
                        break;
                      e3[n2++ >>> 0] = 240 | a2 >> 18, e3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                    }
                    e3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                  }
                  e3[n2++ >>> 0] = 128 | 63 & a2;
                }
              }
              return e3[n2 >>> 0] = 0, n2 - i2;
            }
            function G(t3) {
              for (var e3 = 0, n2 = 0; n2 < t3.length; ++n2) {
                var r3 = t3.charCodeAt(n2);
                127 >= r3 ? e3++ : 2047 >= r3 ? e3 += 2 : 55296 <= r3 && 57343 >= r3 ? (e3 += 4, ++n2) : e3 += 3;
              }
              return e3;
            }
            function H(t3) {
              C = t3, s.HEAP8 = F = new Int8Array(t3), s.HEAP16 = new Int16Array(t3), s.HEAP32 = L = new Int32Array(t3), s.HEAPU8 = N = new Uint8Array(t3), s.HEAPU16 = new Uint16Array(t3), s.HEAPU32 = R = new Uint32Array(t3), s.HEAPF32 = new Float32Array(t3), s.HEAPF64 = j = new Float64Array(t3);
            }
            x && (C = s.buffer);
            var W = s.INITIAL_MEMORY || 16777216;
            if (x)
              $ = s.wasmMemory, C = s.buffer;
            else if (s.wasmMemory)
              $ = s.wasmMemory;
            else if (!(($ = new WebAssembly.Memory({ initial: W / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer))
              throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), w && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory");
            $ && (C = $.buffer), W = C.byteLength, H(C);
            var q, X = [], Y = [], K = [], Z = [];
            function J() {
              return D || false;
            }
            function Q() {
              var t3 = s.preRun.shift();
              X.unshift(t3);
            }
            var tt, et = 0, nt = null, rt = null;
            function it(t3) {
              throw x ? postMessage({ cmd: "onAbort", arg: t3 }) : s.onAbort && s.onAbort(t3), P(t3 = "Aborted(" + t3 + ")"), M = true, t3 = new WebAssembly.RuntimeError(t3 + ". Build with -sASSERTIONS for more info."), c(t3), t3;
            }
            function ot() {
              return tt.startsWith("data:application/octet-stream;base64,");
            }
            function at() {
              var t3 = tt;
              try {
                if (t3 == tt && E)
                  return new Uint8Array(E);
                if (f)
                  return f(t3);
                throw "both async and sync fetching of the wasm failed";
              } catch (t4) {
                it(t4);
              }
            }
            tt = "ort-wasm-threaded.wasm", ot() || (tt = S(tt));
            var st = {};
            function ut(t3) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + t3 + ")", this.status = t3;
            }
            function ct(t3) {
              (t3 = dt.Vb[t3]) || it(), dt.mc(t3);
            }
            function lt(t3) {
              var e3 = dt.Cc();
              if (!e3)
                return 6;
              dt.ac.push(e3), dt.Vb[t3.Ub] = e3, e3.Ub = t3.Ub;
              var n2 = { cmd: "run", start_routine: t3.Ic, arg: t3.zc, pthread_ptr: t3.Ub };
              return e3.$b = () => {
                n2.time = performance.now(), e3.postMessage(n2, t3.Nc);
              }, e3.loaded && (e3.$b(), delete e3.$b), 0;
            }
            function pt(t3) {
              if (x)
                return qt(1, 1, t3);
              J() || (dt.oc(), s.onExit && s.onExit(t3), M = true), y(t3, new ut(t3));
            }
            function ft(t3, e3) {
              if (!e3 && x)
                throw bt(t3), "unwind";
              J() || x || (me(), ht(K), be(0), re[1].length && ie(1, 10), re[2].length && ie(2, 10), dt.oc()), pt(t3);
            }
            var dt = { Yb: [], ac: [], qc: [], Vb: {}, fc: function() {
              x && dt.Ec();
            }, Pc: function() {
            }, Ec: function() {
              dt.receiveObjectTransfer = dt.Gc, dt.threadInitTLS = dt.pc, dt.setExitStatus = dt.nc, D = false;
            }, nc: function() {
            }, oc: function() {
              for (var t3 of Object.values(dt.Vb))
                dt.mc(t3);
              for (t3 of dt.Yb)
                t3.terminate();
              dt.Yb = [];
            }, mc: function(t3) {
              var e3 = t3.Ub;
              delete dt.Vb[e3], dt.Yb.push(t3), dt.ac.splice(dt.ac.indexOf(t3), 1), t3.Ub = 0, xe(e3);
            }, Gc: function() {
            }, pc: function() {
              dt.qc.forEach((t3) => t3());
            }, Fc: function(t3, e3) {
              t3.onmessage = (n2) => {
                var r3 = (n2 = n2.data).cmd;
                if (t3.Ub && (dt.Bc = t3.Ub), n2.targetThread && n2.targetThread != de()) {
                  var i2 = dt.Vb[n2.Qc];
                  i2 ? i2.postMessage(n2, n2.transferList) : P('Internal error! Worker sent a message "' + r3 + '" to target pthread ' + n2.targetThread + ", but that thread no longer exists!");
                } else
                  "processProxyingQueue" === r3 ? Vt(n2.queue) : "spawnThread" === r3 ? lt(n2) : "cleanupThread" === r3 ? ct(n2.thread) : "killThread" === r3 ? (n2 = n2.thread, r3 = dt.Vb[n2], delete dt.Vb[n2], r3.terminate(), xe(n2), dt.ac.splice(dt.ac.indexOf(r3), 1), r3.Ub = 0) : "cancelThread" === r3 ? dt.Vb[n2.thread].postMessage({ cmd: "cancel" }) : "loaded" === r3 ? (t3.loaded = true, e3 && e3(t3), t3.$b && (t3.$b(), delete t3.$b)) : "print" === r3 ? I("Thread " + n2.threadId + ": " + n2.text) : "printErr" === r3 ? P("Thread " + n2.threadId + ": " + n2.text) : "alert" === r3 ? alert("Thread " + n2.threadId + ": " + n2.text) : "setimmediate" === n2.target ? t3.postMessage(n2) : "onAbort" === r3 ? s.onAbort && s.onAbort(n2.arg) : r3 && P("worker sent an unknown command " + r3);
                dt.Bc = void 0;
              }, t3.onerror = (t4) => {
                throw P("worker sent an error! " + t4.filename + ":" + t4.lineno + ": " + t4.message), t4;
              }, w && (t3.on("message", function(e4) {
                t3.onmessage({ data: e4 });
              }), t3.on("error", function(e4) {
                t3.onerror(e4);
              }), t3.on("detachedExit", function() {
              })), t3.postMessage({ cmd: "load", urlOrBlob: s.mainScriptUrlOrBlob || _scriptDir, wasmMemory: $, wasmModule: k });
            }, yc: function() {
              var t3 = S("ort-wasm-threaded.worker.js");
              dt.Yb.push(new Worker(t3));
            }, Cc: function() {
              return 0 == dt.Yb.length && (dt.yc(), dt.Fc(dt.Yb[0])), dt.Yb.pop();
            } };
            function ht(t3) {
              for (; 0 < t3.length; )
                t3.shift()(s);
            }
            function gt(t3) {
              var e3 = Ae();
              return t3 = t3(), Ee(e3), t3;
            }
            function bt(t3) {
              if (x)
                return qt(2, 0, t3);
              try {
                ft(t3);
              } catch (t4) {
                t4 instanceof ut || "unwind" == t4 || y(1, t4);
              }
            }
            s.PThread = dt, s.establishStackSpace = function() {
              var t3 = de(), e3 = i()[t3 + 44 >> 2 >>> 0];
              t3 = i()[t3 + 48 >> 2 >>> 0], Oe(e3, e3 - t3), Ee(e3);
            };
            var mt = [];
            function yt(t3) {
              var e3 = mt[t3];
              return e3 || (t3 >= mt.length && (mt.length = t3 + 1), mt[t3] = e3 = q.get(t3)), e3;
            }
            s.invokeEntryPoint = function(t3, e3) {
              t3 = yt(t3)(e3), J() ? dt.nc(t3) : Te(t3);
            };
            var _t, vt, wt = [], xt = 0, Tt = 0;
            function St(t3) {
              this.Zb = t3, this.Sb = t3 - 24, this.xc = function(t4) {
                o()[this.Sb + 4 >> 2 >>> 0] = t4;
              }, this.bc = function() {
                return o()[this.Sb + 4 >> 2 >>> 0];
              }, this.wc = function(t4) {
                o()[this.Sb + 8 >> 2 >>> 0] = t4;
              }, this.Dc = function() {
                return o()[this.Sb + 8 >> 2 >>> 0];
              }, this.rc = function() {
                i()[this.Sb >> 2 >>> 0] = 0;
              }, this.hc = function(t4) {
                t4 = t4 ? 1 : 0, e2()[this.Sb + 12 >> 0 >>> 0] = t4;
              }, this.uc = function() {
                return 0 != e2()[this.Sb + 12 >> 0 >>> 0];
              }, this.ic = function(t4) {
                t4 = t4 ? 1 : 0, e2()[this.Sb + 13 >> 0 >>> 0] = t4;
              }, this.kc = function() {
                return 0 != e2()[this.Sb + 13 >> 0 >>> 0];
              }, this.fc = function(t4, e3) {
                this.cc(0), this.xc(t4), this.wc(e3), this.rc(), this.hc(false), this.ic(false);
              }, this.sc = function() {
                Atomics.add(i(), this.Sb >> 2, 1);
              }, this.Hc = function() {
                return 1 === Atomics.sub(i(), this.Sb >> 2, 1);
              }, this.cc = function(t4) {
                o()[this.Sb + 16 >> 2 >>> 0] = t4;
              }, this.tc = function() {
                return o()[this.Sb + 16 >> 2 >>> 0];
              }, this.vc = function() {
                if (De(this.bc()))
                  return o()[this.Zb >> 2 >>> 0];
                var t4 = this.tc();
                return 0 !== t4 ? t4 : this.Zb;
              };
            }
            function Ot(t3) {
              return ge(new St(t3).Sb);
            }
            function At(t3, e3, n2, r3) {
              return x ? qt(3, 1, t3, e3, n2, r3) : Et(t3, e3, n2, r3);
            }
            function Et(t3, e3, n2, r3) {
              if ("undefined" == typeof SharedArrayBuffer)
                return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
              var i2 = [];
              return x && 0 === i2.length ? At(t3, e3, n2, r3) : (t3 = { Ic: n2, Ub: t3, zc: r3, Nc: i2 }, x ? (t3.Oc = "spawnThread", postMessage(t3, i2), 0) : lt(t3));
            }
            function It(t3, e3, n2) {
              return x ? qt(4, 1, t3, e3, n2) : 0;
            }
            function Pt(t3, e3) {
              if (x)
                return qt(5, 1, t3, e3);
            }
            function Dt(t3, e3) {
              if (x)
                return qt(6, 1, t3, e3);
            }
            function $t(t3, e3, n2) {
              if (x)
                return qt(7, 1, t3, e3, n2);
            }
            function kt(t3, e3, n2) {
              return x ? qt(8, 1, t3, e3, n2) : 0;
            }
            function Ct(t3, e3) {
              if (x)
                return qt(9, 1, t3, e3);
            }
            function Ft(t3, e3, n2) {
              if (x)
                return qt(10, 1, t3, e3, n2);
            }
            function Nt(t3, e3, n2, r3) {
              if (x)
                return qt(11, 1, t3, e3, n2, r3);
            }
            function Lt(t3, e3, n2, r3) {
              if (x)
                return qt(12, 1, t3, e3, n2, r3);
            }
            function Rt(t3, e3, n2, r3) {
              if (x)
                return qt(13, 1, t3, e3, n2, r3);
            }
            function jt(t3) {
              if (x)
                return qt(14, 1, t3);
            }
            function Mt(t3, e3) {
              if (x)
                return qt(15, 1, t3, e3);
            }
            function Ut(t3, e3, n2) {
              if (x)
                return qt(16, 1, t3, e3, n2);
            }
            function Vt(t3) {
              Atomics.store(i(), t3 >> 2, 1), de() && we(t3), Atomics.compareExchange(i(), t3 >> 2, 1, 0);
            }
            function Bt(t3) {
              return o()[t3 >>> 2] + 4294967296 * i()[t3 + 4 >>> 2];
            }
            function zt(t3, e3, n2, r3, i2, o2) {
              return x ? qt(17, 1, t3, e3, n2, r3, i2, o2) : -52;
            }
            function Gt(t3, e3, n2, r3, i2, o2) {
              if (x)
                return qt(18, 1, t3, e3, n2, r3, i2, o2);
            }
            function Ht(t3) {
              var n2 = G(t3) + 1, r3 = he(n2);
              return r3 && z(t3, e2(), r3, n2), r3;
            }
            function Wt(t3, e3, n2) {
              function r3(t4) {
                return (t4 = t4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t4[1] : "GMT";
              }
              if (x)
                return qt(19, 1, t3, e3, n2);
              var a2 = (/* @__PURE__ */ new Date()).getFullYear(), s2 = new Date(a2, 0, 1), u2 = new Date(a2, 6, 1);
              a2 = s2.getTimezoneOffset();
              var c2 = u2.getTimezoneOffset(), l2 = Math.max(a2, c2);
              i()[t3 >> 2 >>> 0] = 60 * l2, i()[e3 >> 2 >>> 0] = Number(a2 != c2), t3 = r3(s2), e3 = r3(u2), t3 = Ht(t3), e3 = Ht(e3), c2 < a2 ? (o()[n2 >> 2 >>> 0] = t3, o()[n2 + 4 >> 2 >>> 0] = e3) : (o()[n2 >> 2 >>> 0] = e3, o()[n2 + 4 >> 2 >>> 0] = t3);
            }
            function qt(t3, e3) {
              var n2 = arguments.length - 2, r3 = arguments;
              return gt(() => {
                for (var i2 = Ie(8 * n2), o2 = i2 >> 3, s2 = 0; s2 < n2; s2++) {
                  var u2 = r3[2 + s2];
                  a()[o2 + s2 >>> 0] = u2;
                }
                return ve(t3, n2, i2, e3);
              });
            }
            s.executeNotifiedProxyingQueue = Vt, vt = w ? () => {
              var t3 = process.hrtime();
              return 1e3 * t3[0] + t3[1] / 1e6;
            } : x ? () => performance.now() - s.__performance_now_clock_drift : () => performance.now();
            var Xt, Yt = [], Kt = {};
            function Zt() {
              if (!Xt) {
                var t3, e3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: m || "./this.program" };
                for (t3 in Kt)
                  void 0 === Kt[t3] ? delete e3[t3] : e3[t3] = Kt[t3];
                var n2 = [];
                for (t3 in e3)
                  n2.push(t3 + "=" + e3[t3]);
                Xt = n2;
              }
              return Xt;
            }
            function Jt(t3, n2) {
              if (x)
                return qt(20, 1, t3, n2);
              var r3 = 0;
              return Zt().forEach(function(i2, a2) {
                var s2 = n2 + r3;
                for (a2 = o()[t3 + 4 * a2 >> 2 >>> 0] = s2, s2 = 0; s2 < i2.length; ++s2)
                  e2()[a2++ >> 0 >>> 0] = i2.charCodeAt(s2);
                e2()[a2 >> 0 >>> 0] = 0, r3 += i2.length + 1;
              }), 0;
            }
            function Qt(t3, e3) {
              if (x)
                return qt(21, 1, t3, e3);
              var n2 = Zt();
              o()[t3 >> 2 >>> 0] = n2.length;
              var r3 = 0;
              return n2.forEach(function(t4) {
                r3 += t4.length + 1;
              }), o()[e3 >> 2 >>> 0] = r3, 0;
            }
            function te(t3) {
              return x ? qt(22, 1, t3) : 52;
            }
            function ee(t3, e3, n2, r3) {
              return x ? qt(23, 1, t3, e3, n2, r3) : 52;
            }
            function ne(t3, e3, n2, r3, i2) {
              return x ? qt(24, 1, t3, e3, n2, r3, i2) : 70;
            }
            var re = [null, [], []];
            function ie(t3, e3) {
              var n2 = re[t3];
              0 === e3 || 10 === e3 ? ((1 === t3 ? I : P)(V(n2, 0)), n2.length = 0) : n2.push(e3);
            }
            function oe(t3, e3, n2, i2) {
              if (x)
                return qt(25, 1, t3, e3, n2, i2);
              for (var a2 = 0, s2 = 0; s2 < n2; s2++) {
                var u2 = o()[e3 >> 2 >>> 0], c2 = o()[e3 + 4 >> 2 >>> 0];
                e3 += 8;
                for (var l2 = 0; l2 < c2; l2++)
                  ie(t3, r2()[u2 + l2 >>> 0]);
                a2 += c2;
              }
              return o()[i2 >> 2 >>> 0] = a2, 0;
            }
            var ae = 0;
            function se(t3) {
              return 0 == t3 % 4 && (0 != t3 % 100 || 0 == t3 % 400);
            }
            var ue = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ce = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function le(t3, n2, r3, o2) {
              function a2(t4, e3, n3) {
                for (t4 = "number" == typeof t4 ? t4.toString() : t4 || ""; t4.length < e3; )
                  t4 = n3[0] + t4;
                return t4;
              }
              function s2(t4, e3) {
                return a2(t4, e3, "0");
              }
              function u2(t4, e3) {
                function n3(t5) {
                  return 0 > t5 ? -1 : 0 < t5 ? 1 : 0;
                }
                var r4;
                return 0 === (r4 = n3(t4.getFullYear() - e3.getFullYear())) && 0 === (r4 = n3(t4.getMonth() - e3.getMonth())) && (r4 = n3(t4.getDate() - e3.getDate())), r4;
              }
              function c2(t4) {
                switch (t4.getDay()) {
                  case 0:
                    return new Date(t4.getFullYear() - 1, 11, 29);
                  case 1:
                    return t4;
                  case 2:
                    return new Date(t4.getFullYear(), 0, 3);
                  case 3:
                    return new Date(t4.getFullYear(), 0, 2);
                  case 4:
                    return new Date(t4.getFullYear(), 0, 1);
                  case 5:
                    return new Date(t4.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(t4.getFullYear() - 1, 11, 30);
                }
              }
              function l2(t4) {
                var e3 = t4.Wb;
                for (t4 = new Date(new Date(t4.Xb + 1900, 0, 1).getTime()); 0 < e3; ) {
                  var n3 = t4.getMonth(), r4 = (se(t4.getFullYear()) ? ue : ce)[n3];
                  if (!(e3 > r4 - t4.getDate())) {
                    t4.setDate(t4.getDate() + e3);
                    break;
                  }
                  e3 -= r4 - t4.getDate() + 1, t4.setDate(1), 11 > n3 ? t4.setMonth(n3 + 1) : (t4.setMonth(0), t4.setFullYear(t4.getFullYear() + 1));
                }
                return n3 = new Date(t4.getFullYear() + 1, 0, 4), e3 = c2(new Date(t4.getFullYear(), 0, 4)), n3 = c2(n3), 0 >= u2(e3, t4) ? 0 >= u2(n3, t4) ? t4.getFullYear() + 1 : t4.getFullYear() : t4.getFullYear() - 1;
              }
              var p2 = i()[o2 + 40 >> 2 >>> 0];
              for (var f2 in o2 = { Lc: i()[o2 >> 2 >>> 0], Kc: i()[o2 + 4 >> 2 >>> 0], dc: i()[o2 + 8 >> 2 >>> 0], jc: i()[o2 + 12 >> 2 >>> 0], ec: i()[o2 + 16 >> 2 >>> 0], Xb: i()[o2 + 20 >> 2 >>> 0], Tb: i()[o2 + 24 >> 2 >>> 0], Wb: i()[o2 + 28 >> 2 >>> 0], Rc: i()[o2 + 32 >> 2 >>> 0], Jc: i()[o2 + 36 >> 2 >>> 0], Mc: p2 ? B(p2) : "" }, r3 = B(r3), p2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
                r3 = r3.replace(new RegExp(f2, "g"), p2[f2]);
              var d2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), h2 = "January February March April May June July August September October November December".split(" ");
              for (f2 in p2 = { "%a": function(t4) {
                return d2[t4.Tb].substring(0, 3);
              }, "%A": function(t4) {
                return d2[t4.Tb];
              }, "%b": function(t4) {
                return h2[t4.ec].substring(0, 3);
              }, "%B": function(t4) {
                return h2[t4.ec];
              }, "%C": function(t4) {
                return s2((t4.Xb + 1900) / 100 | 0, 2);
              }, "%d": function(t4) {
                return s2(t4.jc, 2);
              }, "%e": function(t4) {
                return a2(t4.jc, 2, " ");
              }, "%g": function(t4) {
                return l2(t4).toString().substring(2);
              }, "%G": function(t4) {
                return l2(t4);
              }, "%H": function(t4) {
                return s2(t4.dc, 2);
              }, "%I": function(t4) {
                return 0 == (t4 = t4.dc) ? t4 = 12 : 12 < t4 && (t4 -= 12), s2(t4, 2);
              }, "%j": function(t4) {
                for (var e3 = 0, n3 = 0; n3 <= t4.ec - 1; e3 += (se(t4.Xb + 1900) ? ue : ce)[n3++])
                  ;
                return s2(t4.jc + e3, 3);
              }, "%m": function(t4) {
                return s2(t4.ec + 1, 2);
              }, "%M": function(t4) {
                return s2(t4.Kc, 2);
              }, "%n": function() {
                return "\n";
              }, "%p": function(t4) {
                return 0 <= t4.dc && 12 > t4.dc ? "AM" : "PM";
              }, "%S": function(t4) {
                return s2(t4.Lc, 2);
              }, "%t": function() {
                return "	";
              }, "%u": function(t4) {
                return t4.Tb || 7;
              }, "%U": function(t4) {
                return s2(Math.floor((t4.Wb + 7 - t4.Tb) / 7), 2);
              }, "%V": function(t4) {
                var e3 = Math.floor((t4.Wb + 7 - (t4.Tb + 6) % 7) / 7);
                if (2 >= (t4.Tb + 371 - t4.Wb - 2) % 7 && e3++, e3)
                  53 == e3 && (4 == (n3 = (t4.Tb + 371 - t4.Wb) % 7) || 3 == n3 && se(t4.Xb) || (e3 = 1));
                else {
                  e3 = 52;
                  var n3 = (t4.Tb + 7 - t4.Wb - 1) % 7;
                  (4 == n3 || 5 == n3 && se(t4.Xb % 400 - 1)) && e3++;
                }
                return s2(e3, 2);
              }, "%w": function(t4) {
                return t4.Tb;
              }, "%W": function(t4) {
                return s2(Math.floor((t4.Wb + 7 - (t4.Tb + 6) % 7) / 7), 2);
              }, "%y": function(t4) {
                return (t4.Xb + 1900).toString().substring(2);
              }, "%Y": function(t4) {
                return t4.Xb + 1900;
              }, "%z": function(t4) {
                var e3 = 0 <= (t4 = t4.Jc);
                return t4 = Math.abs(t4) / 60, (e3 ? "+" : "-") + String("0000" + (t4 / 60 * 100 + t4 % 60)).slice(-4);
              }, "%Z": function(t4) {
                return t4.Mc;
              }, "%%": function() {
                return "%";
              } }, r3 = r3.replace(/%%/g, "\0\0"), p2)
                r3.includes(f2) && (r3 = r3.replace(new RegExp(f2, "g"), p2[f2](o2)));
              return f2 = function(t4) {
                var e3 = Array(G(t4) + 1);
                return z(t4, e3, 0, e3.length), e3;
              }(r3 = r3.replace(/\0\0/g, "%")), f2.length > n2 ? 0 : (function(t4, n3) {
                e2().set(t4, n3 >>> 0);
              }(f2, t3), f2.length - 1);
            }
            dt.fc();
            var pe = [null, pt, bt, At, It, Pt, Dt, $t, kt, Ct, Ft, Nt, Lt, Rt, jt, Mt, Ut, zt, Gt, Wt, Jt, Qt, te, ee, ne, oe], fe = { b: function(t3) {
              return he(t3 + 24) + 24;
            }, n: function(t3) {
              return (t3 = new St(t3)).uc() || (t3.hc(true), xt--), t3.ic(false), wt.push(t3), t3.sc(), t3.vc();
            }, ma: function(t3) {
              throw P("Unexpected exception thrown, this is not properly supported - aborting"), M = true, t3;
            }, x: function() {
              Se(0);
              var t3 = wt.pop();
              if (t3.Hc() && !t3.kc()) {
                var e3 = t3.Dc();
                e3 && yt(e3)(t3.Zb), Ot(t3.Zb);
              }
              Tt = 0;
            }, e: function() {
              var t3 = Tt;
              if (!t3)
                return ae = 0;
              var e3 = new St(t3);
              e3.cc(t3);
              var n2 = e3.bc();
              if (!n2)
                return ae = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2)
                  break;
                if (Pe(o2, n2, e3.Sb + 16))
                  return ae = o2, t3;
              }
              return ae = n2, t3;
            }, l: function() {
              var t3 = Tt;
              if (!t3)
                return ae = 0;
              var e3 = new St(t3);
              e3.cc(t3);
              var n2 = e3.bc();
              if (!n2)
                return ae = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2)
                  break;
                if (Pe(o2, n2, e3.Sb + 16))
                  return ae = o2, t3;
              }
              return ae = n2, t3;
            }, h: function() {
              var t3 = Tt;
              if (!t3)
                return ae = 0;
              var e3 = new St(t3);
              e3.cc(t3);
              var n2 = e3.bc();
              if (!n2)
                return ae = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2)
                  break;
                if (Pe(o2, n2, e3.Sb + 16))
                  return ae = o2, t3;
              }
              return ae = n2, t3;
            }, t: Ot, M: function() {
              var t3 = wt.pop();
              t3 || it("no exception to throw");
              var e3 = t3.Zb;
              throw t3.kc() || (wt.push(t3), t3.ic(true), t3.hc(false), xt++), Tt = e3, e3;
            }, c: function(t3, e3, n2) {
              throw new St(t3).fc(e3, n2), Tt = t3, xt++, t3;
            }, pa: function() {
              return xt;
            }, Fa: function(t3) {
              ye(t3, !v, 1, !_), dt.pc();
            }, T: function(t3) {
              x ? postMessage({ cmd: "cleanupThread", thread: t3 }) : ct(t3);
            }, xa: Et, j: function(t3) {
              throw Tt || (Tt = t3), t3;
            }, H: It, Ma: Pt, ua: Dt, wa: $t, oa: kt, Ka: Ct, Ca: Ft, Ja: Nt, V: Lt, va: Rt, sa: jt, La: Mt, ta: Ut, Ta: function() {
            }, X: function() {
              it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, Ua: function() {
              it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, W: function() {
              return Date.now();
            }, ya: function() {
              return 2097152;
            }, Oa: function() {
              return true;
            }, za: function(t3, e3, n2, r3) {
              if (t3 == e3)
                setTimeout(() => Vt(r3));
              else if (x)
                postMessage({ targetThread: t3, cmd: "processProxyingQueue", queue: r3 });
              else {
                if (!(t3 = dt.Vb[t3]))
                  return;
                t3.postMessage({ cmd: "processProxyingQueue", queue: r3 });
              }
              return 1;
            }, Ea: function() {
              return -1;
            }, Pa: function(t3, e3) {
              t3 = new Date(1e3 * Bt(t3)), i()[e3 >> 2 >>> 0] = t3.getUTCSeconds(), i()[e3 + 4 >> 2 >>> 0] = t3.getUTCMinutes(), i()[e3 + 8 >> 2 >>> 0] = t3.getUTCHours(), i()[e3 + 12 >> 2 >>> 0] = t3.getUTCDate(), i()[e3 + 16 >> 2 >>> 0] = t3.getUTCMonth(), i()[e3 + 20 >> 2 >>> 0] = t3.getUTCFullYear() - 1900, i()[e3 + 24 >> 2 >>> 0] = t3.getUTCDay(), t3 = (t3.getTime() - Date.UTC(t3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[e3 + 28 >> 2 >>> 0] = t3;
            }, Qa: function(t3, e3) {
              t3 = new Date(1e3 * Bt(t3)), i()[e3 >> 2 >>> 0] = t3.getSeconds(), i()[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), i()[e3 + 8 >> 2 >>> 0] = t3.getHours(), i()[e3 + 12 >> 2 >>> 0] = t3.getDate(), i()[e3 + 16 >> 2 >>> 0] = t3.getMonth(), i()[e3 + 20 >> 2 >>> 0] = t3.getFullYear() - 1900, i()[e3 + 24 >> 2 >>> 0] = t3.getDay();
              var n2 = new Date(t3.getFullYear(), 0, 1), r3 = (t3.getTime() - n2.getTime()) / 864e5 | 0;
              i()[e3 + 28 >> 2 >>> 0] = r3, i()[e3 + 36 >> 2 >>> 0] = -60 * t3.getTimezoneOffset(), r3 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), t3 = 0 | (r3 != (n2 = n2.getTimezoneOffset()) && t3.getTimezoneOffset() == Math.min(n2, r3)), i()[e3 + 32 >> 2 >>> 0] = t3;
            }, Ra: function(t3) {
              var e3 = new Date(i()[t3 + 20 >> 2 >>> 0] + 1900, i()[t3 + 16 >> 2 >>> 0], i()[t3 + 12 >> 2 >>> 0], i()[t3 + 8 >> 2 >>> 0], i()[t3 + 4 >> 2 >>> 0], i()[t3 >> 2 >>> 0], 0), n2 = i()[t3 + 32 >> 2 >>> 0], r3 = e3.getTimezoneOffset(), o2 = new Date(e3.getFullYear(), 0, 1), a2 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset(), s2 = o2.getTimezoneOffset(), u2 = Math.min(s2, a2);
              return 0 > n2 ? i()[t3 + 32 >> 2 >>> 0] = Number(a2 != s2 && u2 == r3) : 0 < n2 != (u2 == r3) && (a2 = Math.max(s2, a2), e3.setTime(e3.getTime() + 6e4 * ((0 < n2 ? u2 : a2) - r3))), i()[t3 + 24 >> 2 >>> 0] = e3.getDay(), n2 = (e3.getTime() - o2.getTime()) / 864e5 | 0, i()[t3 + 28 >> 2 >>> 0] = n2, i()[t3 >> 2 >>> 0] = e3.getSeconds(), i()[t3 + 4 >> 2 >>> 0] = e3.getMinutes(), i()[t3 + 8 >> 2 >>> 0] = e3.getHours(), i()[t3 + 12 >> 2 >>> 0] = e3.getDate(), i()[t3 + 16 >> 2 >>> 0] = e3.getMonth(), e3.getTime() / 1e3 | 0;
            }, Aa: zt, Ba: Gt, Sa: function t3(e3, n2, r3) {
              t3.Ac || (t3.Ac = true, Wt(e3, n2, r3));
            }, y: function() {
              it("");
            }, U: function() {
              if (!w && !v) {
                var t3 = "Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";
                _t || (_t = {}), _t[t3] || (_t[t3] = 1, w && (t3 = "warning: " + t3), P(t3));
              }
            }, ra: function() {
              return 4294901760;
            }, B: vt, Ia: function(t3, e3, n2) {
              r2().copyWithin(t3 >>> 0, e3 >>> 0, e3 + n2 >>> 0);
            }, F: function() {
              return w ? n(3993).cpus().length : navigator.hardwareConcurrency;
            }, Da: function(t3, e3, n2) {
              Yt.length = e3, n2 >>= 3;
              for (var r3 = 0; r3 < e3; r3++)
                Yt[r3] = a()[n2 + r3 >>> 0];
              return (0 > t3 ? st[-t3 - 1] : pe[t3]).apply(null, Yt);
            }, qa: function(t3) {
              var e3 = r2().length;
              if ((t3 >>>= 0) <= e3 || 4294901760 < t3)
                return false;
              for (var n2 = 1; 4 >= n2; n2 *= 2) {
                var i2 = e3 * (1 + 0.2 / n2);
                i2 = Math.min(i2, t3 + 100663296);
                var o2 = Math;
                i2 = Math.max(t3, i2), o2 = o2.min.call(o2, 4294901760, i2 + (65536 - i2 % 65536) % 65536);
                t: {
                  try {
                    $.grow(o2 - C.byteLength + 65535 >>> 16), H($.buffer);
                    var a2 = 1;
                    break t;
                  } catch (t4) {
                  }
                  a2 = void 0;
                }
                if (a2)
                  return true;
              }
              return false;
            }, Na: function() {
              throw "unwind";
            }, Ga: Jt, Ha: Qt, J: ft, I: te, S: ee, ga: ne, R: oe, d: function() {
              return ae;
            }, na: function t3(r3, i2) {
              t3.lc || (t3.lc = function() {
                if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
                  var t4 = new Uint8Array(1);
                  return () => (crypto.getRandomValues(t4), t4[0]);
                }
                if (w)
                  try {
                    var e3 = n(Object(function() {
                      var t5 = new Error("Cannot find module 'crypto'");
                      throw t5.code = "MODULE_NOT_FOUND", t5;
                    }()));
                    return () => e3.randomBytes(1)[0];
                  } catch (t5) {
                  }
                return () => it("randomDevice");
              }());
              for (var o2 = 0; o2 < i2; o2++)
                e2()[r3 + o2 >> 0 >>> 0] = t3.lc();
              return 0;
            }, ia: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, ja: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, K: function(t3) {
              var e3 = Ae();
              try {
                return yt(t3)();
              } catch (t4) {
                if (Ee(e3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, f: function(t3, e3) {
              var n2 = Ae();
              try {
                return yt(t3)(e3);
              } catch (t4) {
                if (Ee(n2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, P: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, Q: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, k: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, p: function(t3, e3, n2, r3) {
              var i2 = Ae();
              try {
                return yt(t3)(e3, n2, r3);
              } catch (t4) {
                if (Ee(i2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, q: function(t3, e3, n2, r3, i2) {
              var o2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2);
              } catch (t4) {
                if (Ee(o2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, N: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (Ee(a2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, s: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (Ee(a2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, w: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (Ee(s2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, L: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (Ee(u2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, E: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
              var f2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
              } catch (t4) {
                if (Ee(f2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, aa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Ae();
              try {
                return Me(t3, e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (Ee(u2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, _: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Ae();
              try {
                return ke(t3, e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (Ee(s2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, Z: function(t3, e3, n2, r3, i2) {
              var o2 = Ae();
              try {
                return Ue(t3, e3, n2, r3, i2);
              } catch (t4) {
                if (Ee(o2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, ca: function(t3, e3, n2, r3) {
              var i2 = Ae();
              try {
                return Re(t3, e3, n2, r3);
              } catch (t4) {
                if (Ee(i2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, $: function(t3) {
              var e3 = Ae();
              try {
                return $e(t3);
              } catch (t4) {
                if (Ee(e3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, ba: function(t3, e3) {
              var n2 = Ae();
              try {
                return je(t3, e3);
              } catch (t4) {
                if (Ee(n2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, Y: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return Ce(t3, e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, g: function(t3) {
              var e3 = Ae();
              try {
                yt(t3)();
              } catch (t4) {
                if (Ee(e3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, r: function(t3, e3) {
              var n2 = Ae();
              try {
                yt(t3)(e3);
              } catch (t4) {
                if (Ee(n2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, i: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, ha: function(t3, e3, n2, r3) {
              var i2 = Ae();
              try {
                yt(t3)(e3, n2, r3);
              } catch (t4) {
                if (Ee(i2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, m: function(t3, e3, n2, r3) {
              var i2 = Ae();
              try {
                yt(t3)(e3, n2, r3);
              } catch (t4) {
                if (Ee(i2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, v: function(t3, e3, n2, r3, i2) {
              var o2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2);
              } catch (t4) {
                if (Ee(o2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, u: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (Ee(a2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, O: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (Ee(s2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, A: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (Ee(u2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, ka: function(t3, e3, n2, r3, i2, o2, a2, s2, u2) {
              var c2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2);
              } catch (t4) {
                if (Ee(c2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, C: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2) {
              var p2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2);
              } catch (t4) {
                if (Ee(p2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, D: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2) {
              var b2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2);
              } catch (t4) {
                if (Ee(b2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, fa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Ae();
              try {
                Fe(t3, e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (Ee(u2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, da: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
              var f2 = Ae();
              try {
                Le(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
              } catch (t4) {
                if (Ee(f2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, ea: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Ae();
              try {
                Ne(t3, e3, n2, r3, i2, o2);
              } catch (t4) {
                if (Ee(a2), t4 !== t4 + 0)
                  throw t4;
                Se(1, 0);
              }
            }, o: function(t3) {
              return t3;
            }, a: $ || s.wasmMemory, G: function(t3) {
              ae = t3;
            }, la: le, z: function(t3, e3, n2, r3) {
              return le(t3, e3, n2, r3);
            } };
            !function() {
              function t3(t4, e4) {
                s.asm = t4.exports, dt.qc.push(s.asm.sb), q = s.asm.ub, Y.unshift(s.asm.Va), k = e4, x || (et--, s.monitorRunDependencies && s.monitorRunDependencies(et), 0 == et && (null !== nt && (clearInterval(nt), nt = null), rt && (t4 = rt, rt = null, t4())));
              }
              function e3(e4) {
                t3(e4.instance, e4.module);
              }
              function n2(t4) {
                return function() {
                  if (!E && (_ || v)) {
                    if ("function" == typeof fetch && !tt.startsWith("file://"))
                      return fetch(tt, { credentials: "same-origin" }).then(function(t5) {
                        if (!t5.ok)
                          throw "failed to load wasm binary file at '" + tt + "'";
                        return t5.arrayBuffer();
                      }).catch(function() {
                        return at();
                      });
                    if (p)
                      return new Promise(function(t5, e4) {
                        p(tt, function(e5) {
                          t5(new Uint8Array(e5));
                        }, e4);
                      });
                  }
                  return Promise.resolve().then(function() {
                    return at();
                  });
                }().then(function(t5) {
                  return WebAssembly.instantiate(t5, r3);
                }).then(function(t5) {
                  return t5;
                }).then(t4, function(t5) {
                  P("failed to asynchronously prepare wasm: " + t5), it(t5);
                });
              }
              var r3 = { a: fe };
              if (x || (et++, s.monitorRunDependencies && s.monitorRunDependencies(et)), s.instantiateWasm)
                try {
                  return s.instantiateWasm(r3, t3);
                } catch (t4) {
                  return P("Module.instantiateWasm callback failed with error: " + t4), false;
                }
              (E || "function" != typeof WebAssembly.instantiateStreaming || ot() || tt.startsWith("file://") || w || "function" != typeof fetch ? n2(e3) : fetch(tt, { credentials: "same-origin" }).then(function(t4) {
                return WebAssembly.instantiateStreaming(t4, r3).then(e3, function(t5) {
                  return P("wasm streaming compile failed: " + t5), P("falling back to ArrayBuffer instantiation"), n2(e3);
                });
              })).catch(c);
            }(), s.___wasm_call_ctors = function() {
              return (s.___wasm_call_ctors = s.asm.Va).apply(null, arguments);
            }, s._OrtInit = function() {
              return (s._OrtInit = s.asm.Wa).apply(null, arguments);
            }, s._OrtCreateSessionOptions = function() {
              return (s._OrtCreateSessionOptions = s.asm.Xa).apply(null, arguments);
            }, s._OrtAppendExecutionProvider = function() {
              return (s._OrtAppendExecutionProvider = s.asm.Ya).apply(null, arguments);
            }, s._OrtAddSessionConfigEntry = function() {
              return (s._OrtAddSessionConfigEntry = s.asm.Za).apply(null, arguments);
            }, s._OrtReleaseSessionOptions = function() {
              return (s._OrtReleaseSessionOptions = s.asm._a).apply(null, arguments);
            }, s._OrtCreateSession = function() {
              return (s._OrtCreateSession = s.asm.$a).apply(null, arguments);
            }, s._OrtReleaseSession = function() {
              return (s._OrtReleaseSession = s.asm.ab).apply(null, arguments);
            }, s._OrtGetInputCount = function() {
              return (s._OrtGetInputCount = s.asm.bb).apply(null, arguments);
            }, s._OrtGetOutputCount = function() {
              return (s._OrtGetOutputCount = s.asm.cb).apply(null, arguments);
            }, s._OrtGetInputName = function() {
              return (s._OrtGetInputName = s.asm.db).apply(null, arguments);
            }, s._OrtGetOutputName = function() {
              return (s._OrtGetOutputName = s.asm.eb).apply(null, arguments);
            }, s._OrtFree = function() {
              return (s._OrtFree = s.asm.fb).apply(null, arguments);
            }, s._OrtCreateTensor = function() {
              return (s._OrtCreateTensor = s.asm.gb).apply(null, arguments);
            }, s._OrtGetTensorData = function() {
              return (s._OrtGetTensorData = s.asm.hb).apply(null, arguments);
            }, s._OrtReleaseTensor = function() {
              return (s._OrtReleaseTensor = s.asm.ib).apply(null, arguments);
            }, s._OrtCreateRunOptions = function() {
              return (s._OrtCreateRunOptions = s.asm.jb).apply(null, arguments);
            }, s._OrtAddRunConfigEntry = function() {
              return (s._OrtAddRunConfigEntry = s.asm.kb).apply(null, arguments);
            }, s._OrtReleaseRunOptions = function() {
              return (s._OrtReleaseRunOptions = s.asm.lb).apply(null, arguments);
            }, s._OrtRun = function() {
              return (s._OrtRun = s.asm.mb).apply(null, arguments);
            }, s._OrtEndProfiling = function() {
              return (s._OrtEndProfiling = s.asm.nb).apply(null, arguments);
            };
            var de = s._pthread_self = function() {
              return (de = s._pthread_self = s.asm.ob).apply(null, arguments);
            }, he = s._malloc = function() {
              return (he = s._malloc = s.asm.pb).apply(null, arguments);
            }, ge = s._free = function() {
              return (ge = s._free = s.asm.qb).apply(null, arguments);
            }, be = s._fflush = function() {
              return (be = s._fflush = s.asm.rb).apply(null, arguments);
            };
            s.__emscripten_tls_init = function() {
              return (s.__emscripten_tls_init = s.asm.sb).apply(null, arguments);
            };
            var me = s.___funcs_on_exit = function() {
              return (me = s.___funcs_on_exit = s.asm.tb).apply(null, arguments);
            }, ye = s.__emscripten_thread_init = function() {
              return (ye = s.__emscripten_thread_init = s.asm.vb).apply(null, arguments);
            };
            s.__emscripten_thread_crashed = function() {
              return (s.__emscripten_thread_crashed = s.asm.wb).apply(null, arguments);
            };
            var _e, ve = s._emscripten_run_in_main_runtime_thread_js = function() {
              return (ve = s._emscripten_run_in_main_runtime_thread_js = s.asm.xb).apply(null, arguments);
            }, we = s.__emscripten_proxy_execute_task_queue = function() {
              return (we = s.__emscripten_proxy_execute_task_queue = s.asm.yb).apply(null, arguments);
            }, xe = s.__emscripten_thread_free_data = function() {
              return (xe = s.__emscripten_thread_free_data = s.asm.zb).apply(null, arguments);
            }, Te = s.__emscripten_thread_exit = function() {
              return (Te = s.__emscripten_thread_exit = s.asm.Ab).apply(null, arguments);
            }, Se = s._setThrew = function() {
              return (Se = s._setThrew = s.asm.Bb).apply(null, arguments);
            }, Oe = s._emscripten_stack_set_limits = function() {
              return (Oe = s._emscripten_stack_set_limits = s.asm.Cb).apply(null, arguments);
            }, Ae = s.stackSave = function() {
              return (Ae = s.stackSave = s.asm.Db).apply(null, arguments);
            }, Ee = s.stackRestore = function() {
              return (Ee = s.stackRestore = s.asm.Eb).apply(null, arguments);
            }, Ie = s.stackAlloc = function() {
              return (Ie = s.stackAlloc = s.asm.Fb).apply(null, arguments);
            }, Pe = s.___cxa_can_catch = function() {
              return (Pe = s.___cxa_can_catch = s.asm.Gb).apply(null, arguments);
            }, De = s.___cxa_is_pointer_type = function() {
              return (De = s.___cxa_is_pointer_type = s.asm.Hb).apply(null, arguments);
            }, $e = s.dynCall_j = function() {
              return ($e = s.dynCall_j = s.asm.Ib).apply(null, arguments);
            }, ke = s.dynCall_iiiiij = function() {
              return (ke = s.dynCall_iiiiij = s.asm.Jb).apply(null, arguments);
            }, Ce = s.dynCall_jii = function() {
              return (Ce = s.dynCall_jii = s.asm.Kb).apply(null, arguments);
            }, Fe = s.dynCall_viiiiij = function() {
              return (Fe = s.dynCall_viiiiij = s.asm.Lb).apply(null, arguments);
            }, Ne = s.dynCall_vjji = function() {
              return (Ne = s.dynCall_vjji = s.asm.Mb).apply(null, arguments);
            }, Le = s.dynCall_viiijjjii = function() {
              return (Le = s.dynCall_viiijjjii = s.asm.Nb).apply(null, arguments);
            }, Re = s.dynCall_iij = function() {
              return (Re = s.dynCall_iij = s.asm.Ob).apply(null, arguments);
            }, je = s.dynCall_ji = function() {
              return (je = s.dynCall_ji = s.asm.Pb).apply(null, arguments);
            }, Me = s.dynCall_iiiiiij = function() {
              return (Me = s.dynCall_iiiiiij = s.asm.Qb).apply(null, arguments);
            }, Ue = s.dynCall_iiij = function() {
              return (Ue = s.dynCall_iiij = s.asm.Rb).apply(null, arguments);
            };
            function Ve() {
              function t3() {
                if (!_e && (_e = true, s.calledRun = true, !M) && (x || ht(Y), u(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), !x)) {
                  if (s.postRun)
                    for ("function" == typeof s.postRun && (s.postRun = [s.postRun]); s.postRun.length; ) {
                      var t4 = s.postRun.shift();
                      Z.unshift(t4);
                    }
                  ht(Z);
                }
              }
              if (!(0 < et))
                if (x)
                  u(s), x || ht(Y), postMessage({ cmd: "loaded" });
                else {
                  if (s.preRun)
                    for ("function" == typeof s.preRun && (s.preRun = [s.preRun]); s.preRun.length; )
                      Q();
                  ht(X), 0 < et || (s.setStatus ? (s.setStatus("Running..."), setTimeout(function() {
                    setTimeout(function() {
                      s.setStatus("");
                    }, 1), t3();
                  }, 1)) : t3());
                }
            }
            if (s.UTF8ToString = B, s.stringToUTF8 = function(t3, e3, n2) {
              return z(t3, r2(), e3, n2);
            }, s.lengthBytesUTF8 = G, s.keepRuntimeAlive = J, s.wasmMemory = $, s.stackSave = Ae, s.stackRestore = Ee, s.stackAlloc = Ie, s.ExitStatus = ut, s.PThread = dt, rt = function t3() {
              _e || Ve(), _e || (rt = t3);
            }, s.preInit)
              for ("function" == typeof s.preInit && (s.preInit = [s.preInit]); 0 < s.preInit.length; )
                s.preInit.pop()();
            return Ve(), t2.ready;
          });
          t.exports = r;
        }, 932: (t, e, n) => {
          var _scriptDir, r = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t2) {
            var e2, r2, i;
            t2 = t2 || {}, e2 || (e2 = void 0 !== t2 ? t2 : {}), e2.ready = new Promise(function(t3, e3) {
              r2 = t3, i = e3;
            });
            var o, a, s, u, c, l, p = Object.assign({}, e2), f = "./this.program", d = (t3, e3) => {
              throw e3;
            }, h = "object" == typeof window, g = "function" == typeof importScripts, b = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, m = "";
            b ? (m = g ? n(908).dirname(m) + "/" : "//", l = () => {
              c || (u = n(1384), c = n(908));
            }, o = function(t3, e3) {
              return l(), t3 = c.normalize(t3), u.readFileSync(t3, e3 ? void 0 : "utf8");
            }, s = (t3) => ((t3 = o(t3, true)).buffer || (t3 = new Uint8Array(t3)), t3), a = (t3, e3, n2) => {
              l(), t3 = c.normalize(t3), u.readFile(t3, function(t4, r3) {
                t4 ? n2(t4) : e3(r3.buffer);
              });
            }, 1 < process.argv.length && (f = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t3) {
              if (!(t3 instanceof K))
                throw t3;
            }), process.on("unhandledRejection", function(t3) {
              throw t3;
            }), d = (t3, e3) => {
              if (w || 0 < U)
                throw process.exitCode = t3, e3;
              e3 instanceof K || v("exiting due to exception: " + e3), process.exit(t3);
            }, e2.inspect = function() {
              return "[Emscripten Module object]";
            }) : (h || g) && (g ? m = self.location.href : "undefined" != typeof document && document.currentScript && (m = document.currentScript.src), _scriptDir && (m = _scriptDir), m = 0 !== m.indexOf("blob:") ? m.substr(0, m.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", o = (t3) => {
              var e3 = new XMLHttpRequest();
              return e3.open("GET", t3, false), e3.send(null), e3.responseText;
            }, g && (s = (t3) => {
              var e3 = new XMLHttpRequest();
              return e3.open("GET", t3, false), e3.responseType = "arraybuffer", e3.send(null), new Uint8Array(e3.response);
            }), a = (t3, e3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", t3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? e3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            });
            var y, _ = e2.print || console.log.bind(console), v = e2.printErr || console.warn.bind(console);
            Object.assign(e2, p), p = null, e2.thisProgram && (f = e2.thisProgram), e2.quit && (d = e2.quit), e2.wasmBinary && (y = e2.wasmBinary);
            var w = e2.noExitRuntime || false;
            "object" != typeof WebAssembly && W("no native wasm support detected");
            var x, T, S, O, A, E, I = false, P = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
            function D(t3, e3, n2) {
              var r3 = (e3 >>>= 0) + n2;
              for (n2 = e3; t3[n2] && !(n2 >= r3); )
                ++n2;
              if (16 < n2 - e3 && t3.buffer && P)
                return P.decode(t3.subarray(e3, n2));
              for (r3 = ""; e3 < n2; ) {
                var i2 = t3[e3++];
                if (128 & i2) {
                  var o2 = 63 & t3[e3++];
                  if (192 == (224 & i2))
                    r3 += String.fromCharCode((31 & i2) << 6 | o2);
                  else {
                    var a2 = 63 & t3[e3++];
                    65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & t3[e3++]) ? r3 += String.fromCharCode(i2) : (i2 -= 65536, r3 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
                  }
                } else
                  r3 += String.fromCharCode(i2);
              }
              return r3;
            }
            function $(t3, e3) {
              return (t3 >>>= 0) ? D(O, t3, e3) : "";
            }
            function k(t3, e3, n2, r3) {
              if (!(0 < r3))
                return 0;
              var i2 = n2 >>>= 0;
              r3 = n2 + r3 - 1;
              for (var o2 = 0; o2 < t3.length; ++o2) {
                var a2 = t3.charCodeAt(o2);
                if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & t3.charCodeAt(++o2)), 127 >= a2) {
                  if (n2 >= r3)
                    break;
                  e3[n2++ >>> 0] = a2;
                } else {
                  if (2047 >= a2) {
                    if (n2 + 1 >= r3)
                      break;
                    e3[n2++ >>> 0] = 192 | a2 >> 6;
                  } else {
                    if (65535 >= a2) {
                      if (n2 + 2 >= r3)
                        break;
                      e3[n2++ >>> 0] = 224 | a2 >> 12;
                    } else {
                      if (n2 + 3 >= r3)
                        break;
                      e3[n2++ >>> 0] = 240 | a2 >> 18, e3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                    }
                    e3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                  }
                  e3[n2++ >>> 0] = 128 | 63 & a2;
                }
              }
              return e3[n2 >>> 0] = 0, n2 - i2;
            }
            function C(t3) {
              for (var e3 = 0, n2 = 0; n2 < t3.length; ++n2) {
                var r3 = t3.charCodeAt(n2);
                127 >= r3 ? e3++ : 2047 >= r3 ? e3 += 2 : 55296 <= r3 && 57343 >= r3 ? (e3 += 4, ++n2) : e3 += 3;
              }
              return e3;
            }
            function F() {
              var t3 = x.buffer;
              T = t3, e2.HEAP8 = S = new Int8Array(t3), e2.HEAP16 = new Int16Array(t3), e2.HEAP32 = A = new Int32Array(t3), e2.HEAPU8 = O = new Uint8Array(t3), e2.HEAPU16 = new Uint16Array(t3), e2.HEAPU32 = E = new Uint32Array(t3), e2.HEAPF32 = new Float32Array(t3), e2.HEAPF64 = new Float64Array(t3);
            }
            var N, L = [], R = [], j = [], M = [], U = 0;
            function V() {
              var t3 = e2.preRun.shift();
              L.unshift(t3);
            }
            var B, z = 0, G = null, H = null;
            function W(t3) {
              throw e2.onAbort && e2.onAbort(t3), v(t3 = "Aborted(" + t3 + ")"), I = true, t3 = new WebAssembly.RuntimeError(t3 + ". Build with -sASSERTIONS for more info."), i(t3), t3;
            }
            function q() {
              return B.startsWith("data:application/octet-stream;base64,");
            }
            if (B = "ort-wasm.wasm", !q()) {
              var X = B;
              B = e2.locateFile ? e2.locateFile(X, m) : m + X;
            }
            function Y() {
              var t3 = B;
              try {
                if (t3 == B && y)
                  return new Uint8Array(y);
                if (s)
                  return s(t3);
                throw "both async and sync fetching of the wasm failed";
              } catch (t4) {
                W(t4);
              }
            }
            function K(t3) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + t3 + ")", this.status = t3;
            }
            function Z(t3) {
              for (; 0 < t3.length; )
                t3.shift()(e2);
            }
            var J = [], Q = 0, tt = 0;
            function et(t3) {
              this.Db = t3, this.zb = t3 - 24, this.Ub = function(t4) {
                E[this.zb + 4 >> 2 >>> 0] = t4;
              }, this.Eb = function() {
                return E[this.zb + 4 >> 2 >>> 0];
              }, this.Sb = function(t4) {
                E[this.zb + 8 >> 2 >>> 0] = t4;
              }, this.Wb = function() {
                return E[this.zb + 8 >> 2 >>> 0];
              }, this.Tb = function() {
                A[this.zb >> 2 >>> 0] = 0;
              }, this.Ib = function(t4) {
                S[this.zb + 12 >> 0 >>> 0] = t4 ? 1 : 0;
              }, this.Pb = function() {
                return 0 != S[this.zb + 12 >> 0 >>> 0];
              }, this.Jb = function(t4) {
                S[this.zb + 13 >> 0 >>> 0] = t4 ? 1 : 0;
              }, this.Lb = function() {
                return 0 != S[this.zb + 13 >> 0 >>> 0];
              }, this.Rb = function(t4, e3) {
                this.Fb(0), this.Ub(t4), this.Sb(e3), this.Tb(), this.Ib(false), this.Jb(false);
              }, this.Nb = function() {
                A[this.zb >> 2 >>> 0] += 1;
              }, this.Xb = function() {
                var t4 = A[this.zb >> 2 >>> 0];
                return A[this.zb >> 2 >>> 0] = t4 - 1, 1 === t4;
              }, this.Fb = function(t4) {
                E[this.zb + 16 >> 2 >>> 0] = t4;
              }, this.Ob = function() {
                return E[this.zb + 16 >> 2 >>> 0];
              }, this.Qb = function() {
                if (Et(this.Eb()))
                  return E[this.Db >> 2 >>> 0];
                var t4 = this.Ob();
                return 0 !== t4 ? t4 : this.Db;
              };
            }
            function nt(t3) {
              return _t(new et(t3).zb);
            }
            var rt = [];
            function it(t3) {
              var e3 = rt[t3];
              return e3 || (t3 >= rt.length && (rt.length = t3 + 1), rt[t3] = e3 = N.get(t3)), e3;
            }
            function ot(t3) {
              var e3 = C(t3) + 1, n2 = yt(e3);
              return n2 && k(t3, S, n2, e3), n2;
            }
            var at = {};
            function st() {
              if (!ut) {
                var t3, e3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: f || "./this.program" };
                for (t3 in at)
                  void 0 === at[t3] ? delete e3[t3] : e3[t3] = at[t3];
                var n2 = [];
                for (t3 in e3)
                  n2.push(t3 + "=" + e3[t3]);
                ut = n2;
              }
              return ut;
            }
            var ut, ct = [null, [], []];
            function lt(t3, e3) {
              var n2 = ct[t3];
              0 === e3 || 10 === e3 ? ((1 === t3 ? _ : v)(D(n2, 0)), n2.length = 0) : n2.push(e3);
            }
            var pt = 0;
            function ft(t3) {
              return 0 == t3 % 4 && (0 != t3 % 100 || 0 == t3 % 400);
            }
            var dt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ht = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function gt(t3, e3, n2, r3) {
              function i2(t4, e4, n3) {
                for (t4 = "number" == typeof t4 ? t4.toString() : t4 || ""; t4.length < e4; )
                  t4 = n3[0] + t4;
                return t4;
              }
              function o2(t4, e4) {
                return i2(t4, e4, "0");
              }
              function a2(t4, e4) {
                function n3(t5) {
                  return 0 > t5 ? -1 : 0 < t5 ? 1 : 0;
                }
                var r4;
                return 0 === (r4 = n3(t4.getFullYear() - e4.getFullYear())) && 0 === (r4 = n3(t4.getMonth() - e4.getMonth())) && (r4 = n3(t4.getDate() - e4.getDate())), r4;
              }
              function s2(t4) {
                switch (t4.getDay()) {
                  case 0:
                    return new Date(t4.getFullYear() - 1, 11, 29);
                  case 1:
                    return t4;
                  case 2:
                    return new Date(t4.getFullYear(), 0, 3);
                  case 3:
                    return new Date(t4.getFullYear(), 0, 2);
                  case 4:
                    return new Date(t4.getFullYear(), 0, 1);
                  case 5:
                    return new Date(t4.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(t4.getFullYear() - 1, 11, 30);
                }
              }
              function u2(t4) {
                var e4 = t4.Bb;
                for (t4 = new Date(new Date(t4.Cb + 1900, 0, 1).getTime()); 0 < e4; ) {
                  var n3 = t4.getMonth(), r4 = (ft(t4.getFullYear()) ? dt : ht)[n3];
                  if (!(e4 > r4 - t4.getDate())) {
                    t4.setDate(t4.getDate() + e4);
                    break;
                  }
                  e4 -= r4 - t4.getDate() + 1, t4.setDate(1), 11 > n3 ? t4.setMonth(n3 + 1) : (t4.setMonth(0), t4.setFullYear(t4.getFullYear() + 1));
                }
                return n3 = new Date(t4.getFullYear() + 1, 0, 4), e4 = s2(new Date(t4.getFullYear(), 0, 4)), n3 = s2(n3), 0 >= a2(e4, t4) ? 0 >= a2(n3, t4) ? t4.getFullYear() + 1 : t4.getFullYear() : t4.getFullYear() - 1;
              }
              var c2 = A[r3 + 40 >> 2 >>> 0];
              for (var l2 in r3 = { $b: A[r3 >> 2 >>> 0], Zb: A[r3 + 4 >> 2 >>> 0], Gb: A[r3 + 8 >> 2 >>> 0], Kb: A[r3 + 12 >> 2 >>> 0], Hb: A[r3 + 16 >> 2 >>> 0], Cb: A[r3 + 20 >> 2 >>> 0], Ab: A[r3 + 24 >> 2 >>> 0], Bb: A[r3 + 28 >> 2 >>> 0], bc: A[r3 + 32 >> 2 >>> 0], Yb: A[r3 + 36 >> 2 >>> 0], ac: c2 ? $(c2) : "" }, n2 = $(n2), c2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
                n2 = n2.replace(new RegExp(l2, "g"), c2[l2]);
              var p2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), f2 = "January February March April May June July August September October November December".split(" ");
              for (l2 in c2 = { "%a": function(t4) {
                return p2[t4.Ab].substring(0, 3);
              }, "%A": function(t4) {
                return p2[t4.Ab];
              }, "%b": function(t4) {
                return f2[t4.Hb].substring(0, 3);
              }, "%B": function(t4) {
                return f2[t4.Hb];
              }, "%C": function(t4) {
                return o2((t4.Cb + 1900) / 100 | 0, 2);
              }, "%d": function(t4) {
                return o2(t4.Kb, 2);
              }, "%e": function(t4) {
                return i2(t4.Kb, 2, " ");
              }, "%g": function(t4) {
                return u2(t4).toString().substring(2);
              }, "%G": function(t4) {
                return u2(t4);
              }, "%H": function(t4) {
                return o2(t4.Gb, 2);
              }, "%I": function(t4) {
                return 0 == (t4 = t4.Gb) ? t4 = 12 : 12 < t4 && (t4 -= 12), o2(t4, 2);
              }, "%j": function(t4) {
                for (var e4 = 0, n3 = 0; n3 <= t4.Hb - 1; e4 += (ft(t4.Cb + 1900) ? dt : ht)[n3++])
                  ;
                return o2(t4.Kb + e4, 3);
              }, "%m": function(t4) {
                return o2(t4.Hb + 1, 2);
              }, "%M": function(t4) {
                return o2(t4.Zb, 2);
              }, "%n": function() {
                return "\n";
              }, "%p": function(t4) {
                return 0 <= t4.Gb && 12 > t4.Gb ? "AM" : "PM";
              }, "%S": function(t4) {
                return o2(t4.$b, 2);
              }, "%t": function() {
                return "	";
              }, "%u": function(t4) {
                return t4.Ab || 7;
              }, "%U": function(t4) {
                return o2(Math.floor((t4.Bb + 7 - t4.Ab) / 7), 2);
              }, "%V": function(t4) {
                var e4 = Math.floor((t4.Bb + 7 - (t4.Ab + 6) % 7) / 7);
                if (2 >= (t4.Ab + 371 - t4.Bb - 2) % 7 && e4++, e4)
                  53 == e4 && (4 == (n3 = (t4.Ab + 371 - t4.Bb) % 7) || 3 == n3 && ft(t4.Cb) || (e4 = 1));
                else {
                  e4 = 52;
                  var n3 = (t4.Ab + 7 - t4.Bb - 1) % 7;
                  (4 == n3 || 5 == n3 && ft(t4.Cb % 400 - 1)) && e4++;
                }
                return o2(e4, 2);
              }, "%w": function(t4) {
                return t4.Ab;
              }, "%W": function(t4) {
                return o2(Math.floor((t4.Bb + 7 - (t4.Ab + 6) % 7) / 7), 2);
              }, "%y": function(t4) {
                return (t4.Cb + 1900).toString().substring(2);
              }, "%Y": function(t4) {
                return t4.Cb + 1900;
              }, "%z": function(t4) {
                var e4 = 0 <= (t4 = t4.Yb);
                return t4 = Math.abs(t4) / 60, (e4 ? "+" : "-") + String("0000" + (t4 / 60 * 100 + t4 % 60)).slice(-4);
              }, "%Z": function(t4) {
                return t4.ac;
              }, "%%": function() {
                return "%";
              } }, n2 = n2.replace(/%%/g, "\0\0"), c2)
                n2.includes(l2) && (n2 = n2.replace(new RegExp(l2, "g"), c2[l2](r3)));
              return l2 = function(t4) {
                var e4 = Array(C(t4) + 1);
                return k(t4, e4, 0, e4.length), e4;
              }(n2 = n2.replace(/\0\0/g, "%")), l2.length > e3 ? 0 : (S.set(l2, t3 >>> 0), l2.length - 1);
            }
            var bt = { a: function(t3) {
              return yt(t3 + 24) + 24;
            }, m: function(t3) {
              return (t3 = new et(t3)).Pb() || (t3.Ib(true), Q--), t3.Jb(false), J.push(t3), t3.Nb(), t3.Qb();
            }, ia: function(t3) {
              throw v("Unexpected exception thrown, this is not properly supported - aborting"), I = true, t3;
            }, w: function() {
              xt(0);
              var t3 = J.pop();
              if (t3.Xb() && !t3.Lb()) {
                var e3 = t3.Wb();
                e3 && it(e3)(t3.Db), nt(t3.Db);
              }
              tt = 0;
            }, d: function() {
              var t3 = tt;
              if (!t3)
                return pt = 0;
              var e3 = new et(t3);
              e3.Fb(t3);
              var n2 = e3.Eb();
              if (!n2)
                return pt = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2)
                  break;
                if (At(o2, n2, e3.zb + 16))
                  return pt = o2, t3;
              }
              return pt = n2, t3;
            }, k: function() {
              var t3 = tt;
              if (!t3)
                return pt = 0;
              var e3 = new et(t3);
              e3.Fb(t3);
              var n2 = e3.Eb();
              if (!n2)
                return pt = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2)
                  break;
                if (At(o2, n2, e3.zb + 16))
                  return pt = o2, t3;
              }
              return pt = n2, t3;
            }, g: function() {
              var t3 = tt;
              if (!t3)
                return pt = 0;
              var e3 = new et(t3);
              e3.Fb(t3);
              var n2 = e3.Eb();
              if (!n2)
                return pt = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2)
                  break;
                if (At(o2, n2, e3.zb + 16))
                  return pt = o2, t3;
              }
              return pt = n2, t3;
            }, s: nt, L: function() {
              var t3 = J.pop();
              t3 || W("no exception to throw");
              var e3 = t3.Db;
              throw t3.Lb() || (J.push(t3), t3.Jb(true), t3.Ib(false), Q++), tt = e3, e3;
            }, b: function(t3, e3, n2) {
              throw new et(t3).Rb(e3, n2), tt = t3, Q++, t3;
            }, la: function() {
              return Q;
            }, i: function(t3) {
              throw tt || (tt = t3), t3;
            }, H: function() {
              return 0;
            }, Ba: function() {
            }, pa: function() {
            }, ra: function() {
            }, ka: function() {
              return 0;
            }, za: function() {
            }, ua: function() {
            }, ya: function() {
            }, R: function() {
            }, qa: function() {
            }, na: function() {
            }, Aa: function() {
            }, oa: function() {
            }, Ha: function() {
            }, Ja: function() {
              W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, Ia: function() {
              W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, S: function() {
              return Date.now();
            }, Ca: function() {
              return true;
            }, Da: function(t3, e3) {
              t3 = new Date(1e3 * (E[t3 >>> 2] + 4294967296 * A[t3 + 4 >>> 2])), A[e3 >> 2 >>> 0] = t3.getUTCSeconds(), A[e3 + 4 >> 2 >>> 0] = t3.getUTCMinutes(), A[e3 + 8 >> 2 >>> 0] = t3.getUTCHours(), A[e3 + 12 >> 2 >>> 0] = t3.getUTCDate(), A[e3 + 16 >> 2 >>> 0] = t3.getUTCMonth(), A[e3 + 20 >> 2 >>> 0] = t3.getUTCFullYear() - 1900, A[e3 + 24 >> 2 >>> 0] = t3.getUTCDay(), A[e3 + 28 >> 2 >>> 0] = (t3.getTime() - Date.UTC(t3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
            }, Ea: function(t3, e3) {
              t3 = new Date(1e3 * (E[t3 >>> 2] + 4294967296 * A[t3 + 4 >>> 2])), A[e3 >> 2 >>> 0] = t3.getSeconds(), A[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), A[e3 + 8 >> 2 >>> 0] = t3.getHours(), A[e3 + 12 >> 2 >>> 0] = t3.getDate(), A[e3 + 16 >> 2 >>> 0] = t3.getMonth(), A[e3 + 20 >> 2 >>> 0] = t3.getFullYear() - 1900, A[e3 + 24 >> 2 >>> 0] = t3.getDay();
              var n2 = new Date(t3.getFullYear(), 0, 1);
              A[e3 + 28 >> 2 >>> 0] = (t3.getTime() - n2.getTime()) / 864e5 | 0, A[e3 + 36 >> 2 >>> 0] = -60 * t3.getTimezoneOffset();
              var r3 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset();
              n2 = n2.getTimezoneOffset(), A[e3 + 32 >> 2 >>> 0] = 0 | (r3 != n2 && t3.getTimezoneOffset() == Math.min(n2, r3));
            }, Fa: function(t3) {
              var e3 = new Date(A[t3 + 20 >> 2 >>> 0] + 1900, A[t3 + 16 >> 2 >>> 0], A[t3 + 12 >> 2 >>> 0], A[t3 + 8 >> 2 >>> 0], A[t3 + 4 >> 2 >>> 0], A[t3 >> 2 >>> 0], 0), n2 = A[t3 + 32 >> 2 >>> 0], r3 = e3.getTimezoneOffset(), i2 = new Date(e3.getFullYear(), 0, 1), o2 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset(), a2 = i2.getTimezoneOffset(), s2 = Math.min(a2, o2);
              return 0 > n2 ? A[t3 + 32 >> 2 >>> 0] = Number(o2 != a2 && s2 == r3) : 0 < n2 != (s2 == r3) && (o2 = Math.max(a2, o2), e3.setTime(e3.getTime() + 6e4 * ((0 < n2 ? s2 : o2) - r3))), A[t3 + 24 >> 2 >>> 0] = e3.getDay(), A[t3 + 28 >> 2 >>> 0] = (e3.getTime() - i2.getTime()) / 864e5 | 0, A[t3 >> 2 >>> 0] = e3.getSeconds(), A[t3 + 4 >> 2 >>> 0] = e3.getMinutes(), A[t3 + 8 >> 2 >>> 0] = e3.getHours(), A[t3 + 12 >> 2 >>> 0] = e3.getDate(), A[t3 + 16 >> 2 >>> 0] = e3.getMonth(), e3.getTime() / 1e3 | 0;
            }, sa: function() {
              return -52;
            }, ta: function() {
            }, Ga: function t3(e3, n2, r3) {
              t3.Vb || (t3.Vb = true, function(t4, e4, n3) {
                function r4(t5) {
                  return (t5 = t5.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t5[1] : "GMT";
                }
                var i2 = (/* @__PURE__ */ new Date()).getFullYear(), o2 = new Date(i2, 0, 1), a2 = new Date(i2, 6, 1);
                i2 = o2.getTimezoneOffset();
                var s2 = a2.getTimezoneOffset();
                A[t4 >> 2 >>> 0] = 60 * Math.max(i2, s2), A[e4 >> 2 >>> 0] = Number(i2 != s2), t4 = r4(o2), e4 = r4(a2), t4 = ot(t4), e4 = ot(e4), s2 < i2 ? (E[n3 >> 2 >>> 0] = t4, E[n3 + 4 >> 2 >>> 0] = e4) : (E[n3 >> 2 >>> 0] = e4, E[n3 + 4 >> 2 >>> 0] = t4);
              }(e3, n2, r3));
            }, B: function() {
              W("");
            }, ma: function() {
              return 4294901760;
            }, I: b ? () => {
              var t3 = process.hrtime();
              return 1e3 * t3[0] + t3[1] / 1e6;
            } : () => performance.now(), xa: function(t3, e3, n2) {
              O.copyWithin(t3 >>> 0, e3 >>> 0, e3 + n2 >>> 0);
            }, G: function(t3) {
              var e3 = O.length;
              if (4294901760 < (t3 >>>= 0))
                return false;
              for (var n2 = 1; 4 >= n2; n2 *= 2) {
                var r3 = e3 * (1 + 0.2 / n2);
                r3 = Math.min(r3, t3 + 100663296);
                var i2 = Math;
                r3 = Math.max(t3, r3), i2 = i2.min.call(i2, 4294901760, r3 + (65536 - r3 % 65536) % 65536);
                t: {
                  try {
                    x.grow(i2 - T.byteLength + 65535 >>> 16), F();
                    var o2 = 1;
                    break t;
                  } catch (t4) {
                  }
                  o2 = void 0;
                }
                if (o2)
                  return true;
              }
              return false;
            }, va: function(t3, e3) {
              var n2 = 0;
              return st().forEach(function(r3, i2) {
                var o2 = e3 + n2;
                for (i2 = E[t3 + 4 * i2 >> 2 >>> 0] = o2, o2 = 0; o2 < r3.length; ++o2)
                  S[i2++ >> 0 >>> 0] = r3.charCodeAt(o2);
                S[i2 >> 0 >>> 0] = 0, n2 += r3.length + 1;
              }), 0;
            }, wa: function(t3, e3) {
              var n2 = st();
              E[t3 >> 2 >>> 0] = n2.length;
              var r3 = 0;
              return n2.forEach(function(t4) {
                r3 += t4.length + 1;
              }), E[e3 >> 2 >>> 0] = r3, 0;
            }, ba: function(t3) {
              w || 0 < U || (wt(), Z(j), vt(0), ct[1].length && lt(1, 10), ct[2].length && lt(2, 10)), w || 0 < U || (e2.onExit && e2.onExit(t3), I = true), d(t3, new K(t3));
            }, E: function() {
              return 52;
            }, Q: function() {
              return 52;
            }, ca: function() {
              return 70;
            }, P: function(t3, e3, n2, r3) {
              for (var i2 = 0, o2 = 0; o2 < n2; o2++) {
                var a2 = E[e3 >> 2 >>> 0], s2 = E[e3 + 4 >> 2 >>> 0];
                e3 += 8;
                for (var u2 = 0; u2 < s2; u2++)
                  lt(t3, O[a2 + u2 >>> 0]);
                i2 += s2;
              }
              return E[r3 >> 2 >>> 0] = i2, 0;
            }, c: function() {
              return pt;
            }, ja: function t3(e3, r3) {
              t3.Mb || (t3.Mb = function() {
                if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
                  var t4 = new Uint8Array(1);
                  return () => (crypto.getRandomValues(t4), t4[0]);
                }
                if (b)
                  try {
                    var e4 = n(Object(function() {
                      var t5 = new Error("Cannot find module 'crypto'");
                      throw t5.code = "MODULE_NOT_FOUND", t5;
                    }()));
                    return () => e4.randomBytes(1)[0];
                  } catch (t5) {
                  }
                return () => W("randomDevice");
              }());
              for (var i2 = 0; i2 < r3; i2++)
                S[e3 + i2 >> 0 >>> 0] = t3.Mb();
              return 0;
            }, ea: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, fa: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, J: function(t3) {
              var e3 = Tt();
              try {
                return it(t3)();
              } catch (t4) {
                if (St(e3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, e: function(t3, e3) {
              var n2 = Tt();
              try {
                return it(t3)(e3);
              } catch (t4) {
                if (St(n2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, N: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, O: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, j: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, o: function(t3, e3, n2, r3) {
              var i2 = Tt();
              try {
                return it(t3)(e3, n2, r3);
              } catch (t4) {
                if (St(i2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, p: function(t3, e3, n2, r3, i2) {
              var o2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2);
              } catch (t4) {
                if (St(o2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, M: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (St(a2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, r: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (St(a2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, v: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (St(s2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, K: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (St(u2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, D: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
              var f2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
              } catch (t4) {
                if (St(f2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, X: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Tt();
              try {
                return Lt(t3, e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (St(u2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, V: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Tt();
              try {
                return Pt(t3, e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (St(s2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, U: function(t3, e3, n2, r3, i2) {
              var o2 = Tt();
              try {
                return Rt(t3, e3, n2, r3, i2);
              } catch (t4) {
                if (St(o2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, Z: function(t3, e3, n2, r3) {
              var i2 = Tt();
              try {
                return Ft(t3, e3, n2, r3);
              } catch (t4) {
                if (St(i2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, W: function(t3) {
              var e3 = Tt();
              try {
                return It(t3);
              } catch (t4) {
                if (St(e3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, Y: function(t3, e3) {
              var n2 = Tt();
              try {
                return Nt(t3, e3);
              } catch (t4) {
                if (St(n2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, T: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return Dt(t3, e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, f: function(t3) {
              var e3 = Tt();
              try {
                it(t3)();
              } catch (t4) {
                if (St(e3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, q: function(t3, e3) {
              var n2 = Tt();
              try {
                it(t3)(e3);
              } catch (t4) {
                if (St(n2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, h: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, da: function(t3, e3, n2, r3) {
              var i2 = Tt();
              try {
                it(t3)(e3, n2, r3);
              } catch (t4) {
                if (St(i2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, l: function(t3, e3, n2, r3) {
              var i2 = Tt();
              try {
                it(t3)(e3, n2, r3);
              } catch (t4) {
                if (St(i2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, t: function(t3, e3, n2, r3, i2) {
              var o2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2);
              } catch (t4) {
                if (St(o2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, u: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (St(a2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, x: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (St(s2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, z: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (St(u2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, ga: function(t3, e3, n2, r3, i2, o2, a2, s2, u2) {
              var c2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2, s2, u2);
              } catch (t4) {
                if (St(c2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, A: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2) {
              var p2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2);
              } catch (t4) {
                if (St(p2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, C: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2) {
              var b2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2);
              } catch (t4) {
                if (St(b2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, aa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Tt();
              try {
                $t(t3, e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (St(u2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, _: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
              var f2 = Tt();
              try {
                Ct(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
              } catch (t4) {
                if (St(f2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, $: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Tt();
              try {
                kt(t3, e3, n2, r3, i2, o2);
              } catch (t4) {
                if (St(a2), t4 !== t4 + 0)
                  throw t4;
                xt(1, 0);
              }
            }, n: function(t3) {
              return t3;
            }, F: function(t3) {
              pt = t3;
            }, ha: gt, y: function(t3, e3, n2, r3) {
              return gt(t3, e3, n2, r3);
            } };
            !function() {
              function t3(t4) {
                e2.asm = t4.exports, x = e2.asm.Ka, F(), N = e2.asm.ib, R.unshift(e2.asm.La), z--, e2.monitorRunDependencies && e2.monitorRunDependencies(z), 0 == z && (null !== G && (clearInterval(G), G = null), H && (t4 = H, H = null, t4()));
              }
              function n2(e3) {
                t3(e3.instance);
              }
              function r3(t4) {
                return function() {
                  if (!y && (h || g)) {
                    if ("function" == typeof fetch && !B.startsWith("file://"))
                      return fetch(B, { credentials: "same-origin" }).then(function(t5) {
                        if (!t5.ok)
                          throw "failed to load wasm binary file at '" + B + "'";
                        return t5.arrayBuffer();
                      }).catch(function() {
                        return Y();
                      });
                    if (a)
                      return new Promise(function(t5, e3) {
                        a(B, function(e4) {
                          t5(new Uint8Array(e4));
                        }, e3);
                      });
                  }
                  return Promise.resolve().then(function() {
                    return Y();
                  });
                }().then(function(t5) {
                  return WebAssembly.instantiate(t5, o2);
                }).then(function(t5) {
                  return t5;
                }).then(t4, function(t5) {
                  v("failed to asynchronously prepare wasm: " + t5), W(t5);
                });
              }
              var o2 = { a: bt };
              if (z++, e2.monitorRunDependencies && e2.monitorRunDependencies(z), e2.instantiateWasm)
                try {
                  return e2.instantiateWasm(o2, t3);
                } catch (t4) {
                  return v("Module.instantiateWasm callback failed with error: " + t4), false;
                }
              (y || "function" != typeof WebAssembly.instantiateStreaming || q() || B.startsWith("file://") || b || "function" != typeof fetch ? r3(n2) : fetch(B, { credentials: "same-origin" }).then(function(t4) {
                return WebAssembly.instantiateStreaming(t4, o2).then(n2, function(t5) {
                  return v("wasm streaming compile failed: " + t5), v("falling back to ArrayBuffer instantiation"), r3(n2);
                });
              })).catch(i);
            }(), e2.___wasm_call_ctors = function() {
              return (e2.___wasm_call_ctors = e2.asm.La).apply(null, arguments);
            }, e2._OrtInit = function() {
              return (e2._OrtInit = e2.asm.Ma).apply(null, arguments);
            }, e2._OrtCreateSessionOptions = function() {
              return (e2._OrtCreateSessionOptions = e2.asm.Na).apply(null, arguments);
            }, e2._OrtAppendExecutionProvider = function() {
              return (e2._OrtAppendExecutionProvider = e2.asm.Oa).apply(null, arguments);
            }, e2._OrtAddSessionConfigEntry = function() {
              return (e2._OrtAddSessionConfigEntry = e2.asm.Pa).apply(null, arguments);
            }, e2._OrtReleaseSessionOptions = function() {
              return (e2._OrtReleaseSessionOptions = e2.asm.Qa).apply(null, arguments);
            }, e2._OrtCreateSession = function() {
              return (e2._OrtCreateSession = e2.asm.Ra).apply(null, arguments);
            }, e2._OrtReleaseSession = function() {
              return (e2._OrtReleaseSession = e2.asm.Sa).apply(null, arguments);
            }, e2._OrtGetInputCount = function() {
              return (e2._OrtGetInputCount = e2.asm.Ta).apply(null, arguments);
            }, e2._OrtGetOutputCount = function() {
              return (e2._OrtGetOutputCount = e2.asm.Ua).apply(null, arguments);
            }, e2._OrtGetInputName = function() {
              return (e2._OrtGetInputName = e2.asm.Va).apply(null, arguments);
            }, e2._OrtGetOutputName = function() {
              return (e2._OrtGetOutputName = e2.asm.Wa).apply(null, arguments);
            }, e2._OrtFree = function() {
              return (e2._OrtFree = e2.asm.Xa).apply(null, arguments);
            }, e2._OrtCreateTensor = function() {
              return (e2._OrtCreateTensor = e2.asm.Ya).apply(null, arguments);
            }, e2._OrtGetTensorData = function() {
              return (e2._OrtGetTensorData = e2.asm.Za).apply(null, arguments);
            }, e2._OrtReleaseTensor = function() {
              return (e2._OrtReleaseTensor = e2.asm._a).apply(null, arguments);
            }, e2._OrtCreateRunOptions = function() {
              return (e2._OrtCreateRunOptions = e2.asm.$a).apply(null, arguments);
            }, e2._OrtAddRunConfigEntry = function() {
              return (e2._OrtAddRunConfigEntry = e2.asm.ab).apply(null, arguments);
            }, e2._OrtReleaseRunOptions = function() {
              return (e2._OrtReleaseRunOptions = e2.asm.bb).apply(null, arguments);
            }, e2._OrtRun = function() {
              return (e2._OrtRun = e2.asm.cb).apply(null, arguments);
            }, e2._OrtEndProfiling = function() {
              return (e2._OrtEndProfiling = e2.asm.db).apply(null, arguments);
            };
            var mt, yt = e2._malloc = function() {
              return (yt = e2._malloc = e2.asm.eb).apply(null, arguments);
            }, _t = e2._free = function() {
              return (_t = e2._free = e2.asm.fb).apply(null, arguments);
            }, vt = e2._fflush = function() {
              return (vt = e2._fflush = e2.asm.gb).apply(null, arguments);
            }, wt = e2.___funcs_on_exit = function() {
              return (wt = e2.___funcs_on_exit = e2.asm.hb).apply(null, arguments);
            }, xt = e2._setThrew = function() {
              return (xt = e2._setThrew = e2.asm.jb).apply(null, arguments);
            }, Tt = e2.stackSave = function() {
              return (Tt = e2.stackSave = e2.asm.kb).apply(null, arguments);
            }, St = e2.stackRestore = function() {
              return (St = e2.stackRestore = e2.asm.lb).apply(null, arguments);
            }, Ot = e2.stackAlloc = function() {
              return (Ot = e2.stackAlloc = e2.asm.mb).apply(null, arguments);
            }, At = e2.___cxa_can_catch = function() {
              return (At = e2.___cxa_can_catch = e2.asm.nb).apply(null, arguments);
            }, Et = e2.___cxa_is_pointer_type = function() {
              return (Et = e2.___cxa_is_pointer_type = e2.asm.ob).apply(null, arguments);
            }, It = e2.dynCall_j = function() {
              return (It = e2.dynCall_j = e2.asm.pb).apply(null, arguments);
            }, Pt = e2.dynCall_iiiiij = function() {
              return (Pt = e2.dynCall_iiiiij = e2.asm.qb).apply(null, arguments);
            }, Dt = e2.dynCall_jii = function() {
              return (Dt = e2.dynCall_jii = e2.asm.rb).apply(null, arguments);
            }, $t = e2.dynCall_viiiiij = function() {
              return ($t = e2.dynCall_viiiiij = e2.asm.sb).apply(null, arguments);
            }, kt = e2.dynCall_vjji = function() {
              return (kt = e2.dynCall_vjji = e2.asm.tb).apply(null, arguments);
            }, Ct = e2.dynCall_viiijjjii = function() {
              return (Ct = e2.dynCall_viiijjjii = e2.asm.ub).apply(null, arguments);
            }, Ft = e2.dynCall_iij = function() {
              return (Ft = e2.dynCall_iij = e2.asm.vb).apply(null, arguments);
            }, Nt = e2.dynCall_ji = function() {
              return (Nt = e2.dynCall_ji = e2.asm.wb).apply(null, arguments);
            }, Lt = e2.dynCall_iiiiiij = function() {
              return (Lt = e2.dynCall_iiiiiij = e2.asm.xb).apply(null, arguments);
            }, Rt = e2.dynCall_iiij = function() {
              return (Rt = e2.dynCall_iiij = e2.asm.yb).apply(null, arguments);
            };
            function jt() {
              function t3() {
                if (!mt && (mt = true, e2.calledRun = true, !I)) {
                  if (Z(R), r2(e2), e2.onRuntimeInitialized && e2.onRuntimeInitialized(), e2.postRun)
                    for ("function" == typeof e2.postRun && (e2.postRun = [e2.postRun]); e2.postRun.length; ) {
                      var t4 = e2.postRun.shift();
                      M.unshift(t4);
                    }
                  Z(M);
                }
              }
              if (!(0 < z)) {
                if (e2.preRun)
                  for ("function" == typeof e2.preRun && (e2.preRun = [e2.preRun]); e2.preRun.length; )
                    V();
                Z(L), 0 < z || (e2.setStatus ? (e2.setStatus("Running..."), setTimeout(function() {
                  setTimeout(function() {
                    e2.setStatus("");
                  }, 1), t3();
                }, 1)) : t3());
              }
            }
            if (e2.UTF8ToString = $, e2.stringToUTF8 = function(t3, e3, n2) {
              return k(t3, O, e3, n2);
            }, e2.lengthBytesUTF8 = C, e2.stackSave = Tt, e2.stackRestore = St, e2.stackAlloc = Ot, H = function t3() {
              mt || jt(), mt || (H = t3);
            }, e2.preInit)
              for ("function" == typeof e2.preInit && (e2.preInit = [e2.preInit]); 0 < e2.preInit.length; )
                e2.preInit.pop()();
            return jt(), t2.ready;
          });
          t.exports = r;
        }, 4537: (t) => {
          "use strict";
          t.exports = function(t2, e) {
            for (var n = new Array(arguments.length - 1), r = 0, i = 2, o = true; i < arguments.length; )
              n[r++] = arguments[i++];
            return new Promise(function(i2, a) {
              n[r] = function(t3) {
                if (o)
                  if (o = false, t3)
                    a(t3);
                  else {
                    for (var e2 = new Array(arguments.length - 1), n2 = 0; n2 < e2.length; )
                      e2[n2++] = arguments[n2];
                    i2.apply(null, e2);
                  }
              };
              try {
                t2.apply(e || null, n);
              } catch (t3) {
                o && (o = false, a(t3));
              }
            });
          };
        }, 7419: (t, e) => {
          "use strict";
          var n = e;
          n.length = function(t2) {
            var e2 = t2.length;
            if (!e2)
              return 0;
            for (var n2 = 0; --e2 % 4 > 1 && "=" === t2.charAt(e2); )
              ++n2;
            return Math.ceil(3 * t2.length) / 4 - n2;
          };
          for (var r = new Array(64), i = new Array(123), o = 0; o < 64; )
            i[r[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;
          n.encode = function(t2, e2, n2) {
            for (var i2, o2 = null, a2 = [], s = 0, u = 0; e2 < n2; ) {
              var c = t2[e2++];
              switch (u) {
                case 0:
                  a2[s++] = r[c >> 2], i2 = (3 & c) << 4, u = 1;
                  break;
                case 1:
                  a2[s++] = r[i2 | c >> 4], i2 = (15 & c) << 2, u = 2;
                  break;
                case 2:
                  a2[s++] = r[i2 | c >> 6], a2[s++] = r[63 & c], u = 0;
              }
              s > 8191 && ((o2 || (o2 = [])).push(String.fromCharCode.apply(String, a2)), s = 0);
            }
            return u && (a2[s++] = r[i2], a2[s++] = 61, 1 === u && (a2[s++] = 61)), o2 ? (s && o2.push(String.fromCharCode.apply(String, a2.slice(0, s))), o2.join("")) : String.fromCharCode.apply(String, a2.slice(0, s));
          };
          var a = "invalid encoding";
          n.decode = function(t2, e2, n2) {
            for (var r2, o2 = n2, s = 0, u = 0; u < t2.length; ) {
              var c = t2.charCodeAt(u++);
              if (61 === c && s > 1)
                break;
              if (void 0 === (c = i[c]))
                throw Error(a);
              switch (s) {
                case 0:
                  r2 = c, s = 1;
                  break;
                case 1:
                  e2[n2++] = r2 << 2 | (48 & c) >> 4, r2 = c, s = 2;
                  break;
                case 2:
                  e2[n2++] = (15 & r2) << 4 | (60 & c) >> 2, r2 = c, s = 3;
                  break;
                case 3:
                  e2[n2++] = (3 & r2) << 6 | c, s = 0;
              }
            }
            if (1 === s)
              throw Error(a);
            return n2 - o2;
          }, n.test = function(t2) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t2);
          };
        }, 9211: (t) => {
          "use strict";
          function e() {
            this._listeners = {};
          }
          t.exports = e, e.prototype.on = function(t2, e2, n) {
            return (this._listeners[t2] || (this._listeners[t2] = [])).push({ fn: e2, ctx: n || this }), this;
          }, e.prototype.off = function(t2, e2) {
            if (void 0 === t2)
              this._listeners = {};
            else if (void 0 === e2)
              this._listeners[t2] = [];
            else
              for (var n = this._listeners[t2], r = 0; r < n.length; )
                n[r].fn === e2 ? n.splice(r, 1) : ++r;
            return this;
          }, e.prototype.emit = function(t2) {
            var e2 = this._listeners[t2];
            if (e2) {
              for (var n = [], r = 1; r < arguments.length; )
                n.push(arguments[r++]);
              for (r = 0; r < e2.length; )
                e2[r].fn.apply(e2[r++].ctx, n);
            }
            return this;
          };
        }, 945: (t) => {
          "use strict";
          function e(t2) {
            return "undefined" != typeof Float32Array ? function() {
              var e2 = new Float32Array([-0]), n2 = new Uint8Array(e2.buffer), r2 = 128 === n2[3];
              function i2(t3, r3, i3) {
                e2[0] = t3, r3[i3] = n2[0], r3[i3 + 1] = n2[1], r3[i3 + 2] = n2[2], r3[i3 + 3] = n2[3];
              }
              function o2(t3, r3, i3) {
                e2[0] = t3, r3[i3] = n2[3], r3[i3 + 1] = n2[2], r3[i3 + 2] = n2[1], r3[i3 + 3] = n2[0];
              }
              function a(t3, r3) {
                return n2[0] = t3[r3], n2[1] = t3[r3 + 1], n2[2] = t3[r3 + 2], n2[3] = t3[r3 + 3], e2[0];
              }
              function s(t3, r3) {
                return n2[3] = t3[r3], n2[2] = t3[r3 + 1], n2[1] = t3[r3 + 2], n2[0] = t3[r3 + 3], e2[0];
              }
              t2.writeFloatLE = r2 ? i2 : o2, t2.writeFloatBE = r2 ? o2 : i2, t2.readFloatLE = r2 ? a : s, t2.readFloatBE = r2 ? s : a;
            }() : function() {
              function e2(t3, e3, n2, r2) {
                var i2 = e3 < 0 ? 1 : 0;
                if (i2 && (e3 = -e3), 0 === e3)
                  t3(1 / e3 > 0 ? 0 : 2147483648, n2, r2);
                else if (isNaN(e3))
                  t3(2143289344, n2, r2);
                else if (e3 > 34028234663852886e22)
                  t3((i2 << 31 | 2139095040) >>> 0, n2, r2);
                else if (e3 < 11754943508222875e-54)
                  t3((i2 << 31 | Math.round(e3 / 1401298464324817e-60)) >>> 0, n2, r2);
                else {
                  var o2 = Math.floor(Math.log(e3) / Math.LN2);
                  t3((i2 << 31 | o2 + 127 << 23 | 8388607 & Math.round(e3 * Math.pow(2, -o2) * 8388608)) >>> 0, n2, r2);
                }
              }
              function a(t3, e3, n2) {
                var r2 = t3(e3, n2), i2 = 2 * (r2 >> 31) + 1, o2 = r2 >>> 23 & 255, a2 = 8388607 & r2;
                return 255 === o2 ? a2 ? NaN : i2 * (1 / 0) : 0 === o2 ? 1401298464324817e-60 * i2 * a2 : i2 * Math.pow(2, o2 - 150) * (a2 + 8388608);
              }
              t2.writeFloatLE = e2.bind(null, n), t2.writeFloatBE = e2.bind(null, r), t2.readFloatLE = a.bind(null, i), t2.readFloatBE = a.bind(null, o);
            }(), "undefined" != typeof Float64Array ? function() {
              var e2 = new Float64Array([-0]), n2 = new Uint8Array(e2.buffer), r2 = 128 === n2[7];
              function i2(t3, r3, i3) {
                e2[0] = t3, r3[i3] = n2[0], r3[i3 + 1] = n2[1], r3[i3 + 2] = n2[2], r3[i3 + 3] = n2[3], r3[i3 + 4] = n2[4], r3[i3 + 5] = n2[5], r3[i3 + 6] = n2[6], r3[i3 + 7] = n2[7];
              }
              function o2(t3, r3, i3) {
                e2[0] = t3, r3[i3] = n2[7], r3[i3 + 1] = n2[6], r3[i3 + 2] = n2[5], r3[i3 + 3] = n2[4], r3[i3 + 4] = n2[3], r3[i3 + 5] = n2[2], r3[i3 + 6] = n2[1], r3[i3 + 7] = n2[0];
              }
              function a(t3, r3) {
                return n2[0] = t3[r3], n2[1] = t3[r3 + 1], n2[2] = t3[r3 + 2], n2[3] = t3[r3 + 3], n2[4] = t3[r3 + 4], n2[5] = t3[r3 + 5], n2[6] = t3[r3 + 6], n2[7] = t3[r3 + 7], e2[0];
              }
              function s(t3, r3) {
                return n2[7] = t3[r3], n2[6] = t3[r3 + 1], n2[5] = t3[r3 + 2], n2[4] = t3[r3 + 3], n2[3] = t3[r3 + 4], n2[2] = t3[r3 + 5], n2[1] = t3[r3 + 6], n2[0] = t3[r3 + 7], e2[0];
              }
              t2.writeDoubleLE = r2 ? i2 : o2, t2.writeDoubleBE = r2 ? o2 : i2, t2.readDoubleLE = r2 ? a : s, t2.readDoubleBE = r2 ? s : a;
            }() : function() {
              function e2(t3, e3, n2, r2, i2, o2) {
                var a2 = r2 < 0 ? 1 : 0;
                if (a2 && (r2 = -r2), 0 === r2)
                  t3(0, i2, o2 + e3), t3(1 / r2 > 0 ? 0 : 2147483648, i2, o2 + n2);
                else if (isNaN(r2))
                  t3(0, i2, o2 + e3), t3(2146959360, i2, o2 + n2);
                else if (r2 > 17976931348623157e292)
                  t3(0, i2, o2 + e3), t3((a2 << 31 | 2146435072) >>> 0, i2, o2 + n2);
                else {
                  var s;
                  if (r2 < 22250738585072014e-324)
                    t3((s = r2 / 5e-324) >>> 0, i2, o2 + e3), t3((a2 << 31 | s / 4294967296) >>> 0, i2, o2 + n2);
                  else {
                    var u = Math.floor(Math.log(r2) / Math.LN2);
                    1024 === u && (u = 1023), t3(4503599627370496 * (s = r2 * Math.pow(2, -u)) >>> 0, i2, o2 + e3), t3((a2 << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, i2, o2 + n2);
                  }
                }
              }
              function a(t3, e3, n2, r2, i2) {
                var o2 = t3(r2, i2 + e3), a2 = t3(r2, i2 + n2), s = 2 * (a2 >> 31) + 1, u = a2 >>> 20 & 2047, c = 4294967296 * (1048575 & a2) + o2;
                return 2047 === u ? c ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * c : s * Math.pow(2, u - 1075) * (c + 4503599627370496);
              }
              t2.writeDoubleLE = e2.bind(null, n, 0, 4), t2.writeDoubleBE = e2.bind(null, r, 4, 0), t2.readDoubleLE = a.bind(null, i, 0, 4), t2.readDoubleBE = a.bind(null, o, 4, 0);
            }(), t2;
          }
          function n(t2, e2, n2) {
            e2[n2] = 255 & t2, e2[n2 + 1] = t2 >>> 8 & 255, e2[n2 + 2] = t2 >>> 16 & 255, e2[n2 + 3] = t2 >>> 24;
          }
          function r(t2, e2, n2) {
            e2[n2] = t2 >>> 24, e2[n2 + 1] = t2 >>> 16 & 255, e2[n2 + 2] = t2 >>> 8 & 255, e2[n2 + 3] = 255 & t2;
          }
          function i(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16 | t2[e2 + 3] << 24) >>> 0;
          }
          function o(t2, e2) {
            return (t2[e2] << 24 | t2[e2 + 1] << 16 | t2[e2 + 2] << 8 | t2[e2 + 3]) >>> 0;
          }
          t.exports = e(e);
        }, 7199: (module) => {
          "use strict";
          function inquire(moduleName) {
            try {
              var mod = eval("quire".replace(/^/, "re"))(moduleName);
              if (mod && (mod.length || Object.keys(mod).length))
                return mod;
            } catch (t) {
            }
            return null;
          }
          module.exports = inquire;
        }, 6662: (t) => {
          "use strict";
          t.exports = function(t2, e, n) {
            var r = n || 8192, i = r >>> 1, o = null, a = r;
            return function(n2) {
              if (n2 < 1 || n2 > i)
                return t2(n2);
              a + n2 > r && (o = t2(r), a = 0);
              var s = e.call(o, a, a += n2);
              return 7 & a && (a = 1 + (7 | a)), s;
            };
          };
        }, 4997: (t, e) => {
          "use strict";
          var n = e;
          n.length = function(t2) {
            for (var e2 = 0, n2 = 0, r = 0; r < t2.length; ++r)
              (n2 = t2.charCodeAt(r)) < 128 ? e2 += 1 : n2 < 2048 ? e2 += 2 : 55296 == (64512 & n2) && 56320 == (64512 & t2.charCodeAt(r + 1)) ? (++r, e2 += 4) : e2 += 3;
            return e2;
          }, n.read = function(t2, e2, n2) {
            if (n2 - e2 < 1)
              return "";
            for (var r, i = null, o = [], a = 0; e2 < n2; )
              (r = t2[e2++]) < 128 ? o[a++] = r : r > 191 && r < 224 ? o[a++] = (31 & r) << 6 | 63 & t2[e2++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & t2[e2++]) << 12 | (63 & t2[e2++]) << 6 | 63 & t2[e2++]) - 65536, o[a++] = 55296 + (r >> 10), o[a++] = 56320 + (1023 & r)) : o[a++] = (15 & r) << 12 | (63 & t2[e2++]) << 6 | 63 & t2[e2++], a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), a = 0);
            return i ? (a && i.push(String.fromCharCode.apply(String, o.slice(0, a))), i.join("")) : String.fromCharCode.apply(String, o.slice(0, a));
          }, n.write = function(t2, e2, n2) {
            for (var r, i, o = n2, a = 0; a < t2.length; ++a)
              (r = t2.charCodeAt(a)) < 128 ? e2[n2++] = r : r < 2048 ? (e2[n2++] = r >> 6 | 192, e2[n2++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (i = t2.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & i), ++a, e2[n2++] = r >> 18 | 240, e2[n2++] = r >> 12 & 63 | 128, e2[n2++] = r >> 6 & 63 | 128, e2[n2++] = 63 & r | 128) : (e2[n2++] = r >> 12 | 224, e2[n2++] = r >> 6 & 63 | 128, e2[n2++] = 63 & r | 128);
            return n2 - o;
          };
        }, 3442: (t, e) => {
          "use strict";
          e.__esModule = true;
          var n = function() {
            function t2(e2) {
              if (!e2)
                throw new TypeError("Invalid argument; `value` has no value.");
              this.value = t2.EMPTY, e2 && t2.isGuid(e2) && (this.value = e2);
            }
            return t2.isGuid = function(e2) {
              var n2 = e2.toString();
              return e2 && (e2 instanceof t2 || t2.validator.test(n2));
            }, t2.create = function() {
              return new t2([t2.gen(2), t2.gen(1), t2.gen(1), t2.gen(1), t2.gen(3)].join("-"));
            }, t2.createEmpty = function() {
              return new t2("emptyguid");
            }, t2.parse = function(e2) {
              return new t2(e2);
            }, t2.raw = function() {
              return [t2.gen(2), t2.gen(1), t2.gen(1), t2.gen(1), t2.gen(3)].join("-");
            }, t2.gen = function(t3) {
              for (var e2 = "", n2 = 0; n2 < t3; n2++)
                e2 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
              return e2;
            }, t2.prototype.equals = function(e2) {
              return t2.isGuid(e2) && this.value === e2.toString();
            }, t2.prototype.isEmpty = function() {
              return this.value === t2.EMPTY;
            }, t2.prototype.toString = function() {
              return this.value;
            }, t2.prototype.toJSON = function() {
              return { value: this.value };
            }, t2.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), t2.EMPTY = "00000000-0000-0000-0000-000000000000", t2;
          }();
          e.Guid = n;
        }, 3720: (t) => {
          t.exports = n;
          var e = null;
          try {
            e = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
          } catch (t2) {
          }
          function n(t2, e2, n2) {
            this.low = 0 | t2, this.high = 0 | e2, this.unsigned = !!n2;
          }
          function r(t2) {
            return true === (t2 && t2.__isLong__);
          }
          n.prototype.__isLong__, Object.defineProperty(n.prototype, "__isLong__", { value: true }), n.isLong = r;
          var i = {}, o = {};
          function a(t2, e2) {
            var n2, r2, a2;
            return e2 ? (a2 = 0 <= (t2 >>>= 0) && t2 < 256) && (r2 = o[t2]) ? r2 : (n2 = u(t2, (0 | t2) < 0 ? -1 : 0, true), a2 && (o[t2] = n2), n2) : (a2 = -128 <= (t2 |= 0) && t2 < 128) && (r2 = i[t2]) ? r2 : (n2 = u(t2, t2 < 0 ? -1 : 0, false), a2 && (i[t2] = n2), n2);
          }
          function s(t2, e2) {
            if (isNaN(t2))
              return e2 ? m : b;
            if (e2) {
              if (t2 < 0)
                return m;
              if (t2 >= d)
                return x;
            } else {
              if (t2 <= -h)
                return T;
              if (t2 + 1 >= h)
                return w;
            }
            return t2 < 0 ? s(-t2, e2).neg() : u(t2 % f | 0, t2 / f | 0, e2);
          }
          function u(t2, e2, r2) {
            return new n(t2, e2, r2);
          }
          n.fromInt = a, n.fromNumber = s, n.fromBits = u;
          var c = Math.pow;
          function l(t2, e2, n2) {
            if (0 === t2.length)
              throw Error("empty string");
            if ("NaN" === t2 || "Infinity" === t2 || "+Infinity" === t2 || "-Infinity" === t2)
              return b;
            if ("number" == typeof e2 ? (n2 = e2, e2 = false) : e2 = !!e2, (n2 = n2 || 10) < 2 || 36 < n2)
              throw RangeError("radix");
            var r2;
            if ((r2 = t2.indexOf("-")) > 0)
              throw Error("interior hyphen");
            if (0 === r2)
              return l(t2.substring(1), e2, n2).neg();
            for (var i2 = s(c(n2, 8)), o2 = b, a2 = 0; a2 < t2.length; a2 += 8) {
              var u2 = Math.min(8, t2.length - a2), p2 = parseInt(t2.substring(a2, a2 + u2), n2);
              if (u2 < 8) {
                var f2 = s(c(n2, u2));
                o2 = o2.mul(f2).add(s(p2));
              } else
                o2 = (o2 = o2.mul(i2)).add(s(p2));
            }
            return o2.unsigned = e2, o2;
          }
          function p(t2, e2) {
            return "number" == typeof t2 ? s(t2, e2) : "string" == typeof t2 ? l(t2, e2) : u(t2.low, t2.high, "boolean" == typeof e2 ? e2 : t2.unsigned);
          }
          n.fromString = l, n.fromValue = p;
          var f = 4294967296, d = f * f, h = d / 2, g = a(1 << 24), b = a(0);
          n.ZERO = b;
          var m = a(0, true);
          n.UZERO = m;
          var y = a(1);
          n.ONE = y;
          var _ = a(1, true);
          n.UONE = _;
          var v = a(-1);
          n.NEG_ONE = v;
          var w = u(-1, 2147483647, false);
          n.MAX_VALUE = w;
          var x = u(-1, -1, true);
          n.MAX_UNSIGNED_VALUE = x;
          var T = u(0, -2147483648, false);
          n.MIN_VALUE = T;
          var S = n.prototype;
          S.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low;
          }, S.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);
          }, S.toString = function(t2) {
            if ((t2 = t2 || 10) < 2 || 36 < t2)
              throw RangeError("radix");
            if (this.isZero())
              return "0";
            if (this.isNegative()) {
              if (this.eq(T)) {
                var e2 = s(t2), n2 = this.div(e2), r2 = n2.mul(e2).sub(this);
                return n2.toString(t2) + r2.toInt().toString(t2);
              }
              return "-" + this.neg().toString(t2);
            }
            for (var i2 = s(c(t2, 6), this.unsigned), o2 = this, a2 = ""; ; ) {
              var u2 = o2.div(i2), l2 = (o2.sub(u2.mul(i2)).toInt() >>> 0).toString(t2);
              if ((o2 = u2).isZero())
                return l2 + a2;
              for (; l2.length < 6; )
                l2 = "0" + l2;
              a2 = "" + l2 + a2;
            }
          }, S.getHighBits = function() {
            return this.high;
          }, S.getHighBitsUnsigned = function() {
            return this.high >>> 0;
          }, S.getLowBits = function() {
            return this.low;
          }, S.getLowBitsUnsigned = function() {
            return this.low >>> 0;
          }, S.getNumBitsAbs = function() {
            if (this.isNegative())
              return this.eq(T) ? 64 : this.neg().getNumBitsAbs();
            for (var t2 = 0 != this.high ? this.high : this.low, e2 = 31; e2 > 0 && 0 == (t2 & 1 << e2); e2--)
              ;
            return 0 != this.high ? e2 + 33 : e2 + 1;
          }, S.isZero = function() {
            return 0 === this.high && 0 === this.low;
          }, S.eqz = S.isZero, S.isNegative = function() {
            return !this.unsigned && this.high < 0;
          }, S.isPositive = function() {
            return this.unsigned || this.high >= 0;
          }, S.isOdd = function() {
            return 1 == (1 & this.low);
          }, S.isEven = function() {
            return 0 == (1 & this.low);
          }, S.equals = function(t2) {
            return r(t2) || (t2 = p(t2)), (this.unsigned === t2.unsigned || this.high >>> 31 != 1 || t2.high >>> 31 != 1) && this.high === t2.high && this.low === t2.low;
          }, S.eq = S.equals, S.notEquals = function(t2) {
            return !this.eq(t2);
          }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function(t2) {
            return this.comp(t2) < 0;
          }, S.lt = S.lessThan, S.lessThanOrEqual = function(t2) {
            return this.comp(t2) <= 0;
          }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function(t2) {
            return this.comp(t2) > 0;
          }, S.gt = S.greaterThan, S.greaterThanOrEqual = function(t2) {
            return this.comp(t2) >= 0;
          }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function(t2) {
            if (r(t2) || (t2 = p(t2)), this.eq(t2))
              return 0;
            var e2 = this.isNegative(), n2 = t2.isNegative();
            return e2 && !n2 ? -1 : !e2 && n2 ? 1 : this.unsigned ? t2.high >>> 0 > this.high >>> 0 || t2.high === this.high && t2.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t2).isNegative() ? -1 : 1;
          }, S.comp = S.compare, S.negate = function() {
            return !this.unsigned && this.eq(T) ? T : this.not().add(y);
          }, S.neg = S.negate, S.add = function(t2) {
            r(t2) || (t2 = p(t2));
            var e2 = this.high >>> 16, n2 = 65535 & this.high, i2 = this.low >>> 16, o2 = 65535 & this.low, a2 = t2.high >>> 16, s2 = 65535 & t2.high, c2 = t2.low >>> 16, l2 = 0, f2 = 0, d2 = 0, h2 = 0;
            return d2 += (h2 += o2 + (65535 & t2.low)) >>> 16, f2 += (d2 += i2 + c2) >>> 16, l2 += (f2 += n2 + s2) >>> 16, l2 += e2 + a2, u((d2 &= 65535) << 16 | (h2 &= 65535), (l2 &= 65535) << 16 | (f2 &= 65535), this.unsigned);
          }, S.subtract = function(t2) {
            return r(t2) || (t2 = p(t2)), this.add(t2.neg());
          }, S.sub = S.subtract, S.multiply = function(t2) {
            if (this.isZero())
              return b;
            if (r(t2) || (t2 = p(t2)), e)
              return u(e.mul(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned);
            if (t2.isZero())
              return b;
            if (this.eq(T))
              return t2.isOdd() ? T : b;
            if (t2.eq(T))
              return this.isOdd() ? T : b;
            if (this.isNegative())
              return t2.isNegative() ? this.neg().mul(t2.neg()) : this.neg().mul(t2).neg();
            if (t2.isNegative())
              return this.mul(t2.neg()).neg();
            if (this.lt(g) && t2.lt(g))
              return s(this.toNumber() * t2.toNumber(), this.unsigned);
            var n2 = this.high >>> 16, i2 = 65535 & this.high, o2 = this.low >>> 16, a2 = 65535 & this.low, c2 = t2.high >>> 16, l2 = 65535 & t2.high, f2 = t2.low >>> 16, d2 = 65535 & t2.low, h2 = 0, m2 = 0, y2 = 0, _2 = 0;
            return y2 += (_2 += a2 * d2) >>> 16, m2 += (y2 += o2 * d2) >>> 16, y2 &= 65535, m2 += (y2 += a2 * f2) >>> 16, h2 += (m2 += i2 * d2) >>> 16, m2 &= 65535, h2 += (m2 += o2 * f2) >>> 16, m2 &= 65535, h2 += (m2 += a2 * l2) >>> 16, h2 += n2 * d2 + i2 * f2 + o2 * l2 + a2 * c2, u((y2 &= 65535) << 16 | (_2 &= 65535), (h2 &= 65535) << 16 | (m2 &= 65535), this.unsigned);
          }, S.mul = S.multiply, S.divide = function(t2) {
            if (r(t2) || (t2 = p(t2)), t2.isZero())
              throw Error("division by zero");
            var n2, i2, o2;
            if (e)
              return this.unsigned || -2147483648 !== this.high || -1 !== t2.low || -1 !== t2.high ? u((this.unsigned ? e.div_u : e.div_s)(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned) : this;
            if (this.isZero())
              return this.unsigned ? m : b;
            if (this.unsigned) {
              if (t2.unsigned || (t2 = t2.toUnsigned()), t2.gt(this))
                return m;
              if (t2.gt(this.shru(1)))
                return _;
              o2 = m;
            } else {
              if (this.eq(T))
                return t2.eq(y) || t2.eq(v) ? T : t2.eq(T) ? y : (n2 = this.shr(1).div(t2).shl(1)).eq(b) ? t2.isNegative() ? y : v : (i2 = this.sub(t2.mul(n2)), o2 = n2.add(i2.div(t2)));
              if (t2.eq(T))
                return this.unsigned ? m : b;
              if (this.isNegative())
                return t2.isNegative() ? this.neg().div(t2.neg()) : this.neg().div(t2).neg();
              if (t2.isNegative())
                return this.div(t2.neg()).neg();
              o2 = b;
            }
            for (i2 = this; i2.gte(t2); ) {
              n2 = Math.max(1, Math.floor(i2.toNumber() / t2.toNumber()));
              for (var a2 = Math.ceil(Math.log(n2) / Math.LN2), l2 = a2 <= 48 ? 1 : c(2, a2 - 48), f2 = s(n2), d2 = f2.mul(t2); d2.isNegative() || d2.gt(i2); )
                d2 = (f2 = s(n2 -= l2, this.unsigned)).mul(t2);
              f2.isZero() && (f2 = y), o2 = o2.add(f2), i2 = i2.sub(d2);
            }
            return o2;
          }, S.div = S.divide, S.modulo = function(t2) {
            return r(t2) || (t2 = p(t2)), e ? u((this.unsigned ? e.rem_u : e.rem_s)(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned) : this.sub(this.div(t2).mul(t2));
          }, S.mod = S.modulo, S.rem = S.modulo, S.not = function() {
            return u(~this.low, ~this.high, this.unsigned);
          }, S.and = function(t2) {
            return r(t2) || (t2 = p(t2)), u(this.low & t2.low, this.high & t2.high, this.unsigned);
          }, S.or = function(t2) {
            return r(t2) || (t2 = p(t2)), u(this.low | t2.low, this.high | t2.high, this.unsigned);
          }, S.xor = function(t2) {
            return r(t2) || (t2 = p(t2)), u(this.low ^ t2.low, this.high ^ t2.high, this.unsigned);
          }, S.shiftLeft = function(t2) {
            return r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63) ? this : t2 < 32 ? u(this.low << t2, this.high << t2 | this.low >>> 32 - t2, this.unsigned) : u(0, this.low << t2 - 32, this.unsigned);
          }, S.shl = S.shiftLeft, S.shiftRight = function(t2) {
            return r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63) ? this : t2 < 32 ? u(this.low >>> t2 | this.high << 32 - t2, this.high >> t2, this.unsigned) : u(this.high >> t2 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
          }, S.shr = S.shiftRight, S.shiftRightUnsigned = function(t2) {
            if (r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63))
              return this;
            var e2 = this.high;
            return t2 < 32 ? u(this.low >>> t2 | e2 << 32 - t2, e2 >>> t2, this.unsigned) : u(32 === t2 ? e2 : e2 >>> t2 - 32, 0, this.unsigned);
          }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.toSigned = function() {
            return this.unsigned ? u(this.low, this.high, false) : this;
          }, S.toUnsigned = function() {
            return this.unsigned ? this : u(this.low, this.high, true);
          }, S.toBytes = function(t2) {
            return t2 ? this.toBytesLE() : this.toBytesBE();
          }, S.toBytesLE = function() {
            var t2 = this.high, e2 = this.low;
            return [255 & e2, e2 >>> 8 & 255, e2 >>> 16 & 255, e2 >>> 24, 255 & t2, t2 >>> 8 & 255, t2 >>> 16 & 255, t2 >>> 24];
          }, S.toBytesBE = function() {
            var t2 = this.high, e2 = this.low;
            return [t2 >>> 24, t2 >>> 16 & 255, t2 >>> 8 & 255, 255 & t2, e2 >>> 24, e2 >>> 16 & 255, e2 >>> 8 & 255, 255 & e2];
          }, n.fromBytes = function(t2, e2, r2) {
            return r2 ? n.fromBytesLE(t2, e2) : n.fromBytesBE(t2, e2);
          }, n.fromBytesLE = function(t2, e2) {
            return new n(t2[0] | t2[1] << 8 | t2[2] << 16 | t2[3] << 24, t2[4] | t2[5] << 8 | t2[6] << 16 | t2[7] << 24, e2);
          }, n.fromBytesBE = function(t2, e2) {
            return new n(t2[4] << 24 | t2[5] << 16 | t2[6] << 8 | t2[7], t2[0] << 24 | t2[1] << 16 | t2[2] << 8 | t2[3], e2);
          };
        }, 1446: (t, e, n) => {
          "use strict";
          var r, i, o, a = n(2100), s = a.Reader, u = a.Writer, c = a.util, l = a.roots.default || (a.roots.default = {});
          l.onnx = ((o = {}).Version = (r = {}, (i = Object.create(r))[r[0] = "_START_VERSION"] = 0, i[r[1] = "IR_VERSION_2017_10_10"] = 1, i[r[2] = "IR_VERSION_2017_10_30"] = 2, i[r[3] = "IR_VERSION_2017_11_3"] = 3, i[r[4] = "IR_VERSION_2019_1_22"] = 4, i[r[5] = "IR_VERSION"] = 5, i), o.AttributeProto = function() {
            function t2(t3) {
              if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.name = "", t2.prototype.refAttrName = "", t2.prototype.docString = "", t2.prototype.type = 0, t2.prototype.f = 0, t2.prototype.i = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.s = c.newBuffer([]), t2.prototype.t = null, t2.prototype.g = null, t2.prototype.floats = c.emptyArray, t2.prototype.ints = c.emptyArray, t2.prototype.strings = c.emptyArray, t2.prototype.tensors = c.emptyArray, t2.prototype.graphs = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.name && t3.hasOwnProperty("name") && e2.uint32(10).string(t3.name), null != t3.f && t3.hasOwnProperty("f") && e2.uint32(21).float(t3.f), null != t3.i && t3.hasOwnProperty("i") && e2.uint32(24).int64(t3.i), null != t3.s && t3.hasOwnProperty("s") && e2.uint32(34).bytes(t3.s), null != t3.t && t3.hasOwnProperty("t") && l.onnx.TensorProto.encode(t3.t, e2.uint32(42).fork()).ldelim(), null != t3.g && t3.hasOwnProperty("g") && l.onnx.GraphProto.encode(t3.g, e2.uint32(50).fork()).ldelim(), null != t3.floats && t3.floats.length) {
                e2.uint32(58).fork();
                for (var n2 = 0; n2 < t3.floats.length; ++n2)
                  e2.float(t3.floats[n2]);
                e2.ldelim();
              }
              if (null != t3.ints && t3.ints.length) {
                for (e2.uint32(66).fork(), n2 = 0; n2 < t3.ints.length; ++n2)
                  e2.int64(t3.ints[n2]);
                e2.ldelim();
              }
              if (null != t3.strings && t3.strings.length)
                for (n2 = 0; n2 < t3.strings.length; ++n2)
                  e2.uint32(74).bytes(t3.strings[n2]);
              if (null != t3.tensors && t3.tensors.length)
                for (n2 = 0; n2 < t3.tensors.length; ++n2)
                  l.onnx.TensorProto.encode(t3.tensors[n2], e2.uint32(82).fork()).ldelim();
              if (null != t3.graphs && t3.graphs.length)
                for (n2 = 0; n2 < t3.graphs.length; ++n2)
                  l.onnx.GraphProto.encode(t3.graphs[n2], e2.uint32(90).fork()).ldelim();
              return null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(106).string(t3.docString), null != t3.type && t3.hasOwnProperty("type") && e2.uint32(160).int32(t3.type), null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && e2.uint32(170).string(t3.refAttrName), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.AttributeProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.name = t3.string();
                    break;
                  case 21:
                    r2.refAttrName = t3.string();
                    break;
                  case 13:
                    r2.docString = t3.string();
                    break;
                  case 20:
                    r2.type = t3.int32();
                    break;
                  case 2:
                    r2.f = t3.float();
                    break;
                  case 3:
                    r2.i = t3.int64();
                    break;
                  case 4:
                    r2.s = t3.bytes();
                    break;
                  case 5:
                    r2.t = l.onnx.TensorProto.decode(t3, t3.uint32());
                    break;
                  case 6:
                    r2.g = l.onnx.GraphProto.decode(t3, t3.uint32());
                    break;
                  case 7:
                    if (r2.floats && r2.floats.length || (r2.floats = []), 2 == (7 & i2))
                      for (var o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                        r2.floats.push(t3.float());
                    else
                      r2.floats.push(t3.float());
                    break;
                  case 8:
                    if (r2.ints && r2.ints.length || (r2.ints = []), 2 == (7 & i2))
                      for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                        r2.ints.push(t3.int64());
                    else
                      r2.ints.push(t3.int64());
                    break;
                  case 9:
                    r2.strings && r2.strings.length || (r2.strings = []), r2.strings.push(t3.bytes());
                    break;
                  case 10:
                    r2.tensors && r2.tensors.length || (r2.tensors = []), r2.tensors.push(l.onnx.TensorProto.decode(t3, t3.uint32()));
                    break;
                  case 11:
                    r2.graphs && r2.graphs.length || (r2.graphs = []), r2.graphs.push(l.onnx.GraphProto.decode(t3, t3.uint32()));
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                return "name: string expected";
              if (null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && !c.isString(t3.refAttrName))
                return "refAttrName: string expected";
              if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString))
                return "docString: string expected";
              if (null != t3.type && t3.hasOwnProperty("type"))
                switch (t3.type) {
                  default:
                    return "type: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 10:
                }
              if (null != t3.f && t3.hasOwnProperty("f") && "number" != typeof t3.f)
                return "f: number expected";
              if (null != t3.i && t3.hasOwnProperty("i") && !(c.isInteger(t3.i) || t3.i && c.isInteger(t3.i.low) && c.isInteger(t3.i.high)))
                return "i: integer|Long expected";
              if (null != t3.s && t3.hasOwnProperty("s") && !(t3.s && "number" == typeof t3.s.length || c.isString(t3.s)))
                return "s: buffer expected";
              if (null != t3.t && t3.hasOwnProperty("t") && (n2 = l.onnx.TensorProto.verify(t3.t)))
                return "t." + n2;
              if (null != t3.g && t3.hasOwnProperty("g") && (n2 = l.onnx.GraphProto.verify(t3.g)))
                return "g." + n2;
              if (null != t3.floats && t3.hasOwnProperty("floats")) {
                if (!Array.isArray(t3.floats))
                  return "floats: array expected";
                for (var e2 = 0; e2 < t3.floats.length; ++e2)
                  if ("number" != typeof t3.floats[e2])
                    return "floats: number[] expected";
              }
              if (null != t3.ints && t3.hasOwnProperty("ints")) {
                if (!Array.isArray(t3.ints))
                  return "ints: array expected";
                for (e2 = 0; e2 < t3.ints.length; ++e2)
                  if (!(c.isInteger(t3.ints[e2]) || t3.ints[e2] && c.isInteger(t3.ints[e2].low) && c.isInteger(t3.ints[e2].high)))
                    return "ints: integer|Long[] expected";
              }
              if (null != t3.strings && t3.hasOwnProperty("strings")) {
                if (!Array.isArray(t3.strings))
                  return "strings: array expected";
                for (e2 = 0; e2 < t3.strings.length; ++e2)
                  if (!(t3.strings[e2] && "number" == typeof t3.strings[e2].length || c.isString(t3.strings[e2])))
                    return "strings: buffer[] expected";
              }
              if (null != t3.tensors && t3.hasOwnProperty("tensors")) {
                if (!Array.isArray(t3.tensors))
                  return "tensors: array expected";
                for (e2 = 0; e2 < t3.tensors.length; ++e2)
                  if (n2 = l.onnx.TensorProto.verify(t3.tensors[e2]))
                    return "tensors." + n2;
              }
              if (null != t3.graphs && t3.hasOwnProperty("graphs")) {
                if (!Array.isArray(t3.graphs))
                  return "graphs: array expected";
                for (e2 = 0; e2 < t3.graphs.length; ++e2) {
                  var n2;
                  if (n2 = l.onnx.GraphProto.verify(t3.graphs[e2]))
                    return "graphs." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.AttributeProto)
                return t3;
              var e2 = new l.onnx.AttributeProto();
              switch (null != t3.name && (e2.name = String(t3.name)), null != t3.refAttrName && (e2.refAttrName = String(t3.refAttrName)), null != t3.docString && (e2.docString = String(t3.docString)), t3.type) {
                case "UNDEFINED":
                case 0:
                  e2.type = 0;
                  break;
                case "FLOAT":
                case 1:
                  e2.type = 1;
                  break;
                case "INT":
                case 2:
                  e2.type = 2;
                  break;
                case "STRING":
                case 3:
                  e2.type = 3;
                  break;
                case "TENSOR":
                case 4:
                  e2.type = 4;
                  break;
                case "GRAPH":
                case 5:
                  e2.type = 5;
                  break;
                case "FLOATS":
                case 6:
                  e2.type = 6;
                  break;
                case "INTS":
                case 7:
                  e2.type = 7;
                  break;
                case "STRINGS":
                case 8:
                  e2.type = 8;
                  break;
                case "TENSORS":
                case 9:
                  e2.type = 9;
                  break;
                case "GRAPHS":
                case 10:
                  e2.type = 10;
              }
              if (null != t3.f && (e2.f = Number(t3.f)), null != t3.i && (c.Long ? (e2.i = c.Long.fromValue(t3.i)).unsigned = false : "string" == typeof t3.i ? e2.i = parseInt(t3.i, 10) : "number" == typeof t3.i ? e2.i = t3.i : "object" == typeof t3.i && (e2.i = new c.LongBits(t3.i.low >>> 0, t3.i.high >>> 0).toNumber())), null != t3.s && ("string" == typeof t3.s ? c.base64.decode(t3.s, e2.s = c.newBuffer(c.base64.length(t3.s)), 0) : t3.s.length && (e2.s = t3.s)), null != t3.t) {
                if ("object" != typeof t3.t)
                  throw TypeError(".onnx.AttributeProto.t: object expected");
                e2.t = l.onnx.TensorProto.fromObject(t3.t);
              }
              if (null != t3.g) {
                if ("object" != typeof t3.g)
                  throw TypeError(".onnx.AttributeProto.g: object expected");
                e2.g = l.onnx.GraphProto.fromObject(t3.g);
              }
              if (t3.floats) {
                if (!Array.isArray(t3.floats))
                  throw TypeError(".onnx.AttributeProto.floats: array expected");
                e2.floats = [];
                for (var n2 = 0; n2 < t3.floats.length; ++n2)
                  e2.floats[n2] = Number(t3.floats[n2]);
              }
              if (t3.ints) {
                if (!Array.isArray(t3.ints))
                  throw TypeError(".onnx.AttributeProto.ints: array expected");
                for (e2.ints = [], n2 = 0; n2 < t3.ints.length; ++n2)
                  c.Long ? (e2.ints[n2] = c.Long.fromValue(t3.ints[n2])).unsigned = false : "string" == typeof t3.ints[n2] ? e2.ints[n2] = parseInt(t3.ints[n2], 10) : "number" == typeof t3.ints[n2] ? e2.ints[n2] = t3.ints[n2] : "object" == typeof t3.ints[n2] && (e2.ints[n2] = new c.LongBits(t3.ints[n2].low >>> 0, t3.ints[n2].high >>> 0).toNumber());
              }
              if (t3.strings) {
                if (!Array.isArray(t3.strings))
                  throw TypeError(".onnx.AttributeProto.strings: array expected");
                for (e2.strings = [], n2 = 0; n2 < t3.strings.length; ++n2)
                  "string" == typeof t3.strings[n2] ? c.base64.decode(t3.strings[n2], e2.strings[n2] = c.newBuffer(c.base64.length(t3.strings[n2])), 0) : t3.strings[n2].length && (e2.strings[n2] = t3.strings[n2]);
              }
              if (t3.tensors) {
                if (!Array.isArray(t3.tensors))
                  throw TypeError(".onnx.AttributeProto.tensors: array expected");
                for (e2.tensors = [], n2 = 0; n2 < t3.tensors.length; ++n2) {
                  if ("object" != typeof t3.tensors[n2])
                    throw TypeError(".onnx.AttributeProto.tensors: object expected");
                  e2.tensors[n2] = l.onnx.TensorProto.fromObject(t3.tensors[n2]);
                }
              }
              if (t3.graphs) {
                if (!Array.isArray(t3.graphs))
                  throw TypeError(".onnx.AttributeProto.graphs: array expected");
                for (e2.graphs = [], n2 = 0; n2 < t3.graphs.length; ++n2) {
                  if ("object" != typeof t3.graphs[n2])
                    throw TypeError(".onnx.AttributeProto.graphs: object expected");
                  e2.graphs[n2] = l.onnx.GraphProto.fromObject(t3.graphs[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.floats = [], n2.ints = [], n2.strings = [], n2.tensors = [], n2.graphs = []), e2.defaults) {
                if (n2.name = "", n2.f = 0, c.Long) {
                  var r2 = new c.Long(0, 0, false);
                  n2.i = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                } else
                  n2.i = e2.longs === String ? "0" : 0;
                e2.bytes === String ? n2.s = "" : (n2.s = [], e2.bytes !== Array && (n2.s = c.newBuffer(n2.s))), n2.t = null, n2.g = null, n2.docString = "", n2.type = e2.enums === String ? "UNDEFINED" : 0, n2.refAttrName = "";
              }
              if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.f && t3.hasOwnProperty("f") && (n2.f = e2.json && !isFinite(t3.f) ? String(t3.f) : t3.f), null != t3.i && t3.hasOwnProperty("i") && ("number" == typeof t3.i ? n2.i = e2.longs === String ? String(t3.i) : t3.i : n2.i = e2.longs === String ? c.Long.prototype.toString.call(t3.i) : e2.longs === Number ? new c.LongBits(t3.i.low >>> 0, t3.i.high >>> 0).toNumber() : t3.i), null != t3.s && t3.hasOwnProperty("s") && (n2.s = e2.bytes === String ? c.base64.encode(t3.s, 0, t3.s.length) : e2.bytes === Array ? Array.prototype.slice.call(t3.s) : t3.s), null != t3.t && t3.hasOwnProperty("t") && (n2.t = l.onnx.TensorProto.toObject(t3.t, e2)), null != t3.g && t3.hasOwnProperty("g") && (n2.g = l.onnx.GraphProto.toObject(t3.g, e2)), t3.floats && t3.floats.length) {
                n2.floats = [];
                for (var i2 = 0; i2 < t3.floats.length; ++i2)
                  n2.floats[i2] = e2.json && !isFinite(t3.floats[i2]) ? String(t3.floats[i2]) : t3.floats[i2];
              }
              if (t3.ints && t3.ints.length)
                for (n2.ints = [], i2 = 0; i2 < t3.ints.length; ++i2)
                  "number" == typeof t3.ints[i2] ? n2.ints[i2] = e2.longs === String ? String(t3.ints[i2]) : t3.ints[i2] : n2.ints[i2] = e2.longs === String ? c.Long.prototype.toString.call(t3.ints[i2]) : e2.longs === Number ? new c.LongBits(t3.ints[i2].low >>> 0, t3.ints[i2].high >>> 0).toNumber() : t3.ints[i2];
              if (t3.strings && t3.strings.length)
                for (n2.strings = [], i2 = 0; i2 < t3.strings.length; ++i2)
                  n2.strings[i2] = e2.bytes === String ? c.base64.encode(t3.strings[i2], 0, t3.strings[i2].length) : e2.bytes === Array ? Array.prototype.slice.call(t3.strings[i2]) : t3.strings[i2];
              if (t3.tensors && t3.tensors.length)
                for (n2.tensors = [], i2 = 0; i2 < t3.tensors.length; ++i2)
                  n2.tensors[i2] = l.onnx.TensorProto.toObject(t3.tensors[i2], e2);
              if (t3.graphs && t3.graphs.length)
                for (n2.graphs = [], i2 = 0; i2 < t3.graphs.length; ++i2)
                  n2.graphs[i2] = l.onnx.GraphProto.toObject(t3.graphs[i2], e2);
              return null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.type && t3.hasOwnProperty("type") && (n2.type = e2.enums === String ? l.onnx.AttributeProto.AttributeType[t3.type] : t3.type), null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && (n2.refAttrName = t3.refAttrName), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2.AttributeType = function() {
              var t3 = {}, e2 = Object.create(t3);
              return e2[t3[0] = "UNDEFINED"] = 0, e2[t3[1] = "FLOAT"] = 1, e2[t3[2] = "INT"] = 2, e2[t3[3] = "STRING"] = 3, e2[t3[4] = "TENSOR"] = 4, e2[t3[5] = "GRAPH"] = 5, e2[t3[6] = "FLOATS"] = 6, e2[t3[7] = "INTS"] = 7, e2[t3[8] = "STRINGS"] = 8, e2[t3[9] = "TENSORS"] = 9, e2[t3[10] = "GRAPHS"] = 10, e2;
            }(), t2;
          }(), o.ValueInfoProto = function() {
            function t2(t3) {
              if (t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.name = "", t2.prototype.type = null, t2.prototype.docString = "", t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              return e2 || (e2 = u.create()), null != t3.name && t3.hasOwnProperty("name") && e2.uint32(10).string(t3.name), null != t3.type && t3.hasOwnProperty("type") && l.onnx.TypeProto.encode(t3.type, e2.uint32(18).fork()).ldelim(), null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(26).string(t3.docString), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.ValueInfoProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.name = t3.string();
                    break;
                  case 2:
                    r2.type = l.onnx.TypeProto.decode(t3, t3.uint32());
                    break;
                  case 3:
                    r2.docString = t3.string();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                return "name: string expected";
              if (null != t3.type && t3.hasOwnProperty("type")) {
                var e2 = l.onnx.TypeProto.verify(t3.type);
                if (e2)
                  return "type." + e2;
              }
              return null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString) ? "docString: string expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.ValueInfoProto)
                return t3;
              var e2 = new l.onnx.ValueInfoProto();
              if (null != t3.name && (e2.name = String(t3.name)), null != t3.type) {
                if ("object" != typeof t3.type)
                  throw TypeError(".onnx.ValueInfoProto.type: object expected");
                e2.type = l.onnx.TypeProto.fromObject(t3.type);
              }
              return null != t3.docString && (e2.docString = String(t3.docString)), e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              return e2.defaults && (n2.name = "", n2.type = null, n2.docString = ""), null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.type && t3.hasOwnProperty("type") && (n2.type = l.onnx.TypeProto.toObject(t3.type, e2)), null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.NodeProto = function() {
            function t2(t3) {
              if (this.input = [], this.output = [], this.attribute = [], t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.input = c.emptyArray, t2.prototype.output = c.emptyArray, t2.prototype.name = "", t2.prototype.opType = "", t2.prototype.domain = "", t2.prototype.attribute = c.emptyArray, t2.prototype.docString = "", t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.input && t3.input.length)
                for (var n2 = 0; n2 < t3.input.length; ++n2)
                  e2.uint32(10).string(t3.input[n2]);
              if (null != t3.output && t3.output.length)
                for (n2 = 0; n2 < t3.output.length; ++n2)
                  e2.uint32(18).string(t3.output[n2]);
              if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(26).string(t3.name), null != t3.opType && t3.hasOwnProperty("opType") && e2.uint32(34).string(t3.opType), null != t3.attribute && t3.attribute.length)
                for (n2 = 0; n2 < t3.attribute.length; ++n2)
                  l.onnx.AttributeProto.encode(t3.attribute[n2], e2.uint32(42).fork()).ldelim();
              return null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(50).string(t3.docString), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(58).string(t3.domain), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.NodeProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.input && r2.input.length || (r2.input = []), r2.input.push(t3.string());
                    break;
                  case 2:
                    r2.output && r2.output.length || (r2.output = []), r2.output.push(t3.string());
                    break;
                  case 3:
                    r2.name = t3.string();
                    break;
                  case 4:
                    r2.opType = t3.string();
                    break;
                  case 7:
                    r2.domain = t3.string();
                    break;
                  case 5:
                    r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(l.onnx.AttributeProto.decode(t3, t3.uint32()));
                    break;
                  case 6:
                    r2.docString = t3.string();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.input && t3.hasOwnProperty("input")) {
                if (!Array.isArray(t3.input))
                  return "input: array expected";
                for (var e2 = 0; e2 < t3.input.length; ++e2)
                  if (!c.isString(t3.input[e2]))
                    return "input: string[] expected";
              }
              if (null != t3.output && t3.hasOwnProperty("output")) {
                if (!Array.isArray(t3.output))
                  return "output: array expected";
                for (e2 = 0; e2 < t3.output.length; ++e2)
                  if (!c.isString(t3.output[e2]))
                    return "output: string[] expected";
              }
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                return "name: string expected";
              if (null != t3.opType && t3.hasOwnProperty("opType") && !c.isString(t3.opType))
                return "opType: string expected";
              if (null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain))
                return "domain: string expected";
              if (null != t3.attribute && t3.hasOwnProperty("attribute")) {
                if (!Array.isArray(t3.attribute))
                  return "attribute: array expected";
                for (e2 = 0; e2 < t3.attribute.length; ++e2) {
                  var n2 = l.onnx.AttributeProto.verify(t3.attribute[e2]);
                  if (n2)
                    return "attribute." + n2;
                }
              }
              return null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString) ? "docString: string expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.NodeProto)
                return t3;
              var e2 = new l.onnx.NodeProto();
              if (t3.input) {
                if (!Array.isArray(t3.input))
                  throw TypeError(".onnx.NodeProto.input: array expected");
                e2.input = [];
                for (var n2 = 0; n2 < t3.input.length; ++n2)
                  e2.input[n2] = String(t3.input[n2]);
              }
              if (t3.output) {
                if (!Array.isArray(t3.output))
                  throw TypeError(".onnx.NodeProto.output: array expected");
                for (e2.output = [], n2 = 0; n2 < t3.output.length; ++n2)
                  e2.output[n2] = String(t3.output[n2]);
              }
              if (null != t3.name && (e2.name = String(t3.name)), null != t3.opType && (e2.opType = String(t3.opType)), null != t3.domain && (e2.domain = String(t3.domain)), t3.attribute) {
                if (!Array.isArray(t3.attribute))
                  throw TypeError(".onnx.NodeProto.attribute: array expected");
                for (e2.attribute = [], n2 = 0; n2 < t3.attribute.length; ++n2) {
                  if ("object" != typeof t3.attribute[n2])
                    throw TypeError(".onnx.NodeProto.attribute: object expected");
                  e2.attribute[n2] = l.onnx.AttributeProto.fromObject(t3.attribute[n2]);
                }
              }
              return null != t3.docString && (e2.docString = String(t3.docString)), e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.input = [], n2.output = [], n2.attribute = []), e2.defaults && (n2.name = "", n2.opType = "", n2.docString = "", n2.domain = ""), t3.input && t3.input.length) {
                n2.input = [];
                for (var r2 = 0; r2 < t3.input.length; ++r2)
                  n2.input[r2] = t3.input[r2];
              }
              if (t3.output && t3.output.length)
                for (n2.output = [], r2 = 0; r2 < t3.output.length; ++r2)
                  n2.output[r2] = t3.output[r2];
              if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.opType && t3.hasOwnProperty("opType") && (n2.opType = t3.opType), t3.attribute && t3.attribute.length)
                for (n2.attribute = [], r2 = 0; r2 < t3.attribute.length; ++r2)
                  n2.attribute[r2] = l.onnx.AttributeProto.toObject(t3.attribute[r2], e2);
              return null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.ModelProto = function() {
            function t2(t3) {
              if (this.opsetImport = [], this.metadataProps = [], t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.irVersion = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.opsetImport = c.emptyArray, t2.prototype.producerName = "", t2.prototype.producerVersion = "", t2.prototype.domain = "", t2.prototype.modelVersion = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.docString = "", t2.prototype.graph = null, t2.prototype.metadataProps = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.irVersion && t3.hasOwnProperty("irVersion") && e2.uint32(8).int64(t3.irVersion), null != t3.producerName && t3.hasOwnProperty("producerName") && e2.uint32(18).string(t3.producerName), null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && e2.uint32(26).string(t3.producerVersion), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(34).string(t3.domain), null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && e2.uint32(40).int64(t3.modelVersion), null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(50).string(t3.docString), null != t3.graph && t3.hasOwnProperty("graph") && l.onnx.GraphProto.encode(t3.graph, e2.uint32(58).fork()).ldelim(), null != t3.opsetImport && t3.opsetImport.length)
                for (var n2 = 0; n2 < t3.opsetImport.length; ++n2)
                  l.onnx.OperatorSetIdProto.encode(t3.opsetImport[n2], e2.uint32(66).fork()).ldelim();
              if (null != t3.metadataProps && t3.metadataProps.length)
                for (n2 = 0; n2 < t3.metadataProps.length; ++n2)
                  l.onnx.StringStringEntryProto.encode(t3.metadataProps[n2], e2.uint32(114).fork()).ldelim();
              return e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.ModelProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.irVersion = t3.int64();
                    break;
                  case 8:
                    r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t3, t3.uint32()));
                    break;
                  case 2:
                    r2.producerName = t3.string();
                    break;
                  case 3:
                    r2.producerVersion = t3.string();
                    break;
                  case 4:
                    r2.domain = t3.string();
                    break;
                  case 5:
                    r2.modelVersion = t3.int64();
                    break;
                  case 6:
                    r2.docString = t3.string();
                    break;
                  case 7:
                    r2.graph = l.onnx.GraphProto.decode(t3, t3.uint32());
                    break;
                  case 14:
                    r2.metadataProps && r2.metadataProps.length || (r2.metadataProps = []), r2.metadataProps.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.irVersion && t3.hasOwnProperty("irVersion") && !(c.isInteger(t3.irVersion) || t3.irVersion && c.isInteger(t3.irVersion.low) && c.isInteger(t3.irVersion.high)))
                return "irVersion: integer|Long expected";
              if (null != t3.opsetImport && t3.hasOwnProperty("opsetImport")) {
                if (!Array.isArray(t3.opsetImport))
                  return "opsetImport: array expected";
                for (var e2 = 0; e2 < t3.opsetImport.length; ++e2)
                  if (n2 = l.onnx.OperatorSetIdProto.verify(t3.opsetImport[e2]))
                    return "opsetImport." + n2;
              }
              if (null != t3.producerName && t3.hasOwnProperty("producerName") && !c.isString(t3.producerName))
                return "producerName: string expected";
              if (null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && !c.isString(t3.producerVersion))
                return "producerVersion: string expected";
              if (null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain))
                return "domain: string expected";
              if (null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && !(c.isInteger(t3.modelVersion) || t3.modelVersion && c.isInteger(t3.modelVersion.low) && c.isInteger(t3.modelVersion.high)))
                return "modelVersion: integer|Long expected";
              if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString))
                return "docString: string expected";
              if (null != t3.graph && t3.hasOwnProperty("graph") && (n2 = l.onnx.GraphProto.verify(t3.graph)))
                return "graph." + n2;
              if (null != t3.metadataProps && t3.hasOwnProperty("metadataProps")) {
                if (!Array.isArray(t3.metadataProps))
                  return "metadataProps: array expected";
                for (e2 = 0; e2 < t3.metadataProps.length; ++e2) {
                  var n2;
                  if (n2 = l.onnx.StringStringEntryProto.verify(t3.metadataProps[e2]))
                    return "metadataProps." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.ModelProto)
                return t3;
              var e2 = new l.onnx.ModelProto();
              if (null != t3.irVersion && (c.Long ? (e2.irVersion = c.Long.fromValue(t3.irVersion)).unsigned = false : "string" == typeof t3.irVersion ? e2.irVersion = parseInt(t3.irVersion, 10) : "number" == typeof t3.irVersion ? e2.irVersion = t3.irVersion : "object" == typeof t3.irVersion && (e2.irVersion = new c.LongBits(t3.irVersion.low >>> 0, t3.irVersion.high >>> 0).toNumber())), t3.opsetImport) {
                if (!Array.isArray(t3.opsetImport))
                  throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                e2.opsetImport = [];
                for (var n2 = 0; n2 < t3.opsetImport.length; ++n2) {
                  if ("object" != typeof t3.opsetImport[n2])
                    throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                  e2.opsetImport[n2] = l.onnx.OperatorSetIdProto.fromObject(t3.opsetImport[n2]);
                }
              }
              if (null != t3.producerName && (e2.producerName = String(t3.producerName)), null != t3.producerVersion && (e2.producerVersion = String(t3.producerVersion)), null != t3.domain && (e2.domain = String(t3.domain)), null != t3.modelVersion && (c.Long ? (e2.modelVersion = c.Long.fromValue(t3.modelVersion)).unsigned = false : "string" == typeof t3.modelVersion ? e2.modelVersion = parseInt(t3.modelVersion, 10) : "number" == typeof t3.modelVersion ? e2.modelVersion = t3.modelVersion : "object" == typeof t3.modelVersion && (e2.modelVersion = new c.LongBits(t3.modelVersion.low >>> 0, t3.modelVersion.high >>> 0).toNumber())), null != t3.docString && (e2.docString = String(t3.docString)), null != t3.graph) {
                if ("object" != typeof t3.graph)
                  throw TypeError(".onnx.ModelProto.graph: object expected");
                e2.graph = l.onnx.GraphProto.fromObject(t3.graph);
              }
              if (t3.metadataProps) {
                if (!Array.isArray(t3.metadataProps))
                  throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                for (e2.metadataProps = [], n2 = 0; n2 < t3.metadataProps.length; ++n2) {
                  if ("object" != typeof t3.metadataProps[n2])
                    throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                  e2.metadataProps[n2] = l.onnx.StringStringEntryProto.fromObject(t3.metadataProps[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.opsetImport = [], n2.metadataProps = []), e2.defaults) {
                if (c.Long) {
                  var r2 = new c.Long(0, 0, false);
                  n2.irVersion = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                } else
                  n2.irVersion = e2.longs === String ? "0" : 0;
                n2.producerName = "", n2.producerVersion = "", n2.domain = "", c.Long ? (r2 = new c.Long(0, 0, false), n2.modelVersion = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2) : n2.modelVersion = e2.longs === String ? "0" : 0, n2.docString = "", n2.graph = null;
              }
              if (null != t3.irVersion && t3.hasOwnProperty("irVersion") && ("number" == typeof t3.irVersion ? n2.irVersion = e2.longs === String ? String(t3.irVersion) : t3.irVersion : n2.irVersion = e2.longs === String ? c.Long.prototype.toString.call(t3.irVersion) : e2.longs === Number ? new c.LongBits(t3.irVersion.low >>> 0, t3.irVersion.high >>> 0).toNumber() : t3.irVersion), null != t3.producerName && t3.hasOwnProperty("producerName") && (n2.producerName = t3.producerName), null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && (n2.producerVersion = t3.producerVersion), null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && ("number" == typeof t3.modelVersion ? n2.modelVersion = e2.longs === String ? String(t3.modelVersion) : t3.modelVersion : n2.modelVersion = e2.longs === String ? c.Long.prototype.toString.call(t3.modelVersion) : e2.longs === Number ? new c.LongBits(t3.modelVersion.low >>> 0, t3.modelVersion.high >>> 0).toNumber() : t3.modelVersion), null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.graph && t3.hasOwnProperty("graph") && (n2.graph = l.onnx.GraphProto.toObject(t3.graph, e2)), t3.opsetImport && t3.opsetImport.length) {
                n2.opsetImport = [];
                for (var i2 = 0; i2 < t3.opsetImport.length; ++i2)
                  n2.opsetImport[i2] = l.onnx.OperatorSetIdProto.toObject(t3.opsetImport[i2], e2);
              }
              if (t3.metadataProps && t3.metadataProps.length)
                for (n2.metadataProps = [], i2 = 0; i2 < t3.metadataProps.length; ++i2)
                  n2.metadataProps[i2] = l.onnx.StringStringEntryProto.toObject(t3.metadataProps[i2], e2);
              return n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.StringStringEntryProto = function() {
            function t2(t3) {
              if (t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.key = "", t2.prototype.value = "", t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              return e2 || (e2 = u.create()), null != t3.key && t3.hasOwnProperty("key") && e2.uint32(10).string(t3.key), null != t3.value && t3.hasOwnProperty("value") && e2.uint32(18).string(t3.value), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.StringStringEntryProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.key = t3.string();
                    break;
                  case 2:
                    r2.value = t3.string();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              return "object" != typeof t3 || null === t3 ? "object expected" : null != t3.key && t3.hasOwnProperty("key") && !c.isString(t3.key) ? "key: string expected" : null != t3.value && t3.hasOwnProperty("value") && !c.isString(t3.value) ? "value: string expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.StringStringEntryProto)
                return t3;
              var e2 = new l.onnx.StringStringEntryProto();
              return null != t3.key && (e2.key = String(t3.key)), null != t3.value && (e2.value = String(t3.value)), e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              return e2.defaults && (n2.key = "", n2.value = ""), null != t3.key && t3.hasOwnProperty("key") && (n2.key = t3.key), null != t3.value && t3.hasOwnProperty("value") && (n2.value = t3.value), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.TensorAnnotation = function() {
            function t2(t3) {
              if (this.quantParameterTensorNames = [], t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.tensorName = "", t2.prototype.quantParameterTensorNames = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.tensorName && t3.hasOwnProperty("tensorName") && e2.uint32(10).string(t3.tensorName), null != t3.quantParameterTensorNames && t3.quantParameterTensorNames.length)
                for (var n2 = 0; n2 < t3.quantParameterTensorNames.length; ++n2)
                  l.onnx.StringStringEntryProto.encode(t3.quantParameterTensorNames[n2], e2.uint32(18).fork()).ldelim();
              return e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorAnnotation(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.tensorName = t3.string();
                    break;
                  case 2:
                    r2.quantParameterTensorNames && r2.quantParameterTensorNames.length || (r2.quantParameterTensorNames = []), r2.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.tensorName && t3.hasOwnProperty("tensorName") && !c.isString(t3.tensorName))
                return "tensorName: string expected";
              if (null != t3.quantParameterTensorNames && t3.hasOwnProperty("quantParameterTensorNames")) {
                if (!Array.isArray(t3.quantParameterTensorNames))
                  return "quantParameterTensorNames: array expected";
                for (var e2 = 0; e2 < t3.quantParameterTensorNames.length; ++e2) {
                  var n2 = l.onnx.StringStringEntryProto.verify(t3.quantParameterTensorNames[e2]);
                  if (n2)
                    return "quantParameterTensorNames." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.TensorAnnotation)
                return t3;
              var e2 = new l.onnx.TensorAnnotation();
              if (null != t3.tensorName && (e2.tensorName = String(t3.tensorName)), t3.quantParameterTensorNames) {
                if (!Array.isArray(t3.quantParameterTensorNames))
                  throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                e2.quantParameterTensorNames = [];
                for (var n2 = 0; n2 < t3.quantParameterTensorNames.length; ++n2) {
                  if ("object" != typeof t3.quantParameterTensorNames[n2])
                    throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                  e2.quantParameterTensorNames[n2] = l.onnx.StringStringEntryProto.fromObject(t3.quantParameterTensorNames[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.quantParameterTensorNames = []), e2.defaults && (n2.tensorName = ""), null != t3.tensorName && t3.hasOwnProperty("tensorName") && (n2.tensorName = t3.tensorName), t3.quantParameterTensorNames && t3.quantParameterTensorNames.length) {
                n2.quantParameterTensorNames = [];
                for (var r2 = 0; r2 < t3.quantParameterTensorNames.length; ++r2)
                  n2.quantParameterTensorNames[r2] = l.onnx.StringStringEntryProto.toObject(t3.quantParameterTensorNames[r2], e2);
              }
              return n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.GraphProto = function() {
            function t2(t3) {
              if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.node = c.emptyArray, t2.prototype.name = "", t2.prototype.initializer = c.emptyArray, t2.prototype.docString = "", t2.prototype.input = c.emptyArray, t2.prototype.output = c.emptyArray, t2.prototype.valueInfo = c.emptyArray, t2.prototype.quantizationAnnotation = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.node && t3.node.length)
                for (var n2 = 0; n2 < t3.node.length; ++n2)
                  l.onnx.NodeProto.encode(t3.node[n2], e2.uint32(10).fork()).ldelim();
              if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(18).string(t3.name), null != t3.initializer && t3.initializer.length)
                for (n2 = 0; n2 < t3.initializer.length; ++n2)
                  l.onnx.TensorProto.encode(t3.initializer[n2], e2.uint32(42).fork()).ldelim();
              if (null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(82).string(t3.docString), null != t3.input && t3.input.length)
                for (n2 = 0; n2 < t3.input.length; ++n2)
                  l.onnx.ValueInfoProto.encode(t3.input[n2], e2.uint32(90).fork()).ldelim();
              if (null != t3.output && t3.output.length)
                for (n2 = 0; n2 < t3.output.length; ++n2)
                  l.onnx.ValueInfoProto.encode(t3.output[n2], e2.uint32(98).fork()).ldelim();
              if (null != t3.valueInfo && t3.valueInfo.length)
                for (n2 = 0; n2 < t3.valueInfo.length; ++n2)
                  l.onnx.ValueInfoProto.encode(t3.valueInfo[n2], e2.uint32(106).fork()).ldelim();
              if (null != t3.quantizationAnnotation && t3.quantizationAnnotation.length)
                for (n2 = 0; n2 < t3.quantizationAnnotation.length; ++n2)
                  l.onnx.TensorAnnotation.encode(t3.quantizationAnnotation[n2], e2.uint32(114).fork()).ldelim();
              return e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.GraphProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.node && r2.node.length || (r2.node = []), r2.node.push(l.onnx.NodeProto.decode(t3, t3.uint32()));
                    break;
                  case 2:
                    r2.name = t3.string();
                    break;
                  case 5:
                    r2.initializer && r2.initializer.length || (r2.initializer = []), r2.initializer.push(l.onnx.TensorProto.decode(t3, t3.uint32()));
                    break;
                  case 10:
                    r2.docString = t3.string();
                    break;
                  case 11:
                    r2.input && r2.input.length || (r2.input = []), r2.input.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                    break;
                  case 12:
                    r2.output && r2.output.length || (r2.output = []), r2.output.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                    break;
                  case 13:
                    r2.valueInfo && r2.valueInfo.length || (r2.valueInfo = []), r2.valueInfo.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                    break;
                  case 14:
                    r2.quantizationAnnotation && r2.quantizationAnnotation.length || (r2.quantizationAnnotation = []), r2.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t3, t3.uint32()));
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.node && t3.hasOwnProperty("node")) {
                if (!Array.isArray(t3.node))
                  return "node: array expected";
                for (var e2 = 0; e2 < t3.node.length; ++e2)
                  if (n2 = l.onnx.NodeProto.verify(t3.node[e2]))
                    return "node." + n2;
              }
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                return "name: string expected";
              if (null != t3.initializer && t3.hasOwnProperty("initializer")) {
                if (!Array.isArray(t3.initializer))
                  return "initializer: array expected";
                for (e2 = 0; e2 < t3.initializer.length; ++e2)
                  if (n2 = l.onnx.TensorProto.verify(t3.initializer[e2]))
                    return "initializer." + n2;
              }
              if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString))
                return "docString: string expected";
              if (null != t3.input && t3.hasOwnProperty("input")) {
                if (!Array.isArray(t3.input))
                  return "input: array expected";
                for (e2 = 0; e2 < t3.input.length; ++e2)
                  if (n2 = l.onnx.ValueInfoProto.verify(t3.input[e2]))
                    return "input." + n2;
              }
              if (null != t3.output && t3.hasOwnProperty("output")) {
                if (!Array.isArray(t3.output))
                  return "output: array expected";
                for (e2 = 0; e2 < t3.output.length; ++e2)
                  if (n2 = l.onnx.ValueInfoProto.verify(t3.output[e2]))
                    return "output." + n2;
              }
              if (null != t3.valueInfo && t3.hasOwnProperty("valueInfo")) {
                if (!Array.isArray(t3.valueInfo))
                  return "valueInfo: array expected";
                for (e2 = 0; e2 < t3.valueInfo.length; ++e2)
                  if (n2 = l.onnx.ValueInfoProto.verify(t3.valueInfo[e2]))
                    return "valueInfo." + n2;
              }
              if (null != t3.quantizationAnnotation && t3.hasOwnProperty("quantizationAnnotation")) {
                if (!Array.isArray(t3.quantizationAnnotation))
                  return "quantizationAnnotation: array expected";
                for (e2 = 0; e2 < t3.quantizationAnnotation.length; ++e2) {
                  var n2;
                  if (n2 = l.onnx.TensorAnnotation.verify(t3.quantizationAnnotation[e2]))
                    return "quantizationAnnotation." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.GraphProto)
                return t3;
              var e2 = new l.onnx.GraphProto();
              if (t3.node) {
                if (!Array.isArray(t3.node))
                  throw TypeError(".onnx.GraphProto.node: array expected");
                e2.node = [];
                for (var n2 = 0; n2 < t3.node.length; ++n2) {
                  if ("object" != typeof t3.node[n2])
                    throw TypeError(".onnx.GraphProto.node: object expected");
                  e2.node[n2] = l.onnx.NodeProto.fromObject(t3.node[n2]);
                }
              }
              if (null != t3.name && (e2.name = String(t3.name)), t3.initializer) {
                if (!Array.isArray(t3.initializer))
                  throw TypeError(".onnx.GraphProto.initializer: array expected");
                for (e2.initializer = [], n2 = 0; n2 < t3.initializer.length; ++n2) {
                  if ("object" != typeof t3.initializer[n2])
                    throw TypeError(".onnx.GraphProto.initializer: object expected");
                  e2.initializer[n2] = l.onnx.TensorProto.fromObject(t3.initializer[n2]);
                }
              }
              if (null != t3.docString && (e2.docString = String(t3.docString)), t3.input) {
                if (!Array.isArray(t3.input))
                  throw TypeError(".onnx.GraphProto.input: array expected");
                for (e2.input = [], n2 = 0; n2 < t3.input.length; ++n2) {
                  if ("object" != typeof t3.input[n2])
                    throw TypeError(".onnx.GraphProto.input: object expected");
                  e2.input[n2] = l.onnx.ValueInfoProto.fromObject(t3.input[n2]);
                }
              }
              if (t3.output) {
                if (!Array.isArray(t3.output))
                  throw TypeError(".onnx.GraphProto.output: array expected");
                for (e2.output = [], n2 = 0; n2 < t3.output.length; ++n2) {
                  if ("object" != typeof t3.output[n2])
                    throw TypeError(".onnx.GraphProto.output: object expected");
                  e2.output[n2] = l.onnx.ValueInfoProto.fromObject(t3.output[n2]);
                }
              }
              if (t3.valueInfo) {
                if (!Array.isArray(t3.valueInfo))
                  throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                for (e2.valueInfo = [], n2 = 0; n2 < t3.valueInfo.length; ++n2) {
                  if ("object" != typeof t3.valueInfo[n2])
                    throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                  e2.valueInfo[n2] = l.onnx.ValueInfoProto.fromObject(t3.valueInfo[n2]);
                }
              }
              if (t3.quantizationAnnotation) {
                if (!Array.isArray(t3.quantizationAnnotation))
                  throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                for (e2.quantizationAnnotation = [], n2 = 0; n2 < t3.quantizationAnnotation.length; ++n2) {
                  if ("object" != typeof t3.quantizationAnnotation[n2])
                    throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                  e2.quantizationAnnotation[n2] = l.onnx.TensorAnnotation.fromObject(t3.quantizationAnnotation[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.node = [], n2.initializer = [], n2.input = [], n2.output = [], n2.valueInfo = [], n2.quantizationAnnotation = []), e2.defaults && (n2.name = "", n2.docString = ""), t3.node && t3.node.length) {
                n2.node = [];
                for (var r2 = 0; r2 < t3.node.length; ++r2)
                  n2.node[r2] = l.onnx.NodeProto.toObject(t3.node[r2], e2);
              }
              if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), t3.initializer && t3.initializer.length)
                for (n2.initializer = [], r2 = 0; r2 < t3.initializer.length; ++r2)
                  n2.initializer[r2] = l.onnx.TensorProto.toObject(t3.initializer[r2], e2);
              if (null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), t3.input && t3.input.length)
                for (n2.input = [], r2 = 0; r2 < t3.input.length; ++r2)
                  n2.input[r2] = l.onnx.ValueInfoProto.toObject(t3.input[r2], e2);
              if (t3.output && t3.output.length)
                for (n2.output = [], r2 = 0; r2 < t3.output.length; ++r2)
                  n2.output[r2] = l.onnx.ValueInfoProto.toObject(t3.output[r2], e2);
              if (t3.valueInfo && t3.valueInfo.length)
                for (n2.valueInfo = [], r2 = 0; r2 < t3.valueInfo.length; ++r2)
                  n2.valueInfo[r2] = l.onnx.ValueInfoProto.toObject(t3.valueInfo[r2], e2);
              if (t3.quantizationAnnotation && t3.quantizationAnnotation.length)
                for (n2.quantizationAnnotation = [], r2 = 0; r2 < t3.quantizationAnnotation.length; ++r2)
                  n2.quantizationAnnotation[r2] = l.onnx.TensorAnnotation.toObject(t3.quantizationAnnotation[r2], e2);
              return n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.TensorProto = function() {
            function t2(t3) {
              if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.dims = c.emptyArray, t2.prototype.dataType = 0, t2.prototype.segment = null, t2.prototype.floatData = c.emptyArray, t2.prototype.int32Data = c.emptyArray, t2.prototype.stringData = c.emptyArray, t2.prototype.int64Data = c.emptyArray, t2.prototype.name = "", t2.prototype.docString = "", t2.prototype.rawData = c.newBuffer([]), t2.prototype.externalData = c.emptyArray, t2.prototype.dataLocation = 0, t2.prototype.doubleData = c.emptyArray, t2.prototype.uint64Data = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.dims && t3.dims.length) {
                e2.uint32(10).fork();
                for (var n2 = 0; n2 < t3.dims.length; ++n2)
                  e2.int64(t3.dims[n2]);
                e2.ldelim();
              }
              if (null != t3.dataType && t3.hasOwnProperty("dataType") && e2.uint32(16).int32(t3.dataType), null != t3.segment && t3.hasOwnProperty("segment") && l.onnx.TensorProto.Segment.encode(t3.segment, e2.uint32(26).fork()).ldelim(), null != t3.floatData && t3.floatData.length) {
                for (e2.uint32(34).fork(), n2 = 0; n2 < t3.floatData.length; ++n2)
                  e2.float(t3.floatData[n2]);
                e2.ldelim();
              }
              if (null != t3.int32Data && t3.int32Data.length) {
                for (e2.uint32(42).fork(), n2 = 0; n2 < t3.int32Data.length; ++n2)
                  e2.int32(t3.int32Data[n2]);
                e2.ldelim();
              }
              if (null != t3.stringData && t3.stringData.length)
                for (n2 = 0; n2 < t3.stringData.length; ++n2)
                  e2.uint32(50).bytes(t3.stringData[n2]);
              if (null != t3.int64Data && t3.int64Data.length) {
                for (e2.uint32(58).fork(), n2 = 0; n2 < t3.int64Data.length; ++n2)
                  e2.int64(t3.int64Data[n2]);
                e2.ldelim();
              }
              if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(66).string(t3.name), null != t3.rawData && t3.hasOwnProperty("rawData") && e2.uint32(74).bytes(t3.rawData), null != t3.doubleData && t3.doubleData.length) {
                for (e2.uint32(82).fork(), n2 = 0; n2 < t3.doubleData.length; ++n2)
                  e2.double(t3.doubleData[n2]);
                e2.ldelim();
              }
              if (null != t3.uint64Data && t3.uint64Data.length) {
                for (e2.uint32(90).fork(), n2 = 0; n2 < t3.uint64Data.length; ++n2)
                  e2.uint64(t3.uint64Data[n2]);
                e2.ldelim();
              }
              if (null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(98).string(t3.docString), null != t3.externalData && t3.externalData.length)
                for (n2 = 0; n2 < t3.externalData.length; ++n2)
                  l.onnx.StringStringEntryProto.encode(t3.externalData[n2], e2.uint32(106).fork()).ldelim();
              return null != t3.dataLocation && t3.hasOwnProperty("dataLocation") && e2.uint32(112).int32(t3.dataLocation), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & i2))
                      for (var o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                        r2.dims.push(t3.int64());
                    else
                      r2.dims.push(t3.int64());
                    break;
                  case 2:
                    r2.dataType = t3.int32();
                    break;
                  case 3:
                    r2.segment = l.onnx.TensorProto.Segment.decode(t3, t3.uint32());
                    break;
                  case 4:
                    if (r2.floatData && r2.floatData.length || (r2.floatData = []), 2 == (7 & i2))
                      for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                        r2.floatData.push(t3.float());
                    else
                      r2.floatData.push(t3.float());
                    break;
                  case 5:
                    if (r2.int32Data && r2.int32Data.length || (r2.int32Data = []), 2 == (7 & i2))
                      for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                        r2.int32Data.push(t3.int32());
                    else
                      r2.int32Data.push(t3.int32());
                    break;
                  case 6:
                    r2.stringData && r2.stringData.length || (r2.stringData = []), r2.stringData.push(t3.bytes());
                    break;
                  case 7:
                    if (r2.int64Data && r2.int64Data.length || (r2.int64Data = []), 2 == (7 & i2))
                      for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                        r2.int64Data.push(t3.int64());
                    else
                      r2.int64Data.push(t3.int64());
                    break;
                  case 8:
                    r2.name = t3.string();
                    break;
                  case 12:
                    r2.docString = t3.string();
                    break;
                  case 9:
                    r2.rawData = t3.bytes();
                    break;
                  case 13:
                    r2.externalData && r2.externalData.length || (r2.externalData = []), r2.externalData.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                    break;
                  case 14:
                    r2.dataLocation = t3.int32();
                    break;
                  case 10:
                    if (r2.doubleData && r2.doubleData.length || (r2.doubleData = []), 2 == (7 & i2))
                      for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                        r2.doubleData.push(t3.double());
                    else
                      r2.doubleData.push(t3.double());
                    break;
                  case 11:
                    if (r2.uint64Data && r2.uint64Data.length || (r2.uint64Data = []), 2 == (7 & i2))
                      for (o2 = t3.uint32() + t3.pos; t3.pos < o2; )
                        r2.uint64Data.push(t3.uint64());
                    else
                      r2.uint64Data.push(t3.uint64());
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.dims && t3.hasOwnProperty("dims")) {
                if (!Array.isArray(t3.dims))
                  return "dims: array expected";
                for (var e2 = 0; e2 < t3.dims.length; ++e2)
                  if (!(c.isInteger(t3.dims[e2]) || t3.dims[e2] && c.isInteger(t3.dims[e2].low) && c.isInteger(t3.dims[e2].high)))
                    return "dims: integer|Long[] expected";
              }
              if (null != t3.dataType && t3.hasOwnProperty("dataType") && !c.isInteger(t3.dataType))
                return "dataType: integer expected";
              if (null != t3.segment && t3.hasOwnProperty("segment") && (n2 = l.onnx.TensorProto.Segment.verify(t3.segment)))
                return "segment." + n2;
              if (null != t3.floatData && t3.hasOwnProperty("floatData")) {
                if (!Array.isArray(t3.floatData))
                  return "floatData: array expected";
                for (e2 = 0; e2 < t3.floatData.length; ++e2)
                  if ("number" != typeof t3.floatData[e2])
                    return "floatData: number[] expected";
              }
              if (null != t3.int32Data && t3.hasOwnProperty("int32Data")) {
                if (!Array.isArray(t3.int32Data))
                  return "int32Data: array expected";
                for (e2 = 0; e2 < t3.int32Data.length; ++e2)
                  if (!c.isInteger(t3.int32Data[e2]))
                    return "int32Data: integer[] expected";
              }
              if (null != t3.stringData && t3.hasOwnProperty("stringData")) {
                if (!Array.isArray(t3.stringData))
                  return "stringData: array expected";
                for (e2 = 0; e2 < t3.stringData.length; ++e2)
                  if (!(t3.stringData[e2] && "number" == typeof t3.stringData[e2].length || c.isString(t3.stringData[e2])))
                    return "stringData: buffer[] expected";
              }
              if (null != t3.int64Data && t3.hasOwnProperty("int64Data")) {
                if (!Array.isArray(t3.int64Data))
                  return "int64Data: array expected";
                for (e2 = 0; e2 < t3.int64Data.length; ++e2)
                  if (!(c.isInteger(t3.int64Data[e2]) || t3.int64Data[e2] && c.isInteger(t3.int64Data[e2].low) && c.isInteger(t3.int64Data[e2].high)))
                    return "int64Data: integer|Long[] expected";
              }
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name))
                return "name: string expected";
              if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString))
                return "docString: string expected";
              if (null != t3.rawData && t3.hasOwnProperty("rawData") && !(t3.rawData && "number" == typeof t3.rawData.length || c.isString(t3.rawData)))
                return "rawData: buffer expected";
              if (null != t3.externalData && t3.hasOwnProperty("externalData")) {
                if (!Array.isArray(t3.externalData))
                  return "externalData: array expected";
                for (e2 = 0; e2 < t3.externalData.length; ++e2) {
                  var n2;
                  if (n2 = l.onnx.StringStringEntryProto.verify(t3.externalData[e2]))
                    return "externalData." + n2;
                }
              }
              if (null != t3.dataLocation && t3.hasOwnProperty("dataLocation"))
                switch (t3.dataLocation) {
                  default:
                    return "dataLocation: enum value expected";
                  case 0:
                  case 1:
                }
              if (null != t3.doubleData && t3.hasOwnProperty("doubleData")) {
                if (!Array.isArray(t3.doubleData))
                  return "doubleData: array expected";
                for (e2 = 0; e2 < t3.doubleData.length; ++e2)
                  if ("number" != typeof t3.doubleData[e2])
                    return "doubleData: number[] expected";
              }
              if (null != t3.uint64Data && t3.hasOwnProperty("uint64Data")) {
                if (!Array.isArray(t3.uint64Data))
                  return "uint64Data: array expected";
                for (e2 = 0; e2 < t3.uint64Data.length; ++e2)
                  if (!(c.isInteger(t3.uint64Data[e2]) || t3.uint64Data[e2] && c.isInteger(t3.uint64Data[e2].low) && c.isInteger(t3.uint64Data[e2].high)))
                    return "uint64Data: integer|Long[] expected";
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.TensorProto)
                return t3;
              var e2 = new l.onnx.TensorProto();
              if (t3.dims) {
                if (!Array.isArray(t3.dims))
                  throw TypeError(".onnx.TensorProto.dims: array expected");
                e2.dims = [];
                for (var n2 = 0; n2 < t3.dims.length; ++n2)
                  c.Long ? (e2.dims[n2] = c.Long.fromValue(t3.dims[n2])).unsigned = false : "string" == typeof t3.dims[n2] ? e2.dims[n2] = parseInt(t3.dims[n2], 10) : "number" == typeof t3.dims[n2] ? e2.dims[n2] = t3.dims[n2] : "object" == typeof t3.dims[n2] && (e2.dims[n2] = new c.LongBits(t3.dims[n2].low >>> 0, t3.dims[n2].high >>> 0).toNumber());
              }
              if (null != t3.dataType && (e2.dataType = 0 | t3.dataType), null != t3.segment) {
                if ("object" != typeof t3.segment)
                  throw TypeError(".onnx.TensorProto.segment: object expected");
                e2.segment = l.onnx.TensorProto.Segment.fromObject(t3.segment);
              }
              if (t3.floatData) {
                if (!Array.isArray(t3.floatData))
                  throw TypeError(".onnx.TensorProto.floatData: array expected");
                for (e2.floatData = [], n2 = 0; n2 < t3.floatData.length; ++n2)
                  e2.floatData[n2] = Number(t3.floatData[n2]);
              }
              if (t3.int32Data) {
                if (!Array.isArray(t3.int32Data))
                  throw TypeError(".onnx.TensorProto.int32Data: array expected");
                for (e2.int32Data = [], n2 = 0; n2 < t3.int32Data.length; ++n2)
                  e2.int32Data[n2] = 0 | t3.int32Data[n2];
              }
              if (t3.stringData) {
                if (!Array.isArray(t3.stringData))
                  throw TypeError(".onnx.TensorProto.stringData: array expected");
                for (e2.stringData = [], n2 = 0; n2 < t3.stringData.length; ++n2)
                  "string" == typeof t3.stringData[n2] ? c.base64.decode(t3.stringData[n2], e2.stringData[n2] = c.newBuffer(c.base64.length(t3.stringData[n2])), 0) : t3.stringData[n2].length && (e2.stringData[n2] = t3.stringData[n2]);
              }
              if (t3.int64Data) {
                if (!Array.isArray(t3.int64Data))
                  throw TypeError(".onnx.TensorProto.int64Data: array expected");
                for (e2.int64Data = [], n2 = 0; n2 < t3.int64Data.length; ++n2)
                  c.Long ? (e2.int64Data[n2] = c.Long.fromValue(t3.int64Data[n2])).unsigned = false : "string" == typeof t3.int64Data[n2] ? e2.int64Data[n2] = parseInt(t3.int64Data[n2], 10) : "number" == typeof t3.int64Data[n2] ? e2.int64Data[n2] = t3.int64Data[n2] : "object" == typeof t3.int64Data[n2] && (e2.int64Data[n2] = new c.LongBits(t3.int64Data[n2].low >>> 0, t3.int64Data[n2].high >>> 0).toNumber());
              }
              if (null != t3.name && (e2.name = String(t3.name)), null != t3.docString && (e2.docString = String(t3.docString)), null != t3.rawData && ("string" == typeof t3.rawData ? c.base64.decode(t3.rawData, e2.rawData = c.newBuffer(c.base64.length(t3.rawData)), 0) : t3.rawData.length && (e2.rawData = t3.rawData)), t3.externalData) {
                if (!Array.isArray(t3.externalData))
                  throw TypeError(".onnx.TensorProto.externalData: array expected");
                for (e2.externalData = [], n2 = 0; n2 < t3.externalData.length; ++n2) {
                  if ("object" != typeof t3.externalData[n2])
                    throw TypeError(".onnx.TensorProto.externalData: object expected");
                  e2.externalData[n2] = l.onnx.StringStringEntryProto.fromObject(t3.externalData[n2]);
                }
              }
              switch (t3.dataLocation) {
                case "DEFAULT":
                case 0:
                  e2.dataLocation = 0;
                  break;
                case "EXTERNAL":
                case 1:
                  e2.dataLocation = 1;
              }
              if (t3.doubleData) {
                if (!Array.isArray(t3.doubleData))
                  throw TypeError(".onnx.TensorProto.doubleData: array expected");
                for (e2.doubleData = [], n2 = 0; n2 < t3.doubleData.length; ++n2)
                  e2.doubleData[n2] = Number(t3.doubleData[n2]);
              }
              if (t3.uint64Data) {
                if (!Array.isArray(t3.uint64Data))
                  throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                for (e2.uint64Data = [], n2 = 0; n2 < t3.uint64Data.length; ++n2)
                  c.Long ? (e2.uint64Data[n2] = c.Long.fromValue(t3.uint64Data[n2])).unsigned = true : "string" == typeof t3.uint64Data[n2] ? e2.uint64Data[n2] = parseInt(t3.uint64Data[n2], 10) : "number" == typeof t3.uint64Data[n2] ? e2.uint64Data[n2] = t3.uint64Data[n2] : "object" == typeof t3.uint64Data[n2] && (e2.uint64Data[n2] = new c.LongBits(t3.uint64Data[n2].low >>> 0, t3.uint64Data[n2].high >>> 0).toNumber(true));
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.dims = [], n2.floatData = [], n2.int32Data = [], n2.stringData = [], n2.int64Data = [], n2.doubleData = [], n2.uint64Data = [], n2.externalData = []), e2.defaults && (n2.dataType = 0, n2.segment = null, n2.name = "", e2.bytes === String ? n2.rawData = "" : (n2.rawData = [], e2.bytes !== Array && (n2.rawData = c.newBuffer(n2.rawData))), n2.docString = "", n2.dataLocation = e2.enums === String ? "DEFAULT" : 0), t3.dims && t3.dims.length) {
                n2.dims = [];
                for (var r2 = 0; r2 < t3.dims.length; ++r2)
                  "number" == typeof t3.dims[r2] ? n2.dims[r2] = e2.longs === String ? String(t3.dims[r2]) : t3.dims[r2] : n2.dims[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.dims[r2]) : e2.longs === Number ? new c.LongBits(t3.dims[r2].low >>> 0, t3.dims[r2].high >>> 0).toNumber() : t3.dims[r2];
              }
              if (null != t3.dataType && t3.hasOwnProperty("dataType") && (n2.dataType = t3.dataType), null != t3.segment && t3.hasOwnProperty("segment") && (n2.segment = l.onnx.TensorProto.Segment.toObject(t3.segment, e2)), t3.floatData && t3.floatData.length)
                for (n2.floatData = [], r2 = 0; r2 < t3.floatData.length; ++r2)
                  n2.floatData[r2] = e2.json && !isFinite(t3.floatData[r2]) ? String(t3.floatData[r2]) : t3.floatData[r2];
              if (t3.int32Data && t3.int32Data.length)
                for (n2.int32Data = [], r2 = 0; r2 < t3.int32Data.length; ++r2)
                  n2.int32Data[r2] = t3.int32Data[r2];
              if (t3.stringData && t3.stringData.length)
                for (n2.stringData = [], r2 = 0; r2 < t3.stringData.length; ++r2)
                  n2.stringData[r2] = e2.bytes === String ? c.base64.encode(t3.stringData[r2], 0, t3.stringData[r2].length) : e2.bytes === Array ? Array.prototype.slice.call(t3.stringData[r2]) : t3.stringData[r2];
              if (t3.int64Data && t3.int64Data.length)
                for (n2.int64Data = [], r2 = 0; r2 < t3.int64Data.length; ++r2)
                  "number" == typeof t3.int64Data[r2] ? n2.int64Data[r2] = e2.longs === String ? String(t3.int64Data[r2]) : t3.int64Data[r2] : n2.int64Data[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.int64Data[r2]) : e2.longs === Number ? new c.LongBits(t3.int64Data[r2].low >>> 0, t3.int64Data[r2].high >>> 0).toNumber() : t3.int64Data[r2];
              if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.rawData && t3.hasOwnProperty("rawData") && (n2.rawData = e2.bytes === String ? c.base64.encode(t3.rawData, 0, t3.rawData.length) : e2.bytes === Array ? Array.prototype.slice.call(t3.rawData) : t3.rawData), t3.doubleData && t3.doubleData.length)
                for (n2.doubleData = [], r2 = 0; r2 < t3.doubleData.length; ++r2)
                  n2.doubleData[r2] = e2.json && !isFinite(t3.doubleData[r2]) ? String(t3.doubleData[r2]) : t3.doubleData[r2];
              if (t3.uint64Data && t3.uint64Data.length)
                for (n2.uint64Data = [], r2 = 0; r2 < t3.uint64Data.length; ++r2)
                  "number" == typeof t3.uint64Data[r2] ? n2.uint64Data[r2] = e2.longs === String ? String(t3.uint64Data[r2]) : t3.uint64Data[r2] : n2.uint64Data[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.uint64Data[r2]) : e2.longs === Number ? new c.LongBits(t3.uint64Data[r2].low >>> 0, t3.uint64Data[r2].high >>> 0).toNumber(true) : t3.uint64Data[r2];
              if (null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), t3.externalData && t3.externalData.length)
                for (n2.externalData = [], r2 = 0; r2 < t3.externalData.length; ++r2)
                  n2.externalData[r2] = l.onnx.StringStringEntryProto.toObject(t3.externalData[r2], e2);
              return null != t3.dataLocation && t3.hasOwnProperty("dataLocation") && (n2.dataLocation = e2.enums === String ? l.onnx.TensorProto.DataLocation[t3.dataLocation] : t3.dataLocation), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2.DataType = function() {
              var t3 = {}, e2 = Object.create(t3);
              return e2[t3[0] = "UNDEFINED"] = 0, e2[t3[1] = "FLOAT"] = 1, e2[t3[2] = "UINT8"] = 2, e2[t3[3] = "INT8"] = 3, e2[t3[4] = "UINT16"] = 4, e2[t3[5] = "INT16"] = 5, e2[t3[6] = "INT32"] = 6, e2[t3[7] = "INT64"] = 7, e2[t3[8] = "STRING"] = 8, e2[t3[9] = "BOOL"] = 9, e2[t3[10] = "FLOAT16"] = 10, e2[t3[11] = "DOUBLE"] = 11, e2[t3[12] = "UINT32"] = 12, e2[t3[13] = "UINT64"] = 13, e2[t3[14] = "COMPLEX64"] = 14, e2[t3[15] = "COMPLEX128"] = 15, e2[t3[16] = "BFLOAT16"] = 16, e2;
            }(), t2.Segment = function() {
              function t3(t4) {
                if (t4)
                  for (var e2 = Object.keys(t4), n2 = 0; n2 < e2.length; ++n2)
                    null != t4[e2[n2]] && (this[e2[n2]] = t4[e2[n2]]);
              }
              return t3.prototype.begin = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.prototype.end = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.create = function(e2) {
                return new t3(e2);
              }, t3.encode = function(t4, e2) {
                return e2 || (e2 = u.create()), null != t4.begin && t4.hasOwnProperty("begin") && e2.uint32(8).int64(t4.begin), null != t4.end && t4.hasOwnProperty("end") && e2.uint32(16).int64(t4.end), e2;
              }, t3.encodeDelimited = function(t4, e2) {
                return this.encode(t4, e2).ldelim();
              }, t3.decode = function(t4, e2) {
                t4 instanceof s || (t4 = s.create(t4));
                for (var n2 = void 0 === e2 ? t4.len : t4.pos + e2, r2 = new l.onnx.TensorProto.Segment(); t4.pos < n2; ) {
                  var i2 = t4.uint32();
                  switch (i2 >>> 3) {
                    case 1:
                      r2.begin = t4.int64();
                      break;
                    case 2:
                      r2.end = t4.int64();
                      break;
                    default:
                      t4.skipType(7 & i2);
                  }
                }
                return r2;
              }, t3.decodeDelimited = function(t4) {
                return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
              }, t3.verify = function(t4) {
                return "object" != typeof t4 || null === t4 ? "object expected" : null != t4.begin && t4.hasOwnProperty("begin") && !(c.isInteger(t4.begin) || t4.begin && c.isInteger(t4.begin.low) && c.isInteger(t4.begin.high)) ? "begin: integer|Long expected" : null != t4.end && t4.hasOwnProperty("end") && !(c.isInteger(t4.end) || t4.end && c.isInteger(t4.end.low) && c.isInteger(t4.end.high)) ? "end: integer|Long expected" : null;
              }, t3.fromObject = function(t4) {
                if (t4 instanceof l.onnx.TensorProto.Segment)
                  return t4;
                var e2 = new l.onnx.TensorProto.Segment();
                return null != t4.begin && (c.Long ? (e2.begin = c.Long.fromValue(t4.begin)).unsigned = false : "string" == typeof t4.begin ? e2.begin = parseInt(t4.begin, 10) : "number" == typeof t4.begin ? e2.begin = t4.begin : "object" == typeof t4.begin && (e2.begin = new c.LongBits(t4.begin.low >>> 0, t4.begin.high >>> 0).toNumber())), null != t4.end && (c.Long ? (e2.end = c.Long.fromValue(t4.end)).unsigned = false : "string" == typeof t4.end ? e2.end = parseInt(t4.end, 10) : "number" == typeof t4.end ? e2.end = t4.end : "object" == typeof t4.end && (e2.end = new c.LongBits(t4.end.low >>> 0, t4.end.high >>> 0).toNumber())), e2;
              }, t3.toObject = function(t4, e2) {
                e2 || (e2 = {});
                var n2 = {};
                if (e2.defaults) {
                  if (c.Long) {
                    var r2 = new c.Long(0, 0, false);
                    n2.begin = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                  } else
                    n2.begin = e2.longs === String ? "0" : 0;
                  c.Long ? (r2 = new c.Long(0, 0, false), n2.end = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2) : n2.end = e2.longs === String ? "0" : 0;
                }
                return null != t4.begin && t4.hasOwnProperty("begin") && ("number" == typeof t4.begin ? n2.begin = e2.longs === String ? String(t4.begin) : t4.begin : n2.begin = e2.longs === String ? c.Long.prototype.toString.call(t4.begin) : e2.longs === Number ? new c.LongBits(t4.begin.low >>> 0, t4.begin.high >>> 0).toNumber() : t4.begin), null != t4.end && t4.hasOwnProperty("end") && ("number" == typeof t4.end ? n2.end = e2.longs === String ? String(t4.end) : t4.end : n2.end = e2.longs === String ? c.Long.prototype.toString.call(t4.end) : e2.longs === Number ? new c.LongBits(t4.end.low >>> 0, t4.end.high >>> 0).toNumber() : t4.end), n2;
              }, t3.prototype.toJSON = function() {
                return this.constructor.toObject(this, a.util.toJSONOptions);
              }, t3;
            }(), t2.DataLocation = function() {
              var t3 = {}, e2 = Object.create(t3);
              return e2[t3[0] = "DEFAULT"] = 0, e2[t3[1] = "EXTERNAL"] = 1, e2;
            }(), t2;
          }(), o.TensorShapeProto = function() {
            function t2(t3) {
              if (this.dim = [], t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.dim = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.dim && t3.dim.length)
                for (var n2 = 0; n2 < t3.dim.length; ++n2)
                  l.onnx.TensorShapeProto.Dimension.encode(t3.dim[n2], e2.uint32(10).fork()).ldelim();
              return e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorShapeProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                i2 >>> 3 == 1 ? (r2.dim && r2.dim.length || (r2.dim = []), r2.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t3, t3.uint32()))) : t3.skipType(7 & i2);
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.dim && t3.hasOwnProperty("dim")) {
                if (!Array.isArray(t3.dim))
                  return "dim: array expected";
                for (var e2 = 0; e2 < t3.dim.length; ++e2) {
                  var n2 = l.onnx.TensorShapeProto.Dimension.verify(t3.dim[e2]);
                  if (n2)
                    return "dim." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.TensorShapeProto)
                return t3;
              var e2 = new l.onnx.TensorShapeProto();
              if (t3.dim) {
                if (!Array.isArray(t3.dim))
                  throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                e2.dim = [];
                for (var n2 = 0; n2 < t3.dim.length; ++n2) {
                  if ("object" != typeof t3.dim[n2])
                    throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                  e2.dim[n2] = l.onnx.TensorShapeProto.Dimension.fromObject(t3.dim[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.dim = []), t3.dim && t3.dim.length) {
                n2.dim = [];
                for (var r2 = 0; r2 < t3.dim.length; ++r2)
                  n2.dim[r2] = l.onnx.TensorShapeProto.Dimension.toObject(t3.dim[r2], e2);
              }
              return n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2.Dimension = function() {
              function t3(t4) {
                if (t4)
                  for (var e3 = Object.keys(t4), n2 = 0; n2 < e3.length; ++n2)
                    null != t4[e3[n2]] && (this[e3[n2]] = t4[e3[n2]]);
              }
              var e2;
              return t3.prototype.dimValue = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.prototype.dimParam = "", t3.prototype.denotation = "", Object.defineProperty(t3.prototype, "value", { get: c.oneOfGetter(e2 = ["dimValue", "dimParam"]), set: c.oneOfSetter(e2) }), t3.create = function(e3) {
                return new t3(e3);
              }, t3.encode = function(t4, e3) {
                return e3 || (e3 = u.create()), null != t4.dimValue && t4.hasOwnProperty("dimValue") && e3.uint32(8).int64(t4.dimValue), null != t4.dimParam && t4.hasOwnProperty("dimParam") && e3.uint32(18).string(t4.dimParam), null != t4.denotation && t4.hasOwnProperty("denotation") && e3.uint32(26).string(t4.denotation), e3;
              }, t3.encodeDelimited = function(t4, e3) {
                return this.encode(t4, e3).ldelim();
              }, t3.decode = function(t4, e3) {
                t4 instanceof s || (t4 = s.create(t4));
                for (var n2 = void 0 === e3 ? t4.len : t4.pos + e3, r2 = new l.onnx.TensorShapeProto.Dimension(); t4.pos < n2; ) {
                  var i2 = t4.uint32();
                  switch (i2 >>> 3) {
                    case 1:
                      r2.dimValue = t4.int64();
                      break;
                    case 2:
                      r2.dimParam = t4.string();
                      break;
                    case 3:
                      r2.denotation = t4.string();
                      break;
                    default:
                      t4.skipType(7 & i2);
                  }
                }
                return r2;
              }, t3.decodeDelimited = function(t4) {
                return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
              }, t3.verify = function(t4) {
                if ("object" != typeof t4 || null === t4)
                  return "object expected";
                var e3 = {};
                if (null != t4.dimValue && t4.hasOwnProperty("dimValue") && (e3.value = 1, !(c.isInteger(t4.dimValue) || t4.dimValue && c.isInteger(t4.dimValue.low) && c.isInteger(t4.dimValue.high))))
                  return "dimValue: integer|Long expected";
                if (null != t4.dimParam && t4.hasOwnProperty("dimParam")) {
                  if (1 === e3.value)
                    return "value: multiple values";
                  if (e3.value = 1, !c.isString(t4.dimParam))
                    return "dimParam: string expected";
                }
                return null != t4.denotation && t4.hasOwnProperty("denotation") && !c.isString(t4.denotation) ? "denotation: string expected" : null;
              }, t3.fromObject = function(t4) {
                if (t4 instanceof l.onnx.TensorShapeProto.Dimension)
                  return t4;
                var e3 = new l.onnx.TensorShapeProto.Dimension();
                return null != t4.dimValue && (c.Long ? (e3.dimValue = c.Long.fromValue(t4.dimValue)).unsigned = false : "string" == typeof t4.dimValue ? e3.dimValue = parseInt(t4.dimValue, 10) : "number" == typeof t4.dimValue ? e3.dimValue = t4.dimValue : "object" == typeof t4.dimValue && (e3.dimValue = new c.LongBits(t4.dimValue.low >>> 0, t4.dimValue.high >>> 0).toNumber())), null != t4.dimParam && (e3.dimParam = String(t4.dimParam)), null != t4.denotation && (e3.denotation = String(t4.denotation)), e3;
              }, t3.toObject = function(t4, e3) {
                e3 || (e3 = {});
                var n2 = {};
                return e3.defaults && (n2.denotation = ""), null != t4.dimValue && t4.hasOwnProperty("dimValue") && ("number" == typeof t4.dimValue ? n2.dimValue = e3.longs === String ? String(t4.dimValue) : t4.dimValue : n2.dimValue = e3.longs === String ? c.Long.prototype.toString.call(t4.dimValue) : e3.longs === Number ? new c.LongBits(t4.dimValue.low >>> 0, t4.dimValue.high >>> 0).toNumber() : t4.dimValue, e3.oneofs && (n2.value = "dimValue")), null != t4.dimParam && t4.hasOwnProperty("dimParam") && (n2.dimParam = t4.dimParam, e3.oneofs && (n2.value = "dimParam")), null != t4.denotation && t4.hasOwnProperty("denotation") && (n2.denotation = t4.denotation), n2;
              }, t3.prototype.toJSON = function() {
                return this.constructor.toObject(this, a.util.toJSONOptions);
              }, t3;
            }(), t2;
          }(), o.TypeProto = function() {
            function t2(t3) {
              if (t3)
                for (var e3 = Object.keys(t3), n2 = 0; n2 < e3.length; ++n2)
                  null != t3[e3[n2]] && (this[e3[n2]] = t3[e3[n2]]);
            }
            var e2;
            return t2.prototype.tensorType = null, t2.prototype.denotation = "", Object.defineProperty(t2.prototype, "value", { get: c.oneOfGetter(e2 = ["tensorType"]), set: c.oneOfSetter(e2) }), t2.create = function(e3) {
              return new t2(e3);
            }, t2.encode = function(t3, e3) {
              return e3 || (e3 = u.create()), null != t3.tensorType && t3.hasOwnProperty("tensorType") && l.onnx.TypeProto.Tensor.encode(t3.tensorType, e3.uint32(10).fork()).ldelim(), null != t3.denotation && t3.hasOwnProperty("denotation") && e3.uint32(50).string(t3.denotation), e3;
            }, t2.encodeDelimited = function(t3, e3) {
              return this.encode(t3, e3).ldelim();
            }, t2.decode = function(t3, e3) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e3 ? t3.len : t3.pos + e3, r2 = new l.onnx.TypeProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.tensorType = l.onnx.TypeProto.Tensor.decode(t3, t3.uint32());
                    break;
                  case 6:
                    r2.denotation = t3.string();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3)
                return "object expected";
              if (null != t3.tensorType && t3.hasOwnProperty("tensorType")) {
                var e3 = l.onnx.TypeProto.Tensor.verify(t3.tensorType);
                if (e3)
                  return "tensorType." + e3;
              }
              return null != t3.denotation && t3.hasOwnProperty("denotation") && !c.isString(t3.denotation) ? "denotation: string expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.TypeProto)
                return t3;
              var e3 = new l.onnx.TypeProto();
              if (null != t3.tensorType) {
                if ("object" != typeof t3.tensorType)
                  throw TypeError(".onnx.TypeProto.tensorType: object expected");
                e3.tensorType = l.onnx.TypeProto.Tensor.fromObject(t3.tensorType);
              }
              return null != t3.denotation && (e3.denotation = String(t3.denotation)), e3;
            }, t2.toObject = function(t3, e3) {
              e3 || (e3 = {});
              var n2 = {};
              return e3.defaults && (n2.denotation = ""), null != t3.tensorType && t3.hasOwnProperty("tensorType") && (n2.tensorType = l.onnx.TypeProto.Tensor.toObject(t3.tensorType, e3), e3.oneofs && (n2.value = "tensorType")), null != t3.denotation && t3.hasOwnProperty("denotation") && (n2.denotation = t3.denotation), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2.Tensor = function() {
              function t3(t4) {
                if (t4)
                  for (var e3 = Object.keys(t4), n2 = 0; n2 < e3.length; ++n2)
                    null != t4[e3[n2]] && (this[e3[n2]] = t4[e3[n2]]);
              }
              return t3.prototype.elemType = 0, t3.prototype.shape = null, t3.create = function(e3) {
                return new t3(e3);
              }, t3.encode = function(t4, e3) {
                return e3 || (e3 = u.create()), null != t4.elemType && t4.hasOwnProperty("elemType") && e3.uint32(8).int32(t4.elemType), null != t4.shape && t4.hasOwnProperty("shape") && l.onnx.TensorShapeProto.encode(t4.shape, e3.uint32(18).fork()).ldelim(), e3;
              }, t3.encodeDelimited = function(t4, e3) {
                return this.encode(t4, e3).ldelim();
              }, t3.decode = function(t4, e3) {
                t4 instanceof s || (t4 = s.create(t4));
                for (var n2 = void 0 === e3 ? t4.len : t4.pos + e3, r2 = new l.onnx.TypeProto.Tensor(); t4.pos < n2; ) {
                  var i2 = t4.uint32();
                  switch (i2 >>> 3) {
                    case 1:
                      r2.elemType = t4.int32();
                      break;
                    case 2:
                      r2.shape = l.onnx.TensorShapeProto.decode(t4, t4.uint32());
                      break;
                    default:
                      t4.skipType(7 & i2);
                  }
                }
                return r2;
              }, t3.decodeDelimited = function(t4) {
                return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
              }, t3.verify = function(t4) {
                if ("object" != typeof t4 || null === t4)
                  return "object expected";
                if (null != t4.elemType && t4.hasOwnProperty("elemType") && !c.isInteger(t4.elemType))
                  return "elemType: integer expected";
                if (null != t4.shape && t4.hasOwnProperty("shape")) {
                  var e3 = l.onnx.TensorShapeProto.verify(t4.shape);
                  if (e3)
                    return "shape." + e3;
                }
                return null;
              }, t3.fromObject = function(t4) {
                if (t4 instanceof l.onnx.TypeProto.Tensor)
                  return t4;
                var e3 = new l.onnx.TypeProto.Tensor();
                if (null != t4.elemType && (e3.elemType = 0 | t4.elemType), null != t4.shape) {
                  if ("object" != typeof t4.shape)
                    throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                  e3.shape = l.onnx.TensorShapeProto.fromObject(t4.shape);
                }
                return e3;
              }, t3.toObject = function(t4, e3) {
                e3 || (e3 = {});
                var n2 = {};
                return e3.defaults && (n2.elemType = 0, n2.shape = null), null != t4.elemType && t4.hasOwnProperty("elemType") && (n2.elemType = t4.elemType), null != t4.shape && t4.hasOwnProperty("shape") && (n2.shape = l.onnx.TensorShapeProto.toObject(t4.shape, e3)), n2;
              }, t3.prototype.toJSON = function() {
                return this.constructor.toObject(this, a.util.toJSONOptions);
              }, t3;
            }(), t2;
          }(), o.OperatorSetIdProto = function() {
            function t2(t3) {
              if (t3)
                for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2)
                  null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.domain = "", t2.prototype.version = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              return e2 || (e2 = u.create()), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(10).string(t3.domain), null != t3.version && t3.hasOwnProperty("version") && e2.uint32(16).int64(t3.version), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.OperatorSetIdProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.domain = t3.string();
                    break;
                  case 2:
                    r2.version = t3.int64();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              return "object" != typeof t3 || null === t3 ? "object expected" : null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain) ? "domain: string expected" : null != t3.version && t3.hasOwnProperty("version") && !(c.isInteger(t3.version) || t3.version && c.isInteger(t3.version.low) && c.isInteger(t3.version.high)) ? "version: integer|Long expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.OperatorSetIdProto)
                return t3;
              var e2 = new l.onnx.OperatorSetIdProto();
              return null != t3.domain && (e2.domain = String(t3.domain)), null != t3.version && (c.Long ? (e2.version = c.Long.fromValue(t3.version)).unsigned = false : "string" == typeof t3.version ? e2.version = parseInt(t3.version, 10) : "number" == typeof t3.version ? e2.version = t3.version : "object" == typeof t3.version && (e2.version = new c.LongBits(t3.version.low >>> 0, t3.version.high >>> 0).toNumber())), e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if (e2.defaults)
                if (n2.domain = "", c.Long) {
                  var r2 = new c.Long(0, 0, false);
                  n2.version = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                } else
                  n2.version = e2.longs === String ? "0" : 0;
              return null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), null != t3.version && t3.hasOwnProperty("version") && ("number" == typeof t3.version ? n2.version = e2.longs === String ? String(t3.version) : t3.version : n2.version = e2.longs === String ? c.Long.prototype.toString.call(t3.version) : e2.longs === Number ? new c.LongBits(t3.version.low >>> 0, t3.version.high >>> 0).toNumber() : t3.version), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o), t.exports = l;
        }, 2100: (t, e, n) => {
          "use strict";
          t.exports = n(9482);
        }, 9482: (t, e, n) => {
          "use strict";
          var r = e;
          function i() {
            r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
          }
          r.build = "minimal", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = i, i();
        }, 1408: (t, e, n) => {
          "use strict";
          t.exports = u;
          var r, i = n(9693), o = i.LongBits, a = i.utf8;
          function s(t2, e2) {
            return RangeError("index out of range: " + t2.pos + " + " + (e2 || 1) + " > " + t2.len);
          }
          function u(t2) {
            this.buf = t2, this.pos = 0, this.len = t2.length;
          }
          var c, l = "undefined" != typeof Uint8Array ? function(t2) {
            if (t2 instanceof Uint8Array || Array.isArray(t2))
              return new u(t2);
            throw Error("illegal buffer");
          } : function(t2) {
            if (Array.isArray(t2))
              return new u(t2);
            throw Error("illegal buffer");
          }, p = function() {
            return i.Buffer ? function(t2) {
              return (u.create = function(t3) {
                return i.Buffer.isBuffer(t3) ? new r(t3) : l(t3);
              })(t2);
            } : l;
          };
          function f() {
            var t2 = new o(0, 0), e2 = 0;
            if (!(this.len - this.pos > 4)) {
              for (; e2 < 3; ++e2) {
                if (this.pos >= this.len)
                  throw s(this);
                if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 7 * e2) >>> 0, this.buf[this.pos++] < 128)
                  return t2;
              }
              return t2.lo = (t2.lo | (127 & this.buf[this.pos++]) << 7 * e2) >>> 0, t2;
            }
            for (; e2 < 4; ++e2)
              if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 7 * e2) >>> 0, this.buf[this.pos++] < 128)
                return t2;
            if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t2.hi = (t2.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
              return t2;
            if (e2 = 0, this.len - this.pos > 4) {
              for (; e2 < 5; ++e2)
                if (t2.hi = (t2.hi | (127 & this.buf[this.pos]) << 7 * e2 + 3) >>> 0, this.buf[this.pos++] < 128)
                  return t2;
            } else
              for (; e2 < 5; ++e2) {
                if (this.pos >= this.len)
                  throw s(this);
                if (t2.hi = (t2.hi | (127 & this.buf[this.pos]) << 7 * e2 + 3) >>> 0, this.buf[this.pos++] < 128)
                  return t2;
              }
            throw Error("invalid varint encoding");
          }
          function d(t2, e2) {
            return (t2[e2 - 4] | t2[e2 - 3] << 8 | t2[e2 - 2] << 16 | t2[e2 - 1] << 24) >>> 0;
          }
          function h() {
            if (this.pos + 8 > this.len)
              throw s(this, 8);
            return new o(d(this.buf, this.pos += 4), d(this.buf, this.pos += 4));
          }
          u.create = p(), u.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, u.prototype.uint32 = (c = 4294967295, function() {
            if (c = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128)
              return c;
            if (c = (c | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128)
              return c;
            if (c = (c | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128)
              return c;
            if (c = (c | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128)
              return c;
            if (c = (c | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128)
              return c;
            if ((this.pos += 5) > this.len)
              throw this.pos = this.len, s(this, 10);
            return c;
          }), u.prototype.int32 = function() {
            return 0 | this.uint32();
          }, u.prototype.sint32 = function() {
            var t2 = this.uint32();
            return t2 >>> 1 ^ -(1 & t2) | 0;
          }, u.prototype.bool = function() {
            return 0 !== this.uint32();
          }, u.prototype.fixed32 = function() {
            if (this.pos + 4 > this.len)
              throw s(this, 4);
            return d(this.buf, this.pos += 4);
          }, u.prototype.sfixed32 = function() {
            if (this.pos + 4 > this.len)
              throw s(this, 4);
            return 0 | d(this.buf, this.pos += 4);
          }, u.prototype.float = function() {
            if (this.pos + 4 > this.len)
              throw s(this, 4);
            var t2 = i.float.readFloatLE(this.buf, this.pos);
            return this.pos += 4, t2;
          }, u.prototype.double = function() {
            if (this.pos + 8 > this.len)
              throw s(this, 4);
            var t2 = i.float.readDoubleLE(this.buf, this.pos);
            return this.pos += 8, t2;
          }, u.prototype.bytes = function() {
            var t2 = this.uint32(), e2 = this.pos, n2 = this.pos + t2;
            if (n2 > this.len)
              throw s(this, t2);
            return this.pos += t2, Array.isArray(this.buf) ? this.buf.slice(e2, n2) : e2 === n2 ? new this.buf.constructor(0) : this._slice.call(this.buf, e2, n2);
          }, u.prototype.string = function() {
            var t2 = this.bytes();
            return a.read(t2, 0, t2.length);
          }, u.prototype.skip = function(t2) {
            if ("number" == typeof t2) {
              if (this.pos + t2 > this.len)
                throw s(this, t2);
              this.pos += t2;
            } else
              do {
                if (this.pos >= this.len)
                  throw s(this);
              } while (128 & this.buf[this.pos++]);
            return this;
          }, u.prototype.skipType = function(t2) {
            switch (t2) {
              case 0:
                this.skip();
                break;
              case 1:
                this.skip(8);
                break;
              case 2:
                this.skip(this.uint32());
                break;
              case 3:
                for (; 4 != (t2 = 7 & this.uint32()); )
                  this.skipType(t2);
                break;
              case 5:
                this.skip(4);
                break;
              default:
                throw Error("invalid wire type " + t2 + " at offset " + this.pos);
            }
            return this;
          }, u._configure = function(t2) {
            r = t2, u.create = p(), r._configure();
            var e2 = i.Long ? "toLong" : "toNumber";
            i.merge(u.prototype, { int64: function() {
              return f.call(this)[e2](false);
            }, uint64: function() {
              return f.call(this)[e2](true);
            }, sint64: function() {
              return f.call(this).zzDecode()[e2](false);
            }, fixed64: function() {
              return h.call(this)[e2](true);
            }, sfixed64: function() {
              return h.call(this)[e2](false);
            } });
          };
        }, 593: (t, e, n) => {
          "use strict";
          t.exports = o;
          var r = n(1408);
          (o.prototype = Object.create(r.prototype)).constructor = o;
          var i = n(9693);
          function o(t2) {
            r.call(this, t2);
          }
          o._configure = function() {
            i.Buffer && (o.prototype._slice = i.Buffer.prototype.slice);
          }, o.prototype.string = function() {
            var t2 = this.uint32();
            return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t2, this.len));
          }, o._configure();
        }, 5054: (t) => {
          "use strict";
          t.exports = {};
        }, 5994: (t, e, n) => {
          "use strict";
          e.Service = n(7948);
        }, 7948: (t, e, n) => {
          "use strict";
          t.exports = i;
          var r = n(9693);
          function i(t2, e2, n2) {
            if ("function" != typeof t2)
              throw TypeError("rpcImpl must be a function");
            r.EventEmitter.call(this), this.rpcImpl = t2, this.requestDelimited = Boolean(e2), this.responseDelimited = Boolean(n2);
          }
          (i.prototype = Object.create(r.EventEmitter.prototype)).constructor = i, i.prototype.rpcCall = function t2(e2, n2, i2, o, a) {
            if (!o)
              throw TypeError("request must be specified");
            var s = this;
            if (!a)
              return r.asPromise(t2, s, e2, n2, i2, o);
            if (s.rpcImpl)
              try {
                return s.rpcImpl(e2, n2[s.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function(t3, n3) {
                  if (t3)
                    return s.emit("error", t3, e2), a(t3);
                  if (null !== n3) {
                    if (!(n3 instanceof i2))
                      try {
                        n3 = i2[s.responseDelimited ? "decodeDelimited" : "decode"](n3);
                      } catch (t4) {
                        return s.emit("error", t4, e2), a(t4);
                      }
                    return s.emit("data", n3, e2), a(null, n3);
                  }
                  s.end(true);
                });
              } catch (t3) {
                return s.emit("error", t3, e2), void setTimeout(function() {
                  a(t3);
                }, 0);
              }
            else
              setTimeout(function() {
                a(Error("already ended"));
              }, 0);
          }, i.prototype.end = function(t2) {
            return this.rpcImpl && (t2 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
          };
        }, 1945: (t, e, n) => {
          "use strict";
          t.exports = i;
          var r = n(9693);
          function i(t2, e2) {
            this.lo = t2 >>> 0, this.hi = e2 >>> 0;
          }
          var o = i.zero = new i(0, 0);
          o.toNumber = function() {
            return 0;
          }, o.zzEncode = o.zzDecode = function() {
            return this;
          }, o.length = function() {
            return 1;
          };
          var a = i.zeroHash = "\0\0\0\0\0\0\0\0";
          i.fromNumber = function(t2) {
            if (0 === t2)
              return o;
            var e2 = t2 < 0;
            e2 && (t2 = -t2);
            var n2 = t2 >>> 0, r2 = (t2 - n2) / 4294967296 >>> 0;
            return e2 && (r2 = ~r2 >>> 0, n2 = ~n2 >>> 0, ++n2 > 4294967295 && (n2 = 0, ++r2 > 4294967295 && (r2 = 0))), new i(n2, r2);
          }, i.from = function(t2) {
            if ("number" == typeof t2)
              return i.fromNumber(t2);
            if (r.isString(t2)) {
              if (!r.Long)
                return i.fromNumber(parseInt(t2, 10));
              t2 = r.Long.fromString(t2);
            }
            return t2.low || t2.high ? new i(t2.low >>> 0, t2.high >>> 0) : o;
          }, i.prototype.toNumber = function(t2) {
            if (!t2 && this.hi >>> 31) {
              var e2 = 1 + ~this.lo >>> 0, n2 = ~this.hi >>> 0;
              return e2 || (n2 = n2 + 1 >>> 0), -(e2 + 4294967296 * n2);
            }
            return this.lo + 4294967296 * this.hi;
          }, i.prototype.toLong = function(t2) {
            return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(t2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(t2) };
          };
          var s = String.prototype.charCodeAt;
          i.fromHash = function(t2) {
            return t2 === a ? o : new i((s.call(t2, 0) | s.call(t2, 1) << 8 | s.call(t2, 2) << 16 | s.call(t2, 3) << 24) >>> 0, (s.call(t2, 4) | s.call(t2, 5) << 8 | s.call(t2, 6) << 16 | s.call(t2, 7) << 24) >>> 0);
          }, i.prototype.toHash = function() {
            return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
          }, i.prototype.zzEncode = function() {
            var t2 = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t2) >>> 0, this.lo = (this.lo << 1 ^ t2) >>> 0, this;
          }, i.prototype.zzDecode = function() {
            var t2 = -(1 & this.lo);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t2) >>> 0, this.hi = (this.hi >>> 1 ^ t2) >>> 0, this;
          }, i.prototype.length = function() {
            var t2 = this.lo, e2 = (this.lo >>> 28 | this.hi << 4) >>> 0, n2 = this.hi >>> 24;
            return 0 === n2 ? 0 === e2 ? t2 < 16384 ? t2 < 128 ? 1 : 2 : t2 < 2097152 ? 3 : 4 : e2 < 16384 ? e2 < 128 ? 5 : 6 : e2 < 2097152 ? 7 : 8 : n2 < 128 ? 9 : 10;
          };
        }, 9693: function(t, e, n) {
          "use strict";
          var r = e;
          function i(t2, e2, n2) {
            for (var r2 = Object.keys(e2), i2 = 0; i2 < r2.length; ++i2)
              void 0 !== t2[r2[i2]] && n2 || (t2[r2[i2]] = e2[r2[i2]]);
            return t2;
          }
          function o(t2) {
            function e2(t3, n2) {
              if (!(this instanceof e2))
                return new e2(t3, n2);
              Object.defineProperty(this, "message", { get: function() {
                return t3;
              } }), Error.captureStackTrace ? Error.captureStackTrace(this, e2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n2 && i(this, n2);
            }
            return (e2.prototype = Object.create(Error.prototype)).constructor = e2, Object.defineProperty(e2.prototype, "name", { get: function() {
              return t2;
            } }), e2.prototype.toString = function() {
              return this.name + ": " + this.message;
            }, e2;
          }
          r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean(void 0 !== n.g && n.g && n.g.process && n.g.process.versions && n.g.process.versions.node), r.global = r.isNode && n.g || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(t2) {
            return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
          }, r.isString = function(t2) {
            return "string" == typeof t2 || t2 instanceof String;
          }, r.isObject = function(t2) {
            return t2 && "object" == typeof t2;
          }, r.isset = r.isSet = function(t2, e2) {
            var n2 = t2[e2];
            return !(null == n2 || !t2.hasOwnProperty(e2)) && ("object" != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0);
          }, r.Buffer = function() {
            try {
              var t2 = r.inquire("buffer").Buffer;
              return t2.prototype.utf8Write ? t2 : null;
            } catch (t3) {
              return null;
            }
          }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(t2) {
            return "number" == typeof t2 ? r.Buffer ? r._Buffer_allocUnsafe(t2) : new r.Array(t2) : r.Buffer ? r._Buffer_from(t2) : "undefined" == typeof Uint8Array ? t2 : new Uint8Array(t2);
          }, r.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(t2) {
            return t2 ? r.LongBits.from(t2).toHash() : r.LongBits.zeroHash;
          }, r.longFromHash = function(t2, e2) {
            var n2 = r.LongBits.fromHash(t2);
            return r.Long ? r.Long.fromBits(n2.lo, n2.hi, e2) : n2.toNumber(Boolean(e2));
          }, r.merge = i, r.lcFirst = function(t2) {
            return t2.charAt(0).toLowerCase() + t2.substring(1);
          }, r.newError = o, r.ProtocolError = o("ProtocolError"), r.oneOfGetter = function(t2) {
            for (var e2 = {}, n2 = 0; n2 < t2.length; ++n2)
              e2[t2[n2]] = 1;
            return function() {
              for (var t3 = Object.keys(this), n3 = t3.length - 1; n3 > -1; --n3)
                if (1 === e2[t3[n3]] && void 0 !== this[t3[n3]] && null !== this[t3[n3]])
                  return t3[n3];
            };
          }, r.oneOfSetter = function(t2) {
            return function(e2) {
              for (var n2 = 0; n2 < t2.length; ++n2)
                t2[n2] !== e2 && delete this[t2[n2]];
            };
          }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r._configure = function() {
            var t2 = r.Buffer;
            t2 ? (r._Buffer_from = t2.from !== Uint8Array.from && t2.from || function(e2, n2) {
              return new t2(e2, n2);
            }, r._Buffer_allocUnsafe = t2.allocUnsafe || function(e2) {
              return new t2(e2);
            }) : r._Buffer_from = r._Buffer_allocUnsafe = null;
          };
        }, 1173: (t, e, n) => {
          "use strict";
          t.exports = p;
          var r, i = n(9693), o = i.LongBits, a = i.base64, s = i.utf8;
          function u(t2, e2, n2) {
            this.fn = t2, this.len = e2, this.next = void 0, this.val = n2;
          }
          function c() {
          }
          function l(t2) {
            this.head = t2.head, this.tail = t2.tail, this.len = t2.len, this.next = t2.states;
          }
          function p() {
            this.len = 0, this.head = new u(c, 0, 0), this.tail = this.head, this.states = null;
          }
          var f = function() {
            return i.Buffer ? function() {
              return (p.create = function() {
                return new r();
              })();
            } : function() {
              return new p();
            };
          };
          function d(t2, e2, n2) {
            e2[n2] = 255 & t2;
          }
          function h(t2, e2) {
            this.len = t2, this.next = void 0, this.val = e2;
          }
          function g(t2, e2, n2) {
            for (; t2.hi; )
              e2[n2++] = 127 & t2.lo | 128, t2.lo = (t2.lo >>> 7 | t2.hi << 25) >>> 0, t2.hi >>>= 7;
            for (; t2.lo > 127; )
              e2[n2++] = 127 & t2.lo | 128, t2.lo = t2.lo >>> 7;
            e2[n2++] = t2.lo;
          }
          function b(t2, e2, n2) {
            e2[n2] = 255 & t2, e2[n2 + 1] = t2 >>> 8 & 255, e2[n2 + 2] = t2 >>> 16 & 255, e2[n2 + 3] = t2 >>> 24;
          }
          p.create = f(), p.alloc = function(t2) {
            return new i.Array(t2);
          }, i.Array !== Array && (p.alloc = i.pool(p.alloc, i.Array.prototype.subarray)), p.prototype._push = function(t2, e2, n2) {
            return this.tail = this.tail.next = new u(t2, e2, n2), this.len += e2, this;
          }, h.prototype = Object.create(u.prototype), h.prototype.fn = function(t2, e2, n2) {
            for (; t2 > 127; )
              e2[n2++] = 127 & t2 | 128, t2 >>>= 7;
            e2[n2] = t2;
          }, p.prototype.uint32 = function(t2) {
            return this.len += (this.tail = this.tail.next = new h((t2 >>>= 0) < 128 ? 1 : t2 < 16384 ? 2 : t2 < 2097152 ? 3 : t2 < 268435456 ? 4 : 5, t2)).len, this;
          }, p.prototype.int32 = function(t2) {
            return t2 < 0 ? this._push(g, 10, o.fromNumber(t2)) : this.uint32(t2);
          }, p.prototype.sint32 = function(t2) {
            return this.uint32((t2 << 1 ^ t2 >> 31) >>> 0);
          }, p.prototype.uint64 = function(t2) {
            var e2 = o.from(t2);
            return this._push(g, e2.length(), e2);
          }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(t2) {
            var e2 = o.from(t2).zzEncode();
            return this._push(g, e2.length(), e2);
          }, p.prototype.bool = function(t2) {
            return this._push(d, 1, t2 ? 1 : 0);
          }, p.prototype.fixed32 = function(t2) {
            return this._push(b, 4, t2 >>> 0);
          }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(t2) {
            var e2 = o.from(t2);
            return this._push(b, 4, e2.lo)._push(b, 4, e2.hi);
          }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(t2) {
            return this._push(i.float.writeFloatLE, 4, t2);
          }, p.prototype.double = function(t2) {
            return this._push(i.float.writeDoubleLE, 8, t2);
          };
          var m = i.Array.prototype.set ? function(t2, e2, n2) {
            e2.set(t2, n2);
          } : function(t2, e2, n2) {
            for (var r2 = 0; r2 < t2.length; ++r2)
              e2[n2 + r2] = t2[r2];
          };
          p.prototype.bytes = function(t2) {
            var e2 = t2.length >>> 0;
            if (!e2)
              return this._push(d, 1, 0);
            if (i.isString(t2)) {
              var n2 = p.alloc(e2 = a.length(t2));
              a.decode(t2, n2, 0), t2 = n2;
            }
            return this.uint32(e2)._push(m, e2, t2);
          }, p.prototype.string = function(t2) {
            var e2 = s.length(t2);
            return e2 ? this.uint32(e2)._push(s.write, e2, t2) : this._push(d, 1, 0);
          }, p.prototype.fork = function() {
            return this.states = new l(this), this.head = this.tail = new u(c, 0, 0), this.len = 0, this;
          }, p.prototype.reset = function() {
            return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(c, 0, 0), this.len = 0), this;
          }, p.prototype.ldelim = function() {
            var t2 = this.head, e2 = this.tail, n2 = this.len;
            return this.reset().uint32(n2), n2 && (this.tail.next = t2.next, this.tail = e2, this.len += n2), this;
          }, p.prototype.finish = function() {
            for (var t2 = this.head.next, e2 = this.constructor.alloc(this.len), n2 = 0; t2; )
              t2.fn(t2.val, e2, n2), n2 += t2.len, t2 = t2.next;
            return e2;
          }, p._configure = function(t2) {
            r = t2, p.create = f(), r._configure();
          };
        }, 3155: (t, e, n) => {
          "use strict";
          t.exports = o;
          var r = n(1173);
          (o.prototype = Object.create(r.prototype)).constructor = o;
          var i = n(9693);
          function o() {
            r.call(this);
          }
          function a(t2, e2, n2) {
            t2.length < 40 ? i.utf8.write(t2, e2, n2) : e2.utf8Write ? e2.utf8Write(t2, n2) : e2.write(t2, n2);
          }
          o._configure = function() {
            o.alloc = i._Buffer_allocUnsafe, o.writeBytesBuffer = i.Buffer && i.Buffer.prototype instanceof Uint8Array && "set" === i.Buffer.prototype.set.name ? function(t2, e2, n2) {
              e2.set(t2, n2);
            } : function(t2, e2, n2) {
              if (t2.copy)
                t2.copy(e2, n2, 0, t2.length);
              else
                for (var r2 = 0; r2 < t2.length; )
                  e2[n2++] = t2[r2++];
            };
          }, o.prototype.bytes = function(t2) {
            i.isString(t2) && (t2 = i._Buffer_from(t2, "base64"));
            var e2 = t2.length >>> 0;
            return this.uint32(e2), e2 && this._push(o.writeBytesBuffer, e2, t2), this;
          }, o.prototype.string = function(t2) {
            var e2 = i.Buffer.byteLength(t2);
            return this.uint32(e2), e2 && this._push(a, e2, t2), this;
          }, o._configure();
        }, 7714: (t, e, n) => {
          "use strict";
          e.R = void 0;
          const r = n(6919), i = n(7448);
          e.R = new class {
            async init() {
            }
            async createSessionHandler(t2, e2) {
              const n2 = new r.Session(e2);
              return await n2.loadModel(t2), new i.OnnxjsSessionHandler(n2);
            }
          }();
        }, 4200: (t, e, n) => {
          "use strict";
          e.c8 = e.rX = void 0;
          const r = n(1670), i = n(5381), o = n(2157), a = n(2306);
          e.rX = () => {
            if (("number" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), "boolean" != typeof r.env.wasm.simd && (r.env.wasm.simd = true), "boolean" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = false), "number" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {
              const t2 = "undefined" == typeof navigator ? (0, i.cpus)().length : navigator.hardwareConcurrency;
              r.env.wasm.numThreads = Math.min(4, Math.ceil((t2 || 1) / 2));
            }
          }, e.c8 = new class {
            async init() {
              (0, e.rX)(), await (0, o.initWasm)();
            }
            async createSessionHandler(t2, e2) {
              const n2 = new a.OnnxruntimeWebAssemblySessionHandler();
              return await n2.loadModel(t2, e2), Promise.resolve(n2);
            }
          }();
        }, 6018: function(t, e, n) {
          "use strict";
          var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), i = this && this.__exportStar || function(t2, e2) {
            for (var n2 in t2)
              "default" === n2 || Object.prototype.hasOwnProperty.call(e2, n2) || r(e2, t2, n2);
          };
          Object.defineProperty(e, "__esModule", { value: true }), i(n(1670), e);
          const o = n(1670);
          {
            const t2 = n(7714).R;
            (0, o.registerBackend)("webgl", t2, -10);
          }
          {
            const t2 = n(4200).c8;
            (0, o.registerBackend)("cpu", t2, 10), (0, o.registerBackend)("wasm", t2, 10), (0, o.registerBackend)("xnnpack", t2, 9);
          }
        }, 246: (t, e) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createAttributeWithCacheKey = void 0;
          class n {
            constructor(t2) {
              Object.assign(this, t2);
            }
            get cacheKey() {
              return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((t2) => `${this[t2]}`).join(";")), this._cacheKey;
            }
          }
          e.createAttributeWithCacheKey = (t2) => new n(t2);
        }, 7778: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.Attribute = void 0;
          const r = n(1446), i = n(9395), o = n(9162), a = n(2517);
          var s = i.onnxruntime.experimental.fbs;
          class u {
            constructor(t2) {
              if (this._attributes = /* @__PURE__ */ new Map(), null != t2) {
                for (const e2 of t2)
                  e2 instanceof r.onnx.AttributeProto ? this._attributes.set(e2.name, [u.getValue(e2), u.getType(e2)]) : e2 instanceof s.Attribute && this._attributes.set(e2.name(), [u.getValue(e2), u.getType(e2)]);
                if (this._attributes.size < t2.length)
                  throw new Error("duplicated attribute names");
              }
            }
            set(t2, e2, n2) {
              this._attributes.set(t2, [n2, e2]);
            }
            delete(t2) {
              this._attributes.delete(t2);
            }
            getFloat(t2, e2) {
              return this.get(t2, "float", e2);
            }
            getInt(t2, e2) {
              return this.get(t2, "int", e2);
            }
            getString(t2, e2) {
              return this.get(t2, "string", e2);
            }
            getTensor(t2, e2) {
              return this.get(t2, "tensor", e2);
            }
            getFloats(t2, e2) {
              return this.get(t2, "floats", e2);
            }
            getInts(t2, e2) {
              return this.get(t2, "ints", e2);
            }
            getStrings(t2, e2) {
              return this.get(t2, "strings", e2);
            }
            getTensors(t2, e2) {
              return this.get(t2, "tensors", e2);
            }
            get(t2, e2, n2) {
              const r2 = this._attributes.get(t2);
              if (void 0 === r2) {
                if (void 0 !== n2)
                  return n2;
                throw new Error(`required attribute not found: ${t2}`);
              }
              if (r2[1] !== e2)
                throw new Error(`type mismatch: expected ${e2} but got ${r2[1]}`);
              return r2[0];
            }
            static getType(t2) {
              const e2 = t2 instanceof r.onnx.AttributeProto ? t2.type : t2.type();
              switch (e2) {
                case r.onnx.AttributeProto.AttributeType.FLOAT:
                  return "float";
                case r.onnx.AttributeProto.AttributeType.INT:
                  return "int";
                case r.onnx.AttributeProto.AttributeType.STRING:
                  return "string";
                case r.onnx.AttributeProto.AttributeType.TENSOR:
                  return "tensor";
                case r.onnx.AttributeProto.AttributeType.FLOATS:
                  return "floats";
                case r.onnx.AttributeProto.AttributeType.INTS:
                  return "ints";
                case r.onnx.AttributeProto.AttributeType.STRINGS:
                  return "strings";
                case r.onnx.AttributeProto.AttributeType.TENSORS:
                  return "tensors";
                default:
                  throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e2]}`);
              }
            }
            static getValue(t2) {
              const e2 = t2 instanceof r.onnx.AttributeProto ? t2.type : t2.type();
              if (e2 === r.onnx.AttributeProto.AttributeType.GRAPH || e2 === r.onnx.AttributeProto.AttributeType.GRAPHS)
                throw new Error("graph attribute is not supported yet");
              const n2 = this.getValueNoCheck(t2);
              if (e2 === r.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n2))
                return a.LongUtil.longToNumber(n2);
              if (e2 === r.onnx.AttributeProto.AttributeType.INTS) {
                const t3 = n2, e3 = new Array(t3.length);
                for (let n3 = 0; n3 < t3.length; n3++) {
                  const r2 = t3[n3];
                  e3[n3] = a.LongUtil.longToNumber(r2);
                }
                return e3;
              }
              if (e2 === r.onnx.AttributeProto.AttributeType.TENSOR)
                return t2 instanceof r.onnx.AttributeProto ? o.Tensor.fromProto(n2) : o.Tensor.fromOrtTensor(n2);
              if (e2 === r.onnx.AttributeProto.AttributeType.TENSORS) {
                if (t2 instanceof r.onnx.AttributeProto)
                  return n2.map((t3) => o.Tensor.fromProto(t3));
                if (t2 instanceof s.Attribute)
                  return n2.map((t3) => o.Tensor.fromOrtTensor(t3));
              }
              if (e2 === r.onnx.AttributeProto.AttributeType.STRING && t2 instanceof r.onnx.AttributeProto) {
                const t3 = n2;
                return (0, a.decodeUtf8String)(t3);
              }
              return e2 === r.onnx.AttributeProto.AttributeType.STRINGS && t2 instanceof r.onnx.AttributeProto ? n2.map(a.decodeUtf8String) : n2;
            }
            static getValueNoCheck(t2) {
              return t2 instanceof r.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(t2) : this.getValueNoCheckFromOrtFormat(t2);
            }
            static getValueNoCheckFromOnnxFormat(t2) {
              switch (t2.type) {
                case r.onnx.AttributeProto.AttributeType.FLOAT:
                  return t2.f;
                case r.onnx.AttributeProto.AttributeType.INT:
                  return t2.i;
                case r.onnx.AttributeProto.AttributeType.STRING:
                  return t2.s;
                case r.onnx.AttributeProto.AttributeType.TENSOR:
                  return t2.t;
                case r.onnx.AttributeProto.AttributeType.GRAPH:
                  return t2.g;
                case r.onnx.AttributeProto.AttributeType.FLOATS:
                  return t2.floats;
                case r.onnx.AttributeProto.AttributeType.INTS:
                  return t2.ints;
                case r.onnx.AttributeProto.AttributeType.STRINGS:
                  return t2.strings;
                case r.onnx.AttributeProto.AttributeType.TENSORS:
                  return t2.tensors;
                case r.onnx.AttributeProto.AttributeType.GRAPHS:
                  return t2.graphs;
                default:
                  throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t2.type]}`);
              }
            }
            static getValueNoCheckFromOrtFormat(t2) {
              switch (t2.type()) {
                case s.AttributeType.FLOAT:
                  return t2.f();
                case s.AttributeType.INT:
                  return t2.i();
                case s.AttributeType.STRING:
                  return t2.s();
                case s.AttributeType.TENSOR:
                  return t2.t();
                case s.AttributeType.GRAPH:
                  return t2.g();
                case s.AttributeType.FLOATS:
                  return t2.floatsArray();
                case s.AttributeType.INTS: {
                  const e2 = [];
                  for (let n2 = 0; n2 < t2.intsLength(); n2++)
                    e2.push(t2.ints(n2));
                  return e2;
                }
                case s.AttributeType.STRINGS: {
                  const e2 = [];
                  for (let n2 = 0; n2 < t2.stringsLength(); n2++)
                    e2.push(t2.strings(n2));
                  return e2;
                }
                case s.AttributeType.TENSORS: {
                  const e2 = [];
                  for (let n2 = 0; n2 < t2.tensorsLength(); n2++)
                    e2.push(t2.tensors(n2));
                  return e2;
                }
                default:
                  throw new Error(`unsupported attribute type: ${s.AttributeType[t2.type()]}`);
              }
            }
          }
          e.Attribute = u;
        }, 7091: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.resolveBackend = e.backend = void 0;
          const r = n(5038), i = /* @__PURE__ */ new Map();
          async function o(t2) {
            const n2 = e.backend;
            if (void 0 !== n2[t2] && function(t3) {
              const e2 = t3;
              return "initialize" in e2 && "function" == typeof e2.initialize && "createSessionHandler" in e2 && "function" == typeof e2.createSessionHandler && "dispose" in e2 && "function" == typeof e2.dispose;
            }(n2[t2])) {
              const e2 = n2[t2];
              let r2 = e2.initialize();
              if ("object" == typeof r2 && "then" in r2 && (r2 = await r2), r2)
                return i.set(t2, e2), e2;
            }
          }
          e.backend = { webgl: new r.WebGLBackend() }, e.resolveBackend = async function t2(e2) {
            if (!e2)
              return t2(["webgl"]);
            {
              const t3 = "string" == typeof e2 ? [e2] : e2;
              for (const e3 of t3) {
                const t4 = i.get(e3);
                if (t4)
                  return t4;
                const n2 = await o(e3);
                if (n2)
                  return n2;
              }
            }
            throw new Error("no available backend to use");
          };
        }, 5038: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.WebGLBackend = void 0;
          const r = n(1670), i = n(6231), o = n(6416), a = n(7305);
          e.WebGLBackend = class {
            get contextId() {
              return r.env.webgl.contextId;
            }
            set contextId(t2) {
              r.env.webgl.contextId = t2;
            }
            get matmulMaxBatchSize() {
              return r.env.webgl.matmulMaxBatchSize;
            }
            set matmulMaxBatchSize(t2) {
              r.env.webgl.matmulMaxBatchSize = t2;
            }
            get textureCacheMode() {
              return r.env.webgl.textureCacheMode;
            }
            set textureCacheMode(t2) {
              r.env.webgl.textureCacheMode = t2;
            }
            get pack() {
              return r.env.webgl.pack;
            }
            set pack(t2) {
              r.env.webgl.pack = t2;
            }
            get async() {
              return r.env.webgl.async;
            }
            set async(t2) {
              r.env.webgl.async = t2;
            }
            initialize() {
              try {
                return this.glContext = (0, a.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), i.Logger.setWithEnv(r.env), i.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
              } catch (t2) {
                return i.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${t2}`), false;
              }
            }
            createSessionHandler(t2) {
              return new o.WebGLSessionHandler(this, t2);
            }
            dispose() {
              this.glContext.dispose();
            }
          };
        }, 5107: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.CoordsGlslLib = void 0;
          const r = n(2517), i = n(8520), o = n(5060), a = n(7859), s = n(9390);
          class u extends i.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
            }
            getCustomTypes() {
              return {};
            }
            offsetToCoords() {
              return { offsetToCoords: new i.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
            }
            coordsToOffset() {
              return { coordsToOffset: new i.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
            }
            getOutputSamplingSnippet() {
              const t2 = this.context.outputTextureLayout;
              return t2.isPacked ? this.getPackedOutputSamplingSnippet(t2) : this.getUnpackedOutputSamplingSnippet(t2);
            }
            getPackedOutputSamplingSnippet(t2) {
              const e2 = t2.unpackedShape, n2 = [t2.width, t2.height], r2 = {}, a2 = "getOutputCoords";
              switch (e2.length) {
                case 0:
                  r2[a2] = this.getOutputScalarCoords();
                  break;
                case 1:
                  r2[a2] = this.getOutputPacked1DCoords(e2, n2);
                  break;
                case 2:
                  r2[a2] = this.getOutputPacked2DCoords(e2, n2);
                  break;
                case 3:
                  r2[a2] = this.getOutputPacked3DCoords(e2, n2);
                  break;
                default:
                  r2[a2] = this.getOutputPackedNDCoords(e2, n2);
              }
              const s2 = `
      void setOutput(vec4 val) {
        ${(0, o.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
              return r2.floatTextureSetRGBA = new i.GlslLibRoutine(s2), r2;
            }
            getUnpackedOutputSamplingSnippet(t2) {
              const e2 = t2.unpackedShape, n2 = [t2.width, t2.height], r2 = {}, a2 = "getOutputCoords";
              switch (e2.length) {
                case 0:
                  r2[a2] = this.getOutputScalarCoords();
                  break;
                case 1:
                  r2[a2] = this.getOutputUnpacked1DCoords(e2, n2);
                  break;
                case 2:
                  r2[a2] = this.getOutputUnpacked2DCoords(e2, n2);
                  break;
                case 3:
                  r2[a2] = this.getOutputUnpacked3DCoords(e2, n2);
                  break;
                case 4:
                  r2[a2] = this.getOutputUnpacked4DCoords(e2, n2);
                  break;
                case 5:
                  r2[a2] = this.getOutputUnpacked5DCoords(e2, n2);
                  break;
                case 6:
                  r2[a2] = this.getOutputUnpacked6DCoords(e2, n2);
                  break;
                default:
                  throw new Error(`Unsupported output dimensionality: ${e2.length}`);
              }
              const s2 = `
        void setOutput(float val) {
          ${(0, o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
              return r2.floatTextureSetR = new i.GlslLibRoutine(s2), r2;
            }
            getOutputScalarCoords() {
              return new i.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
            }
            getOutputPacked1DCoords(t2, e2) {
              const n2 = e2;
              let r2 = "";
              return 1 === n2[0] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n2[1]}.0);
          }
        `, new i.GlslLibRoutine(r2)) : 1 === n2[1] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n2[0]}.0);
          }
        `, new i.GlslLibRoutine(r2)) : (r2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n2[0]}, ${n2[1]}));
          return 2 * (resTexRC.y * ${n2[0]} + resTexRC.x);
        }
      `, new i.GlslLibRoutine(r2));
            }
            getOutputPacked2DCoords(t2, e2) {
              let n2 = "";
              if (r.ArrayUtil.arraysEqual(t2, e2))
                return n2 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${e2[0]}, ${e2[1]}));
        }
      `, new i.GlslLibRoutine(n2);
              const o2 = e2, a2 = Math.ceil(t2[1] / 2);
              return n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o2[0]}, ${o2[1]}));

          int index = resTexRC.y * ${o2[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${a2}) * 2;
          int c = 2 * (index / ${a2});

          return ivec2(r, c);
        }
      `, new i.GlslLibRoutine(n2);
            }
            getOutputPacked3DCoords(t2, e2) {
              const n2 = [e2[0], e2[1]], r2 = Math.ceil(t2[2] / 2), o2 = r2 * Math.ceil(t2[1] / 2), a2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n2[0]}, ${n2[1]}));
          int index = resTexRC.y * ${n2[0]} + resTexRC.x;

          int b = index / ${o2};
          index -= b * ${o2};

          // reverse r and c order for packed texture
          int r = imod(index, ${r2}) * 2;
          int c = 2 * (index / ${r2});

          return ivec3(b, r, c);
        }
      `;
              return new i.GlslLibRoutine(a2);
            }
            getOutputPackedNDCoords(t2, e2) {
              const n2 = [e2[0], e2[1]], r2 = Math.ceil(t2[t2.length - 1] / 2), o2 = r2 * Math.ceil(t2[t2.length - 2] / 2);
              let a2 = o2, s2 = "", u2 = "b, r, c";
              for (let e3 = 2; e3 < t2.length - 1; e3++)
                a2 *= t2[t2.length - e3 - 1], s2 = `
      int b${e3} = index / ${a2};
      index -= b${e3} * ${a2};
    ` + s2, u2 = `b${e3}, ` + u2;
              const c = `
      ivec${t2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n2[0]}, ${n2[1]}));
        int index = resTexRC.y * ${n2[0]} + resTexRC.x;

        ${s2}

        int b = index / ${o2};
        index -= b * ${o2};

        // reverse r and c order for packed texture
        int r = imod(index, ${r2}) * 2;
        int c = 2 * (index / ${r2});

        return ivec${t2.length}(${u2});
      }
    `;
              return new i.GlslLibRoutine(c);
            }
            getOutputUnpacked1DCoords(t2, e2) {
              const n2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          return resTexRC.y * ${e2[0]} + resTexRC.x;
        }
      `;
              return new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked2DCoords(t2, e2) {
              const n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          int r = index / ${t2[1]};
          int c = index - r * ${t2[1]};
          return ivec2(r, c);
        }
      `;
              return new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked3DCoords(t2, e2) {
              let n2 = "";
              const r2 = t2.length;
              let o2 = null;
              r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
              for (let e3 = r2 - 3; e3 >= 0; --e3)
                o2[e3] = o2[e3 + 1] * t2[e3 + 1];
              const a2 = ["r", "c", "d"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
              return n2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec3(r, c, d);
        }
      `, new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked4DCoords(t2, e2) {
              let n2 = "";
              const r2 = t2.length;
              let o2 = null;
              r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
              for (let e3 = r2 - 3; e3 >= 0; --e3)
                o2[e3] = o2[e3 + 1] * t2[e3 + 1];
              const a2 = ["r", "c", "d", "d2"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
              return n2 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec4(r, c, d, d2);
        }
      `, new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked5DCoords(t2, e2) {
              let n2 = "";
              const r2 = t2.length;
              let o2 = null;
              r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
              for (let e3 = r2 - 3; e3 >= 0; --e3)
                o2[e3] = o2[e3 + 1] * t2[e3 + 1];
              const a2 = ["r", "c", "d", "d2", "d3"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
              return n2 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec5(r, c, d, d2, d3);
        }
      `, new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked6DCoords(t2, e2) {
              let n2 = "";
              const r2 = t2.length;
              let o2 = null;
              r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
              for (let e3 = r2 - 3; e3 >= 0; --e3)
                o2[e3] = o2[e3 + 1] * t2[e3 + 1];
              const a2 = ["r", "c", "d", "d2", "d3", "d4"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
              return n2 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${e2[0]}, ${e2[1]}));
         int index = resTexRC.y * ${e2[0]} + resTexRC.x;
         ${s2}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new i.GlslLibRoutine(n2);
            }
            getCommonUtilFuncs() {
              const t2 = {};
              let e2 = "uvFromFlat";
              t2[e2] = new i.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), e2 = "packedUVfrom1D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "packedUVfrom2D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "packedUVfrom3D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "sampleTexture";
              const n2 = (0, o.getGlsl)(this.context.glContext.version);
              return t2[e2] = new i.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n2.texture2D}(textureSampler, uv).r;
        }`), t2;
            }
            getInputsSamplingSnippets() {
              const t2 = {}, e2 = this.context.outputTextureLayout;
              return this.context.programInfo.inputNames.forEach((n2, r2) => {
                const i2 = this.context.inputTextureLayouts[r2], o2 = (0, s.generateShaderFuncNameFromInputSamplerName)(n2);
                i2.isPacked ? t2[o2] = this.getPackedSamplerFromInput(o2, n2, i2) : t2[o2] = this.getUnpackedSamplerFromInput(o2, n2, i2);
                const a2 = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n2);
                i2.unpackedShape.length <= e2.unpackedShape.length && (i2.isPacked ? t2[a2] = this.getPackedSamplerAtOutputCoords(a2, i2, e2, n2) : t2[a2] = this.getUnpackedSamplerAtOutputCoords(a2, i2, e2, n2));
              }), t2;
            }
            getPackedSamplerAtOutputCoords(t2, e2, n2, o2) {
              const a2 = e2.unpackedShape, u2 = n2.unpackedShape, c = o2, l = (0, s.generateShaderFuncNameFromInputSamplerName)(c), p = a2.length, f = u2.length, d = r.BroadcastUtil.getBroadcastDims(a2, u2), h = (0, s.getCoordsDataType)(f), g = f - p;
              let b;
              const m = (0, s.getGlChannels)();
              b = 0 === p ? "" : f < 2 && d.length >= 1 ? "coords = 0;" : d.map((t3) => `coords.${m[t3 + g]} = 0;`).join("\n");
              let y = "";
              y = f < 2 && p > 0 ? "coords" : a2.map((t3, e3) => `coords.${m[e3 + g]}`).join(", ");
              let _ = "return outputValue;";
              const v = 1 === r.ShapeUtil.size(a2), w = 1 === r.ShapeUtil.size(u2);
              if (1 !== p || v || w) {
                if (v && !w)
                  _ = 1 === f ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
                else if (d.length) {
                  const t3 = p - 2, e3 = p - 1;
                  d.indexOf(t3) > -1 && d.indexOf(e3) > -1 ? _ = "return vec4(outputValue.x);" : d.indexOf(t3) > -1 ? _ = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : d.indexOf(e3) > -1 && (_ = "return vec4(outputValue.xx, outputValue.zz);");
                }
              } else
                _ = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
              const x = `
      vec4 ${t2}() {
        ${h} coords = getOutputCoords();
        
        int lastDim = coords.${m[f - 1]};
        coords.${m[f - 1]} = coords.${m[f - 2]};
        coords.${m[f - 2]} = lastDim;
      
        ${b}
        vec4 outputValue = ${l}(${y});
        ${_}
      }
    `;
              return new i.GlslLibRoutine(x, ["coordinates.getOutputCoords"]);
            }
            getUnpackedSamplerAtOutputCoords(t2, e2, n2, o2) {
              const a2 = [n2.width, n2.height], u2 = [e2.width, e2.height], c = e2.unpackedShape.length, l = n2.unpackedShape.length, p = e2.unpackedShape, f = n2.unpackedShape, d = (0, s.generateShaderFuncNameFromInputSamplerName)(o2);
              if (c === l && r.ArrayUtil.arraysEqual(u2, a2)) {
                const e3 = `
          float ${t2}() {
            return sampleTexture(${o2}, TexCoords);
          }
        `;
                return new i.GlslLibRoutine(e3, ["coordinates.sampleTexture"]);
              }
              const h = (0, s.getCoordsDataType)(l), g = r.BroadcastUtil.getBroadcastDims(p, f), b = l - c;
              let m;
              const y = (0, s.getGlChannels)();
              m = 0 === c ? "" : l < 2 && g.length >= 1 ? "coords = 0;" : g.map((t3) => `coords.${y[t3 + b]} = 0;`).join("\n");
              let _ = "";
              _ = l < 2 && c > 0 ? "coords" : e2.unpackedShape.map((t3, e3) => `coords.${y[e3 + b]}`).join(", ");
              const v = `
        float ${t2}() {
          ${h} coords = getOutputCoords();
          ${m}
          return ${d}(${_});
        }
      `;
              return new i.GlslLibRoutine(v, ["coordinates.getOutputCoords"]);
            }
            getPackedSamplerFromInput(t2, e2, n2) {
              switch (n2.unpackedShape.length) {
                case 0:
                  return this.getPackedSamplerScalar(t2, e2);
                case 1:
                  return this.getPackedSampler1D(t2, e2, n2);
                case 2:
                  return this.getPackedSampler2D(t2, e2, n2);
                case 3:
                  return this.getPackedSampler3D(t2, e2, n2);
                default:
                  return this.getPackedSamplerND(t2, e2, n2);
              }
            }
            getUnpackedSamplerFromInput(t2, e2, n2) {
              const r2 = n2.unpackedShape;
              switch (r2.length) {
                case 0:
                  return this.getUnpackedSamplerScalar(t2, e2, n2);
                case 1:
                  return this.getUnpackedSampler1D(t2, e2, n2);
                case 2:
                  return this.getUnpackedSampler2D(t2, e2, n2);
                case 3:
                  return this.getUnpackedSampler3D(t2, e2, n2);
                case 4:
                  return this.getUnpackedSampler4D(t2, e2, n2);
                case 5:
                  return this.getUnpackedSampler5D(t2, e2, n2);
                case 6:
                  return this.getUnpackedSampler6D(t2, e2, n2);
                default:
                  throw new Error(`Unsupported dimension ${r2.length}-D`);
              }
            }
            getPackedSamplerScalar(t2, e2) {
              const n2 = `
          vec4 ${t2}() {
            return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${e2}, halfCR);
          }
        `;
              return new i.GlslLibRoutine(n2);
            }
            getPackedSampler1D(t2, e2, n2) {
              const r2 = [n2.width, n2.height], a2 = [r2[1], r2[0]], s2 = (0, o.getGlsl)(this.context.glContext.version), u2 = `vec4 ${t2}(int index) {
      vec2 uv = packedUVfrom1D(
      ${a2[0]}, ${a2[1]}, index);
      return ${s2.texture2D}(${e2}, uv);
    }`;
              return new i.GlslLibRoutine(u2, ["coordinates.packedUVfrom1D"]);
            }
            getPackedSampler2D(t2, e2, n2) {
              const a2 = n2.unpackedShape, s2 = [n2.width, n2.height], u2 = (0, o.getGlsl)(this.context.glContext.version), c = s2[0], l = s2[1];
              if (null != s2 && r.ArrayUtil.arraysEqual(a2, s2)) {
                const n3 = `vec4 ${t2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);
        return ${u2.texture2D}(${e2}, uv);
      }`;
                return new i.GlslLibRoutine(n3);
              }
              const p = s2, f = Math.ceil(a2[1] / 2), d = `vec4 ${t2}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);
      return ${u2.texture2D}(${e2}, uv);
    }`;
              return new i.GlslLibRoutine(d, ["coordinates.packedUVfrom2D"]);
            }
            getPackedSampler3D(t2, e2, n2) {
              const r2 = n2.unpackedShape, a2 = [n2.width, n2.height], u2 = [a2[0], a2[1]], c = (0, o.getGlsl)(this.context.glContext.version);
              if (1 === r2[0]) {
                const o2 = r2.slice(1), a3 = [1, 2], u3 = (0, s.squeezeInputShape)(r2, o2), c2 = ["b", "row", "col"], l2 = JSON.parse(JSON.stringify(n2));
                l2.unpackedShape = u3;
                const p2 = this.getPackedSamplerFromInput(t2, e2, l2), f2 = `${p2.routineBody}
      vec4 ${t2}(int b, int row, int col) {
        return ${t2}(${(0, s.getSqueezedParams)(c2, a3)});
      } `;
                return new i.GlslLibRoutine(f2, p2.dependencies);
              }
              const l = u2[0], p = u2[1], f = Math.ceil(r2[2] / 2), d = `vec4 ${t2}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${l}, ${f * Math.ceil(r2[1] / 2)}, ${f}, b, row, col);
      return ${c.texture2D}(${e2}, uv);}`;
              return new i.GlslLibRoutine(d, ["coordinates.packedUVfrom3D"]);
            }
            getPackedSamplerND(t2, e2, n2) {
              const r2 = n2.unpackedShape, a2 = r2.length, s2 = [n2.width, n2.height], u2 = (0, o.getGlsl)(this.context.glContext.version), c = [s2[0], s2[1]], l = c[1], p = c[0], f = Math.ceil(r2[a2 - 1] / 2);
              let d = f * Math.ceil(r2[a2 - 2] / 2), h = "int b, int row, int col", g = `b * ${d} + (row / 2) * ${f} + (col / 2)`;
              for (let t3 = 2; t3 < a2 - 1; t3++)
                h = `int b${t3}, ` + h, d *= r2[a2 - t3 - 1], g = `b${t3} * ${d} + ` + g;
              const b = `vec4 ${t2}(${h}) {
      int index = ${g};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});
      return ${u2.texture2D}(${e2}, uv);
    }`;
              return new i.GlslLibRoutine(b);
            }
            getUnpackedSamplerScalar(t2, e2, n2) {
              const [r2, o2] = [n2.width, n2.height];
              if (1 === r2 && 1 === o2) {
                const n3 = `
          float ${t2}() {
            return sampleTexture(${e2}, halfCR);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const a2 = `
        float ${t2}() {
          int offset_${e2} = coordsToOffset(TexCoords, ${r2}, ${o2});
          vec2 uv = uvFromFlat(${r2}, ${o2}, offset_${e2});
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler1D(t2, e2, n2) {
              const r2 = n2.width, o2 = n2.height;
              if (1 === o2 && 1 === r2) {
                const n3 = `
        float ${t2}(int index) {
          return sampleTexture(${e2}, halfCR);
        }
      `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              if (1 === o2) {
                const n3 = `
          float ${t2}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r2}.0, 0.5);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              if (1 === r2) {
                const n3 = `
          float ${t2}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o2}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const a2 = `
        float ${t2}(int index) {
          vec2 uv = uvFromFlat(${r2}, ${o2}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
            }
            getUnpackedSampler2D(t2, e2, n2) {
              const o2 = n2.unpackedShape, u2 = [n2.height, n2.width];
              if (null != u2 && r.ArrayUtil.arraysEqual(o2, u2)) {
                const n3 = `
          float ${t2}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u2[1]}.0, ${u2[0]}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const { newShape: c, keptDims: l } = (0, a.squeezeShape)(o2), p = c;
              if (p.length < o2.length) {
                const r2 = (0, s.squeezeInputShape)(o2, p), a2 = JSON.parse(JSON.stringify(n2));
                a2.unpackedShape = r2;
                const u3 = ["col", "row"], c2 = `
          ${this.getUnpackedSamplerFromInput(t2, e2, a2).routineBody}
          float ${t2}(int row, int col) {
            return ${t2}(${(0, s.getSqueezedParams)(u3, l)});
          }
        `;
                return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture"]);
              }
              const f = u2[1], d = u2[0];
              if (1 === d) {
                const n3 = `
          float ${t2}(int row, int col) {
            int offset_${e2} = coordsToOffset(TexCoords, ${f}, ${d});
            float index = dot(vec3(row, col, offset_${e2}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
              }
              if (1 === f) {
                const n3 = `
          float ${t2}(int row, int col) {
            int offset_${e2} = coordsToOffset(TexCoords, ${f}, ${d});
            float index = dot(vec3(row, col, offset_${e2}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
              }
              const h = `
        float ${t2}(int row, int col) {
          int index = col * ${o2[1]} + row;
          vec2 uv = uvFromFlat(${f}, ${d}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler3D(t2, e2, n2) {
              const r2 = n2.unpackedShape, o2 = r2[1] * r2[2], u2 = r2[2], { newShape: c, keptDims: l } = (0, a.squeezeShape)(r2), p = c;
              if (p.length < r2.length) {
                const o3 = (0, s.squeezeInputShape)(r2, p), a2 = ["batch", "col", "row"], u3 = JSON.parse(JSON.stringify(n2));
                u3.unpackedShape = o3;
                const c2 = this.getUnpackedSamplerFromInput(t2, e2, u3), f2 = l.reverse(), d = `
          ${c2.routineBody}
          float ${t2}(int batch, int row, int col) {
            return ${t2}(${(0, s.getSqueezedParams)(a2, f2)});
          }
        `;
                return new i.GlslLibRoutine(d, c2.dependencies);
              }
              const f = `
          float ${t2}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${o2} + col * ${u2} + row;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${e2}, uv);
          }
      `;
              return new i.GlslLibRoutine(f, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler4D(t2, e2, n2) {
              const r2 = n2.unpackedShape, o2 = r2[3], a2 = r2[2] * o2, s2 = `
        float ${t2}(int row, int col, int depth, int depth2) {
          int index = row * ${r2[1] * a2} + col * ${a2} +
              depth2 * ${o2} + depth;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
            }
            getUnpackedSampler5D(t2, e2, n2) {
              const r2 = n2.unpackedShape, o2 = r2[4], u2 = r2[3] * o2, c = r2[2] * u2, l = r2[1] * c, { newShape: p, keptDims: f } = (0, a.squeezeShape)(r2);
              if (p.length < r2.length) {
                const o3 = (0, s.squeezeInputShape)(r2, p), a2 = ["row", "col", "depth", "depth2", "depth3"], u3 = JSON.parse(JSON.stringify(n2));
                u3.unpackedShape = o3;
                const c2 = `
          ${this.getUnpackedSamplerFromInput(t2, e2, u3).routineBody}
          float ${t2}(int row, int col, int depth, int depth2, int depth3) {
            return ${t2}(${(0, s.getSqueezedParams)(a2, f)});
          }
        `;
                return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
              }
              const d = `
        float ${t2}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l} + col * ${c} + depth * ${u2} +
          depth3 * ${o2} + depth2;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(d, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            getUnpackedSampler6D(t2, e2, n2) {
              const r2 = n2.unpackedShape, o2 = r2[5], u2 = r2[4] * o2, c = r2[3] * u2, l = r2[2] * c, p = r2[1] * l, { newShape: f, keptDims: d } = (0, a.squeezeShape)(r2);
              if (f.length < r2.length) {
                const o3 = (0, s.squeezeInputShape)(r2, f), a2 = ["row", "col", "depth", "depth2", "depth3", "depth4"], u3 = JSON.parse(JSON.stringify(n2));
                u3.unpackedShape = o3;
                const c2 = `
            ${this.getUnpackedSamplerFromInput(t2, e2, u3).routineBody}
            float ${t2}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${t2}(${(0, s.getSqueezedParams)(a2, d)});
            }
          `;
                return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
              }
              const h = `
          float ${t2}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${l} + depth * ${c} +
            depth2 * ${u2} + depth3 * ${o2} + depth4;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${e2}, uv);
          }
        `;
              return new i.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            toVec() {
              const t2 = this.context.outputTextureLayout, e2 = t2.shape.length, n2 = t2.strides, r2 = t2.width, o2 = t2.height, a2 = [];
              for (let t3 = 0; t3 < e2 - 1; ++t3)
                a2.push(`
        c[${t3}] = offset / ${n2[t3]};`), a2.push(`
        offset -= c[${t3}] * ${n2[t3]};`);
              a2.push(`
        c[${e2 - 1}] = offset;`);
              const s2 = `
      void toVec(vec2 texCoords, out int c[${e2}]) {
        int offset = coordsToOffset(texCoords, ${r2}, ${o2});
        ${a2.join("")}
      }
      void toVec(int offset, out int c[${e2}]) {
        ${a2.join("")}
      }
    `;
              return { toVec: new i.GlslLibRoutine(s2, ["coordinates.coordsToOffset"]) };
            }
            valueFrom() {
              const t2 = {};
              return this.context.programInfo.inputNames.forEach((e2, n2) => {
                const r2 = this.context.inputTextureLayouts[n2], o2 = (r2.unpackedShape.length > 0 ? r2.unpackedShape : r2.shape).length;
                let a2 = `_${e2}`;
                t2[a2] = new i.GlslLibRoutine(this.getValueFromSingle(e2, o2, r2.width, r2.height, false), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), a2 += "_T", t2[a2] = new i.GlslLibRoutine(this.getValueFromSingle(e2, o2, r2.width, r2.height, true), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
              }), t2;
            }
            getValueFromSingle(t2, e2, n2, r2, i2) {
              let a2 = `_${t2}`;
              return i2 && (a2 += "_T"), `
        float ${a2}(int m[${e2}]) {
          int offset = indicesToOffset${a2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          float value = getColorAsFloat(${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t2}, coords));
          return value;
        }
        `;
            }
            getPackedValueFrom(t2, e2, n2, r2, i2) {
              let a2 = `_${t2}_Pack`;
              return i2 && (a2 += "_T"), `
        vec4 ${a2}(int m[${e2}]) {
          int offset = indicesToOffset_${t2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t2}, coords);
        }
        `;
            }
          }
          e.CoordsGlslLib = u;
        }, 8520: (t, e) => {
          "use strict";
          var n;
          Object.defineProperty(e, "__esModule", { value: true }), e.TopologicalSortGlslRoutines = e.GlslLibRoutineNode = e.GlslLibRoutine = e.GlslLib = e.GlslContext = e.FunctionType = void 0, (n = e.FunctionType || (e.FunctionType = {}))[n.ValueBased = 0] = "ValueBased", n[n.Positional = 1] = "Positional", e.GlslContext = class {
            constructor(t2, e2, n2, r) {
              this.glContext = t2, this.programInfo = e2, this.inputTextureLayouts = n2, this.outputTextureLayout = r;
            }
          }, e.GlslLib = class {
            constructor(t2) {
              this.context = t2;
            }
          }, e.GlslLibRoutine = class {
            constructor(t2, e2) {
              this.routineBody = t2, this.dependencies = e2;
            }
          }, e.GlslLibRoutineNode = class {
            constructor(t2, e2, n2) {
              this.name = t2, this.dependencies = n2 || [], e2 && (this.routineBody = e2);
            }
            addDependency(t2) {
              t2 && this.dependencies.push(t2);
            }
          }, e.TopologicalSortGlslRoutines = class {
            static returnOrderedNodes(t2) {
              if (!t2 || 0 === t2.length)
                return [];
              if (1 === t2.length)
                return t2;
              const e2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set(), r = new Array();
              return this.createOrderedNodes(t2, e2, n2, r), r;
            }
            static createOrderedNodes(t2, e2, n2, r) {
              for (let i = 0; i < t2.length; ++i)
                this.dfsTraverse(t2[i], e2, n2, r);
            }
            static dfsTraverse(t2, e2, n2, r) {
              if (!t2 || n2.has(t2.name))
                return;
              if (e2.has(t2.name))
                throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
              e2.add(t2.name);
              const i = t2.dependencies;
              if (i && i.length > 0)
                for (let t3 = 0; t3 < i.length; ++t3)
                  this.dfsTraverse(i[t3], e2, n2, r);
              r.push(t2), n2.add(t2.name), e2.delete(t2.name);
            }
          };
        }, 7341: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.EncodingGlslLib = void 0;
          const r = n(8520);
          class i extends r.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getFunctions() {
              return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
            }
            getCustomTypes() {
              return {};
            }
            encodeFloat32() {
              return { encode: new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
            }
            decodeFloat32() {
              return { decode: new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
            }
            encodeUint8() {
              const t2 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
              return { encode: new r.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${t2}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
            }
            decodeUint8() {
              const t2 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
              return { decode: new r.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${t2}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
            }
            static isLittleEndian() {
              const t2 = new ArrayBuffer(4), e2 = new Uint32Array(t2), n2 = new Uint8Array(t2);
              if (e2[0] = 3735928559, 239 === n2[0])
                return true;
              if (222 === n2[0])
                return false;
              throw new Error("unknown endianness");
            }
          }
          e.EncodingGlslLib = i;
        }, 9894: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.FragColorGlslLib = void 0;
          const r = n(8520), i = n(5060);
          class o extends r.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getFunctions() {
              return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
            }
            getCustomTypes() {
              return {};
            }
            setFragColor() {
              const t2 = (0, i.getGlsl)(this.context.glContext.version);
              return { setFragColor: new r.GlslLibRoutine(`
        void setFragColor(float value) {
            ${t2.output} = encode(value);
        }
        `, ["encoding.encode"]) };
            }
            getColorAsFloat() {
              return { getColorAsFloat: new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
            }
          }
          e.FragColorGlslLib = o;
        }, 2848: (t, e) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.replaceInlines = void 0;
          const n = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
          e.replaceInlines = function(t2) {
            const e2 = {};
            let r;
            for (; null !== (r = n.exec(t2)); ) {
              const t3 = r[3].split(",").map((t4) => {
                const e3 = t4.trim().split(" ");
                return e3 && 2 === e3.length ? { type: e3[0], name: e3[1] } : null;
              }).filter((t4) => null !== t4);
              e2[r[2]] = { params: t3, body: r[4] };
            }
            for (const n2 in e2) {
              const i = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n2), o = new RegExp(i, "gm");
              for (; null !== (r = o.exec(t2)); ) {
                const i2 = r[1], o2 = r[2], a = r[3].split(","), s = i2 ? `${i2} ${o2};` : "";
                let u = e2[n2].body, c = "";
                e2[n2].params.forEach((t3, e3) => {
                  t3 && (c += `${t3.type} ${t3.name} = ${a[e3]};
`);
                }), u = `${c}
 ${u}`, u = u.replace("return", `${o2} = `);
                const l = `
      ${s}
      {
        ${u}
      }
      `;
                t2 = t2.replace(r[0], l);
              }
            }
            return t2.replace(n, "");
          };
        }, 8879: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.GlslPreprocessor = void 0;
          const r = n(8520), i = n(2848), o = n(5483), a = n(5060);
          e.GlslPreprocessor = class {
            constructor(t2, e2, n2, i2) {
              this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(t2, e2, n2, i2), Object.keys(o.glslRegistry).forEach((t3) => {
                const e3 = new o.glslRegistry[t3](this.context);
                this.libs[t3] = e3;
              });
              const a2 = this.glslLibRoutineDependencyGraph;
              for (const t3 in this.libs) {
                const e3 = this.libs[t3].getFunctions();
                for (const n3 in e3) {
                  const i3 = t3 + "." + n3;
                  let o2;
                  a2[i3] ? (o2 = a2[i3], o2.routineBody = e3[n3].routineBody) : (o2 = new r.GlslLibRoutineNode(i3, e3[n3].routineBody), a2[i3] = o2);
                  const s = e3[n3].dependencies;
                  if (s)
                    for (let t4 = 0; t4 < s.length; ++t4)
                      if (a2[s[t4]])
                        o2.addDependency(a2[s[t4]]);
                      else {
                        const e4 = new r.GlslLibRoutineNode(s[t4]);
                        a2[s[t4]] = e4, o2.addDependency(e4);
                      }
                }
              }
            }
            preprocess() {
              const t2 = this.context.programInfo;
              let e2 = t2.shaderSource;
              return this.context.programInfo.hasMain || (e2 = `${e2}
      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), e2 = (0, i.replaceInlines)(e2), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(t2.inputNames, t2.variables)}
    ${this.getImports(e2)}
    ${e2}`;
            }
            getImports(t2) {
              const e2 = this.selectGlslLibRoutinesToBeIncluded(t2);
              if (0 === e2.length)
                return "";
              let n2 = "";
              for (let t3 = 0; t3 < e2.length; ++t3) {
                if (!e2[t3].routineBody)
                  throw new Error(`Missing body for the Glsl Library routine: ${e2[t3].name}`);
                n2 += e2[t3].routineBody + "\n";
              }
              return n2;
            }
            selectGlslLibRoutinesToBeIncluded(t2) {
              const e2 = [];
              return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n2) => {
                const r2 = n2.split(".")[1];
                -1 !== t2.indexOf(r2) && e2.push(this.glslLibRoutineDependencyGraph[n2]);
              }), r.TopologicalSortGlslRoutines.returnOrderedNodes(e2);
            }
            getUniforms(t2, e2) {
              const n2 = [];
              if (t2)
                for (const e3 of t2)
                  n2.push(`uniform sampler2D ${e3};`);
              if (e2)
                for (const t3 of e2)
                  n2.push(`uniform ${t3.type} ${t3.name}${t3.arrayLength ? `[${t3.arrayLength}]` : ""};`);
              return n2.join("\n");
            }
          };
        }, 5483: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.glslRegistry = void 0;
          const r = n(5107), i = n(7341), o = n(9894), a = n(2655), s = n(3891);
          e.glslRegistry = { encoding: i.EncodingGlslLib, fragcolor: o.FragColorGlslLib, vec: s.VecGlslLib, shapeUtils: a.ShapeUtilsGlslLib, coordinates: r.CoordsGlslLib };
        }, 2655: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.ShapeUtilsGlslLib = void 0;
          const r = n(8520);
          class i extends r.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
            }
            getCustomTypes() {
              return {};
            }
            bcastIndex() {
              const t2 = this.context.outputTextureLayout.shape.length, e2 = {};
              return this.context.programInfo.inputNames.forEach((n2, i2) => {
                const o = this.context.inputTextureLayouts[i2].unpackedShape;
                if (o.length <= t2) {
                  const i3 = o.length, a = t2 - i3, s = `bcastIndices_${n2}`;
                  let u = "";
                  for (let t3 = 0; t3 < i3; ++t3)
                    u += `
          realIndices[${t3}] = int( mod(float(bcastedIndices[${a + t3}]), ${o[t3]}.0) );
          `;
                  const c = `
        void ${s} (int bcastedIndices[${t2}], out int realIndices[${i3}]) {
          ${u}
        }
        `;
                  e2[s] = new r.GlslLibRoutine(c);
                }
              }), e2;
            }
            bcastMatmulIndex() {
              const t2 = this.context.outputTextureLayout.shape.length, e2 = {};
              return this.context.programInfo.inputNames.forEach((n2, i2) => {
                const o = this.context.inputTextureLayouts[i2].shape;
                if (!(o.length < 2 || o.length > t2)) {
                  const i3 = o.length, a = t2 - i3, s = `bcastMatmulIndices_${n2}`;
                  let u = "";
                  for (let t3 = 0; t3 < i3 - 2; ++t3)
                    u += `
          realIndices[${t3}] = int( mod(float(bcastedIndices[${a + t3}]), ${o[t3]}.0) );
          `;
                  const c = `
        void ${s}(int bcastedIndices[${t2}], out int realIndices[${i3}]) {
          ${u}
          realIndices[${i3 - 1}] = bcastedIndices[${t2 - 1}];
          realIndices[${i3 - 2}] = bcastedIndices[${t2 - 2}];
        }
        `;
                  e2[s] = new r.GlslLibRoutine(c);
                }
              }), e2;
            }
            indicesToOffset() {
              const t2 = {};
              return this.context.programInfo.inputNames.forEach((e2, n2) => {
                const o = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = o.length;
                let u = `indicesToOffset_${e2}`;
                t2[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${e2}_T`, t2[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a.slice().reverse()));
              }), t2;
            }
            static indexToOffsetSingle(t2, e2, n2) {
              let r2 = "";
              for (let t3 = e2 - 1; t3 >= 0; --t3)
                r2 += `
        offset += indices[${t3}] * ${n2[t3]};
        `;
              return `
      int ${t2}(int indices[${e2}]) {
        int offset = 0;
        ${r2}
        return offset;
      }
      `;
            }
            offsetToIndices() {
              const t2 = {};
              return this.context.programInfo.inputNames.forEach((e2, n2) => {
                const o = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = o.length;
                let u = `offsetToIndices_${e2}`;
                t2[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${e2}_T`, t2[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a.slice().reverse()));
              }), t2;
            }
            static offsetToIndicesSingle(t2, e2, n2) {
              const r2 = [];
              for (let t3 = 0; t3 < e2 - 1; ++t3)
                r2.push(`
      indices[${t3}] = offset / ${n2[t3]};`), r2.push(`
        offset -= indices[${t3}] * ${n2[t3]};`);
              return r2.push(`
      indices[${e2 - 1}] = offset;`), `
      void ${t2}(int offset, out int indices[${e2}]) {
        ${r2.join("")}
      }
      `;
            }
            incrementIndices() {
              const t2 = {};
              return this.context.programInfo.inputNames.forEach((e2, n2) => {
                const i2 = this.context.inputTextureLayouts[n2].shape, o = i2.length, a = `incrementIndices_${e2}`;
                let s = "";
                for (let t3 = 0; t3 < o; ++t3)
                  s += `
        shape[${t3}] = ${i2[t3]};`;
                const u = `
        void ${a}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${s};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
                t2[a] = new r.GlslLibRoutine(u);
              }), t2;
            }
          }
          e.ShapeUtilsGlslLib = i;
        }, 5060: (t, e) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.getDefaultFragShaderMain = e.getFragShaderPreamble = e.getVertexShaderSource = e.getGlsl = void 0;
          const n = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
          function i(t2) {
            return 1 === t2 ? n : r;
          }
          e.getGlsl = i, e.getVertexShaderSource = function(t2) {
            const e2 = i(t2);
            return `${e2.version}
      precision highp float;
      ${e2.attribute} vec3 position;
      ${e2.attribute} vec2 textureCoord;

      ${e2.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
          }, e.getFragShaderPreamble = function(t2) {
            const e2 = i(t2);
            return `${e2.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e2.varyingFrag} vec2 TexCoords;
    ${e2.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
          }, e.getDefaultFragShaderMain = function(t2, e2) {
            return `
  void main() {
    int indices[${e2}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i(t2).output} = result;
  }
  `;
          };
        }, 3891: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.VecGlslLib = void 0;
          const r = n(8520);
          class i extends r.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getCustomTypes() {
              return {};
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
            }
            binaryVecFunctions() {
              const t2 = this.context.outputTextureLayout.shape.length, e2 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n2 = {};
              for (const i2 in e2) {
                const o = `${i2}Vec`;
                let a = "";
                for (let n3 = 0; n3 < t2; ++n3)
                  a += `
          dest[${n3}] ${e2[i2]} src[${n3}];
          `;
                const s = `
        void ${o}(int src[${t2}], out int dest[${t2}]) {
          ${a}
        }
        `;
                n2[o] = new r.GlslLibRoutine(s);
              }
              return n2;
            }
            copyVec() {
              const t2 = this.context.outputTextureLayout.shape.length;
              let e2 = "";
              for (let n3 = 0; n3 < t2; ++n3)
                e2 += `
        dest[${n3}] = src[${n3}];
        `;
              const n2 = `
      void copyVec(int src[${t2}], out int dest[${t2}]) {
        ${e2}
      }
      `;
              return { copyVec: new r.GlslLibRoutine(n2) };
            }
            setVecItem() {
              const t2 = this.context.outputTextureLayout.shape.length;
              let e2 = `
        if(index < 0)
            index =${t2} + index;
        if (index == 0)
            m[0] = value;
        `;
              for (let n3 = 1; n3 < t2 - 1; ++n3)
                e2 += `
        else if (index == ${n3})
            m[${n3}] = value;
            `;
              e2 += `
        else
            m[${t2 - 1}] = value;
        `;
              const n2 = `
      void setVecItem(out int m[${t2}], int index, int value) {
        ${e2}
      }
        `;
              return { setVecItem: new r.GlslLibRoutine(n2) };
            }
            getVecItem() {
              const t2 = this.context.outputTextureLayout.shape.length;
              let e2 = `
        if(index < 0)
            index = ${t2} + index;
        if (index == 0)
            return m[0];
      `;
              for (let n3 = 1; n3 < t2 - 1; ++n3)
                e2 += `
        else if (index == ${n3})
            return m[${n3}];
      `;
              e2 += `
        else
            return m[${t2 - 1}];
        `;
              const n2 = `
      int getVecItem(int m[${t2}], int index) {
        ${e2}
      }
    `;
              return { getVecItem: new r.GlslLibRoutine(n2) };
            }
          }
          e.VecGlslLib = i;
        }, 8316: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.WebGLInferenceHandler = void 0;
          const r = n(6231), i = n(9162), o = n(2517), a = n(2403), s = n(7019), u = n(8710), c = n(5611), l = n(4057), p = n(2039);
          e.WebGLInferenceHandler = class {
            constructor(t2) {
              this.session = t2, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            calculateTextureWidthAndHeight(t2, e2) {
              return (0, l.calculateTextureWidthAndHeight)(this.session.layoutStrategy, t2, e2);
            }
            executeProgram(t2, e2) {
              if (e2.length < t2.inputNames.length)
                throw new Error(`Input size mustn't be less than ${t2.inputNames.length}.`);
              if (t2.inputNames.length !== t2.inputTypes.length)
                throw new Error("input names size does not match input types");
              const n2 = [];
              for (let r3 = 0; r3 < t2.inputNames.length; ++r3)
                n2[r3] = this.getOrCreateTextureData(e2[r3], t2.inputTypes[r3]);
              const r2 = ((t3, e3) => {
                const n3 = e3.map((t4) => `${t4.unpackedShape.join(",")};${t4.width}x${t4.height}`).join("_");
                let r3 = t3.name;
                return t3.cacheHint && (r3 += "[" + t3.cacheHint + "]"), r3 += ":" + n3, r3;
              })(t2, n2);
              let i2 = this.session.programManager.getArtifact(r2);
              const o2 = i2 ? i2.programInfo : "function" == typeof t2.get ? t2.get() : t2, a2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2.output.dims, o2.output.textureType), s2 = this.createTextureData(a2, o2.output.type);
              return i2 || (i2 = this.session.programManager.build(o2, n2, s2), this.session.programManager.setArtifact(r2, i2)), this.runProgram(i2, n2, s2), s2;
            }
            run(t2, e2) {
              return this.executeProgram(t2, e2).tensor;
            }
            runProgram(t2, e2, n2) {
              for (let n3 = 0; n3 < e2.length; ++n3)
                if (!!e2[n3].isPacked != (t2.programInfo.inputTypes[n3] === p.TextureType.packed))
                  throw new Error(`input[${n3}] property packed inconsistent`);
              if (!!n2.isPacked != (t2.programInfo.output.textureType === p.TextureType.packed))
                throw new Error("output property packed inconsistent");
              this.session.programManager.run(t2, e2, n2);
            }
            getOrCreateTextureData(t2, e2) {
              let n2 = this.getTextureData(t2.dataId, e2 === p.TextureType.packed);
              if (!n2 && (n2 = this.getTextureData(t2.dataId, e2 !== p.TextureType.packed), n2))
                return e2 === p.TextureType.packed ? this.pack(n2) : this.unpack(n2);
              if (!n2) {
                const r2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, t2.dims, e2);
                if (e2 === p.TextureType.packedLastDimension) {
                  const n3 = 1, r3 = 4, i2 = t2.dims;
                  if (4 === i2.length) {
                    const o2 = [i2[0], Math.ceil(i2[1] * i2[2] * i2[3] / r3)], a2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2, e2);
                    let s2 = t2.numberData;
                    if (i2[1] * i2[2] * i2[3] % r3 != 0) {
                      const e3 = i2[0], o3 = i2[1] * i2[2] * i2[3], a3 = Math.ceil(o3 * n3 / r3) * r3;
                      s2 = new Float32Array(e3 * a3);
                      for (let r4 = 0; r4 < e3; ++r4) {
                        const e4 = r4 * o3, i3 = r4 * a3 + r4 % n3 * o3;
                        s2.set(t2.numberData.subarray(e4, e4 + o3), i3);
                      }
                    }
                    return this.createTextureData(a2, t2.type, s2, t2, 1);
                  }
                }
                if (e2 === p.TextureType.packed) {
                  const e3 = (0, l.createTextureLayoutFromShape)(this.session.layoutStrategy, t2.dims, 1, [], { reverseWH: true }), r3 = this.createTextureData(e3, t2.type, t2.numberData, t2, 1);
                  n2 = this.pack(r3);
                } else
                  n2 = this.createTextureData(r2, t2.type, t2.numberData, t2, 1);
              }
              return n2;
            }
            createTextureDataFromLayoutBindTensor(t2, e2, n2, r2) {
              return this.createTextureData(t2, e2, n2, r2, 1);
            }
            createTextureData(t2, e2, n2, i2, o2) {
              r.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(t2)}]`);
              const a2 = this.session.textureManager.createTextureFromLayout(e2, t2, n2, o2);
              return this.createTextureDataFromTexture(t2, e2, a2, i2);
            }
            reshapeUnpacked(t2, e2) {
              const n2 = this.getOrCreateTextureData(t2, p.TextureType.unpacked), r2 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== e2.length ? e2 : [1], strides: o.ShapeUtil.computeStrides(e2), unpackedShape: e2 };
              return this.createTextureDataFromTexture(r2, t2.type, n2.texture).tensor;
            }
            reshapePacked(t2, e2) {
              const n2 = this.getOrCreateTextureData(t2, p.TextureType.packed);
              if ((0, s.isReshapeCheap)(t2.dims, e2)) {
                const r3 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== e2.length ? e2 : [1], strides: o.ShapeUtil.computeStrides(e2), unpackedShape: e2, isPacked: true };
                return this.createTextureDataFromTexture(r3, t2.type, n2.texture).tensor;
              }
              const r2 = (0, s.processDims3D)(t2.dims), i2 = (0, s.processDims3D)(e2), a2 = this.reshapePacked(t2, r2), u2 = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a2, i2), [a2]);
              return this.reshapePacked(u2, e2);
            }
            cast(t2, e2) {
              const n2 = this.getOrCreateTextureData(t2, p.TextureType.unpacked);
              return this.createTextureDataFromTexture(n2, e2, n2.texture).tensor;
            }
            createTextureDataFromTexture(t2, e2, n2, r2, o2) {
              const a2 = Object.assign(Object.assign({}, t2), { tensor: r2 || new i.Tensor(t2.unpackedShape, e2, (t3) => this.readTexture(a2), async (t3) => this.readTextureAsync(a2), void 0, o2), texture: n2 });
              return this.setTextureData(a2.tensor.dataId, a2, t2.isPacked), a2;
            }
            getTextureData(t2, e2 = false) {
              return this.session.isInitializer(t2) ? this.session.getTextureData(t2, e2) : e2 ? this.packedTextureDataCache.get(t2) : this.unpackedTextureDataCache.get(t2);
            }
            setTextureData(t2, e2, n2 = false) {
              this.session.isInitializer(t2) ? this.session.setTextureData(t2, e2, n2) : (n2 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(t2, e2);
            }
            isTextureLayoutCached(t2, e2 = false) {
              return !!this.getTextureData(t2.dataId, e2);
            }
            dispose() {
              this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t2) => this.session.textureManager.releaseTexture(t2)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t2) => this.session.textureManager.releaseTexture(t2)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            readTexture(t2) {
              return t2.isPacked ? this.readTexture(this.unpack(t2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(t2, t2.tensor.type, t2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t2));
            }
            async readTextureAsync(t2) {
              return t2.isPacked ? this.readTextureAsync(this.unpack(t2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(t2, t2.tensor.type, t2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t2));
            }
            pack(t2) {
              return this.executeProgram((0, a.createPackProgramInfoLoader)(this, t2.tensor), [t2.tensor]);
            }
            unpack(t2) {
              return this.executeProgram((0, c.createUnpackProgramInfoLoader)(this, t2.tensor), [t2.tensor]);
            }
          };
        }, 1640: function(t, e, n) {
          "use strict";
          var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
            Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
          } : function(t2, e2) {
            t2.default = e2;
          }), o = this && this.__importStar || function(t2) {
            if (t2 && t2.__esModule)
              return t2;
            var e2 = {};
            if (null != t2)
              for (var n2 in t2)
                "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
            return i(e2, t2), e2;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.WEBGL_OP_RESOLVE_RULES = void 0;
          const a = n(2898), s = o(n(7839)), u = n(4196), c = n(2069), l = n(8138), p = n(9663), f = n(5193), d = n(7992), h = n(1253), g = n(4776), b = n(6572), m = n(3346), y = n(5623), _ = n(2870), v = n(2143), w = n(4939), x = n(718), T = n(2268), S = n(8117), O = n(2278), A = n(5524), E = n(5975), I = n(3933), P = n(6558), D = n(5723), $ = n(3738), k = o(n(4909)), C = n(8428), F = n(9793);
          e.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", k.abs], ["Acos", "", "7+", k.acos], ["Add", "", "7+", s.add], ["And", "", "7+", s.and], ["Asin", "", "7+", k.asin], ["Atan", "", "7+", k.atan], ["AveragePool", "", "7+", v.averagePool, v.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", a.batchNormalization, a.parseBatchNormalizationAttributes], ["Cast", "", "6+", u.cast, u.parseCastAttributes], ["Ceil", "", "6+", k.ceil], ["Clip", "", "6-10", k.clip, k.parseClipAttributes], ["Clip", "", "11+", k.clipV11], ["Concat", "", "4+", c.concat, c.parseConcatAttributes], ["Conv", "", "1+", l.conv, l.parseConvAttributes], ["ConvTranspose", "", "1+", p.convTranspose, p.parseConvTransposeAttributes], ["Cos", "", "7+", k.cos], ["Div", "", "7+", s.div], ["Dropout", "", "7+", k.identity], ["DepthToSpace", "", "1+", f.depthToSpace, f.parseDepthToSpaceAttributes], ["Equal", "", "7+", s.equal], ["Elu", "", "6+", k.elu, k.parseEluAttributes], ["Exp", "", "6+", k.exp], ["Flatten", "", "1+", d.flatten, d.parseFlattenAttributes], ["Floor", "", "6+", k.floor], ["FusedConv", "com.microsoft", "1+", l.conv, l.parseConvAttributes], ["Gather", "", "1+", h.gather, h.parseGatherAttributes], ["Gemm", "", "7-10", g.gemm, g.parseGemmAttributesV7], ["Gemm", "", "11+", g.gemm, g.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", v.globalAveragePool, v.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", v.globalMaxPool], ["Greater", "", "7+", s.greater], ["Identity", "", "1+", k.identity], ["ImageScaler", "", "1+", b.imageScaler, b.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", m.instanceNormalization, m.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", k.leakyRelu, k.parseLeakyReluAttributes], ["Less", "", "7+", s.less], ["Log", "", "6+", k.log], ["MatMul", "", "1+", y.matMul, y.parseMatMulAttributes], ["MaxPool", "", "1+", v.maxPool, v.parseMaxPoolAttributes], ["Mul", "", "7+", s.mul], ["Neg", "", "6+", k.neg], ["Not", "", "1+", k.not], ["Or", "", "7+", s.or], ["Pad", "", "2-10", _.padV2, _.parsePadAttributesV2], ["Pad", "", "11+", _.padV11, _.parsePadAttributesV11], ["Pow", "", "7+", s.pow], ["PRelu", "", "7+", s.pRelu], ["ReduceLogSum", "", "1+", w.reduceLogSum, w.parseReduceAttributes], ["ReduceMax", "", "1+", w.reduceMax, w.parseReduceAttributes], ["ReduceMean", "", "1+", w.reduceMean, w.parseReduceAttributes], ["ReduceMin", "", "1+", w.reduceMin, w.parseReduceAttributes], ["ReduceProd", "", "1+", w.reduceProd, w.parseReduceAttributes], ["ReduceSum", "", "1-12", w.reduceSum, w.parseReduceAttributes], ["ReduceSumSquare", "", "1+", w.reduceLogSumSquare, w.parseReduceAttributes], ["Relu", "", "6+", k.relu], ["Reshape", "", "5+", x.reshape], ["Resize", "", "10", T.resize, T.parseResizeAttributesV10], ["Resize", "", "11+", T.resize, T.parseResizeAttributesV11], ["Shape", "", "1+", S.shape], ["Sigmoid", "", "6+", k.sigmoid], ["Sin", "", "7+", k.sin], ["Slice", "", "10+", O.sliceV10], ["Slice", "", "1-9", O.slice, O.parseSliceAttributes], ["Softmax", "", "1-12", A.softmax, A.parseSoftmaxAttributes], ["Softmax", "", "13+", A.softmaxV13, A.parseSoftmaxAttributesV13], ["Split", "", "2-12", E.split, E.parseSplitAttributes], ["Sqrt", "", "6+", k.sqrt], ["Squeeze", "", "1-12", I.squeeze, I.parseSqueezeAttributes], ["Squeeze", "", "13+", I.squeezeV13], ["Sub", "", "7+", s.sub], ["Sum", "", "6+", P.sum], ["Tan", "", "7+", k.tan], ["Tanh", "", "6+", k.tanh], ["Tile", "", "6+", D.tile], ["Transpose", "", "1+", $.transpose, $.parseTransposeAttributes], ["Upsample", "", "7-8", F.upsample, F.parseUpsampleAttributesV7], ["Upsample", "", "9", F.upsample, F.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", C.unsqueeze, C.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", C.unsqueezeV13], ["Xor", "", "7+", s.xor]];
        }, 2898: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseBatchNormalizationAttributes = e.batchNormalization = void 0;
          const r = n(246), i = n(5060), o = n(2039), a = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] };
          e.batchNormalization = (t2, e2, n2) => (u(e2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(t2, e2, n2) }), e2)]), e.parseBatchNormalizationAttributes = (t2) => {
            const e2 = t2.attributes.getFloat("epsilon", 1e-5), n2 = t2.attributes.getFloat("momentum", 0.9), i2 = t2.attributes.getInt("spatial", 1);
            return (0, r.createAttributeWithCacheKey)({ epsilon: e2, momentum: n2, spatial: i2 });
          };
          const s = (t2, e2, n2) => {
            const r2 = (0, i.getGlsl)(t2.session.backend.glContext.version), s2 = e2[0].dims.length, [u2, c] = t2.calculateTextureWidthAndHeight(e2[1].dims, o.TextureType.unpacked), l = `
  float process(int[${s2}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u2}, ${c});
    float scale = getColorAsFloat(${r2.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r2.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r2.texture2D}(Variance, position));
    float b = getColorAsFloat(${r2.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n2.epsilon})) ) + b;
  }`;
            return Object.assign(Object.assign({}, a), { output: { dims: e2[0].dims, type: e2[0].type, textureType: o.TextureType.unpacked }, shaderSource: l });
          }, u = (t2) => {
            if (!t2 || 5 !== t2.length)
              throw new Error("BatchNormalization requires 5 inputs.");
            const e2 = t2[0], n2 = t2[1], r2 = t2[2], i2 = t2[3], o2 = t2[4];
            if (e2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length || 1 !== i2.dims.length || 1 !== o2.dims.length)
              throw new Error("invalid input shape.");
            if (n2.dims[0] !== e2.dims[1] || r2.dims[0] !== e2.dims[1] || i2.dims[0] !== e2.dims[1] || o2.dims[0] !== e2.dims[1])
              throw new Error("invalid input shape.");
            if ("float32" !== e2.type && "float64" !== e2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type || "float32" !== i2.type && "float64" !== i2.type || "float32" !== o2.type && "float64" !== o2.type)
              throw new Error("invalid input tensor types.");
          };
        }, 7839: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.xor = e.sub = e.pRelu = e.pow = e.or = e.mul = e.less = e.greater = e.equal = e.div = e.and = e.add = e.glslPRelu = e.glslPow = e.glslXor = e.glslOr = e.glslAnd = e.glslLess = e.glslGreater = e.glslEqual = e.glslSub = e.glslMul = e.glslDiv = e.glslAdd = void 0;
          const r = n(2517), i = n(8520), o = n(5060), a = n(2039);
          function s() {
            const t2 = "add_";
            return { body: `
  float ${t2}(float a, float b) {
    return a + b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function u() {
            const t2 = "div_";
            return { body: `
  float ${t2}(float a, float b) {
    return a / b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function c() {
            const t2 = "mul_";
            return { body: `
  float ${t2}(float a, float b) {
    return a * b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function l() {
            const t2 = "sub_";
            return { body: `
  float ${t2}(float a, float b) {
    return a - b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function p() {
            const t2 = "equal_";
            return { body: `
  float ${t2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function f() {
            const t2 = "greater_";
            return { body: `
  float ${t2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function d() {
            const t2 = "less_";
            return { body: `
  float ${t2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function h() {
            const t2 = "and_";
            return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function g() {
            const t2 = "or_";
            return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function b() {
            const t2 = "xor_";
            return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function m() {
            return function(t2) {
              const e2 = `${t2}_`;
              return { body: `
  float ${e2}(float a, float b) {
    return ${t2}(a, b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return ${t2}(v1, v2);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
            }("pow");
          }
          function y() {
            const t2 = "prelu_";
            return { body: `
  float ${t2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          e.glslAdd = s, e.glslDiv = u, e.glslMul = c, e.glslSub = l, e.glslEqual = p, e.glslGreater = f, e.glslLess = d, e.glslAnd = h, e.glslOr = g, e.glslXor = b, e.glslPow = m, e.glslPRelu = y;
          const _ = (t2, e2, n2, r2 = e2[0].type, i2) => {
            const o2 = t2.session.pack ? a.TextureType.packed : a.TextureType.unpacked;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [o2, o2], cacheHint: i2, get: () => v(t2, e2, n2, r2) };
          }, v = (t2, e2, n2, i2 = e2[0].type) => {
            const s2 = t2.session.pack ? a.TextureType.packed : a.TextureType.unpacked, u2 = !r.ShapeUtil.areEqual(e2[0].dims, e2[1].dims);
            let c2 = e2[0].dims;
            const l2 = t2.session.pack;
            if (u2) {
              const a2 = r.BroadcastUtil.calcShape(e2[0].dims, e2[1].dims, false);
              if (!a2)
                throw new Error("Can't perform binary op on the given tensors");
              c2 = a2;
              const u3 = c2.length, p3 = 0 !== e2[0].dims.length ? e2[0].dims.length : 1, f3 = 0 !== e2[1].dims.length ? e2[1].dims.length : 1, d2 = 0 !== e2[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h2 = 0 !== e2[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g2 = (0, o.getGlsl)(t2.session.backend.glContext.version), b2 = l2 ? `
      ${n2.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n2.name}(a, b);
        ${g2.output} = result;
      }` : `
      ${n2.body}
      float process(int indices[${u3}]) {
        int aindices[${p3}];
        int bindices[${f3}];
        ${d2}
        ${h2}
        return ${n2.name}(_A(aindices), _B(bindices));
      }`;
              return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: c2, type: i2, textureType: s2 }, shaderSource: b2, hasMain: l2 };
            }
            const p2 = (0, o.getGlsl)(t2.session.backend.glContext.version), f2 = `
    ${n2.body}
    void main() {
      vec4 v1 = ${p2.texture2D}(A, TexCoords);
      vec4 v2 = ${p2.texture2D}(B, TexCoords);
      vec4 result = ${n2.name}(v1, v2);
      ${p2.output} = result;
    }
    `;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: e2[0].dims, type: i2, textureType: s2 }, shaderSource: f2, hasMain: true };
          };
          e.add = (t2, e2) => [t2.run(_(t2, e2, s()), e2)], e.and = (t2, e2) => [t2.run(_(t2, e2, h(), "bool"), e2)], e.div = (t2, e2) => [t2.run(_(t2, e2, u()), e2)], e.equal = (t2, e2) => [t2.run(_(t2, e2, p(), "bool"), e2)], e.greater = (t2, e2) => [t2.run(_(t2, e2, f(), "bool"), e2)], e.less = (t2, e2) => [t2.run(_(t2, e2, d(), "bool"), e2)], e.mul = (t2, e2) => [t2.run(_(t2, e2, c()), e2)], e.or = (t2, e2) => [t2.run(_(t2, e2, g(), "bool"), e2)], e.pow = (t2, e2) => [t2.run(_(t2, e2, m()), e2)], e.pRelu = (t2, e2) => [t2.run(_(t2, e2, y()), e2)], e.sub = (t2, e2) => [t2.run(_(t2, e2, l()), e2)], e.xor = (t2, e2) => [t2.run(_(t2, e2, b(), "bool"), e2)];
        }, 4196: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseCastAttributes = e.cast = void 0;
          const r = n(2517);
          e.cast = (t2, e2, n2) => (i(e2), [t2.cast(e2[0], n2)]), e.parseCastAttributes = (t2) => r.ProtoUtil.tensorDataTypeFromProto(t2.attributes.getInt("to"));
          const i = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Cast requires 1 input.");
            if ("string" === t2[0].type)
              throw new Error("Invalid input type.");
          };
        }, 1163: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createPackedConcatProgramInfoLoader = void 0;
          const r = n(5060), i = n(2039), o = n(9390), a = n(2827);
          e.createPackedConcatProgramInfoLoader = (t2, e2, n2) => {
            const u = (c = e2.length, l = n2.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: c }, (t3, e3) => `X${e3}`), inputTypes: Array(c).fill(i.TextureType.packed), cacheHint: l });
            var c, l;
            return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, u2) => {
              const c2 = n3[0].dims.slice();
              if (u2 >= c2.length || u2 < -1 * c2.length)
                throw new Error("axis specified for concat doesn't match input dimensionality");
              u2 < 0 && (u2 = c2.length + u2);
              const l2 = c2.slice(0);
              for (let t4 = 1; t4 < n3.length; t4++) {
                const e4 = n3[t4].dims.slice();
                for (let t5 = 0; t5 < c2.length; t5++)
                  if (t5 === u2)
                    l2[u2] += e4[t5];
                  else if (c2[t5] !== e4[t5])
                    throw new Error("non concat dimensions must match");
              }
              const p = l2.length, f = (0, a.getChannels)("coords", p), d = (0, o.getCoordsDataType)(p), h = (0, a.unpackFromChannel)(), g = n3.map((t4) => t4.dims), b = (0, o.getGlChannels)(p), m = new Array(g.length - 1);
              m[0] = g[0][u2];
              for (let t4 = 1; t4 < m.length; t4++)
                m[t4] = m[t4 - 1] + g[t4][u2];
              const y = b[u2], _ = b.slice(-2), v = b.join();
              let w = `if (${y} < ${m[0]}) {
        return getChannel(
            getX0(${v}), vec2(${_.join()}));
        }`;
              for (let t4 = 1; t4 < m.length; t4++) {
                const e4 = m[t4 - 1];
                w += `
            if (${y} < ${m[t4]}  && ${y} >= ${m[t4 - 1]}) {
              return getChannel(
                getX${t4}(${s(b, y, e4)}),
                vec2(${s(_, y, e4)}));
            }`;
              }
              const x = m.length, T = m[m.length - 1];
              w += `
            return getChannel(
              getX${x}(${s(b, y, T)}),
              vec2(${s(_, y, T)}));`;
              const S = (0, r.getGlsl)(t3.session.backend.glContext.version), O = `
          ${h}
          float getValue(${b.map((t4) => "int " + t4)}) {
            ${w}
          }

          void main() {
            ${d} coords = getOutputCoords();
            int lastDim = coords.${b[p - 1]};
            coords.${b[p - 1]} = coords.${b[p - 2]};
            coords.${b[p - 2]} = lastDim;

            vec4 result = vec4(getValue(${f}), 0., 0., 0.);

            ${f[p - 1]} = ${f[p - 1]} + 1;
            if (${f[p - 1]} < ${l2[p - 1]}) {
              result.g = getValue(${f});
            }

            ${f[p - 2]} = ${f[p - 2]} + 1;
            if (${f[p - 2]} < ${l2[p - 2]}) {
              result.a = getValue(${f});
            }

            ${f[p - 1]} = ${f[p - 1]} - 1;
            if (${f[p - 2]} < ${l2[p - 2]} &&
                ${f[p - 1]} < ${l2[p - 1]}) {
              result.b = getValue(${f});
            }
            ${S.output} = result;
          }
        `;
              return Object.assign(Object.assign({}, e3), { output: { dims: l2, type: n3[0].type, textureType: i.TextureType.packed }, shaderSource: O, hasMain: true });
            })(t2, u, e2, n2.axis) });
          };
          const s = (t2, e2, n2) => {
            const r2 = t2.indexOf(e2);
            return t2.map((t3, e3) => e3 === r2 ? `${t3} - ${n2}` : t3).join();
          };
        }, 2069: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseConcatAttributes = e.concat = void 0;
          const r = n(246), i = n(2039), o = n(1163);
          e.concat = (t2, e2, n2) => (p(e2), t2.session.pack && e2[0].dims.length > 1 ? [t2.run((0, o.createPackedConcatProgramInfoLoader)(t2, e2, n2), e2)] : [t2.run(a(t2, e2, n2), e2)]);
          const a = (t2, e2, n2) => {
            const r2 = (o2 = e2.length, a2 = n2.cacheKey, { name: "Concat", inputNames: Array.from({ length: o2 }, (t3, e3) => `X${e3}`), inputTypes: Array(o2).fill(i.TextureType.unpacked), cacheHint: a2 });
            var o2, a2;
            return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
              const o3 = n3[0].dims.slice();
              if (r3 >= o3.length || r3 < -1 * o3.length)
                throw new Error("axis specified for concat doesn't match input dimensionality");
              r3 < 0 && (r3 = o3.length + r3);
              const a3 = o3.slice(0);
              for (let t4 = 1; t4 < n3.length; t4++) {
                const e4 = n3[t4].dims.slice();
                for (let t5 = 0; t5 < o3.length; t5++)
                  if (t5 === r3)
                    a3[r3] += e4[t5];
                  else if (o3[t5] !== e4[t5])
                    throw new Error("non concat dimensions must match");
              }
              const p2 = a3.length, f = new Array(n3.length);
              let d = 0;
              for (let t4 = 0; t4 < f.length; ++t4)
                d += n3[t4].dims[r3], f[t4] = d;
              let h = "";
              h = n3.length < 5 ? s(f) : u(f);
              const g = `
        ${c(n3.length, p2)}
        ${l(f)}
        ${h}
        float process(int indices[${p2}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r3}]);

          if(textureIndex != 0) {
            indices[${r3}] = indices[${r3}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: a3, type: n3[0].type, textureType: i.TextureType.unpacked }, shaderSource: g });
            })(0, r2, e2, n2.axis) });
          }, s = (t2) => `int getTextureWhereDataResides(int index) {
      ${t2.map((t3, e2) => `if(index<${t3}) {return ${e2};}
`).join("")}
    }`, u = (t2) => s(t2), c = (t2, e2) => {
            const n2 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e2}]) {`];
            for (let e3 = 0; e3 < t2; ++e3)
              0 === e3 ? n2.push(`	if (textureIndex == ${e3}) { return _X${e3}(indices); }`) : e3 === t2 - 1 ? n2.push(`	else { return _X${e3}(indices); }`) : n2.push(`	else if (textureIndex == ${e3}) { return _X${e3}(indices); }`);
            return n2.push("	}"), n2.join("\n");
          }, l = (t2) => {
            const e2 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
            for (let n2 = 0; n2 < t2.length; ++n2)
              0 === n2 ? e2.push(`	if (index == ${n2}) { return ${t2[n2]}; }`) : n2 === t2.length - 1 ? e2.push(`	else { return ${t2[n2]}; }`) : e2.push(`	else if (index == ${n2}) { return ${t2[n2]}; }`);
            return e2.push("	}"), e2.join("\n");
          };
          e.parseConcatAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis") });
          const p = (t2) => {
            if (!t2 || t2.length < 1)
              throw new Error("too few inputs");
            const e2 = t2[0].type, n2 = t2[0].dims.length;
            if ("string" === e2)
              throw new Error("string tensor is not supported yet");
            for (const r2 of t2) {
              if (r2.type !== e2)
                throw new Error("input tensors should be one type");
              if (r2.dims.length !== n2)
                throw new Error("input tensors should have the same shape");
            }
          };
        }, 4770: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createUnpackedGroupedConvProgramInfoLoader = void 0;
          const r = n(6231), i = n(5060), o = n(2039), a = n(8138), s = n(2823);
          e.createUnpackedGroupedConvProgramInfoLoader = (t2, e2, n2) => {
            const u = (c = e2.length > 2, l = n2.cacheKey, { name: "GroupedConv", inputNames: c ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: c ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: l });
            var c, l;
            return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, u2) => {
              const c2 = e3.length > 2 ? "value += getBias(output_channel);" : "", l2 = e3[0].dims.slice(), p = e3[1].dims.slice(), f = p[0] / u2.group;
              r.Logger.verbose("GroupedConv", `autpPad:${u2.autoPad}, dilations:${u2.dilations}, group:${u2.group}, kernelShape:${u2.kernelShape}, pads:${u2.pads}, strides:${u2.strides}`);
              const d = (0, a.calculateOutputShape)(l2, p, u2.dilations, u2.pads, u2.strides), h = (0, i.getGlsl)(t3.session.backend.glContext.version), { activationFunction: g, applyActivation: b } = (0, s.getActivationSnippet)(u2), m = `
  const ivec2 strides = ivec2(${u2.strides[0]}, ${u2.strides[1]});
  const ivec2 pads = ivec2(${u2.pads[0]}, ${u2.pads[1]});
  ${g}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${f};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {
      int input_channel = group_id * ${p[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${u2.dilations[0]};

        if (xHeight < 0 || xHeight >= ${l2[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${u2.dilations[1]};
          if (xWidth < 0 || xWidth >= ${l2[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${c2}
    ${b}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;
              return Object.assign(Object.assign({}, n3), { output: { dims: d, type: e3[0].type, textureType: o.TextureType.unpacked }, shaderSource: m, hasMain: true });
            })(t2, e2, u, n2) });
          };
        }, 1386: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.conv2DPacked = e.conv2DPackedPointwise = void 0;
          const r = n(8138), i = n(8555), o = n(708);
          e.conv2DPackedPointwise = (t2, e2, n2) => {
            const i2 = e2[0].dims, a = e2[1].dims, s = (0, r.calculateOutputShape)(i2, a, n2.dilations, n2.pads, n2.strides), u = t2.reshapePacked(e2[0], [i2[1], i2[2] * i2[3]]), c = t2.reshapePacked(e2[1], [a[0], a[1]]), l = e2.length > 2 ? [c, u, e2[2]] : [c, u], p = t2.run((0, o.createPackedMatmulProgramInfoLoader)(t2, l, n2), l);
            return t2.reshapePacked(p, s);
          }, e.conv2DPacked = (t2, e2, n2) => {
            const a = e2[0].dims, s = e2[1].dims, u = (0, r.calculateOutputShape)(a, s, n2.dilations, n2.pads, n2.strides), c = t2.run((0, i.createPackedIm2ColProgramInfoLoader)(t2, e2[0], e2[1], u, n2), [e2[0]]), l = t2.reshapePacked(e2[1], [s[0], s[1] * s[2] * s[3]]), p = 3 === e2.length ? [l, c, e2[2]] : [l, c], f = t2.run((0, o.createPackedMatmulProgramInfoLoader)(t2, p, n2), p);
            return t2.reshapePacked(f, u);
          };
        }, 9663: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseConvTransposeAttributes = e.convTranspose = void 0;
          const r = n(246), i = n(5060), o = n(2039), a = n(2823), s = (t2, e2, n2, r2, i2, o2) => (t2 - 1) * e2 + n2 + (r2 - 1) * i2 + 1 - o2, u = (t2, e2, n2, r2, i2) => {
            const o2 = Math.floor(t2 / 2);
            "SAME_UPPER" === e2 ? (n2[r2] = o2, n2[i2] = t2 - o2) : "SAME_LOWER" === e2 && (n2[r2] = t2 - o2, n2[i2] = o2);
          };
          e.convTranspose = (t2, e2, n2) => (f(e2, n2), c(t2, e2, n2));
          const c = (t2, e2, n2) => {
            const r2 = p(n2, e2);
            return [l(t2, e2, r2)];
          }, l = (t2, e2, n2) => t2.run(((t3, e3, n3) => {
            const r2 = (s2 = e3.length > 2, u2 = n3.cacheKey, { name: "ConvTranspose", inputNames: s2 ? ["X", "W", "B"] : ["X", "W"], inputTypes: s2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: u2 });
            var s2, u2;
            return Object.assign(Object.assign({}, r2), { get: () => ((t4, e4, n4, r3) => {
              const s3 = e4.length > 2 ? "getB(output_channel)" : "0.0", u3 = e4[0].dims, c2 = e4[1].dims, l2 = c2[1], p2 = c2[0] / r3.group, f2 = [e4[0].dims[0], e4[1].dims[1] * r3.group, ...r3.outputShape], d = (0, i.getGlsl)(t4.session.backend.glContext.version), { activationFunction: h, applyActivation: g } = (0, a.getActivationSnippet)(r3), b = `
  const ivec2 strides = ivec2(${r3.strides[0]}, ${r3.strides[1]});
  const ivec2 pads = ivec2(${r3.pads[0]}, ${r3.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${l2};
    int wOutChannel = output_channel - group_id * ${l2};

    float value = ${s3};
    for (int inChannelOffset = 0; inChannelOffset < ${p2}; inChannelOffset++) {
      int input_channel = group_id * ${p2} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${c2[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${c2[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r3.dilations[0]}, wHOff * ${r3.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u3[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u3[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g}
    ${d.output} = vec4(value, .0, .0, .0);
  }
`;
              return Object.assign(Object.assign({}, n4), { output: { dims: f2, type: e4[0].type, textureType: o.TextureType.unpacked }, shaderSource: b, hasMain: true });
            })(t3, e3, r2, n3) });
          })(t2, e2, n2), e2), p = (t2, e2) => {
            const n2 = t2.kernelShape.slice();
            if (0 === t2.kernelShape.length)
              for (let t3 = 2; t3 < e2[1].dims.length; ++t3)
                n2.push(e2[1].dims[t3]);
            const r2 = t2.pads.slice(), i2 = t2.outputShape.slice();
            ((t3, e3, n3, r3, i3, o3, a2, c2) => {
              const l2 = t3.length - 2, p2 = 0 === c2.length;
              for (let f2 = 0; f2 < l2; ++f2) {
                const d = p2 ? t3[f2 + 2] * o3[f2] : c2[f2], h = s(t3[f2 + 2], o3[f2], i3[f2], e3[f2], n3[f2], d);
                u(h, r3, i3, f2, f2 + l2), p2 && c2.push(o3[f2] * (t3[f2 + 2] - 1) + a2[f2] + (e3[f2] - 1) * n3[f2] + 1 - i3[f2] - i3[f2 + l2]);
              }
            })(e2[0].dims, n2, t2.dilations, t2.autoPad, r2, t2.strides, t2.outputPadding, i2);
            const o2 = Object.assign({}, t2);
            return Object.assign(o2, { kernelShape: n2, pads: r2, outputShape: i2, cacheKey: t2.cacheKey }), o2;
          };
          e.parseConvTransposeAttributes = (t2) => {
            const e2 = t2.attributes, n2 = (0, a.parseInternalActivationAttributes)(e2), i2 = e2.getString("auto_pad", "NOTSET"), o2 = e2.getInts("dilations", [1, 1]), s2 = e2.getInt("group", 1), u2 = e2.getInts("kernel_shape", []), c2 = e2.getInts("output_padding", [0, 0]), l2 = e2.getInts("output_shape", []), p2 = e2.getInts("pads", [0, 0, 0, 0]), f2 = e2.getInts("strides", [1, 1]);
            return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: s2, kernelShape: u2, outputPadding: c2, outputShape: l2, pads: p2, strides: f2 }, n2));
          };
          const f = (t2, e2) => {
            if (!t2 || 2 !== t2.length && 3 !== t2.length)
              throw new Error("Conv requires 2 or 3 inputs");
            if (4 !== t2[0].dims.length || 4 !== t2[1].dims.length)
              throw new Error("currently only support 2-dimensional conv");
            if (t2[0].dims[1] !== t2[1].dims[0])
              throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            const n2 = t2[1].dims[1] * e2.group;
            if (3 === t2.length && (1 !== t2[2].dims.length || t2[2].dims[0] !== n2))
              throw new Error("invalid bias");
            const r2 = t2[0].dims.length - 2;
            if (e2.dilations.length !== r2)
              throw new Error(`dilations should be ${r2}D`);
            if (e2.strides.length !== r2)
              throw new Error(`strides should be ${r2}D`);
            if (e2.pads.length !== 2 * r2)
              throw new Error(`pads should be ${2 * r2}D`);
            if (e2.outputPadding.length !== r2)
              throw new Error(`output_padding should be ${r2}D`);
            if (0 !== e2.kernelShape.length && e2.kernelShape.length !== t2[1].dims.length - 2)
              throw new Error("invalid kernel shape");
            if (0 !== e2.outputShape.length && e2.outputShape.length !== t2[0].dims.length - 2)
              throw new Error("invalid output shape");
            if ("float32" !== t2[0].type || "float32" !== t2[1].type)
              throw new Error("ConvTranspose input(X,W) should be float tensor");
            if (3 === t2.length && "float32" !== t2[2].type)
              throw new Error("ConvTranspose input(bias) should be float tensor");
          };
        }, 8138: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseConvAttributes = e.conv = e.calculateOutputShape = void 0;
          const r = n(246), i = n(2517), o = n(4770), a = n(1386), s = n(9828), u = n(2823), c = n(3248), l = n(5623);
          e.calculateOutputShape = (t2, e2, n2, r2, i2) => {
            const o2 = t2[0], a2 = t2.slice(2), s2 = a2.length, u2 = e2[0], c2 = e2.slice(2).map((t3, e3) => t3 + (t3 - 1) * (n2[e3] - 1)), l2 = a2.map((t3, e3) => t3 + r2[e3] + r2[e3 + s2]).map((t3, e3) => Math.floor((t3 - c2[e3] + i2[e3]) / i2[e3]));
            return [o2, u2].concat(...l2);
          }, e.conv = (t2, e2, n2) => (g(e2, n2), p(t2, e2, n2));
          const p = (t2, e2, n2) => {
            const r2 = h(n2, e2), i2 = t2.session.pack, s2 = 1 === r2.kernelShape[0] && 1 === r2.kernelShape[1];
            return r2.group > 1 ? [t2.run((0, o.createUnpackedGroupedConvProgramInfoLoader)(t2, e2, r2), e2)] : s2 && i2 ? [f(t2, e2, r2)] : i2 && 4 === e2[0].dims.length && 1 === e2[0].dims[0] && !s2 ? [(0, a.conv2DPacked)(t2, e2, r2)] : [d(t2, e2, r2)];
          }, f = (t2, n2, r2) => {
            const i2 = n2[0].dims, o2 = n2[1].dims, a2 = (0, e.calculateOutputShape)(i2, o2, r2.dilations, r2.pads, r2.strides), s2 = t2.reshapeUnpacked(n2[0], [i2[1], i2[2] * i2[3]]), u2 = t2.reshapeUnpacked(n2[1], [o2[0], o2[1]]), c2 = n2.length > 2 ? [u2, s2, n2[2]] : [u2, s2], p2 = t2.run((0, l.createMatmulProgramInfoLoader)(c2, r2), c2);
            return t2.reshapeUnpacked(p2, a2);
          }, d = (t2, n2, r2) => {
            const i2 = n2[0].dims, o2 = n2[1].dims, a2 = (0, e.calculateOutputShape)(i2, o2, r2.dilations, r2.pads, r2.strides), u2 = t2.run((0, c.createIm2ColProgramInfoLoader)(t2, n2[0], n2[1], a2, r2), [n2[0]]), l2 = 3 === n2.length ? [u2, n2[1], n2[2]] : [u2, n2[1]];
            return t2.run((0, s.createDotProductProgramInfoLoader)(t2, n2, a2, r2), l2);
          }, h = (t2, e2) => {
            const n2 = t2.kernelShape.slice();
            if (0 === t2.kernelShape.length)
              for (let t3 = 2; t3 < e2[1].dims.length; ++t3)
                n2.push(e2[1].dims[t3]);
            const r2 = t2.pads.slice();
            i.PoolConvUtil.adjustPadsBasedOnAutoPad(e2[0].dims, t2.strides, t2.dilations, n2, r2, t2.autoPad);
            const o2 = Object.assign({}, t2);
            return Object.assign(o2, { kernelShape: n2, pads: r2, cacheKey: t2.cacheKey }), o2;
          };
          e.parseConvAttributes = (t2) => {
            const e2 = t2.attributes, n2 = (0, u.parseInternalActivationAttributes)(e2), i2 = e2.getString("auto_pad", "NOTSET"), o2 = e2.getInts("dilations", [1, 1]), a2 = e2.getInt("group", 1), s2 = e2.getInts("kernel_shape", []), c2 = e2.getInts("pads", [0, 0, 0, 0]), l2 = e2.getInts("strides", [1, 1]);
            return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: a2, kernelShape: s2, pads: c2, strides: l2 }, n2));
          };
          const g = (t2, e2) => {
            if (!t2 || 2 !== t2.length && 3 !== t2.length)
              throw new Error("Conv requires 2 or 3 inputs");
            if (4 !== t2[0].dims.length || 4 !== t2[1].dims.length)
              throw new Error("currently only support 2-dimensional conv");
            if (t2[0].dims[1] !== t2[1].dims[1] * e2.group)
              throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            if (3 === t2.length && (1 !== t2[2].dims.length || t2[1].dims[0] !== t2[2].dims[0]))
              throw new Error("invalid bias");
            const n2 = t2[0].dims.length - 2;
            if (e2.dilations.length !== n2)
              throw new Error(`dilations should be ${n2}D`);
            if (e2.strides.length !== n2)
              throw new Error(`strides should be ${n2}D`);
            if (e2.pads.length !== 2 * n2)
              throw new Error(`pads should be ${2 * n2}D`);
            if (0 !== e2.kernelShape.length && e2.kernelShape.length !== t2[1].dims.length - 2)
              throw new Error("invalid kernel shape");
            if ("float32" !== t2[0].type || "float32" !== t2[1].type)
              throw new Error("Conv input(X,W) should be float tensor");
            if (3 === t2.length && "float32" !== t2[2].type)
              throw new Error("Conv input(bias) should be float tensor");
          };
        }, 5193: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseDepthToSpaceAttributes = e.depthToSpace = void 0;
          const r = n(3738);
          e.depthToSpace = (t2, e2, n2) => {
            i(e2);
            const o = n2.blocksize, a = o * o, s = "DCR" === n2.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], u = "DCR" === n2.mode ? [e2[0].dims[0], o, o, e2[0].dims[1] / a, e2[0].dims[2], e2[0].dims[3]] : [e2[0].dims[0], e2[0].dims[1] / a, o, o, e2[0].dims[2], e2[0].dims[3]], c = t2.reshapeUnpacked(e2[0], u), l = { perm: s, cacheKey: `${s}` }, [p] = (0, r.transpose)(t2, [c], l), f = [e2[0].dims[0], e2[0].dims[1] / a, e2[0].dims[2] * o, e2[0].dims[3] * o];
            return [t2.reshapeUnpacked(p, f)];
          }, e.parseDepthToSpaceAttributes = (t2) => {
            const e2 = t2.attributes.getInt("blocksize");
            if (e2 < 1)
              throw new Error(`blocksize must be >= 1, but got : ${e2} for DepthToSpace`);
            const n2 = t2.attributes.getString("mode", "DCR");
            if ("DCR" !== n2 && "CRD" !== n2)
              throw new Error(`unrecognized mode: ${n2} for DepthToSpace`);
            return { mode: n2, blocksize: e2 };
          };
          const i = (t2) => {
            if (1 !== t2.length)
              throw new Error(`DepthToSpace expect 1 inputs, but got ${t2.length}`);
            if ("string" === t2[0].type || 4 !== t2[0].dims.length)
              throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
          };
        }, 9828: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createDotProductProgramInfoLoader = void 0;
          const r = n(2517), i = n(5060), o = n(2039), a = n(2823), s = n(3248);
          e.createDotProductProgramInfoLoader = (t2, e2, n2, u) => {
            const c = ((t3, e3) => ({ name: "ConvDotProduct", inputNames: t3 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: t3 ? [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.packedLastDimension], cacheKey: e3.activationCacheKey }))(e2.length > 2, u);
            return Object.assign(Object.assign({}, c), { get: () => ((t3, e3, n3, u2, c2) => {
              const l = n3[0].dims, p = n3[1].dims, f = [p[0], Math.ceil(l[1] * p[2] * p[3] / 4)], d = (0, s.calculateIm2ColDims)(l, p, u2), [h, g] = t3.calculateTextureWidthAndHeight(f, o.TextureType.packedLastDimension), b = r.ShapeUtil.computeStrides(d), [m, y] = t3.calculateTextureWidthAndHeight(d, o.TextureType.packedLastDimension), _ = u2.length, v = n3.length < 3 ? "0.0" : "_B(b)", w = Math.ceil(l[1] * p[2] * p[3] / 4), { activationFunction: x, applyActivation: T } = (0, a.getActivationSnippet)(c2), S = (0, i.getGlsl)(t3.session.backend.glContext.version), O = `
${x}
float process(int indices[${_}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};
  int kernelOffset = indices[1] * ${f[1]};
  float value = ${v};
  for (int i = 0; i < ${w}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${T}
  return value;
}`;
              return Object.assign(Object.assign({}, e3), { output: { dims: u2, type: n3[0].type, textureType: o.TextureType.unpacked }, shaderSource: O });
            })(t2, c, e2, n2, u) });
          };
        }, 7992: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseFlattenAttributes = e.flatten = void 0;
          const r = n(2517);
          e.flatten = (t2, e2, n2) => {
            i(e2, n2);
            const o = r.ShapeUtil.flattenShape(e2[0].dims, n2);
            return [t2.reshapeUnpacked(e2[0], o)];
          }, e.parseFlattenAttributes = (t2) => t2.attributes.getInt("axis", 1);
          const i = (t2, e2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Flatten requires 1 input.");
            const n2 = t2[0].dims.length;
            if (0 === n2)
              throw new Error("scalar tensor is not supported.");
            if (e2 < -n2 || e2 > n2)
              throw new Error("Invalid axis");
            if ("string" === t2[0].type)
              throw new Error("string tensor is not supported.");
          };
        }, 2823: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseInternalActivationAttributes = e.getActivationSnippet = void 0;
          const r = n(2517), i = n(4909);
          e.getActivationSnippet = function(t2) {
            let e2;
            switch (t2.activation) {
              case "Relu":
                e2 = (0, i.glslRelu)();
                break;
              case "Sigmoid":
                e2 = (0, i.glslSigmoid)();
                break;
              case "Clip":
                e2 = (0, i.glslClip)(t2.clipMin, t2.clipMax);
                break;
              default:
                return { activationFunction: "", applyActivation: "" };
            }
            const n2 = e2.name;
            return { activationFunction: e2.body, applyActivation: `value = ${n2}_(value);` };
          }, e.parseInternalActivationAttributes = (t2) => {
            const e2 = t2.getString("activation", "");
            if ("Clip" === e2) {
              const [n2, i2] = t2.getFloats("activation_params", [r.MIN_CLIP, r.MAX_CLIP]);
              return { activation: e2, clipMax: i2, clipMin: n2, activationCacheKey: `${e2}:${n2},${i2}` };
            }
            return { activation: e2, activationCacheKey: e2 };
          };
        }, 1253: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseGatherAttributes = e.gather = void 0;
          const r = n(246), i = n(782), o = n(2517), a = n(2039);
          e.gather = (t2, e2, n2) => (c(e2, n2.axis), [t2.run(u(t2, e2, n2), e2)]), e.parseGatherAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", 0) });
          const s = { name: "Gather", inputNames: ["A", "B"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, u = (t2, e2, n2) => {
            const r2 = Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey });
            return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
              const i2 = n3[0].dims.slice(), s2 = n3[1].dims.slice(), u2 = new Array(i2.length + s2.length - 1);
              r3 = o.ShapeUtil.normalizeAxis(r3, i2.length);
              const c2 = [];
              for (let t4 = 0; t4 < u2.length; t4++)
                t4 < r3 ? (u2[t4] = i2[t4], c2.push(`inputIdx[${t4}] = outputIdx[${t4}];`)) : t4 < r3 + s2.length ? (u2[t4] = s2[t4 - r3], c2.push(`indexDataIdx[${t4 - r3}] = outputIdx[${t4}];`)) : (u2[t4] = i2[t4 - s2.length + 1], c2.push(`inputIdx[${t4 - s2.length + 1}] = outputIdx[${t4}];`));
              const l = `
      float process(int outputIdx[${u2.length || 1}]) {
        int inputIdx[${i2.length}];
        int indexDataIdx[${s2.length || 1}];
        indexDataIdx[0] = 0;
        ${c2.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r3}] = idx < 0 ? idx + ${i2[r3]} : idx;
        return _A(inputIdx);
      }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: u2, type: n3[0].type, textureType: a.TextureType.unpacked }, shaderSource: l });
            })(0, r2, e2, n2.axis) });
          }, c = (t2, e2) => {
            if (!t2 || 2 !== t2.length)
              throw new Error("Gather requires 2 inputs.");
            const n2 = t2[0].dims.length;
            if (n2 < 1)
              throw new Error("Invalid input shape.");
            if (e2 < -n2 || e2 > n2 - 1)
              throw new Error("Invalid axis.");
            if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type))
              throw new Error("Invaid input type.");
            if ("int32" !== t2[1].type && "int16" !== t2[1].type)
              throw new Error("Invaid input type.");
          };
        }, 4776: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseGemmAttributesV11 = e.parseGemmAttributesV7 = e.gemm = void 0;
          const r = n(246), i = n(2517), o = n(2039);
          e.gemm = (t2, e2, n2) => (c(e2, n2), [t2.run(s(e2, n2), e2)]);
          const a = (t2, e2) => {
            const n2 = 0 !== t2.attributes.getInt("transA", 0), i2 = 0 !== t2.attributes.getInt("transB", 0), o2 = t2.attributes.getFloat("alpha", 1), a2 = t2.attributes.getFloat("beta", 1);
            return (0, r.createAttributeWithCacheKey)({ transA: n2, transB: i2, alpha: o2, beta: a2, isOptionalC: e2 });
          };
          e.parseGemmAttributesV7 = (t2) => a(t2, false), e.parseGemmAttributesV11 = (t2) => a(t2, true);
          const s = (t2, e2) => {
            const n2 = { name: "Gemm", inputNames: 3 === t2.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === t2.length ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], key: e2.cacheKey };
            return Object.assign(Object.assign({}, n2), { get: () => u(n2, t2, e2) });
          }, u = (t2, e2, n2) => {
            const r2 = e2[0].dims.slice(), a2 = e2[1].dims.slice(), [s2, u2] = i.GemmUtil.getShapeOfGemmResult(r2, n2.transA, a2, n2.transB, 3 === e2.length ? e2[2].dims : void 0), c2 = [s2, u2];
            if (!c2)
              throw new Error("Can't use gemm on the given tensors");
            let l = r2[r2.length - 1], p = "";
            n2.transA && (l = r2[0]), n2.transA && n2.transB ? p = "value += _A_T(a) * _B_T(b);" : n2.transA && !n2.transB ? p = "value += _A_T(a) * _B(b);" : !n2.transA && n2.transB ? p = "value += _A(a) * _B_T(b);" : n2.transA || n2.transB || (p = "value += _A(a) * _B(b);");
            const f = c2.length, d = `
      float process(int indices[${f}]) {
          int a[${f}];
          int b[${f}];
          ${3 === e2.length ? `int c[${e2[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === e2.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${l}; ++k) {
              a[${f - 1}] = k;
              b[${f - 2}] = k;
              ${p}
          }

          value = value * alpha;
          ${3 === e2.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
            return Object.assign(Object.assign({}, t2), { output: { dims: c2, type: e2[0].type, textureType: o.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n2.alpha }, { name: "beta", type: "float", data: n2.beta }], shaderSource: d });
          }, c = (t2, e2) => {
            if (!t2)
              throw new Error("Input is missing");
            if (e2.isOptionalC && (t2.length < 2 || t2.length > 3))
              throw new Error("Invaid input shape.");
            if (!e2.isOptionalC && 3 !== t2.length)
              throw new Error("Gemm requires 3 inputs");
            if (3 === t2.length && 1 !== t2[2].dims.length && 2 !== t2[2].dims.length)
              throw new Error("Invalid input shape of C");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type || "float32" !== t2[1].type && "float64" !== t2[1].type || 3 === t2.length && "float32" !== t2[2].type && "float64" !== t2[2].type)
              throw new Error("Invalid input type.");
            if (t2[0].type !== t2[1].type || 3 === t2.length && t2[0].type !== t2[2].type)
              throw new Error("Input types are mismatched");
          };
        }, 8555: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createPackedIm2ColProgramInfoLoader = void 0;
          const r = n(5060), i = n(2039), o = n(2827);
          e.createPackedIm2ColProgramInfoLoader = (t2, e2, n2, a, s) => {
            const u = (c = s.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [i.TextureType.packed], cacheHint: c });
            var c;
            return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, a2, s2, u2) => {
              const c2 = n3.dims, l = a2.dims, p = s2.length, f = [l[1] * l[2] * l[3], s2[2] * s2[3]], d = l[2] * l[3], h = (0, o.unpackFromChannel)(), g = (0, r.getGlsl)(t3.session.backend.glContext.version);
              let b = "";
              for (let t4 = 0; t4 <= 1; t4++)
                for (let e4 = 0; e4 <= 1; e4++)
                  b += `
            blockIndex = rc.x + ${e4};
            pos = rc.y + ${t4};

            if(blockIndex < ${f[1]} && pos < ${f[0]}) {
              offsetY = int(blockIndex / (${s2[p - 1]})) * ${u2.strides[0]} -
                ${u2.pads[0]};
              d0 = offsetY + ${u2.dilations[0]} * (imod(pos, ${d}) / ${l[2]});

              if(d0 < ${c2[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${s2[p - 1]}) * ${u2.strides[1]} -
                  ${u2.pads[1]};
                d1 = offsetX + ${u2.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});

                if(d1 < ${c2[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * t4 + e4}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
              const m = `
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b}
          ${g.output} = result;
      }
            `;
              return Object.assign(Object.assign({}, e3), { output: { dims: f, type: n3.type, textureType: i.TextureType.packed }, shaderSource: m, hasMain: true });
            })(t2, u, e2, n2, a, s) });
          };
        }, 3248: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.calculateIm2ColDims = e.createIm2ColProgramInfoLoader = void 0;
          const r = n(2039);
          e.createIm2ColProgramInfoLoader = (t2, n2, i, o, a) => {
            const s = (u = a.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r.TextureType.unpacked], cacheHint: u });
            var u;
            return Object.assign(Object.assign({}, s), { get: () => ((t3, n3, i2, o2, a2, s2) => {
              const u2 = i2.dims, c = o2.dims, l = a2.length, p = (0, e.calculateIm2ColDims)(u2, c, a2, 4), f = `
        const int XC = ${u2[1]};
        const int XH = ${u2[2]};
        const int XW = ${u2[3]};
        const int KH = ${s2.kernelShape[0]};
        const int KW = ${s2.kernelShape[1]};
        const int dilationH = ${s2.dilations[0]};
        const int dilationW = ${s2.dilations[1]};
        const int strideH = ${s2.strides[0]};
        const int strideW = ${s2.strides[1]};
        const int padH = ${s2.pads[0]};
        const int padW = ${s2.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${l}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u2.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
              return Object.assign(Object.assign({}, n3), { output: { dims: p, type: i2.type, textureType: r.TextureType.packedLastDimension }, shaderSource: f });
            })(0, s, n2, i, o, a) });
          }, e.calculateIm2ColDims = (t2, e2, n2, r2 = 4) => [n2[0], n2[2], n2[3], Math.ceil(t2[1] * e2[2] * e2[3] / r2)];
        }, 6572: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseImageScalerAttributes = e.imageScaler = void 0;
          const r = n(246), i = n(2039);
          e.imageScaler = (t2, e2, n2) => (u(e2), [t2.run(a(t2, e2, n2), e2)]), e.parseImageScalerAttributes = (t2) => {
            const e2 = t2.attributes.getFloat("scale"), n2 = t2.attributes.getFloats("bias");
            return (0, r.createAttributeWithCacheKey)({ scale: e2, bias: n2 });
          };
          const o = { name: "ImageScaler", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (t2, e2, n2) => {
            const r2 = Object.assign(Object.assign({}, o), { cacheHint: n2.cacheKey });
            return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
              const o2 = n3[0].dims.slice(), a2 = o2.length, u2 = `
      ${s(r3.bias.length)}
      float process(int indices[${a2}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: o2, type: n3[0].type, textureType: i.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r3.bias.length, data: r3.bias }, { name: "scale", type: "float", data: r3.scale }], shaderSource: u2 });
            })(0, r2, e2, n2) });
          }, s = (t2) => {
            const e2 = [`float getBias(float bias[${t2}], int channel) {`];
            for (let n2 = 0; n2 < t2; ++n2)
              0 === n2 ? e2.push(`	if (channel == ${n2}) { return bias[${n2}]; }`) : n2 === t2 - 1 ? e2.push(`	else { return bias[${n2}]; }`) : e2.push(`	else if (channel == ${n2}) { return bias[${n2}]; }`);
            return e2.push("	}"), e2.join("\n");
          }, u = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("ImageScaler requires 1 input.");
            if (4 !== t2[0].dims.length)
              throw new Error("Invalid input shape.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type)
              throw new Error("Invalid input type.");
          };
        }, 3346: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseInstanceNormalizationAttributes = e.instanceNormalization = void 0;
          const r = n(5060), i = n(2039);
          e.instanceNormalization = (t2, e2, n2) => {
            c(e2);
            const r2 = t2.run(a(e2[0]), e2);
            return [t2.run(u(t2, e2[0], n2, r2.dims), [e2[0], r2, e2[1], e2[2]])];
          }, e.parseInstanceNormalizationAttributes = (t2) => t2.attributes.getFloat("epsilon", 1e-5);
          const o = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (t2) => Object.assign(Object.assign({}, o), { get: () => ((t3, e2) => {
            const n2 = e2.dims.slice(), r2 = n2[1], o2 = n2[2] * n2[3], a2 = [n2[0], r2], s2 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o2});
        temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o2});

        return v;
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: a2, type: e2.type, textureType: i.TextureType.packedLastDimension }, shaderSource: s2 });
          })(o, t2) }), s = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked, i.TextureType.unpacked] }, u = (t2, e2, n2, o2) => {
            const a2 = Object.assign(Object.assign({}, s), { cacheHint: `${n2}` });
            return Object.assign(Object.assign({}, a2), { get: () => ((t3, e3, n3, o3, a3) => {
              const s2 = (0, r.getGlsl)(t3.session.backend.glContext.version), [u2, c2] = t3.calculateTextureWidthAndHeight(a3, i.TextureType.packedLastDimension), [l, p] = [u2 / 4, c2], f = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${l}, ${p});
        return ${s2.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: n3.dims, type: n3.type, textureType: i.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: o3 }], shaderSource: f });
            })(t2, a2, e2, n2, o2) });
          }, c = (t2) => {
            if (!t2 || 3 !== t2.length)
              throw new Error("InstanceNormalization requires 3 inputs.");
            const e2 = t2[0], n2 = t2[1], r2 = t2[2];
            if (e2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length)
              throw new Error("Invalid input shape.");
            if (n2.dims[0] !== e2.dims[1] || r2.dims[0] !== e2.dims[1])
              throw new Error("Input shapes are mismatched.");
            if ("float32" !== e2.type && "float64" !== e2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type)
              throw new Error("Invalid input type.");
            if (4 !== t2[0].dims.length)
              throw new Error("Only support 4-D input shape.");
          };
        }, 708: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createPackedMatmulProgramInfoLoader = void 0;
          const r = n(2517), i = n(5060), o = n(2039), a = n(9390), s = n(2823), u = n(5623);
          e.createPackedMatmulProgramInfoLoader = (t2, e2, n2) => {
            const c = (l = e2.length > 2, p = n2.activationCacheKey, { name: "MatMul (packed)", inputNames: l ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: l ? [o.TextureType.packed, o.TextureType.packed, o.TextureType.packed] : [o.TextureType.packed, o.TextureType.packed], cacheHint: p });
            var l, p;
            return Object.assign(Object.assign({}, c), { get: () => ((t3, e3, n3, c2) => {
              const l2 = n3.length > 2, p2 = l2 ? "value += getBiasForMatmul();" : "", f = n3[0].dims, d = n3[1].dims, h = r.BroadcastUtil.calcShape(f, d, true), g = !r.ShapeUtil.areEqual(n3[0].dims, n3[1].dims);
              if (!h)
                throw new Error("Can't use matmul on the given tensors");
              const b = f[f.length - 1], m = Math.ceil(b / 2), y = f.length, _ = d.length, v = (0, i.getGlsl)(t3.session.backend.glContext.version), w = (0, a.getCoordsDataType)(h.length), x = h.length, T = (0, a.getGlChannels)(), { activationFunction: S, applyActivation: O } = (0, s.getActivationSnippet)(c2), A = l2 ? `${(0, u.getBiasForMatmul)(w, T, n3[2].dims, h, true)}` : "", E = g ? `${function(t4, e4, n4, i2) {
                let o2 = [], a2 = [];
                const s2 = n4[0].dims, u2 = n4[1].dims, c3 = s2.length, l3 = u2.length, p3 = i2.length, f2 = p3 - c3, d2 = p3 - l3;
                o2 = s2.map((t5, n5) => `coords.${e4[n5 + f2]}`), o2[c3 - 1] = "i*2", o2.join(", "), a2 = u2.map((t5, n5) => `coords.${e4[n5 + d2]}`), a2[l3 - 2] = "i*2", a2.join(", ");
                const h2 = r.BroadcastUtil.getBroadcastDims(s2, i2), g2 = r.BroadcastUtil.getBroadcastDims(u2, i2), b2 = h2.map((t5) => `coords.${e4[t5 + f2]} = 0;`).join("\n"), m2 = g2.map((t5) => `coords.${e4[t5 + d2]} = 0;`).join("\n"), y2 = `int lastDim = coords.${e4[p3 - 1]};
  coords.${e4[p3 - 1]} = coords.${e4[p3 - 2]};
  coords.${e4[p3 - 2]} = lastDim;`;
                return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${t4} coords = getOutputCoords();
  ${y2}
  ${b2}
  vec4 outputValue = getA(${o2});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${t4} coords = getOutputCoords();
  ${y2}
  ${m2}
  vec4 outputValue = getB(${a2});
  return outputValue;
}`;
              }(w, T, n3, h)}` : "", I = g ? "getAAtOutCoordsMatmul(i)" : `getA(${function(t4, e4) {
                let n4 = "";
                for (let r2 = 0; r2 < e4 - 2; r2++)
                  n4 += `rc.${t4[r2]}, `;
                return n4 += `rc.${t4[e4 - 2]}, i*2`, n4;
              }(T, y)})`, P = g ? "getBAtOutCoordsMatmul(i)" : `getB(${function(t4, e4) {
                let n4 = "";
                for (let r2 = 0; r2 < e4 - 2; r2++)
                  n4 += `rc.${t4[r2]}, `;
                return n4 += `i*2, rc.${t4[e4 - 1]}`, n4;
              }(T, _)})`, D = `
            ${E}
            ${A}
            ${S}
            void main() {
              ${g ? "" : `${w} rc =
          getOutputCoords(); int lastDim = rc.${T[x - 1]}; rc.${T[x - 1]} =
          rc.${T[x - 2]}; rc.${T[x - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${m}; i++) {
                vec4 a = ${I};
                vec4 b = ${P};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p2}
              ${O}
              ${v.output} = value;
            }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: h, type: n3[0].type, textureType: o.TextureType.packed }, shaderSource: D, hasMain: true });
            })(t2, c, e2, n2) });
          };
        }, 5623: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.getBiasForMatmul = e.createMatmulProgramInfoLoader = e.parseMatMulAttributes = e.matMul = void 0;
          const r = n(2517), i = n(2039), o = n(9390), a = n(2823), s = n(708);
          function u(t2, e2) {
            const n2 = (s2 = t2.length > 2, u2 = e2.activationCacheKey, { name: "MatMul", inputNames: s2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: s2 ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: u2 });
            var s2, u2;
            return Object.assign(Object.assign({}, n2), { get: () => function(t3, e3, n3) {
              const s3 = e3[0].dims, u3 = e3[1].dims, c2 = r.BroadcastUtil.calcShape(s3, u3, true);
              if (!c2)
                throw new Error("Can't use matmul on the given tensors");
              const p = (0, o.getCoordsDataType)(c2.length), f = (0, o.getGlChannels)(), { activationFunction: d, applyActivation: h } = (0, a.getActivationSnippet)(n3), g = e3.length > 2, b = g ? "value += getBiasForMatmul();" : "", m = g ? `${l(p, f, e3[2].dims, c2, false)}` : "", y = c2.length, _ = s3.length, v = u3.length, w = `
    ${d}
    ${m}
    float process(int indices[${y}]) {
        int a[${_}];
        int b[${v}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${s3[s3.length - 1]}; ++k) {
            a[${_ - 1}] = k;
            b[${v - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${b}
        ${h}
        return value;
    }`;
              return Object.assign(Object.assign({}, t3), { output: { dims: c2, type: e3[0].type, textureType: i.TextureType.unpacked }, shaderSource: w });
            }(n2, t2, e2) });
          }
          e.matMul = (t2, e2, n2) => (c(e2), t2.session.pack ? [t2.run((0, s.createPackedMatmulProgramInfoLoader)(t2, e2, n2), e2)] : [t2.run(u(e2, n2), e2)]), e.parseMatMulAttributes = (t2) => (0, a.parseInternalActivationAttributes)(t2.attributes), e.createMatmulProgramInfoLoader = u;
          const c = (t2) => {
            if (!t2 || 2 !== t2.length)
              throw new Error("MatMul requires 2 inputs.");
            if (t2[0].dims[t2[0].dims.length - 1] !== t2[1].dims[t2[1].dims.length - 2])
              throw new Error("shared dimension does not match.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type || "float32" !== t2[1].type && "float64" !== t2[1].type)
              throw new Error("inputs should be float type");
            if (t2[0].type !== t2[1].type)
              throw new Error("inputs types should match");
          };
          function l(t2, e2, n2, i2, o2) {
            let a2 = "";
            const s2 = n2.length, u2 = i2.length, c2 = u2 - s2;
            a2 = u2 < 2 && s2 > 0 ? "coords" : n2.map((t3, n3) => `coords.${e2[n3 + c2]}`).join(", ");
            const l2 = r.BroadcastUtil.getBroadcastDims(n2, i2).map((t3) => `coords.${e2[t3 + c2]} = 0;`).join("\n");
            let p = "vec4(outputValue.xx, outputValue.yy)";
            return 1 === r.ShapeUtil.size(n2) && (p = "vec4(outputValue.x)"), o2 ? `
vec4 getBiasForMatmul() {
  ${t2} coords = getOutputCoords();
  ${l2}
  vec4 outputValue = getBias(${a2});
  return ${p};
}` : `
float getBiasForMatmul() {
  ${t2} coords = getOutputCoords();
  ${l2}
  return getBias(coords.x);
}`;
          }
          e.getBiasForMatmul = l;
        }, 2403: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createPackProgramInfoLoader = void 0;
          const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = { name: "pack", inputNames: ["A"], inputTypes: [i.TextureType.unpackedReversed] };
          e.createPackProgramInfoLoader = (t2, e2) => Object.assign(Object.assign({}, s), { get: () => ((t3, e3) => {
            const n2 = (0, r.getGlsl)(t3.session.backend.glContext.version), u = e3.dims, c = u.length, l = e3.dims.length, p = (0, o.getCoordsDataType)(l), f = (0, a.getChannels)("rc", l), d = (h = l, g = f, b = u[u.length - 2], m = u[u.length - 1], 0 === h || 1 === h ? "" : `
    int r = ${g[h - 2]};
    int c = ${g[h - 1]};
    int rp1 = ${g[h - 2]} + 1;
    int cp1 = ${g[h - 1]} + 1;
    bool rEdge = rp1 >= ${m};
    bool cEdge = cp1 >= ${b};
    `);
            var h, g, b, m;
            let y;
            y = 0 === c ? [1, 1] : 1 === c ? [u[0], 1] : [u[l - 1], u[l - 2]];
            const _ = function(t4, e4, n3) {
              if (0 === t4)
                return "false";
              if (1 === t4)
                return `rc > ${e4[0]}`;
              let r2 = "";
              for (let i2 = t4 - 2; i2 < t4; i2++)
                r2 += `${n3[i2]} >= ${e4[i2 - t4 + 2]}`, i2 < t4 - 1 && (r2 += "||");
              return r2;
            }(l, y, f), v = function(t4, e4) {
              const n3 = t4.length;
              if (0 === n3)
                return "getA(), 0, 0, 0";
              if (1 === n3)
                return `getA(rc),
            rc + 1 >= ${t4[0]} ? 0. : getA(rc + 1),
            0, 0`;
              let r2 = "";
              if (n3 > 2)
                for (let t5 = 0; t5 < n3 - 2; ++t5)
                  r2 += `${e4[t5]},`;
              return `getA(${r2}r, c),
          rEdge ? 0. : getA(${r2}rp1, c),
          cEdge ? 0. : getA(${r2}r, cp1),
          rEdge || cEdge ? 0. : getA(${r2}rp1, cp1)`;
            }(u, f), w = `
        void main() {
          ${p} rc = getOutputCoords();

          if(${_}) {
            ${n2.output} = vec4(0);
          } else {
            ${d}

            ${n2.output} = vec4(${v});
          }
        }
      `;
            return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: e3.dims, type: e3.type, textureType: i.TextureType.packed }, shaderSource: w });
          })(t2, e2) });
        }, 2827: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.unpackFromChannel = e.getChannels = e.getVecChannels = void 0;
          const r = n(9390);
          function i(t2, e2) {
            return (0, r.getGlChannels)(e2).map((e3) => `${t2}.${e3}`);
          }
          e.getVecChannels = i, e.getChannels = function(t2, e2) {
            return 1 === e2 ? [t2] : i(t2, e2);
          }, e.unpackFromChannel = function() {
            return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
          };
        }, 2870: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parsePadAttributesV11 = e.padV11 = e.parsePadAttributesV2 = e.padV2 = void 0;
          const r = n(246), i = n(2517), o = n(5060), a = n(2039), s = { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
          e.padV2 = (t2, e2, n2) => (l(e2), [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => c(t2, e2[0], n2) }), e2)]), e.parsePadAttributesV2 = (t2) => {
            const e2 = t2.attributes.getString("mode", "constant"), n2 = t2.attributes.getFloat("value", 0), i2 = t2.attributes.getInts("pads");
            return (0, r.createAttributeWithCacheKey)({ mode: e2, value: n2, pads: i2 });
          }, e.padV11 = (t2, n2, r2) => {
            p(n2);
            const i2 = u(t2, n2, r2);
            return (0, e.padV2)(t2, [n2[0]], i2);
          }, e.parsePadAttributesV11 = (t2) => t2.attributes.getString("mode", "constant");
          const u = (t2, e2, n2) => {
            if (!t2.session.isInitializer(e2[1].dataId) || e2.length >= 3 && !t2.session.isInitializer(e2[2].dataId))
              throw new Error("dynamic pad attributes are not allowed");
            const i2 = Array.from(e2[1].integerData), o2 = e2.length >= 3 ? e2[2].floatData[0] : 0;
            return (0, r.createAttributeWithCacheKey)({ mode: n2, pads: i2, value: o2 });
          }, c = (t2, e2, n2) => {
            const r2 = i.ShapeUtil.padShape(e2.dims.slice(), n2.pads), o2 = r2.length, s2 = `
      ${f(t2, e2, n2)}
      float process(int[${o2}] indices) {
          return padA(indices);
      }`;
            return { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked], output: { dims: r2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: s2 };
          }, l = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Pad requires 1 input");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type)
              throw new Error("Invalid input type.");
          }, p = (t2) => {
            if (!t2 || 2 !== t2.length && 3 !== t2.length)
              throw new Error("Pad requires 2 or 3 inputs");
            if ("int32" !== t2[1].type)
              throw new Error("Invalid input type.");
            if (t2.length >= 3 && "string" === t2[2].type)
              throw new Error("Invalid input type.");
          }, f = (t2, e2, n2) => {
            const r2 = (0, o.getGlsl)(t2.session.backend.glContext.version), [s2, u2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), c2 = i.ShapeUtil.computeStrides(e2.dims);
            switch (n2.mode) {
              case "constant":
                return d(r2, e2.dims, c2, s2, u2, n2.pads, n2.value);
              case "reflect":
                return h(r2, e2.dims, c2, s2, u2, n2.pads);
              case "edge":
                return g(r2, e2.dims, c2, s2, u2, n2.pads);
              default:
                throw new Error("Invalid mode");
            }
          }, d = (t2, e2, n2, r2, i2, o2, a2) => {
            const s2 = e2.length;
            let u2 = "";
            for (let t3 = s2 - 1; t3 >= 0; --t3)
              u2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0)  return constant;
        if (k >= ${e2[t3]}) return constant;
        offset += k * ${n2[t3]};
        `;
            return `
      float padA(int m[${s2}]) {
        const float constant = float(${a2});
        int offset = 0;
        int k = 0;
        ${u2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
          }, h = (t2, e2, n2, r2, i2, o2) => {
            const a2 = e2.length;
            let s2 = "";
            for (let t3 = a2 - 1; t3 >= 0; --t3)
              s2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (e2[t3] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e2[t3]}) { k = _2n_1 - k; }
        }
        offset += k * ${n2[t3]};
        `;
            return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
          }, g = (t2, e2, n2, r2, i2, o2) => {
            const a2 = e2.length;
            let s2 = "";
            for (let t3 = a2 - 1; t3 >= 0; --t3)
              s2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0)  k = 0;
        if (k >= ${e2[t3]}) k = ${e2[t3] - 1};
        offset += k * ${n2[t3]};
      `;
            return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
          };
        }, 2143: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.globalMaxPool = e.parseMaxPoolAttributes = e.maxPool = e.parseGlobalAveragePoolAttributes = e.globalAveragePool = e.parseAveragePoolAttributes = e.averagePool = void 0;
          const r = n(246), i = n(2517), o = n(2039);
          e.averagePool = (t2, e2, n2) => {
            p(e2);
            const r2 = { name: "AveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n2.cacheKey };
            return [t2.run(Object.assign(Object.assign({}, r2), { get: () => a(e2, r2, false, n2) }), e2)];
          }, e.parseAveragePoolAttributes = (t2) => {
            const e2 = t2.attributes.getString("auto_pad", "NOTSET"), n2 = t2.attributes.getInt("ceil_mode", 0), i2 = 0 !== t2.attributes.getInt("count_include_pad", 0), o2 = t2.attributes.getInts("kernel_shape"), a2 = t2.attributes.getInts("strides", []), s2 = t2.attributes.getInts("pads", []);
            if (0 !== n2)
              throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
            return (0, r.createAttributeWithCacheKey)({ autoPad: e2, ceilMode: n2, countIncludePad: i2, kernelShape: o2, strides: a2, pads: s2 });
          };
          const a = (t2, e2, n2, r2) => {
            const [a2, s2] = u(t2, r2, n2), c2 = i.ShapeUtil.size(a2.kernelShape);
            let l2 = "";
            a2.countIncludePad ? l2 += `value /= float(${c2});` : l2 += `value /= float(${c2} - pad);`;
            const p2 = `
        ${f(t2[0].dims, a2, "value += _X(x);", l2, "0.0")}
      `;
            return Object.assign(Object.assign({}, e2), { output: { dims: s2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: p2 });
          };
          e.globalAveragePool = (t2, e2, n2) => {
            p(e2);
            const r2 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: `${n2.countIncludePad}` };
            return [t2.run(Object.assign(Object.assign({}, r2), { get: () => a(e2, r2, true, n2) }), e2)];
          }, e.parseGlobalAveragePoolAttributes = (t2) => {
            const e2 = 0 !== t2.attributes.getInt("count_include_pad", 0);
            return (0, r.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: e2, kernelShape: [], strides: [], pads: [] });
          }, e.maxPool = (t2, e2, n2) => {
            p(e2);
            const r2 = { name: "MaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n2.cacheKey };
            return [t2.run(Object.assign(Object.assign({}, r2), { get: () => s(e2, r2, false, n2) }), e2)];
          }, e.parseMaxPoolAttributes = (t2) => {
            const e2 = t2.attributes.getString("auto_pad", "NOTSET"), n2 = t2.attributes.getInt("ceil_mode", 0), i2 = t2.attributes.getInts("kernel_shape"), o2 = t2.attributes.getInts("strides", []), a2 = t2.attributes.getInts("pads", []), s2 = t2.attributes.getInt("storage_order", 0), u2 = t2.attributes.getInts("dilations", []);
            if (0 !== s2)
              throw new Error("column major storage order is not yet supported for MaxPool");
            if (0 !== n2)
              throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
            return (0, r.createAttributeWithCacheKey)({ autoPad: e2, ceilMode: n2, countIncludePad: false, kernelShape: i2, strides: o2, pads: a2, storageOrder: s2, dilations: u2 });
          };
          const s = (t2, e2, n2, r2) => {
            const [i2, a2] = u(t2, r2, n2), s2 = `
      ${f(t2[0].dims, i2, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
            return Object.assign(Object.assign({}, e2), { output: { dims: a2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: s2 });
          }, u = (t2, e2, n2) => {
            const r2 = t2[0].dims.slice(), o2 = Object.hasOwnProperty.call(e2, "dilations"), a2 = e2.kernelShape.slice(), s2 = e2.strides.slice(), u2 = o2 ? e2.dilations.slice() : [], c2 = e2.pads.slice();
            i.PoolConvUtil.adjustPoolAttributes(n2, r2, a2, s2, u2, c2);
            const l2 = i.PoolConvUtil.computePoolOutputShape(n2, r2, s2, u2, a2, c2, e2.autoPad), p2 = Object.assign({}, e2);
            return o2 ? Object.assign(p2, { kernelShape: a2, strides: s2, pads: c2, dilations: u2, cacheKey: e2.cacheKey }) : Object.assign(p2, { kernelShape: a2, strides: s2, pads: c2, cacheKey: e2.cacheKey }), [p2, l2];
          }, c = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, l = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
          e.globalMaxPool = (t2, e2) => (p(e2), [t2.run(Object.assign(Object.assign({}, l), { get: () => s(e2, l, true, c) }), e2)]);
          const p = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Pool ops requires 1 input.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type)
              throw new Error("Invalid input type.");
          }, f = (t2, e2, n2, r2, o2) => {
            const a2 = t2.length;
            if (e2.kernelShape.length <= 2) {
              const i2 = e2.kernelShape[e2.kernelShape.length - 1], s2 = e2.strides[e2.strides.length - 1], u2 = e2.pads[e2.pads.length / 2 - 1], c2 = e2.pads[e2.pads.length - 1], l2 = t2[a2 - 1];
              let p2 = "", f2 = "", d2 = "";
              if (p2 = u2 + c2 !== 0 ? `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            if (x[${a2} - 1] < 0 || x[${a2} - 1] >= ${l2}) {
              pad++;
              continue;
            }
            ${n2}
          }` : `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            ${n2}
          }`, 2 === e2.kernelShape.length) {
                const n3 = e2.kernelShape[e2.kernelShape.length - 2], r3 = e2.strides[e2.strides.length - 2], o3 = e2.pads[e2.pads.length / 2 - 2], s3 = e2.pads[e2.pads.length - 2], u3 = t2[a2 - 2];
                f2 = o3 + s3 !== 0 ? `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${o3} + j;
              if (x[${a2} - 2] < 0 || x[${a2} - 2] >= ${u3}) {
                pad+= ${i2};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${o3} + j;
            `, d2 = "\n          }\n        ";
              }
              return `
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);

          float value = ${o2};
          int pad = 0;
          ${f2}
          ${p2}
          ${d2}
          ${r2}
          return value;
        }
      `;
            }
            {
              const s2 = i.ShapeUtil.size(e2.kernelShape), u2 = i.ShapeUtil.computeStrides(e2.kernelShape), c2 = u2.length, l2 = e2.pads.length, p2 = h(c2), f2 = d(t2, "inputDims"), g = d(e2.pads, "pads"), b = d(u2, "kernelStrides"), m = d(e2.strides, "strides");
              let y = "";
              return y = e2.pads.reduce((t3, e3) => t3 + e3) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n2}
          }` : `
          }
          ${n2}
        `, `
        ${p2}
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);
          int offset[${c2}];
          int pads[${l2}];
          int inputDims[${a2}];
          int kernelStrides[${c2}];
          int strides[${c2}];
          ${g}
          ${f2}
          ${m}
          ${b}

          float value = ${o2};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s2}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a2} - ${c2}; j < ${a2}; j++) {
              x[j] = indices[j] * strides[j - ${a2} + ${c2}]
                + offset[j - ${a2} + ${c2}] - pads[j - 2];
              ${y}
          }
          ${r2}

          return value;
        }
      `;
            }
          }, d = (t2, e2) => {
            let n2 = "";
            for (let r2 = 0; r2 < t2.length; r2++)
              n2 += `
      ${e2}[${r2}] = ${t2[r2]};
    `;
            return n2;
          }, h = (t2) => `
  void offsetToIndices(int offset, int[${t2}] strides, out int[${t2}] indices) {
    if (${t2} == 0) {
      return;
    }
    for (int i = 0; i < ${t2} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${t2} - 1] = offset;
  }`;
        }, 4939: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.reduceLogSumSquare = e.reduceLogSum = e.reduceProd = e.reduceMin = e.reduceMax = e.reduceMean = e.reduceSum = e.parseReduceAttributes = void 0;
          const r = n(246), i = n(782), o = n(2517), a = n(2039), s = (t2, e2, n2, r2, i2) => {
            c(e2);
            const o2 = { name: r2, inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
            return [t2.run(Object.assign(Object.assign({}, o2), { cacheHint: n2.cacheKey, get: () => u(t2, e2, n2, r2, i2, o2) }), e2)];
          };
          e.parseReduceAttributes = (t2) => {
            const e2 = t2.attributes.getInts("axes", []), n2 = 1 === t2.attributes.getInt("keepdims", 1);
            return (0, r.createAttributeWithCacheKey)({ axes: e2, keepDims: n2 });
          };
          const u = (t2, e2, n2, r2, i2, s2) => {
            const u2 = [], c2 = e2[0].dims.length || 1, l = [], p = o.ShapeUtil.normalizeAxes(n2.axes, e2[0].dims.length), f = i2(e2, p);
            let d = f[1];
            for (let t3 = 0; t3 < e2[0].dims.length; t3++)
              p.indexOf(t3) >= 0 || 0 === p.length ? (n2.keepDims && u2.push(1), d = `
          for(int j${t3} = 0; j${t3} < ${e2[0].dims[t3]}; j${t3}++) {
            inputIdx[${t3}] = j${t3};
            ${d}
          }`) : (l.push(`inputIdx[${t3}] = outputIdx[${u2.length}];`), u2.push(e2[0].dims[t3]));
            const h = `
      float process(int outputIdx[${u2.length || 1}]) {
        float value;                 // final result
        int inputIdx[${c2}];      // addressing input data
        ${l.join("\n")}
        ${f[0]}       // init ops for reduce max/min
        ${d}
        ${f[2]}       // final computation for reduce mean
        return value;
      }`;
            return Object.assign(Object.assign({}, s2), { output: { dims: u2, type: e2[0].type, textureType: a.TextureType.unpacked }, shaderSource: h });
          }, c = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Reduce op requires 1 input.");
            if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type))
              throw new Error("Invalid input type.");
          };
          e.reduceSum = (t2, e2, n2) => s(t2, e2, n2, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), e.reduceMean = (t2, e2, n2) => s(t2, e2, n2, "ReduceMean", (t3, e3) => {
            let n3 = 1;
            for (let r2 = 0; r2 < t3[0].dims.length; r2++)
              (e3.indexOf(r2) >= 0 || 0 === e3.length) && (n3 *= t3[0].dims[r2]);
            return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n3}.;`];
          }), e.reduceMax = (t2, e2, n2) => s(t2, e2, n2, "ReduceMax", (t3, e3) => {
            const n3 = [];
            for (let r2 = 0; r2 < t3[0].dims.length; r2++)
              (e3.indexOf(r2) >= 0 || 0 === e3.length) && n3.push(`inputIdx[${r2}] = 0;`);
            return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
          }), e.reduceMin = (t2, e2, n2) => s(t2, e2, n2, "ReduceMin", (t3, e3) => {
            const n3 = [];
            for (let r2 = 0; r2 < t3[0].dims.length; r2++)
              (e3.indexOf(r2) >= 0 || 0 === e3.length) && n3.push(`inputIdx[${r2}] = 0;`);
            return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
          }), e.reduceProd = (t2, e2, n2) => s(t2, e2, n2, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), e.reduceLogSum = (t2, e2, n2) => s(t2, e2, n2, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), e.reduceLogSumSquare = (t2, e2, n2) => s(t2, e2, n2, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
        }, 7019: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.isReshapeCheap = e.processDims3D = e.createPackedReshape3DProgramInfoLoader = void 0;
          const r = n(2517), i = n(5060), o = n(2039), a = n(2827);
          e.createPackedReshape3DProgramInfoLoader = (t2, e2, n2) => {
            const s = ((t3) => ({ name: "Reshape (packed)", inputTypes: [o.TextureType.packed], inputNames: ["A"], cacheHint: `${t3}` }))(n2);
            return Object.assign(Object.assign({}, s), { get: () => ((t3, e3, n3, s2) => {
              const u = e3.dims, c = s2;
              let l = "";
              for (let t4 = 0; t4 < 4; t4++) {
                let e4 = "";
                switch (t4) {
                  case 0:
                    e4 = "outputCoords = rc;";
                    break;
                  case 1:
                    e4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                    break;
                  case 2:
                    e4 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                    break;
                  case 3:
                    e4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                    break;
                  default:
                    throw new Error();
                }
                l += `
        ${e4}
        ${t4 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${t4}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${t4 > 0 ? "}" : ""}
      `;
              }
              const p = (0, i.getGlsl)(t3.session.backend.glContext.version), f = `
      ${function(t4) {
                const e4 = r.ShapeUtil.computeStrides(t4), n4 = ["b", "r", "c"], i2 = "index";
                return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e4.map((t5, r2) => `int ${n4[r2]} = ${i2} / ${t5}; ${r2 === e4.length - 1 ? `int ${n4[r2 + 1]} = ${i2} - ${n4[r2]} * ${t5}` : `index -= ${n4[r2]} * ${t5}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
              }(u)}
      ${function(t4) {
                const e4 = r.ShapeUtil.computeStrides(t4);
                return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e4[0]} + coords.z * ${e4[1]} + coords.y;
  }
`;
              }(c)}
      ${(0, a.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c[2]};
        int cols = ${c[1]};

        ${l}
        ${p.output} = result;
      }
    `;
              return Object.assign(Object.assign({}, n3), { output: { dims: c, type: e3.type, textureType: o.TextureType.packed }, shaderSource: f, hasMain: true });
            })(t2, e2, s, n2) });
          }, e.processDims3D = function(t2) {
            if (0 === t2.length)
              return [1, 1, 1];
            let e2 = 1;
            for (let n2 = 0; n2 < t2.length - 2; ++n2)
              e2 *= t2[n2];
            return [e2, t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
          }, e.isReshapeCheap = function(t2, e2) {
            let n2 = false;
            return n2 = 0 === t2.length || 0 === e2.length || (t2.length < 2 || e2.length < 2 ? t2[t2.length - 1] === e2[e2.length - 1] : t2[t2.length - 1] === e2[e2.length - 1] && t2[t2.length - 2] === e2[e2.length - 2]), n2;
          };
        }, 718: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.reshape = void 0;
          const r = n(2517);
          e.reshape = (t2, e2) => {
            const n2 = r.ShapeUtil.calculateReshapedDims(e2[0].dims, e2[1].integerData);
            return t2.session.pack ? [t2.reshapePacked(e2[0], n2)] : [t2.reshapeUnpacked(e2[0], n2)];
          };
        }, 2268: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseResizeAttributesV11 = e.parseResizeAttributesV10 = e.resize = void 0;
          const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = n(9793), u = { name: "Resize", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
          e.resize = (t2, e2, n2) => ((0, s.validateInputs)(e2, n2), [t2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => c(t2, e2, n2) }), e2)]), e.parseResizeAttributesV10 = (t2) => (0, s.parseUpsampleAttributes)(t2, 10), e.parseResizeAttributesV11 = (t2) => (0, s.parseUpsampleAttributes)(t2, 11);
          const c = (t2, e2, n2) => {
            const s2 = (0, r.getGlsl)(t2.session.backend.glContext.version), [c2, p2] = l(e2, n2);
            if (c2.every((t3) => 1 === t3) && "tf_crop_and_resize" !== n2.coordinateTransformMode)
              return Object.assign(Object.assign({}, u), { output: { dims: p2, type: e2[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${s2.texture2D}(X, TexCoords);
                    ${s2.output} = v;
                }` });
            const f2 = p2.length;
            if (f2 < 2)
              throw new Error(`output dimension should be at least 2, but got ${f2}`);
            const d = p2[f2 - 2], h = p2[f2 - 1], g = e2[0].dims;
            if (f2 !== g.length)
              throw new Error(`output dimension should match input ${g.length}, but got ${f2}`);
            const b = g[f2 - 2], m = g[f2 - 1], y = c2[f2 - 2], _ = c2[f2 - 1];
            let v = "";
            if ("linear" !== n2.mode)
              throw new Error(`resize (packed) does not support mode: '${n2.mode}'`);
            switch (n2.coordinateTransformMode) {
              case "asymmetric":
                v = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
                break;
              case "half_pixel":
                v = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
                break;
              case "pytorch_half_pixel":
                v = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
                break;
              case "align_corners":
                v = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,
                            ${d}.0 - 1.0);
                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,
                            ${b}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
                break;
              default:
                throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n2.coordinateTransformMode}'`);
            }
            const w = (0, o.getCoordsDataType)(f2), x = `
            const vec2 inputWH = vec2(${b}.0, ${m}.0);
            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));
            ${(0, a.unpackFromChannel)()}
            ${v}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${w} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${d - 1};
                bool hasNextCol = rc.z < ${h - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s2.output} = vec4(newValue);
            }
        `;
            return Object.assign(Object.assign({}, u), { output: { dims: p2, type: e2[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: x });
          }, l = (t2, e2) => {
            const n2 = t2[0].dims;
            let r2, i2 = e2.scales;
            if (0 === i2.length) {
              const o3 = t2[e2.scalesInputIdx];
              if (o3 && 0 !== o3.size) {
                if (t2[e2.sizesInputIdx])
                  throw new Error("Only one of scales or sizes must be provided as input.");
                i2 = p(o3, e2.mode, e2.isResize);
              } else {
                const o4 = t2[e2.sizesInputIdx];
                if (!o4 || 0 === o4.size)
                  throw new Error("Either scales or sizes MUST be provided as input.");
                r2 = Array.from(o4.integerData), i2 = f(r2, n2, e2.mode, e2.isResize);
              }
            } else if (t2[e2.sizesInputIdx])
              throw new Error("Only one of scales or sizes must be provided as input.");
            const o2 = r2 || n2.map((t3, e3) => Math.floor(t3 * i2[e3]));
            return [i2, o2];
          }, p = (t2, e2, n2) => {
            const r2 = Array.from(t2.floatData);
            return (0, s.scalesValidation)(r2, e2, n2), r2;
          }, f = (t2, e2, n2, r2) => {
            const i2 = e2.length, o2 = new Array(i2);
            for (let n3 = 0, r3 = i2; n3 < r3; n3++)
              if (0 === e2[n3]) {
                if (0 !== t2[n3])
                  throw new Error("Input dim is zero but required output dim is non-zero.");
                o2[n3] = 1;
              } else
                o2[n3] = t2[n3] / e2[n3];
            return (0, s.scalesValidation)(o2, n2, r2), o2;
          };
        }, 8117: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.shape = void 0;
          const r = n(9162);
          e.shape = (t2, e2) => (i(e2), [new r.Tensor([e2[0].dims.length], "int32", void 0, void 0, new Int32Array(e2[0].dims))]);
          const i = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Shape requires 1 input.");
          };
        }, 2278: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.sliceV10 = e.parseSliceAttributes = e.slice = void 0;
          const r = n(246), i = n(782), o = n(2517), a = n(2039), s = { name: "Slice", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
          e.slice = (t2, e2, n2) => (c(e2), [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(t2, e2[0], n2) }), e2)]), e.parseSliceAttributes = (t2) => {
            const e2 = t2.attributes.getInts("starts"), n2 = t2.attributes.getInts("ends"), i2 = t2.attributes.getInts("axes", []);
            return (0, r.createAttributeWithCacheKey)({ starts: e2, ends: n2, axes: i2 });
          };
          const u = (t2, e2, n2) => {
            const r2 = 0 === n2.axes.length ? e2.dims.slice(0).map((t3, e3) => e3) : n2.axes, i2 = o.ShapeUtil.normalizeAxes(r2, e2.dims.length), u2 = n2.starts.map((t3, n3) => t3 > e2.dims[i2[n3]] - 1 ? e2.dims[i2[n3]] : o.ShapeUtil.normalizeAxis(t3, e2.dims[i2[n3]])), c2 = n2.ends.map((t3, n3) => t3 > e2.dims[i2[n3]] - 1 ? e2.dims[i2[n3]] : o.ShapeUtil.normalizeAxis(t3, e2.dims[i2[n3]])), l2 = e2.dims.slice(), p2 = [];
            for (let t3 = 0; t3 < i2.length; t3++)
              l2[i2[t3]] = c2[t3] - u2[t3], u2[t3] > 0 && p2.push(`outputIdx[${i2[t3]}] += ${u2[t3]};`);
            const f = `
      float process(int outputIdx[${l2.length}]) {
        ${p2.join("\n      ")}
        return _A(outputIdx);
      }`;
            return Object.assign(Object.assign({}, s), { output: { dims: l2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f });
          }, c = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Slice requires 1 input.");
            if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type))
              throw new Error("Invalid input type.");
          };
          e.sliceV10 = (t2, e2) => {
            p(e2);
            const n2 = l(t2, e2);
            return [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(t2, e2[0], n2) }), [e2[0]])];
          };
          const l = (t2, e2) => {
            if (!t2.session.isInitializer(e2[1].dataId) || !t2.session.isInitializer(e2[2].dataId) || e2.length >= 4 && !t2.session.isInitializer(e2[3].dataId) || e2.length >= 5 && !t2.session.isInitializer(e2[4].dataId))
              throw new Error("dynamic slice attributes are not allowed");
            if (e2.length >= 5 && e2[4].integerData.some((t3) => 1 !== t3))
              throw new Error("currently non-1 steps is not supported for Slice");
            const n2 = Array.from(e2[1].integerData), r2 = Array.from(e2[2].integerData), i2 = e2.length >= 4 ? Array.from(e2[3].integerData) : [];
            return { starts: n2, ends: r2, axes: i2, cacheKey: `${i2};${n2};${r2}` };
          }, p = (t2) => {
            if (!t2 || t2.length < 3 || t2.length > 5)
              throw new Error("Invalid input number.");
            if ("int32" !== t2[1].type || 1 !== t2[1].dims.length)
              throw new Error("Invalid input type.");
            if ("int32" !== t2[2].type || 1 !== t2[2].dims.length)
              throw new Error("Invalid input type.");
            if (t2.length >= 4 && ("int32" !== t2[3].type || 1 !== t2[3].dims.length))
              throw new Error("Invalid input type.");
            if (t2.length >= 5 && ("int32" !== t2[4].type || 1 !== t2[4].dims.length))
              throw new Error("Invalid input type.");
          };
        }, 5524: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.softmaxV13 = e.parseSoftmaxAttributesV13 = e.parseSoftmaxAttributes = e.softmax = void 0;
          const r = n(246), i = n(2517), o = n(5060), a = n(2039), s = n(3738), u = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] }, c = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, l = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked] };
          e.softmax = (t2, e2, n2) => {
            g(e2);
            const r2 = e2[0].dims.slice(), o2 = i.ShapeUtil.normalizeAxis(n2.axis, r2.length), a2 = i.ShapeUtil.sizeToDimension(r2, o2), s2 = i.ShapeUtil.sizeFromDimension(r2, o2);
            return p(t2, e2, n2, a2, s2);
          }, e.parseSoftmaxAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", 1) }), e.parseSoftmaxAttributesV13 = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", -1) }), e.softmaxV13 = (t2, e2, n2) => {
            g(e2);
            const o2 = e2[0].dims.slice(), a2 = i.ShapeUtil.normalizeAxis(n2.axis, o2.length), u2 = o2.length, c2 = a2 !== u2 - 1, l2 = [];
            let f2, d2 = [], h2 = [];
            c2 && (d2 = Array.from({ length: u2 }).map((t3, e3) => e3), d2[a2] = u2 - 1, d2[u2 - 1] = a2, d2.map((t3) => l2.push(o2[t3])), f2 = (0, r.createAttributeWithCacheKey)({ perm: d2 }), h2 = (0, s.transpose)(t2, e2, f2));
            const b = c2 ? i.ShapeUtil.sizeToDimension(l2, u2 - 1) : i.ShapeUtil.sizeToDimension(o2, u2 - 1), m = c2 ? i.ShapeUtil.sizeFromDimension(l2, u2 - 1) : i.ShapeUtil.sizeFromDimension(o2, u2 - 1), y = p(t2, c2 ? h2 : e2, n2, b, m);
            return c2 ? (0, s.transpose)(t2, y, f2) : y;
          };
          const p = (t2, e2, n2, r2, i2) => {
            const o2 = f(t2, e2[0], r2, i2, [r2]), a2 = t2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => o2 }), e2), s2 = d(t2, e2[0], r2, i2, o2.output.dims, [r2]), p2 = t2.run(Object.assign(Object.assign({}, c), { cacheHint: n2.cacheKey, get: () => s2 }), [e2[0], a2]), g2 = h(t2, e2[0], r2, i2, o2.output.dims, s2.output.dims);
            return [t2.run(Object.assign(Object.assign({}, l), { cacheHint: n2.cacheKey, get: () => g2 }), [e2[0], a2, p2])];
          }, f = (t2, e2, n2, r2, i2) => {
            const [s2, c2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), l2 = i2.length;
            if (n2 < 1 || r2 < 1)
              throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== i2.length)
              throw new Error("Dimensionality of the output should be 1");
            if (i2[0] !== n2)
              throw new Error("Shape of the output should be equal to logical row count");
            const p2 = (0, o.getGlsl)(t2.session.backend.glContext.version), f2 = `
      float process(int[${l2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float max = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s2},
        ${c2} )));
        for(int i=1; i<${r2}; ++i)
        {
          float current = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s2}, ${c2})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
            return Object.assign(Object.assign({}, u), { output: { dims: i2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f2 });
          }, d = (t2, e2, n2, r2, i2, s2) => {
            const [u2, l2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), p2 = s2.length;
            if (n2 < 1 || r2 < 1)
              throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== s2.length)
              throw new Error("Dimensionality of the output should be 1");
            if (s2[0] !== n2)
              throw new Error("Shape of the output should be equal to logical row count");
            if (1 !== i2.length)
              throw new Error("Dimensionality of the intermediate results should be 1");
            if (i2[0] !== n2)
              throw new Error("Shape of the intermediate results should be equal to logical row count");
            const f2 = `
      float process(int[${p2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r2}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, o.getGlsl)(t2.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u2}, ${l2}))) - max);
        }

        return norm_factor;
      }`;
            return Object.assign(Object.assign({}, c), { output: { dims: s2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f2 });
          }, h = (t2, e2, n2, r2, i2, o2) => {
            const [s2, u2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), c2 = e2.dims.length;
            if (n2 < 1 || r2 < 1)
              throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== i2.length || 1 !== o2.length)
              throw new Error("Dimensionality of the intermediate results should be 1");
            if (i2[0] !== n2 || o2[0] !== n2)
              throw new Error("Shape of the intermediate results should be equal to logical row count");
            const p2 = `
      float process(int[${c2}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s2}, ${u2});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r2};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
            return Object.assign(Object.assign({}, l), { output: { dims: e2.dims, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: p2 });
          }, g = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Softmax requires 1 input.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type)
              throw new Error("Invalid input type");
          };
        }, 5975: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseSplitAttributes = e.split = void 0;
          const r = n(246), i = n(2517), o = n(2039), a = { name: "Split", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
          e.split = (t2, e2, n2) => {
            c(e2);
            const r2 = i.ShapeUtil.normalizeAxis(n2.axis, e2[0].dims.length), o2 = s(t2, e2, r2, n2), l = [];
            for (let i2 = 0; i2 < o2; ++i2)
              l.push(t2.run(Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey};${i2}`, get: () => u(t2, e2[0], n2, r2, i2) }), e2));
            return l;
          }, e.parseSplitAttributes = (t2) => {
            const e2 = t2.attributes.getInt("axis", 0), n2 = t2.attributes.getInts("split", []), i2 = t2.outputs.length;
            return (0, r.createAttributeWithCacheKey)({ axis: e2, split: n2, numOutputs: i2 });
          };
          const s = (t2, e2, n2, r2) => {
            const [, o2] = i.SplitUtil.splitShape(e2[0].dims, n2, r2.split, r2.numOutputs);
            return o2.length;
          }, u = (t2, e2, n2, r2, s2) => {
            const [u2, c2] = i.SplitUtil.splitShape(e2.dims, r2, n2.split, n2.numOutputs), l = c2[s2], p = u2[s2], f = `
      float process(int indices[${p.length}]) {
        indices[${r2}] += ${l};
        return _A(indices);
      }
    `;
            return Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey}:${s2}`, output: { dims: p, type: e2.type, textureType: o.TextureType.unpacked }, shaderSource: f });
          }, c = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Split requires one input.");
            if ("int8" !== t2[0].type && "uint8" !== t2[0].type && "int16" !== t2[0].type && "uint16" !== t2[0].type && "int32" !== t2[0].type && "uint32" !== t2[0].type && "float32" !== t2[0].type && "float64" !== t2[0].type && "bool" !== t2[0].type)
              throw new Error("Invalid input type.");
          };
        }, 3933: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseSqueezeAttributes = e.squeezeV13 = e.squeeze = void 0;
          const r = n(2517);
          e.squeeze = (t2, e2, n2) => {
            i(e2);
            const o2 = r.ShapeUtil.squeezeShape(e2[0].dims, n2);
            return [t2.reshapeUnpacked(e2[0], o2)];
          }, e.squeezeV13 = (t2, n2) => (o(n2), (0, e.squeeze)(t2, [n2[0]], Array.from(n2[1].integerData))), e.parseSqueezeAttributes = (t2) => t2.attributes.getInts("axes");
          const i = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Squeeze requires 1 input.");
            if ("string" === t2[0].type)
              throw new Error("invalid input tensor types.");
          }, o = (t2) => {
            if (!t2 || 2 !== t2.length)
              throw new Error("Squeeze requires 2 inputs.");
            if ("int32" !== t2[1].type)
              throw new Error("Invalid input type.");
          };
        }, 6558: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.sum = void 0;
          const r = n(5060), i = n(2039);
          e.sum = (t2, e2) => {
            a(e2);
            const n2 = { name: "Sum", inputNames: e2.map((t3, e3) => `X${e3}`), inputTypes: new Array(e2.length).fill(i.TextureType.unpacked) };
            return [t2.run(Object.assign(Object.assign({}, n2), { get: () => o(t2, e2, n2) }), e2)];
          };
          const o = (t2, e2, n2) => {
            const o2 = (0, r.getGlsl)(t2.session.backend.glContext.version), a2 = e2[0].dims.slice(), s = `
      void main() {
        vec4 result = ${e2.map((t3, e3) => `${o2.texture2D}(X${e3},TexCoords)`).join(" + ")};
        ${o2.output} = result;
      }
    `;
            return Object.assign(Object.assign({}, n2), { output: { dims: a2, type: e2[0].type, textureType: i.TextureType.unpacked }, hasMain: true, shaderSource: s });
          }, a = (t2) => {
            if (!t2 || 0 === t2.length)
              throw new Error("Sum requires inputs.");
            const e2 = t2[0].dims.length;
            for (let n2 = 1; n2 < t2.length; n2++) {
              if (e2 !== t2[n2].dims.length)
                throw new Error("Input shapes are mismatched.");
              for (let r2 = 0; r2 < e2; r2++)
                if (t2[0].dims[r2] !== t2[n2].dims[r2])
                  throw new Error("Input shapes are not matched.");
            }
            if ("float32" !== t2[0].type && "float64" !== t2[0].type)
              throw new Error("Invalid input type.");
            for (let e3 = 1; e3 < t2.length; e3++)
              if (t2[0].type !== t2[e3].type)
                throw new Error("Input types are not matched.");
          };
        }, 5723: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.tile = void 0;
          const r = n(782), i = n(2039);
          e.tile = (t2, e2) => {
            a(e2);
            const n2 = { name: "Tile", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
            return [t2.run(Object.assign(Object.assign({}, n2), { get: () => o(t2, e2, n2) }), e2)];
          };
          const o = (t2, e2, n2) => {
            const r2 = e2[0].dims.slice(), o2 = new Array(r2.length), a2 = [];
            for (let t3 = 0; t3 < r2.length; t3++)
              o2[t3] = r2[t3] * e2[1].numberData[t3], a2.push(`inputIdx[${t3}] = int(mod(float(outputIdx[${t3}]), ${r2[t3]}.));`);
            const s = o2.length, u = `
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${a2.join("\n")}
        return _A(inputIdx);
      }
    `;
            return Object.assign(Object.assign({}, n2), { output: { dims: o2, type: e2[0].type, textureType: i.TextureType.unpacked }, shaderSource: u });
          }, a = (t2) => {
            if (!t2 || 2 !== t2.length)
              throw new Error("Tile requires 2 input.");
            if (1 !== t2[1].dims.length)
              throw new Error("The second input shape must 1 dimension.");
            if (t2[1].dims[0] !== t2[0].dims.length)
              throw new Error("Invalid input shape.");
            if (-1 === r.NUMBER_TYPES.indexOf(t2[0].type))
              throw new Error("Invalid input type.");
            if ("int32" !== t2[1].type && "int16" !== t2[1].type)
              throw new Error("Invalid repeat type.");
          };
        }, 3738: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseTransposeAttributes = e.transpose = void 0;
          const r = n(246), i = n(2517), o = n(2039), a = { name: "Transpose", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
          e.transpose = (t2, e2, n2) => (p(e2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(t2, e2[0], n2.perm) }), e2)]), e.parseTransposeAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ perm: t2.attributes.getInts("perm", []) });
          const s = (t2, e2, n2) => {
            const r2 = e2.dims;
            n2 = u(r2, n2);
            const i2 = c(r2, n2), s2 = r2.length, p2 = `
      ${l("perm", n2, s2)}
      float process(int indices[${s2}]) {
        int a[${s2}];
        perm(a, indices);
        return _A(a);
      }`;
            return Object.assign(Object.assign({}, a), { output: { dims: i2, type: e2.type, textureType: o.TextureType.unpacked }, shaderSource: p2 });
          }, u = (t2, e2) => (e2 && e2.length !== t2.length && (e2 = [...t2.keys()].reverse()), e2), c = (t2, e2) => (e2 = u(t2, e2), i.ShapeUtil.sortBasedOnPerm(t2, e2)), l = (t2, e2, n2) => {
            const r2 = [];
            r2.push(`void ${t2}(out int a[${n2}], int src[${n2}]) {`);
            for (let t3 = 0; t3 < n2; ++t3)
              r2.push(`	a[${e2[t3]}]=src[${t3}];`);
            return r2.push("	}"), r2.join("\n");
          }, p = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Transpose requires 1 input.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type)
              throw new Error("input should be float tensor");
          };
        }, 8710: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.encodeAsUint8 = void 0;
          const r = n(5060), i = n(2039);
          e.encodeAsUint8 = (t2, e2) => {
            const n2 = e2.shape, o = (0, r.getGlsl)(t2.session.backend.glContext.version), a = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o.texture2D}(X,TexCoords).r;
      ${o.output} = encodeAsUint8(value);
    }`, s = { name: "Uint8Encode", inputTypes: [i.TextureType.unpacked], inputNames: ["X"], output: { dims: n2, type: e2.tensor.type, textureType: i.TextureType.downloadUint8AsFloat }, shaderSource: a, hasMain: true };
            return t2.executeProgram(s, [e2.tensor]);
          };
        }, 4909: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.tanh = e.tan = e.sqrt = e.sin = e.sigmoid = e.relu = e.not = e.neg = e.log = e.parseLeakyReluAttributes = e.leakyRelu = e.identity = e.floor = e.exp = e.parseEluAttributes = e.elu = e.cos = e.ceil = e.clipV11 = e.parseClipAttributes = e.clip = e.atan = e.asin = e.acos = e.abs = e.glslTanh = e.glslTan = e.glslSqrt = e.glslSigmoid = e.glslRelu = e.glslSin = e.glslNot = e.glslNeg = e.glslLog = e.glslLeakyRelu = e.glslIdentity = e.glslClip = e.glslFloor = e.glslExp = e.glslElu = e.glslCos = e.glslCeil = e.glslAtan = e.glslAsin = e.glslAcos = e.glslAbs = void 0;
          const r = n(246), i = n(2517), o = n(8520), a = n(5060), s = n(2039);
          function u() {
            return P("abs");
          }
          function c() {
            return P("acos");
          }
          function l() {
            return P("asin");
          }
          function p() {
            return P("atan");
          }
          function f() {
            return P("ceil");
          }
          function d() {
            return P("cos");
          }
          function h(t2) {
            const e2 = "elu";
            return { body: `
  const float alpha = float(${t2});

  float ${e2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(${e2}_(v.x), ${e2}_(v.y), ${e2}_(v.z), ${e2}_(v.w));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
          }
          function g() {
            return P("exp");
          }
          function b() {
            return P("floor");
          }
          function m(t2, e2) {
            const n2 = "clip";
            return { body: `
  const float min = float(${t2});
  const float max = float(${e2});

  float ${n2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n2, type: o.FunctionType.ValueBased };
          }
          function y() {
            const t2 = "indentity";
            return { body: `
  float ${t2}_(float a) {
    return a;
  }
  vec4 ${t2}_(vec4 v) {
    return v;
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function _(t2) {
            const e2 = "leakyRelu";
            return { body: `
  const float alpha = float(${t2});

  float ${e2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(${e2}_(v.x), ${e2}_(v.y), ${e2}_(v.z), ${e2}_(v.w));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
          }
          function v() {
            return P("log");
          }
          function w() {
            const t2 = "neg";
            return { body: `
  float ${t2}_(float a) {
    return -a;
  }
  vec4 ${t2}_(vec4 v) {
    return -v;
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function x() {
            const t2 = "not";
            return { body: `
  float ${t2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${t2}_(bool a) {
    return !a;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${t2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function T() {
            return P("sin");
          }
          function S() {
            const t2 = "relu";
            return { body: `
  float ${t2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${t2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function O() {
            const t2 = "sigmoid";
            return { body: `
  float ${t2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${t2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function A() {
            return P("sqrt");
          }
          function E() {
            return P("tan");
          }
          function I() {
            const t2 = "tanh";
            return { body: `
  float ${t2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${t2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function P(t2) {
            return { body: `
  float ${t2}_(float a) {
    return ${t2}(a);
  }
  vec4 ${t2}_(vec4 v) {
    return ${t2}(v);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          e.glslAbs = u, e.glslAcos = c, e.glslAsin = l, e.glslAtan = p, e.glslCeil = f, e.glslCos = d, e.glslElu = h, e.glslExp = g, e.glslFloor = b, e.glslClip = m, e.glslIdentity = y, e.glslLeakyRelu = _, e.glslLog = v, e.glslNeg = w, e.glslNot = x, e.glslSin = T, e.glslRelu = S, e.glslSigmoid = O, e.glslSqrt = A, e.glslTan = E, e.glslTanh = I;
          const D = (t2, e2, n2, r2) => {
            const i2 = t2.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o2 = { name: n2.name, inputTypes: [i2], inputNames: ["A"], cacheHint: r2 };
            return Object.assign(Object.assign({}, o2), { get: () => ((t3, e3, n3, r3) => {
              const i3 = t3.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o3 = (0, a.getGlsl)(t3.session.backend.glContext.version);
              return Object.assign(Object.assign({}, e3), { output: { dims: n3.dims, type: n3.type, textureType: i3 }, shaderSource: `
     ${r3.body}
     void main() {
       vec4 v = ${o3.texture2D}(A, TexCoords);
       v = ${r3.name}_(v);
       ${o3.output} = v;
     }
     `, hasMain: true });
            })(t2, o2, e2, n2) });
          };
          e.abs = (t2, e2) => [t2.run(D(t2, e2[0], u()), e2)], e.acos = (t2, e2) => [t2.run(D(t2, e2[0], c()), e2)], e.asin = (t2, e2) => [t2.run(D(t2, e2[0], l()), e2)], e.atan = (t2, e2) => [t2.run(D(t2, e2[0], p()), e2)], e.clip = (t2, e2, n2) => [t2.run(D(t2, e2[0], m(n2.min, n2.max), n2.cacheKey), e2)], e.parseClipAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ min: t2.attributes.getFloat("min", i.MIN_CLIP), max: t2.attributes.getFloat("max", i.MAX_CLIP) }), e.clipV11 = (t2, n2) => {
            const r2 = $(t2, n2);
            return (0, e.clip)(t2, [n2[0]], r2);
          };
          const $ = (t2, e2) => {
            if (e2.length >= 3 && (!t2.session.isInitializer(e2[1].dataId) || !t2.session.isInitializer(e2[2].dataId)))
              throw new Error("dynamic clip attributes are not allowed");
            const n2 = e2.length >= 3 ? e2[1].numberData[0] : i.MIN_CLIP, o2 = e2.length >= 3 ? e2[2].numberData[0] : i.MAX_CLIP;
            return (0, r.createAttributeWithCacheKey)({ min: n2, max: o2 });
          };
          e.ceil = (t2, e2) => [t2.run(D(t2, e2[0], f()), e2)], e.cos = (t2, e2) => [t2.run(D(t2, e2[0], d()), e2)], e.elu = (t2, e2, n2) => [t2.run(D(t2, e2[0], h(n2.alpha), n2.cacheKey), e2)], e.parseEluAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ alpha: t2.attributes.getFloat("alpha", 1) }), e.exp = (t2, e2) => [t2.run(D(t2, e2[0], g()), e2)], e.floor = (t2, e2) => [t2.run(D(t2, e2[0], b()), e2)], e.identity = (t2, e2) => [t2.run(D(t2, e2[0], y()), e2)], e.leakyRelu = (t2, e2, n2) => [t2.run(D(t2, e2[0], _(n2.alpha), n2.cacheKey), e2)], e.parseLeakyReluAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ alpha: t2.attributes.getFloat("alpha", 0.01) }), e.log = (t2, e2) => [t2.run(D(t2, e2[0], v()), e2)], e.neg = (t2, e2) => [t2.run(D(t2, e2[0], w()), e2)], e.not = (t2, e2) => [t2.run(D(t2, e2[0], x()), e2)], e.relu = (t2, e2) => [t2.run(D(t2, e2[0], S()), e2)], e.sigmoid = (t2, e2) => [t2.run(D(t2, e2[0], O()), e2)], e.sin = (t2, e2) => [t2.run(D(t2, e2[0], T()), e2)], e.sqrt = (t2, e2) => [t2.run(D(t2, e2[0], A()), e2)], e.tan = (t2, e2) => [t2.run(D(t2, e2[0], E()), e2)], e.tanh = (t2, e2) => [t2.run(D(t2, e2[0], I()), e2)];
        }, 5611: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createUnpackProgramInfoLoader = e.createUnpackProgramInfo = void 0;
          const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = { name: "unpack", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
          e.createUnpackProgramInfo = (t2, e2) => {
            const n2 = e2.dims.length, u = (0, a.getChannels)("rc", n2), c = u.slice(-2), l = (0, o.getCoordsDataType)(n2), p = (0, a.unpackFromChannel)(), f = 0 === e2.dims.length ? "" : function(t3, e3) {
              if (1 === t3)
                return "rc";
              let n3 = "";
              for (let r2 = 0; r2 < t3; r2++)
                n3 += e3[r2], r2 < t3 - 1 && (n3 += ",");
              return n3;
            }(n2, u), d = n2 <= 1 ? "rc" : `vec2(${c.join(",")})`, h = `
    ${p}
    void main() {
      ${l} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${f});

       ${(0, r.getGlsl)(t2.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);
     }
   `;
            return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: e2.dims, type: e2.type, textureType: i.TextureType.unpacked }, shaderSource: h });
          }, e.createUnpackProgramInfoLoader = (t2, n2) => Object.assign(Object.assign({}, s), { get: () => (0, e.createUnpackProgramInfo)(t2, n2) });
        }, 8428: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.parseUnsqueezeAttributes = e.unsqueezeV13 = e.unsqueeze = void 0;
          const r = n(2517);
          e.unsqueeze = (t2, e2, n2) => {
            i(e2);
            const o2 = r.ShapeUtil.unsqueezeShape(e2[0].dims, n2);
            return [t2.reshapeUnpacked(e2[0], o2)];
          }, e.unsqueezeV13 = (t2, n2) => (o(n2), (0, e.unsqueeze)(t2, [n2[0]], Array.from(n2[1].integerData))), e.parseUnsqueezeAttributes = (t2) => t2.attributes.getInts("axes");
          const i = (t2) => {
            if (!t2 || 1 !== t2.length)
              throw new Error("Unsqueeze requires 1 input.");
            if ("string" === t2[0].type)
              throw new Error("invalid input tensor types.");
          }, o = (t2) => {
            if (!t2 || 2 !== t2.length)
              throw new Error("Unsqueeze requires 2 inputs.");
            if ("int32" !== t2[1].type)
              throw new Error("Invalid input type.");
          };
        }, 9793: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.scalesValidation = e.validateInputs = e.parseUpsampleAttributes = e.parseUpsampleAttributesV9 = e.parseUpsampleAttributesV7 = e.upsample = void 0;
          const r = n(246), i = n(5060), o = n(2039), a = { name: "Upsample", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
          e.upsample = (t2, n2, r2) => ((0, e.validateInputs)(n2, r2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: r2.cacheKey, get: () => s(t2, n2, r2) }), n2)]), e.parseUpsampleAttributesV7 = (t2) => (0, e.parseUpsampleAttributes)(t2, 7), e.parseUpsampleAttributesV9 = (t2) => (0, e.parseUpsampleAttributes)(t2, 9), e.parseUpsampleAttributes = (t2, n2) => {
            const i2 = n2 >= 10, o2 = t2.attributes.getString("mode", "nearest");
            if ("nearest" !== o2 && "linear" !== o2 && (n2 < 11 || "cubic" !== o2))
              throw new Error(`unrecognized mode: ${o2}`);
            let a2 = [];
            n2 < 9 && (a2 = t2.attributes.getFloats("scales"), (0, e.scalesValidation)(a2, o2, i2));
            const s2 = t2.attributes.getFloat("extrapolation_value", 0), u = n2 > 10 ? t2.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
            if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(u))
              throw new Error(`coordinate_transform_mode '${u}' is not supported`);
            const c = "tf_crop_and_resize" === u, l = c, p = "nearest" === o2 && n2 >= 11 ? t2.attributes.getString("nearest_mode", "round_prefer_floor") : "";
            if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p))
              throw new Error(`nearest_mode '${p}' is not supported`);
            const f = t2.attributes.getFloat("cubic_coeff_a", -0.75), d = 0 !== t2.attributes.getInt("exclude_outside", 0);
            if (d && "cubic" !== o2)
              throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
            const h = n2 < 11 || "nearest" === o2 && "asymmetric" === u && "floor" === p;
            let g = 0, b = 0, m = 0;
            return n2 > 10 ? t2.inputs.length > 2 ? (g = 1, b = 2, m = 3) : (b = 1, m = 2) : 9 === n2 && (b = 1), (0, r.createAttributeWithCacheKey)({ opset: n2, isResize: i2, mode: o2, scales: a2, extrapolationValue: s2, coordinateTransformMode: u, useExtrapolation: l, needRoiInput: c, nearestMode: p, cubicCoefficientA: f, excludeOutside: d, useNearest2xOptimization: h, roiInputIdx: g, scalesInputIdx: b, sizesInputIdx: m });
          };
          const s = (t2, e2, n2) => {
            const r2 = (0, i.getGlsl)(t2.session.backend.glContext.version), [s2, u] = t2.calculateTextureWidthAndHeight(e2[0].dims, o.TextureType.unpacked), c = e2[0].dims.map((t3, e3) => Math.floor(t3 * n2.scales[e3])), [l, p] = t2.calculateTextureWidthAndHeight(c, o.TextureType.unpacked), f = c.length, d = new Array(f), h = new Array(f);
            let g = `
      int output_pitches[${f}];
      int input_pitches[${f}];
      `;
            for (let t3 = f - 1; t3 >= 0; t3--)
              d[t3] = t3 === f - 1 ? 1 : d[t3 + 1] * c[t3 + 1], h[t3] = t3 === f - 1 ? 1 : h[t3 + 1] * e2[0].dims[t3 + 1], g += `
        output_pitches[${t3}] = ${d[t3]};
        input_pitches[${t3}] = ${h[t3]};
        `;
            const b = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s2}, ${u});
        float value = getColorAsFloat(${r2.texture2D}(X, coords));
        return value;
      }
      `, m = "nearest" === n2.mode ? `
    ${b}
    float process(int indices[${f}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int d, m;
      for (int dim = 0; dim < ${f}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === f ? `
    ${b}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e2[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${b}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e2[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
            return Object.assign(Object.assign({}, a), { output: { dims: c, type: e2[0].type, textureType: o.TextureType.unpacked }, shaderSource: m, variables: [{ name: "scales", type: "int", arrayLength: n2.scales.length, data: n2.scales.map((t3) => Math.ceil(t3)) }] });
          };
          e.validateInputs = (t2, e2) => {
            if (!t2 || e2.opset < 9 && 1 !== t2.length || e2.opset >= 9 && e2.opset < 11 && 2 !== t2.length || e2.opset >= 11 && t2.length < 2)
              throw new Error("invalid inputs.");
            if (e2.scales.length > 0 && t2[0].dims.length !== e2.scales.length)
              throw new Error("Invalid input shape.");
            if ("string" === t2[0].type)
              throw new Error("Invalid input tensor types.");
          }, e.scalesValidation = (t2, e2, n2) => {
            if (n2) {
              for (const e3 of t2)
                if (e3 <= 0)
                  throw new Error("Scale value should be greater than 0.");
            } else
              for (const e3 of t2)
                if (e3 < 1)
                  throw new Error("Scale value should be greater than or equal to 1.");
            if (!("linear" !== e2 && "cubic" !== e2 || 2 === t2.length || 4 === t2.length && 1 === t2[0] && 1 === t2[1]))
              throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n2 ? "Resize" : "Upsample"} opeartor.`);
          };
        }, 1958: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.ProgramManager = void 0;
          const r = n(1670), i = n(6231), o = n(8879), a = n(5060);
          e.ProgramManager = class {
            constructor(t2, e2, n2) {
              this.profiler = t2, this.glContext = e2, this.textureLayoutStrategy = n2, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
            }
            getArtifact(t2) {
              return this.repo.get(t2);
            }
            setArtifact(t2, e2) {
              this.repo.set(t2, e2);
            }
            run(t2, e2, n2) {
              var r2;
              this.profiler.event("op", `ProgramManager.run ${null !== (r2 = t2.programInfo.name) && void 0 !== r2 ? r2 : "unknown kernel"}`, () => {
                var r3;
                const o2 = this.glContext.gl, a2 = t2.program;
                o2.useProgram(a2);
                try {
                  this.bindOutput(n2), this.attributesBound || this.bindAttributes(t2.attribLocations), this.bindUniforms(t2.uniformLocations, null !== (r3 = t2.programInfo.variables) && void 0 !== r3 ? r3 : [], e2);
                } catch (e3) {
                  throw i.Logger.error("ProgramManager", t2.programInfo.shaderSource), e3;
                }
                this.profiler.event("backend", "GlContext.draw()", () => {
                  this.glContext.draw();
                });
              }, this.glContext);
            }
            dispose() {
              this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((t2) => this.glContext.deleteProgram(t2.program));
            }
            build(t2, e2, n2) {
              return this.profiler.event("backend", "ProgramManager.build", () => {
                const r2 = new o.GlslPreprocessor(this.glContext, t2, e2, n2), i2 = r2.preprocess(), a2 = this.compile(i2);
                return { programInfo: t2, program: a2, uniformLocations: this.getUniformLocations(a2, r2.context.programInfo.inputNames, r2.context.programInfo.variables), attribLocations: this.getAttribLocations(a2) };
              });
            }
            compile(t2) {
              if (!this.vertexShader) {
                i.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
                const t3 = (0, a.getVertexShaderSource)(this.glContext.version);
                this.vertexShader = this.glContext.compileShader(t3, this.glContext.gl.VERTEX_SHADER);
              }
              r.env.debug && i.Logger.verbose("ProrgramManager", `FragShader:
${t2}
`);
              const e2 = this.glContext.compileShader(t2, this.glContext.gl.FRAGMENT_SHADER), n2 = this.glContext.createProgram(this.vertexShader, e2);
              return this.glContext.deleteShader(e2), n2;
            }
            bindOutput(t2) {
              const e2 = t2.width, n2 = t2.height;
              i.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${e2}/${n2}, shape=${t2.shape}, type=${t2.tensor.type}`), this.glContext.attachFramebuffer(t2.texture, e2, n2);
            }
            bindAttributes(t2) {
              const e2 = t2.position, n2 = t2.textureCoord;
              this.glContext.setVertexAttributes(e2, n2), this.attributesBound = true;
            }
            bindUniforms(t2, e2, n2) {
              var r2;
              const i2 = this.glContext.gl;
              let o2 = 0;
              for (const { name: a2, type: s, location: u, arrayLength: c } of t2) {
                const t3 = null === (r2 = e2.find((t4) => t4.name === a2)) || void 0 === r2 ? void 0 : r2.data;
                if ("sampler2D" !== s && !t3)
                  throw new Error(`variable '${a2}' does not have data defined in program info`);
                switch (s) {
                  case "sampler2D":
                    this.bindTexture(n2[o2], u, o2), o2++;
                    break;
                  case "float":
                    c ? i2.uniform1fv(u, t3) : i2.uniform1f(u, t3);
                    break;
                  case "int":
                    c ? i2.uniform1iv(u, t3) : i2.uniform1i(u, t3);
                    break;
                  default:
                    throw new Error(`Uniform not implemented: ${s}`);
                }
              }
            }
            bindTexture(t2, e2, n2) {
              this.glContext.bindTextureToUniform(t2.texture, n2, e2);
            }
            getAttribLocations(t2) {
              return { position: this.getAttribLocation(t2, "position"), textureCoord: this.getAttribLocation(t2, "textureCoord") };
            }
            getUniformLocations(t2, e2, n2) {
              const r2 = [];
              if (e2)
                for (const n3 of e2)
                  r2.push({ name: n3, type: "sampler2D", location: this.getUniformLocation(t2, n3) });
              if (n2)
                for (const e3 of n2)
                  r2.push(Object.assign(Object.assign({}, e3), { location: this.getUniformLocation(t2, e3.name) }));
              return r2;
            }
            getUniformLocation(t2, e2) {
              const n2 = this.glContext.gl.getUniformLocation(t2, e2);
              if (null === n2)
                throw new Error(`Uniform ${e2} not found.`);
              return n2;
            }
            getAttribLocation(t2, e2) {
              return this.glContext.gl.getAttribLocation(t2, e2);
            }
          };
        }, 6416: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.WebGLSessionHandler = void 0;
          const r = n(6231), i = n(1047), o = n(8316), a = n(1640), s = n(1958), u = n(7859), c = n(5702);
          e.WebGLSessionHandler = class {
            constructor(t2, e2) {
              this.backend = t2, this.context = e2, this.layoutStrategy = new u.PreferLogicalStrategy(t2.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, t2.glContext, this.layoutStrategy), this.textureManager = new c.TextureManager(t2.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === t2.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = t2.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
            }
            createInferenceHandler() {
              return new o.WebGLInferenceHandler(this);
            }
            onGraphInitialized(t2) {
              const e2 = t2.getValues().filter((t3) => -1 === t3.from && t3.tensor).map((t3) => t3.tensor.dataId);
              this.initializers = new Set(e2);
            }
            isInitializer(t2) {
              return !!this.initializers && this.initializers.has(t2);
            }
            addInitializer(t2) {
              this.initializers.add(t2);
            }
            getTextureData(t2, e2) {
              return e2 ? this.packedTextureDataCache.get(t2) : this.unpackedTextureDataCache.get(t2);
            }
            setTextureData(t2, e2, n2 = false) {
              r.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n2 ? this.packedTextureDataCache.set(t2, e2) : this.unpackedTextureDataCache.set(t2, e2);
            }
            dispose() {
              this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t2) => this.textureManager.releaseTexture(t2, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t2) => this.textureManager.releaseTexture(t2, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            resolve(t2, e2, n2) {
              const r2 = (0, i.resolveOperator)(t2, e2, a.WEBGL_OP_RESOLVE_RULES);
              return { impl: r2.opImpl, context: r2.opInit ? r2.opInit(t2, n2) : t2 };
            }
          };
        }, 7769: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.Uint8DataEncoder = e.RGBAFloatDataEncoder = e.RedFloat32DataEncoder = void 0;
          const r = n(6231);
          e.RedFloat32DataEncoder = class {
            constructor(t2, e2 = 1) {
              if (1 === e2)
                this.internalFormat = t2.R32F, this.format = t2.RED, this.textureType = t2.FLOAT, this.channelSize = e2;
              else {
                if (4 !== e2)
                  throw new Error(`Invalid number of channels: ${e2}`);
                this.internalFormat = t2.RGBA32F, this.format = t2.RGBA, this.textureType = t2.FLOAT, this.channelSize = e2;
              }
            }
            encode(t2, e2) {
              let n2, i;
              return t2.constructor !== Float32Array && (r.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), i = new Float32Array(t2)), e2 * this.channelSize > t2.length ? (r.Logger.warning("Encoder", "Source data too small. Allocating larger array"), i = t2, n2 = this.allocate(e2 * this.channelSize), i.forEach((t3, e3) => n2[e3] = t3)) : (i = t2, n2 = i), n2;
            }
            allocate(t2) {
              return new Float32Array(4 * t2);
            }
            decode(t2, e2) {
              return 1 === this.channelSize ? t2.filter((t3, e3) => e3 % 4 == 0).subarray(0, e2) : t2.subarray(0, e2);
            }
          }, e.RGBAFloatDataEncoder = class {
            constructor(t2, e2 = 1, n2) {
              if (1 !== e2 && 4 !== e2)
                throw new Error(`Invalid number of channels: ${e2}`);
              this.internalFormat = t2.RGBA, this.format = t2.RGBA, this.channelSize = e2, this.textureType = n2 || t2.FLOAT;
            }
            encode(t2, e2) {
              let n2 = t2;
              return 1 === this.channelSize && (r.Logger.verbose("Encoder", "Exploding into a larger array"), n2 = this.allocate(e2), t2.forEach((t3, e3) => n2[4 * e3] = t3)), n2;
            }
            allocate(t2) {
              return new Float32Array(4 * t2);
            }
            decode(t2, e2) {
              return 1 === this.channelSize ? t2.filter((t3, e3) => e3 % 4 == 0).subarray(0, e2) : t2.subarray(0, e2);
            }
          }, e.Uint8DataEncoder = class {
            constructor(t2, e2 = 1) {
              if (this.channelSize = 4, 1 === e2)
                this.internalFormat = t2.ALPHA, this.format = t2.ALPHA, this.textureType = t2.UNSIGNED_BYTE, this.channelSize = e2;
              else {
                if (4 !== e2)
                  throw new Error(`Invalid number of channels: ${e2}`);
                this.internalFormat = t2.RGBA, this.format = t2.RGBA, this.textureType = t2.UNSIGNED_BYTE, this.channelSize = e2;
              }
            }
            encode(t2, e2) {
              return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
            }
            allocate(t2) {
              return new Uint8Array(t2 * this.channelSize);
            }
            decode(t2, e2) {
              if (t2 instanceof Uint8Array)
                return t2.subarray(0, e2);
              throw new Error(`Invalid array type: ${t2.constructor}`);
            }
          };
        }, 7859: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.getBatchDim = e.sizeToSquarishShape = e.getRowsCols = e.sizeFromShape = e.isInt = e.parseAxisParam = e.squeezeShape = e.PreferLogicalStrategy = e.AlwaysKeepOriginalSizeStrategy = void 0;
          const r = n(6231), i = n(2517);
          function o(t2, e2) {
            const n2 = [], r2 = [], i2 = null != e2 && Array.isArray(e2) && 0 === e2.length, o2 = null == e2 || i2 ? null : a(e2, t2).sort();
            let s2 = 0;
            for (let e3 = 0; e3 < t2.length; ++e3) {
              if (null != o2) {
                if (o2[s2] === e3 && 1 !== t2[e3])
                  throw new Error(`Can't squeeze axis ${e3} since its dim '${t2[e3]}' is not 1`);
                (null == o2[s2] || o2[s2] > e3) && 1 === t2[e3] && (n2.push(t2[e3]), r2.push(e3)), o2[s2] <= e3 && s2++;
              }
              1 !== t2[e3] && (n2.push(t2[e3]), r2.push(e3));
            }
            return { newShape: n2, keptDims: r2 };
          }
          function a(t2, e2) {
            const n2 = e2.length;
            return t2 = null == t2 ? e2.map((t3, e3) => e3) : [].concat(t2), (0, i.assert)(t2.every((t3) => t3 >= -n2 && t3 < n2), () => `All values in axis param must be in range [-${n2}, ${n2}) but got axis ${t2}`), (0, i.assert)(t2.every(s), () => `All values in axis param must be integers but got axis ${t2}`), t2.map((t3) => t3 < 0 ? n2 + t3 : t3);
          }
          function s(t2) {
            return t2 % 1 == 0;
          }
          function u(t2) {
            if (0 === t2.length)
              return 1;
            let e2 = t2[0];
            for (let n2 = 1; n2 < t2.length; n2++)
              e2 *= t2[n2];
            return e2;
          }
          function c(t2) {
            const e2 = Math.ceil(Math.sqrt(t2));
            return [e2, Math.ceil(t2 / e2)];
          }
          e.AlwaysKeepOriginalSizeStrategy = class {
            constructor(t2) {
              this.maxTextureSize = t2;
            }
            computeTextureWH(t2, e2) {
              if (0 === t2.length)
                return [1, 1];
              const n2 = this.maxTextureSize;
              if (e2 && void 0 !== e2.breakAxis) {
                const i3 = e2.breakAxis >= t2.length ? 1 : t2.slice(e2.breakAxis).reduce((t3, e3) => t3 * e3), o3 = e2.breakAxis <= 0 ? 1 : t2.slice(0, e2.breakAxis).reduce((t3, e3) => t3 * e3);
                if (!(i3 > n2 || o3 > n2))
                  return [i3, o3];
                r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t2}, breakAxis:${e2.breakAxis}`);
              }
              const i2 = t2.reduce((t3, e3) => t3 * e3);
              let o2 = Math.floor(Math.sqrt(i2));
              for (; o2 < n2 && o2 < i2 && i2 % o2 != 0; o2++)
                ;
              if (o2 >= n2 || i2 % o2 != 0)
                throw new Error(`The given dimensions are outside this GPU's boundaries: ${t2}`);
              return [o2, i2 / o2];
            }
          }, e.PreferLogicalStrategy = class {
            constructor(t2) {
              this.maxTextureSize = t2;
            }
            computeTextureWH(t2, e2) {
              const n2 = this.computeTexture(t2, e2);
              return e2 && e2.isPacked && (n2[0] /= 2, n2[1] /= 2), e2 && e2.reverseWH ? [n2[1], n2[0]] : n2;
            }
            computeTexture(t2, e2) {
              const n2 = e2 && e2.isPacked;
              if (0 === t2.length)
                return n2 ? [2, 2] : [1, 1];
              let i2 = this.maxTextureSize;
              if (e2 && void 0 !== e2.breakAxis) {
                const n3 = e2.breakAxis >= t2.length ? 1 : t2.slice(e2.breakAxis).reduce((t3, e3) => t3 * e3), o2 = e2.breakAxis <= 0 ? 1 : t2.slice(0, e2.breakAxis).reduce((t3, e3) => t3 * e3);
                if (!(n3 > i2 || o2 > i2))
                  return [n3, o2];
                r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t2}, breakAxis:${e2.breakAxis}`);
              }
              let a2 = t2.slice(0);
              if (n2 && (i2 *= 2, a2 = a2.map((t3, e3) => e3 >= a2.length - 2 ? a2[e3] % 2 == 0 ? a2[e3] : a2[e3] + 1 : a2[e3]), 1 === a2.length && (a2 = [2, a2[0]])), 2 !== a2.length) {
                const t3 = o(a2);
                a2 = t3.newShape;
              }
              const s2 = u(a2);
              return a2.length <= 1 && s2 <= i2 ? [1, s2] : 2 === a2.length && a2[0] <= i2 && a2[1] <= i2 ? a2 : 3 === a2.length && a2[0] * a2[1] <= i2 && a2[2] <= i2 ? [a2[0] * a2[1], a2[2]] : 3 === a2.length && a2[0] <= i2 && a2[1] * a2[2] <= i2 ? [a2[0], a2[1] * a2[2]] : 4 === a2.length && a2[0] * a2[1] * a2[2] <= i2 && a2[3] <= i2 ? [a2[0] * a2[1] * a2[2], a2[3]] : 4 === a2.length && a2[0] <= i2 && a2[1] * a2[2] * a2[3] <= i2 ? [a2[0], a2[1] * a2[2] * a2[3]] : n2 ? c(s2 / 4).map((t3) => 2 * t3) : c(s2);
            }
          }, e.squeezeShape = o, e.parseAxisParam = a, e.isInt = s, e.sizeFromShape = u, e.getRowsCols = function(t2) {
            if (0 === t2.length)
              throw Error("Cannot get rows and columns of an empty shape array.");
            return [t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
          }, e.sizeToSquarishShape = c, e.getBatchDim = function(t2, e2 = 2) {
            return u(t2.slice(0, t2.length - e2));
          };
        }, 4057: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createTextureLayoutFromShape = e.calculateTextureWidthAndHeight = e.createTextureLayoutFromTextureType = void 0;
          const r = n(2517), i = n(2039);
          e.createTextureLayoutFromTextureType = (t2, n2, r2) => {
            const o = r2 === i.TextureType.unpacked || r2 === i.TextureType.unpackedReversed ? 1 : 4, a = r2 === i.TextureType.packed, s = r2 === i.TextureType.unpackedReversed || r2 === i.TextureType.packed, u = r2 === i.TextureType.packedLastDimension ? n2.length - 1 : void 0, c = r2 === i.TextureType.packedLastDimension ? n2.map((t3, e2) => e2 === n2.length - 1 ? 4 * t3 : t3) : void 0;
            return (0, e.createTextureLayoutFromShape)(t2, n2, o, c, { isPacked: a, reverseWH: s, breakAxis: u });
          }, e.calculateTextureWidthAndHeight = (t2, n2, r2) => {
            const i2 = (0, e.createTextureLayoutFromTextureType)(t2, n2, r2);
            return [i2.width, i2.height];
          }, e.createTextureLayoutFromShape = (t2, e2, n2 = 1, i2, o) => {
            const a = !(!o || !o.isPacked), [s, u] = t2.computeTextureWH(a && i2 || e2, o), c = e2.length;
            let l = e2.slice(0);
            if (0 === c && (l = [1]), 1 === n2)
              i2 = e2;
            else if (a) {
              if (4 !== n2)
                throw new Error("a packed texture must be 4-channel");
              i2 = e2, c > 0 && (l[c - 1] = Math.ceil(l[c - 1] / 2)), c > 1 && (l[c - 2] = Math.ceil(l[c - 2] / 2));
            } else if (!i2)
              throw new Error("Unpacked shape is needed when using channels > 1");
            return { width: s, height: u, channels: n2, isPacked: a, shape: l, strides: r.ShapeUtil.computeStrides(l), unpackedShape: i2, reversedWH: o && o.reverseWH };
          };
        }, 5702: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.TextureManager = void 0;
          const r = n(6231);
          e.TextureManager = class {
            constructor(t2, e2, n2, r2) {
              this.glContext = t2, this.layoutStrategy = e2, this.profiler = n2, this.config = r2, this.pendingRead = /* @__PURE__ */ new Map(), r2.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
            }
            createTextureFromLayout(t2, e2, n2, i) {
              const o = this.toEncoderType(t2), a = this.glContext.getEncoder(o, e2.channels || 1, i);
              if (e2.isPacked && 1 === i)
                throw new Error("not implemented");
              const s = e2.width, u = e2.height;
              let c, l;
              if (this.config.reuseTextures) {
                c = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, l = this.inUseTextures.get(c), l || (l = [], this.inUseTextures.set(c, l));
                const e3 = this.idleTextures.get(c);
                if (e3 && e3.length > 0) {
                  const r2 = e3.pop();
                  return l.push(r2), 1 === i && this.glContext.updateTexture(r2, s, u, a, this.toTextureData(t2, n2)), r2;
                }
              }
              r.Logger.verbose("TextureManager", `Creating new texture of size ${e2.width}x${e2.height}`);
              const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(t2, n2));
              return this.config.reuseTextures && (l.push(p), this.textureLookup.set(p, c)), p;
            }
            readTexture(t2, e2, n2) {
              return n2 || (n2 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
                const r2 = t2.shape.reduce((t3, e3) => t3 * e3) * n2, i = this.glContext.readTexture(t2.texture, t2.width, t2.height, r2, this.toEncoderType(e2), n2);
                return this.toTensorData(e2, i);
              });
            }
            async readTextureAsync(t2, e2, n2) {
              const r2 = t2.tensor.dataId;
              if (n2 || (n2 = 1), this.pendingRead.has(r2)) {
                const t3 = this.pendingRead.get(r2);
                return new Promise((e3) => null == t3 ? void 0 : t3.push(e3));
              }
              return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
                this.pendingRead.set(r2, []);
                const i = t2.shape.reduce((t3, e3) => t3 * e3) * n2;
                await this.glContext.createAndWaitForFence();
                const o = this.glContext.readTexture(t2.texture, t2.width, t2.height, i, this.toEncoderType(e2), n2), a = this.toTensorData(e2, o), s = this.pendingRead.get(r2);
                return this.pendingRead.delete(r2), null == s || s.forEach((t3) => t3(a)), a;
              });
            }
            readUint8TextureAsFloat(t2) {
              return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
                const e2 = t2.shape.reduce((t3, e3) => t3 * e3), n2 = this.glContext.readTexture(t2.texture, t2.width, t2.height, 4 * e2, "byte", 4);
                return new Float32Array(n2.buffer, n2.byteOffset, e2);
              });
            }
            releaseTexture(t2, e2) {
              let n2;
              if (this.config.reuseTextures && (n2 = this.textureLookup.get(t2.texture), n2)) {
                e2 && this.textureLookup.delete(n2);
                const r2 = this.inUseTextures.get(n2);
                if (r2) {
                  const e3 = r2.indexOf(t2.texture);
                  if (-1 !== e3) {
                    r2.splice(e3, 1);
                    let i = this.idleTextures.get(n2);
                    i || (i = [], this.idleTextures.set(n2, i)), i.push(t2.texture);
                  }
                }
              }
              n2 && !e2 || (r.Logger.verbose("TextureManager", `Deleting texture of size ${t2.width}x${t2.height}`), this.glContext.deleteTexture(t2.texture));
            }
            toTensorData(t2, e2) {
              switch (t2) {
                case "int16":
                  return e2 instanceof Int16Array ? e2 : Int16Array.from(e2);
                case "int32":
                  return e2 instanceof Int32Array ? e2 : Int32Array.from(e2);
                case "int8":
                  return e2 instanceof Int8Array ? e2 : Int8Array.from(e2);
                case "uint16":
                  return e2 instanceof Uint16Array ? e2 : Uint16Array.from(e2);
                case "uint32":
                  return e2 instanceof Uint32Array ? e2 : Uint32Array.from(e2);
                case "uint8":
                case "bool":
                  return e2 instanceof Uint8Array ? e2 : Uint8Array.from(e2);
                case "float32":
                  return e2 instanceof Float32Array ? e2 : Float32Array.from(e2);
                case "float64":
                  return e2 instanceof Float64Array ? e2 : Float64Array.from(e2);
                default:
                  throw new Error(`TensorData type ${t2} is not supported`);
              }
            }
            toTextureData(t2, e2) {
              if (e2)
                return e2 instanceof Float32Array ? e2 : new Float32Array(e2);
            }
            toEncoderType(t2) {
              return "float";
            }
            clearActiveTextures() {
              this.glContext.clearActiveTextures();
            }
          };
        }, 2039: (t, e) => {
          "use strict";
          var n;
          Object.defineProperty(e, "__esModule", { value: true }), e.TextureType = void 0, (n = e.TextureType || (e.TextureType = {}))[n.unpacked = 0] = "unpacked", n[n.unpackedReversed = 1] = "unpackedReversed", n[n.packed = 2] = "packed", n[n.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n[n.packedLastDimension = 4] = "packedLastDimension";
        }, 9390: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.getGlChannels = e.getCoordsDataType = e.getSqueezedParams = e.squeezeInputShape = e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = e.generateShaderFuncNameFromInputSamplerName = e.repeatedTry = e.getPackedShape = void 0;
          const r = n(2517);
          e.getPackedShape = function(t2) {
            const e2 = t2.length;
            return t2.slice(0, e2 - 1).concat(t2[e2 - 1] / 4);
          }, e.repeatedTry = async function(t2, e2 = (t3) => 0, n2) {
            return new Promise((r2, i) => {
              let o = 0;
              const a = () => {
                if (t2())
                  return void r2();
                o++;
                const s = e2(o);
                null != n2 && o >= n2 ? i() : setTimeout(a, s);
              };
              a();
            });
          }, e.generateShaderFuncNameFromInputSamplerName = function(t2) {
            return (0, r.assert)(void 0 !== t2 && 0 !== t2.length, () => "empty string found for sampler name"), "get" + t2.charAt(0).toUpperCase() + t2.slice(1);
          }, e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(t2) {
            return (0, r.assert)(void 0 !== t2 && 0 !== t2.length, () => "empty string found for sampler name"), "get" + t2.charAt(0).toUpperCase() + t2.slice(1) + "AtOutCoords";
          }, e.squeezeInputShape = function(t2, e2) {
            let n2 = JSON.parse(JSON.stringify(t2));
            return n2 = e2, n2;
          }, e.getSqueezedParams = function(t2, e2) {
            return e2.map((e3) => t2[e3]).join(", ");
          }, e.getCoordsDataType = function(t2) {
            if (t2 <= 1)
              return "int";
            if (2 === t2)
              return "ivec2";
            if (3 === t2)
              return "ivec3";
            if (4 === t2)
              return "ivec4";
            if (5 === t2)
              return "ivec5";
            if (6 === t2)
              return "ivec6";
            throw Error(`GPU for rank ${t2} is not yet supported`);
          }, e.getGlChannels = function(t2 = 6) {
            return ["x", "y", "z", "w", "u", "v"].slice(0, t2);
          };
        }, 7305: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.createNewWebGLContext = e.createWebGLContext = void 0;
          const r = n(6231), i = n(1713), o = {};
          function a(t2) {
            const e2 = function() {
              if ("undefined" == typeof document) {
                if ("undefined" == typeof OffscreenCanvas)
                  throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");
                return new OffscreenCanvas(1, 1);
              }
              const t3 = document.createElement("canvas");
              return t3.width = 1, t3.height = 1, t3;
            }();
            let n2;
            const o2 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
            if ((!t2 || "webgl2" === t2) && (n2 = e2.getContext("webgl2", o2), n2))
              try {
                return new i.WebGLContext(n2, 2);
              } catch (t3) {
                r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${t3}`);
              }
            if ((!t2 || "webgl" === t2) && (n2 = e2.getContext("webgl", o2) || e2.getContext("experimental-webgl", o2), n2))
              try {
                return new i.WebGLContext(n2, 1);
              } catch (t3) {
                r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t3}`);
              }
            throw new Error("WebGL is not supported");
          }
          e.createWebGLContext = function t2(e2) {
            let n2;
            e2 && "webgl2" !== e2 || !("webgl2" in o) ? e2 && "webgl" !== e2 || !("webgl" in o) || (n2 = o.webgl) : n2 = o.webgl2, n2 = n2 || a(e2), e2 = e2 || 1 === n2.version ? "webgl" : "webgl2";
            const r2 = n2.gl;
            return o[e2] = n2, r2.isContextLost() ? (delete o[e2], t2(e2)) : (r2.disable(r2.DEPTH_TEST), r2.disable(r2.STENCIL_TEST), r2.disable(r2.BLEND), r2.disable(r2.DITHER), r2.disable(r2.POLYGON_OFFSET_FILL), r2.disable(r2.SAMPLE_COVERAGE), r2.enable(r2.SCISSOR_TEST), r2.enable(r2.CULL_FACE), r2.cullFace(r2.BACK), n2);
          }, e.createNewWebGLContext = a;
        }, 1713: function(t, e, n) {
          "use strict";
          var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
            Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
          } : function(t2, e2) {
            t2.default = e2;
          }), o = this && this.__importStar || function(t2) {
            if (t2 && t2.__esModule)
              return t2;
            var e2 = {};
            if (null != t2)
              for (var n2 in t2)
                "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
            return i(e2, t2), e2;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.WebGLContext = e.linearSearchLastTrue = void 0;
          const a = n(1670), s = o(n(7769)), u = n(9390);
          function c(t2) {
            let e2 = 0;
            for (; e2 < t2.length && t2[e2](); ++e2)
              ;
            return e2 - 1;
          }
          e.linearSearchLastTrue = c, e.WebGLContext = class {
            constructor(t2, e2) {
              this.frameBufferBound = false, this.itemsToPoll = [], this.gl = t2, this.version = e2, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
            }
            allocateTexture(t2, e2, n2, r2) {
              const i2 = this.gl, o2 = i2.createTexture();
              i2.bindTexture(i2.TEXTURE_2D, o2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, i2.CLAMP_TO_EDGE), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, i2.CLAMP_TO_EDGE);
              const a2 = r2 ? n2.encode(r2, t2 * e2) : null;
              return i2.texImage2D(i2.TEXTURE_2D, 0, n2.internalFormat, t2, e2, 0, n2.format, n2.textureType, a2), this.checkError(), o2;
            }
            updateTexture(t2, e2, n2, r2, i2) {
              const o2 = this.gl;
              o2.bindTexture(o2.TEXTURE_2D, t2);
              const a2 = r2.encode(i2, e2 * n2);
              o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, e2, n2, r2.format, r2.textureType, a2), this.checkError();
            }
            attachFramebuffer(t2, e2, n2) {
              const r2 = this.gl;
              r2.bindTexture(r2.TEXTURE_2D, t2), r2.bindFramebuffer(r2.FRAMEBUFFER, this.framebuffer), r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.COLOR_ATTACHMENT0, r2.TEXTURE_2D, t2, 0), this.checkError(), r2.viewport(0, 0, e2, n2), r2.scissor(0, 0, e2, n2);
            }
            readTexture(t2, e2, n2, r2, i2, o2) {
              const a2 = this.gl;
              o2 || (o2 = 1), this.frameBufferBound || this.attachFramebuffer(t2, e2, n2);
              const s2 = this.getEncoder(i2, o2), u2 = s2.allocate(e2 * n2);
              return a2.bindTexture(a2.TEXTURE_2D, t2), a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_2D, t2, 0), a2.readPixels(0, 0, e2, n2, a2.RGBA, s2.textureType, u2), this.checkError(), s2.decode(u2, r2);
            }
            isFramebufferReady() {
              return true;
            }
            getActiveTexture() {
              const t2 = this.gl;
              return "TEXTURE" + (t2.getParameter(this.gl.ACTIVE_TEXTURE) - t2.TEXTURE0);
            }
            getTextureBinding() {
              return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
            }
            getFramebufferBinding() {
              return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
            }
            setVertexAttributes(t2, e2) {
              const n2 = this.gl;
              n2.vertexAttribPointer(t2, 3, n2.FLOAT, false, 20, 0), n2.enableVertexAttribArray(t2), -1 !== e2 && (n2.vertexAttribPointer(e2, 2, n2.FLOAT, false, 20, 12), n2.enableVertexAttribArray(e2)), this.checkError();
            }
            createProgram(t2, e2) {
              const n2 = this.gl, r2 = n2.createProgram();
              return n2.attachShader(r2, t2), n2.attachShader(r2, e2), n2.linkProgram(r2), r2;
            }
            compileShader(t2, e2) {
              const n2 = this.gl, r2 = n2.createShader(e2);
              if (!r2)
                throw new Error(`createShader() returned null with type ${e2}`);
              if (n2.shaderSource(r2, t2), n2.compileShader(r2), false === n2.getShaderParameter(r2, n2.COMPILE_STATUS))
                throw new Error(`Failed to compile shader: ${n2.getShaderInfoLog(r2)}
Shader source:
${t2}`);
              return r2;
            }
            deleteShader(t2) {
              this.gl.deleteShader(t2);
            }
            bindTextureToUniform(t2, e2, n2) {
              const r2 = this.gl;
              r2.activeTexture(r2.TEXTURE0 + e2), this.checkError(), r2.bindTexture(r2.TEXTURE_2D, t2), this.checkError(), r2.uniform1i(n2, e2), this.checkError();
            }
            draw() {
              this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
            }
            checkError() {
              if (a.env.debug) {
                const t2 = this.gl, e2 = t2.getError();
                let n2 = "";
                switch (e2) {
                  case t2.NO_ERROR:
                    return;
                  case t2.INVALID_ENUM:
                    n2 = "INVALID_ENUM";
                    break;
                  case t2.INVALID_VALUE:
                    n2 = "INVALID_VALUE";
                    break;
                  case t2.INVALID_OPERATION:
                    n2 = "INVALID_OPERATION";
                    break;
                  case t2.INVALID_FRAMEBUFFER_OPERATION:
                    n2 = "INVALID_FRAMEBUFFER_OPERATION";
                    break;
                  case t2.OUT_OF_MEMORY:
                    n2 = "OUT_OF_MEMORY";
                    break;
                  case t2.CONTEXT_LOST_WEBGL:
                    n2 = "CONTEXT_LOST_WEBGL";
                    break;
                  default:
                    n2 = `Unknown WebGL Error: ${e2.toString(16)}`;
                }
                throw new Error(n2);
              }
            }
            deleteTexture(t2) {
              this.gl.deleteTexture(t2);
            }
            deleteProgram(t2) {
              this.gl.deleteProgram(t2);
            }
            getEncoder(t2, e2, n2 = 0) {
              if (2 === this.version)
                return new s.RedFloat32DataEncoder(this.gl, e2);
              switch (t2) {
                case "float":
                  return 1 === n2 || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, e2) : new s.RGBAFloatDataEncoder(this.gl, e2, this.textureHalfFloatExtension.HALF_FLOAT_OES);
                case "int":
                  throw new Error("not implemented");
                case "byte":
                  return new s.Uint8DataEncoder(this.gl, e2);
                default:
                  throw new Error(`Invalid dataType: ${t2}`);
              }
            }
            clearActiveTextures() {
              const t2 = this.gl;
              for (let e2 = 0; e2 < this.maxTextureImageUnits; ++e2)
                t2.activeTexture(t2.TEXTURE0 + e2), t2.bindTexture(t2.TEXTURE_2D, null);
            }
            dispose() {
              if (this.disposed)
                return;
              const t2 = this.gl;
              t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteFramebuffer(this.framebuffer), t2.bindBuffer(t2.ARRAY_BUFFER, null), t2.deleteBuffer(this.vertexbuffer), t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, null), t2.finish(), this.disposed = true;
            }
            createDefaultGeometry() {
              return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
            }
            createVertexbuffer() {
              const t2 = this.gl, e2 = t2.createBuffer();
              if (!e2)
                throw new Error("createBuffer() returned null");
              const n2 = this.createDefaultGeometry();
              return t2.bindBuffer(t2.ARRAY_BUFFER, e2), t2.bufferData(t2.ARRAY_BUFFER, n2, t2.STATIC_DRAW), this.checkError(), e2;
            }
            createFramebuffer() {
              const t2 = this.gl.createFramebuffer();
              if (!t2)
                throw new Error("createFramebuffer returned null");
              return t2;
            }
            queryVitalParameters() {
              const t2 = this.gl;
              if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported)
                throw new Error("both float32 and float16 TextureType are not supported");
              this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = t2.getParameter(t2.MAX_TEXTURE_IMAGE_UNITS), this.version;
            }
            getExtensions() {
              2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
            }
            checkFloatTextureAttachableToFrameBuffer() {
              const t2 = this.gl, e2 = t2.createTexture();
              t2.bindTexture(t2.TEXTURE_2D, e2);
              const n2 = 2 === this.version ? t2.RGBA32F : t2.RGBA;
              t2.texImage2D(t2.TEXTURE_2D, 0, n2, 1, 1, 0, t2.RGBA, t2.FLOAT, null);
              const r2 = t2.createFramebuffer();
              t2.bindFramebuffer(t2.FRAMEBUFFER, r2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0);
              const i2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER) === t2.FRAMEBUFFER_COMPLETE;
              return t2.bindTexture(t2.TEXTURE_2D, null), t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteTexture(e2), t2.deleteFramebuffer(r2), i2;
            }
            checkRenderFloat32() {
              if (2 === this.version) {
                if (!this.colorBufferFloatExtension)
                  return false;
              } else if (!this.textureFloatExtension)
                return false;
              return this.isFloatTextureAttachableToFrameBuffer;
            }
            checkFloat32Download() {
              if (2 === this.version) {
                if (!this.colorBufferFloatExtension)
                  return false;
              } else {
                if (!this.textureFloatExtension)
                  return false;
                if (!this.gl.getExtension("WEBGL_color_buffer_float"))
                  return false;
              }
              return this.isFloatTextureAttachableToFrameBuffer;
            }
            checkFloat32Blend() {
              const t2 = this.gl;
              let e2, n2, r2, i2, o2;
              try {
                e2 = t2.createTexture(), n2 = t2.createFramebuffer(), t2.bindTexture(t2.TEXTURE_2D, e2);
                const a2 = 2 === this.version ? t2.RGBA32F : t2.RGBA;
                return t2.texImage2D(t2.TEXTURE_2D, 0, a2, 1, 1, 0, t2.RGBA, t2.FLOAT, null), t2.bindFramebuffer(t2.FRAMEBUFFER, n2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), t2.enable(t2.BLEND), r2 = t2.createShader(t2.VERTEX_SHADER), !!r2 && (t2.shaderSource(r2, "void main(){}"), t2.compileShader(r2), i2 = t2.createShader(t2.FRAGMENT_SHADER), !!i2 && (t2.shaderSource(i2, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), t2.compileShader(i2), o2 = t2.createProgram(), !!o2 && (t2.attachShader(o2, r2), t2.attachShader(o2, i2), t2.linkProgram(o2), t2.useProgram(o2), t2.drawArrays(t2.POINTS, 0, 1), t2.getError() === t2.NO_ERROR)));
              } finally {
                t2.disable(t2.BLEND), o2 && t2.deleteProgram(o2), r2 && t2.deleteShader(r2), i2 && t2.deleteShader(i2), n2 && (t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteFramebuffer(n2)), e2 && (t2.bindTexture(t2.TEXTURE_2D, null), t2.deleteTexture(e2));
              }
            }
            beginTimer() {
              if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
                const t2 = this.gl, e2 = this.disjointTimerQueryWebgl2Extension, n2 = t2.createQuery();
                return t2.beginQuery(e2.TIME_ELAPSED_EXT, n2), n2;
              }
              throw new Error("WebGL1 profiling currently not supported.");
            }
            endTimer() {
              if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
                throw new Error("WebGL1 profiling currently not supported");
              {
                const t2 = this.gl, e2 = this.disjointTimerQueryWebgl2Extension;
                t2.endQuery(e2.TIME_ELAPSED_EXT);
              }
            }
            isTimerResultAvailable(t2) {
              let e2 = false, n2 = false;
              if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
                throw new Error("WebGL1 profiling currently not supported");
              {
                const r2 = this.gl, i2 = this.disjointTimerQueryWebgl2Extension;
                e2 = r2.getQueryParameter(t2, r2.QUERY_RESULT_AVAILABLE), n2 = r2.getParameter(i2.GPU_DISJOINT_EXT);
              }
              return e2 && !n2;
            }
            getTimerResult(t2) {
              let e2 = 0;
              if (2 !== this.version)
                throw new Error("WebGL1 profiling currently not supported");
              {
                const n2 = this.gl;
                e2 = n2.getQueryParameter(t2, n2.QUERY_RESULT), n2.deleteQuery(t2);
              }
              return e2 / 1e6;
            }
            async waitForQueryAndGetTime(t2) {
              return await (0, u.repeatedTry)(() => this.isTimerResultAvailable(t2)), this.getTimerResult(t2);
            }
            async createAndWaitForFence() {
              const t2 = this.createFence(this.gl);
              return this.pollFence(t2);
            }
            createFence(t2) {
              let e2;
              const n2 = t2, r2 = n2.fenceSync(n2.SYNC_GPU_COMMANDS_COMPLETE, 0);
              return t2.flush(), e2 = null === r2 ? () => true : () => {
                const t3 = n2.clientWaitSync(r2, 0, 0);
                return t3 === n2.ALREADY_SIGNALED || t3 === n2.CONDITION_SATISFIED;
              }, { query: r2, isFencePassed: e2 };
            }
            async pollFence(t2) {
              return new Promise((e2) => {
                this.addItemToPoll(() => t2.isFencePassed(), () => e2());
              });
            }
            pollItems() {
              const t2 = c(this.itemsToPoll.map((t3) => t3.isDoneFn));
              for (let e2 = 0; e2 <= t2; ++e2) {
                const { resolveFn: t3 } = this.itemsToPoll[e2];
                t3();
              }
              this.itemsToPoll = this.itemsToPoll.slice(t2 + 1);
            }
            async addItemToPoll(t2, e2) {
              this.itemsToPoll.push({ isDoneFn: t2, resolveFn: e2 }), this.itemsToPoll.length > 1 || await (0, u.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length));
            }
          };
        }, 1036: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.ExecutionPlan = void 0;
          const r = n(6231);
          class i {
            constructor(t2, e2) {
              this.op = t2, this.node = e2;
            }
          }
          e.ExecutionPlan = class {
            constructor(t2, e2, n2) {
              this.graph = t2, this.profiler = n2, this.initialize(e2);
            }
            initialize(t2) {
              this.profiler.event("session", "ExecutionPlan.initialize", () => {
                const e2 = this.graph.getNodes();
                if (e2.length !== t2.length)
                  throw new Error("The size of nodes and OPs do not match.");
                this._ops = t2.map((t3, n2) => new i(t3, e2[n2])), this.reset(), this._starter = [], this._ops.forEach((t3, e3) => {
                  let n2 = true;
                  for (const e4 of t3.node.inputs)
                    if (!this._values[e4] && -1 === this.graph.getInputIndices().indexOf(e4)) {
                      n2 = false;
                      break;
                    }
                  n2 && this._starter.push(e3);
                });
              });
            }
            reset() {
              this._values = this.graph.getValues().map((t2) => t2.tensor);
            }
            async execute(t2, e2) {
              return this.profiler.event("session", "ExecutionPlan.execute", async () => {
                this.reset();
                const n2 = t2.createInferenceHandler(), i2 = this.graph.getInputIndices();
                if (e2.length !== i2.length)
                  throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e2.length} expected: ${i2.length}`);
                e2.forEach((t3, e3) => {
                  const n3 = i2[e3];
                  this._values[n3] = t3;
                });
                const o = this._starter.slice(0), a = this.graph.getValues(), s = this.graph.getNodes();
                let u = 0;
                for (; u < o.length; ) {
                  const t3 = o[u++], e3 = this._ops[t3], i3 = e3.node.inputs.map((t4) => this._values[t4]);
                  if (-1 !== i3.indexOf(void 0))
                    throw new Error(`unresolved input detected: op: ${e3.node}`);
                  const c2 = i3;
                  r.Logger.verbose("ExecPlan", `Runing op:${e3.node.name} (${c2.map((t4, n3) => `'${e3.node.inputs[n3]}': ${t4.type}[${t4.dims.join(",")}]`).join(", ")})`);
                  const l = await this.profiler.event("node", e3.node.name, async () => e3.op.impl(n2, c2, e3.op.context));
                  if (l.length !== e3.node.outputs.length)
                    throw new Error("the size of output does not match model definition.");
                  l.forEach((t4, n3) => {
                    const r2 = e3.node.outputs[n3];
                    if (this._values[r2])
                      throw new Error(`output [${r2}] already has value: op:${e3.node.name}`);
                    this._values[r2] = t4;
                  });
                  const p = /* @__PURE__ */ new Set();
                  l.forEach((t4, n3) => {
                    const r2 = e3.node.outputs[n3];
                    for (const t5 of a[r2].to) {
                      const e4 = s[t5];
                      let n4 = true;
                      for (const t6 of e4.inputs)
                        if (!this._values[t6]) {
                          n4 = false;
                          break;
                        }
                      n4 && p.add(t5);
                    }
                  }), o.push(...p);
                }
                const c = [];
                for (let t3 = 0; t3 < this.graph.getOutputIndices().length; t3++) {
                  const e3 = this.graph.getOutputIndices()[t3], n3 = this._values[e3];
                  if (void 0 === n3)
                    throw new Error(`required output [${e3}] does not have value`);
                  0 === e3 ? await n3.getData() : n3.data, c.push(n3);
                }
                return r.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n2.dispose(), c;
              });
            }
          };
        }, 7070: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.Graph = void 0;
          const r = n(1446), i = n(7778), o = n(9395), a = n(9162), s = n(2517);
          var u = o.onnxruntime.experimental.fbs;
          e.Graph = { from: (t2, e2) => new p(t2, e2) };
          class c {
            constructor(t2) {
              this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, t2 && (this.type = s.ProtoUtil.tensorValueTypeFromProto(t2.type.tensorType));
            }
            get from() {
              return this._from;
            }
            get to() {
              return this._to;
            }
          }
          class l {
            constructor(t2, e2) {
              t2 instanceof r.onnx.NodeProto ? (this.name = t2.name, this.opType = t2.opType, this.attributes = new i.Attribute(t2.attribute)) : t2 instanceof u.Node && (this.name = null != e2 ? e2 : t2.name(), this.opType = t2.opType(), this.attributes = new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t2))), this.inputs = [], this.outputs = [], this.executeNode = true;
            }
          }
          class p {
            constructor(t2, e2) {
              if (!t2)
                throw new TypeError("graph is empty");
              this.buildGraph(t2), this.transformGraph(e2), this.checkIsAcyclic();
            }
            getInputIndices() {
              return this._allInputIndices;
            }
            getInputNames() {
              return this._allInputNames;
            }
            getOutputIndices() {
              return this._allOutputIndices;
            }
            getOutputNames() {
              return this._allOutputNames;
            }
            getValues() {
              return this._allData;
            }
            getNodes() {
              return this._nodes;
            }
            buildGraph(t2) {
              if (t2 instanceof r.onnx.GraphProto)
                this.buildGraphFromOnnxFormat(t2);
              else {
                if (!(t2 instanceof u.Graph))
                  throw new TypeError("Graph type is not supported.");
                this.buildGraphFromOrtFormat(t2);
              }
            }
            buildGraphFromOnnxFormat(t2) {
              const e2 = /* @__PURE__ */ new Map();
              this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
              const n2 = /* @__PURE__ */ new Map();
              if (!t2.input)
                throw new Error("missing information in graph: input");
              const r2 = [];
              for (const n3 of t2.input) {
                if (e2.has(n3.name))
                  throw new Error(`duplicated input name: ${n3.name}`);
                const t3 = this._allData.push(new c(n3)) - 1;
                e2.set(n3.name, t3), r2.push(n3.name);
              }
              if (!t2.initializer)
                throw new Error("missing information in graph: initializer");
              for (const n3 of t2.initializer) {
                let t3 = e2.get(n3.name);
                if (void 0 === t3) {
                  const r3 = new c();
                  r3.type = { shape: { dims: s.ProtoUtil.tensorDimsFromProto(n3.dims) }, tensorType: s.ProtoUtil.tensorDataTypeFromProto(n3.dataType) }, t3 = this._allData.push(r3) - 1, e2.set(n3.name, t3);
                }
                this._allData[t3]._from = -1, this._allData[t3].tensor = a.Tensor.fromProto(n3);
              }
              for (let t3 = 0; t3 < this._allData.length; t3++)
                this._allData[t3].tensor || (this._allInputIndices.push(t3), this._allInputNames.push(r2[t3]));
              if (!t2.output)
                throw new Error("missing information in graph: output");
              for (const n3 of t2.output) {
                if (e2.has(n3.name))
                  throw new Error(`duplicated output name: ${n3.name}`);
                const t3 = this._allData.push(new c(n3)) - 1;
                e2.set(n3.name, t3), this._allOutputIndices.push(t3), this._allOutputNames.push(n3.name);
              }
              if (!t2.node)
                throw new Error("missing information in graph: node");
              for (const e3 of t2.node) {
                if (!e3.name)
                  for (let t4 = 0; ; t4++) {
                    const r3 = `unnamed_${e3.opType}_${t4}`;
                    if (!n2.has(r3)) {
                      e3.name = r3;
                      break;
                    }
                  }
                if (n2.has(e3.name))
                  throw new Error(`duplicated node name: ${e3.name}`);
                const t3 = this._nodes.push(new l(e3)) - 1;
                n2.set(e3.name, t3);
              }
              for (let n3 = 0; n3 < this._nodes.length; n3++) {
                const r3 = this._nodes[n3], i2 = t2.node[n3];
                if (!i2.output)
                  throw new Error(`missing output for node: ${i2.name}`);
                for (const t3 of i2.output) {
                  let o2 = e2.get(t3);
                  if (void 0 === o2 && (o2 = this._allData.push(new c()) - 1, e2.set(t3, o2)), r3.outputs.push(o2), void 0 !== this._allData[o2]._from)
                    throw new Error(`multiple nodes output to one data value: ${o2}`);
                  if (this._allData[o2]._from = n3, "Constant" === i2.opType) {
                    if (!i2.attribute || 1 !== i2.attribute.length || !i2.attribute[0].t)
                      throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                    if (!i2.output || 1 !== i2.output.length)
                      throw new Error("missing output or incorrect number of outputs for this Constant operator");
                    r3.outputs.pop(), r3.executeNode = false, this._allData[o2]._from = -1, this._allData[o2].tensor = a.Tensor.fromProto(i2.attribute[0].t);
                  }
                }
              }
              for (let n3 = 0; n3 < this._nodes.length; n3++) {
                const r3 = this._nodes[n3], i2 = t2.node[n3];
                if (!i2.input)
                  throw new Error(`missing input for node: ${i2.name}`);
                for (const t3 of i2.input) {
                  const o2 = e2.get(t3);
                  if (void 0 === o2) {
                    if ("" === t3 && 3 === i2.input.length && "Resize" === i2.opType)
                      continue;
                    throw new Error(`unrecognized input '${t3}' for node: ${i2.name}`);
                  }
                  r3.inputs.push(o2), this._allData[o2]._to.push(n3);
                }
              }
              return true;
            }
            buildGraphFromOrtFormat(t2) {
              var e2, n2, r2;
              const i2 = /* @__PURE__ */ new Map();
              this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
              const o2 = /* @__PURE__ */ new Map(), p2 = [];
              for (let o3 = 0; o3 < t2.inputsLength(); o3++) {
                const a2 = t2.inputs(o3);
                if (i2.has(a2))
                  throw new Error(`duplicated input name: ${a2}`);
                for (let o4 = 0; o4 < t2.nodeArgsLength(); o4++)
                  if ((null === (e2 = t2.nodeArgs(o4)) || void 0 === e2 ? void 0 : e2.name()) === a2) {
                    const e3 = new c();
                    if ((null === (r2 = null === (n2 = t2.nodeArgs(o4)) || void 0 === n2 ? void 0 : n2.type()) || void 0 === r2 ? void 0 : r2.valueType()) !== u.TypeInfoValue.tensor_type)
                      throw new Error("Unexpected value type for the nodeArg.");
                    const l2 = t2.nodeArgs(o4).type().value(new u.TensorTypeAndShape()), f = s.ProtoUtil.tensorDataTypeFromProto(l2.elemType()), d = l2.shape(), h = [];
                    for (let t3 = 0; t3 < d.dimLength(); t3++)
                      h.push(s.LongUtil.longToNumber(d.dim(t3).value().dimValue()));
                    e3.type = { shape: { dims: h }, tensorType: f };
                    const g = this._allData.push(e3) - 1;
                    i2.set(a2, g), p2.push(a2);
                  }
              }
              for (let e3 = 0; e3 < t2.initializersLength(); e3++) {
                const n3 = t2.initializers(e3);
                let r3 = i2.get(n3.name());
                if (void 0 === r3) {
                  const t3 = new c(), e4 = s.ProtoUtil.tensorDimsFromORTFormat(n3), o3 = s.ProtoUtil.tensorDataTypeFromProto(n3.dataType());
                  t3.type = { shape: { dims: e4 }, tensorType: o3 }, r3 = this._allData.push(t3) - 1, i2.set(n3.name(), r3);
                }
                this._allData[r3]._from = -1, this._allData[r3].tensor = a.Tensor.fromOrtTensor(n3);
              }
              for (let t3 = 0; t3 < this._allData.length; t3++)
                this._allData[t3].tensor || (this._allInputIndices.push(t3), this._allInputNames.push(p2[t3]));
              for (let e3 = 0; e3 < t2.outputsLength(); e3++) {
                const n3 = t2.outputs(e3);
                if (i2.has(n3))
                  throw new Error(`duplicated output name: ${n3}`);
                const r3 = this._allData.push(new c()) - 1;
                i2.set(n3, r3), this._allOutputIndices.push(r3), this._allOutputNames.push(n3);
              }
              if (!t2.nodes)
                throw new Error("missing information in graph: node");
              for (let e3 = 0; e3 < t2.nodesLength(); e3++) {
                const n3 = t2.nodes(e3);
                let r3 = n3.name();
                if (!r3)
                  for (let t3 = 0; r3 = `unnamed_${n3.opType()}_${t3}`, o2.has(r3); t3++)
                    ;
                if (o2.has(r3))
                  throw new Error(`duplicated node name: ${r3}`);
                const i3 = this._nodes.push(new l(n3, r3)) - 1;
                o2.set(r3, i3);
              }
              for (let e3 = 0; e3 < this._nodes.length; e3++) {
                const n3 = this._nodes[e3], r3 = t2.nodes(e3);
                if (null == r3)
                  throw new Error(`No node exists at index ${e3}`);
                if (0 === (null == r3 ? void 0 : r3.outputsLength()))
                  throw new Error(`missing output for node: ${r3.name}`);
                for (let t3 = 0; t3 < (null == r3 ? void 0 : r3.outputsLength()); t3++) {
                  const o3 = null == r3 ? void 0 : r3.outputs(t3);
                  let s2 = i2.get(o3);
                  if (void 0 === s2 && (s2 = this._allData.push(new c()) - 1, i2.set(o3, s2)), n3.outputs.push(s2), void 0 !== this._allData[s2]._from)
                    throw new Error(`multiple nodes output to one data value: ${s2}`);
                  if (this._allData[s2]._from = e3, "Constant" === r3.opType()) {
                    if (1 !== r3.attributesLength() || !r3.attributes(0).t())
                      throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                    if (1 !== r3.outputsLength())
                      throw new Error("missing output or incorrect number of outputs for this Constant operator");
                    n3.outputs.pop(), n3.executeNode = false, this._allData[s2]._from = -1, this._allData[s2].tensor = a.Tensor.fromOrtTensor(r3.attributes(0).t());
                  }
                }
              }
              for (let e3 = 0; e3 < this._nodes.length; e3++) {
                const n3 = this._nodes[e3], r3 = t2.nodes(e3);
                if (0 === r3.inputsLength())
                  throw new Error(`missing input for node: ${r3.name}`);
                for (let t3 = 0; t3 < r3.inputsLength(); t3++) {
                  const o3 = r3.inputs(t3), a2 = i2.get(o3);
                  if (void 0 === a2)
                    throw new Error(`unrecognized input '${o3}' for node: ${r3.name()}`);
                  n3.inputs.push(a2), this._allData[a2]._to.push(e3);
                }
              }
            }
            checkIsAcyclic() {
              const t2 = /* @__PURE__ */ new Set();
              this._allInputIndices.forEach((e3) => {
                this._allData[e3]._to.forEach((e4) => {
                  t2.add(e4);
                });
              });
              const e2 = Array.from(t2), n2 = new Array(this._nodes.length).fill("white");
              for (; e2.length > 0; ) {
                const t3 = e2.pop();
                "gray" === n2[t3] ? n2[t3] = "black" : (e2.push(t3), n2[t3] = "gray", this._nodes[t3].outputs.forEach((r2) => {
                  const i2 = this._allData[r2];
                  if (void 0 !== i2.tensor)
                    throw new Error("node outputs should not be initialized");
                  if (i2._from !== t3)
                    throw new Error("from property of the Value object doesn't match index of Node being processed");
                  i2._to.forEach((t4) => {
                    if ("gray" === n2[t4])
                      throw new Error("model graph is cyclic");
                    "white" === n2[t4] && e2.push(t4);
                  });
                }));
              }
            }
            transformGraph(t2) {
              this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), t2 && t2.transformGraph(this), this.finalizeGraph();
            }
            finalizeGraph() {
              let t2 = 0;
              for (let e2 = 0; e2 < this._nodes.length; e2++)
                this._nodes[e2].executeNode ? t2 > 0 && (this._nodes[e2].inputs.forEach((n2) => {
                  const r2 = this._allData[n2]._to.indexOf(e2 + t2);
                  -1 !== r2 && (this._allData[n2]._to[r2] = e2);
                }), this._nodes[e2].outputs.forEach((n2) => {
                  this._allData[n2]._from && this._allData[n2]._from === e2 + t2 && (this._allData[n2]._from = e2);
                })) : (t2++, this._nodes[e2].outputs.forEach((t3) => {
                  this._allData[t3]._from = -2;
                }), this._nodes.splice(e2, 1), e2--);
              t2 = 0;
              for (let e2 = 0; e2 < this._allData.length; e2++)
                if (-2 !== this._allData[e2].from || -1 !== this._allOutputIndices.indexOf(e2 + t2)) {
                  if (t2 > 0) {
                    let n2 = -1;
                    void 0 !== this._allData[e2].from && -1 !== this._allData[e2].from ? (n2 = this._nodes[this._allData[e2].from].outputs.indexOf(e2 + t2), -1 !== n2 && (this._nodes[this._allData[e2].from].outputs[n2] = e2)) : (n2 = this._allInputIndices.indexOf(e2 + t2), -1 !== n2 && (this._allInputIndices[n2] = e2)), this._allData[e2].to.forEach((r2) => {
                      n2 = this._nodes[r2].inputs.indexOf(e2 + t2), -1 !== n2 && (this._nodes[r2].inputs[n2] = e2);
                    }), 0 === this._allData[e2].to.length && (n2 = this._allOutputIndices.indexOf(e2 + t2), -1 !== n2 && (this._allOutputIndices[n2] = e2));
                  }
                } else
                  t2++, this._allData.splice(e2, 1), e2--;
            }
            deleteNode(t2) {
              const e2 = this._nodes[t2];
              if (e2.outputs.length > 1) {
                for (let t3 = 1; t3 < e2.outputs.length; t3++)
                  if (this._allData[e2.outputs[t3]].to.length > 0)
                    throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
              }
              e2.executeNode = false;
              const n2 = e2.inputs[0], r2 = e2.outputs[0], i2 = this._allData[r2].to, o2 = this._allData[n2].to.indexOf(t2);
              if (-1 === o2)
                throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
              this._allData[n2].to.splice(o2, 1), this._allData[r2]._to = [];
              const a2 = this._allOutputIndices.indexOf(r2);
              if (-1 !== a2 && (this._allOutputIndices[a2] = n2), i2 && i2.length > 0)
                for (const t3 of i2) {
                  const e3 = this._nodes[t3].inputs.indexOf(r2);
                  if (-1 === e3)
                    throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                  this._nodes[t3].inputs[e3] = n2, this._allData[n2].to.push(t3);
                }
            }
            removeAllDropoutNodes() {
              let t2 = 0;
              for (const e2 of this._nodes) {
                if ("Dropout" === e2.opType) {
                  if (1 !== e2.inputs.length)
                    throw new Error("Dropout nodes should only contain one input. ");
                  if (1 !== e2.outputs.length && 2 !== e2.outputs.length)
                    throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                  if (2 === e2.outputs.length && 0 !== this._allData[e2.outputs[1]]._to.length)
                    throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                  this.deleteNode(t2);
                }
                t2++;
              }
            }
            removeAllIdentityNodes() {
              let t2 = 0;
              for (const e2 of this._nodes)
                "Identity" === e2.opType && this.deleteNode(t2), t2++;
            }
            isActivation(t2) {
              switch (t2.opType) {
                case "Relu":
                case "Sigmoid":
                case "Clip":
                  return true;
                default:
                  return false;
              }
            }
            fuseConvActivationNodes() {
              for (const t2 of this._nodes)
                if ("Conv" === t2.opType) {
                  const e2 = this._allData[t2.outputs[0]]._to;
                  if (1 === e2.length && this.isActivation(this._nodes[e2[0]])) {
                    const n2 = this._nodes[e2[0]];
                    if ("Clip" === n2.opType)
                      if (1 === n2.inputs.length)
                        try {
                          t2.attributes.set("activation_params", "floats", [n2.attributes.getFloat("min"), n2.attributes.getFloat("max")]);
                        } catch (e3) {
                          t2.attributes.set("activation_params", "floats", [s.MIN_CLIP, s.MAX_CLIP]);
                        }
                      else {
                        if (!(n2.inputs.length >= 3 && void 0 !== this._allData[n2.inputs[1]].tensor && void 0 !== this._allData[n2.inputs[2]].tensor))
                          continue;
                        t2.attributes.set("activation_params", "floats", [this._allData[n2.inputs[1]].tensor.floatData[0], this._allData[n2.inputs[2]].tensor.floatData[0]]);
                      }
                    t2.attributes.set("activation", "string", n2.opType), this.deleteNode(e2[0]);
                  }
                }
            }
          }
        }, 6231: (t, e) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.now = e.Profiler = e.Logger = void 0;
          const n = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r = { none: new class {
            log(t2, e2, n2) {
            }
          }(), console: new class {
            log(t2, e2, n2) {
              console.log(`${this.color(t2)} ${n2 ? "\x1B[35m" + n2 + "\x1B[0m " : ""}${e2}`);
            }
            color(t2) {
              switch (t2) {
                case "verbose":
                  return "\x1B[34;40mv\x1B[0m";
                case "info":
                  return "\x1B[32mi\x1B[0m";
                case "warning":
                  return "\x1B[30;43mw\x1B[0m";
                case "error":
                  return "\x1B[31;40me\x1B[0m";
                case "fatal":
                  return "\x1B[101mf\x1B[0m";
                default:
                  throw new Error(`unsupported severity: ${t2}`);
              }
            }
          }() }, i = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
          let o = { "": i };
          function a(t2, e2, n2, r2) {
            if (void 0 === e2)
              return i2 = t2, { verbose: a.verbose.bind(null, i2), info: a.info.bind(null, i2), warning: a.warning.bind(null, i2), error: a.error.bind(null, i2), fatal: a.fatal.bind(null, i2) };
            if (void 0 === n2)
              s(t2, e2);
            else if ("number" == typeof n2 && void 0 === r2)
              s(t2, e2);
            else if ("string" == typeof n2 && void 0 === r2)
              s(t2, n2, 0, e2);
            else {
              if ("string" != typeof n2 || "number" != typeof r2)
                throw new TypeError("input is valid");
              s(t2, n2, 0, e2);
            }
            var i2;
          }
          function s(t2, e2, i2, a2) {
            const s2 = o[a2 || ""] || o[""];
            n[t2] < n[s2.minimalSeverity] || (s2.logDateTime && (e2 = `${(/* @__PURE__ */ new Date()).toISOString()}|${e2}`), s2.logSourceLocation, r[s2.provider].log(t2, e2, a2));
          }
          !function(t2) {
            function e2(t3) {
              o = {}, n2("", t3 || {});
            }
            function n2(t3, n3) {
              if ("*" === t3)
                e2(n3);
              else {
                const e3 = o[t3] || i;
                o[t3] = { provider: n3.provider || e3.provider, minimalSeverity: n3.minimalSeverity || e3.minimalSeverity, logDateTime: void 0 === n3.logDateTime ? e3.logDateTime : n3.logDateTime, logSourceLocation: void 0 === n3.logSourceLocation ? e3.logSourceLocation : n3.logSourceLocation };
              }
            }
            t2.verbose = function(e3, n3) {
              t2("verbose", e3, n3);
            }, t2.info = function(e3, n3) {
              t2("info", e3, n3);
            }, t2.warning = function(e3, n3) {
              t2("warning", e3, n3);
            }, t2.error = function(e3, n3) {
              t2("error", e3, n3);
            }, t2.fatal = function(e3, n3) {
              t2("fatal", e3, n3);
            }, t2.reset = e2, t2.set = n2, t2.setWithEnv = function(t3) {
              const e3 = {};
              t3.logLevel && (e3.minimalSeverity = t3.logLevel), n2("", e3);
            };
          }(a || (a = {})), e.Logger = a;
          class u {
            constructor(t2, e2, n2, r2, i2, o2) {
              this.category = t2, this.name = e2, this.startTime = n2, this.endCallback = r2, this.timer = i2, this.ctx = o2;
            }
            end() {
              return this.endCallback(this);
            }
            async checkTimer() {
              if (void 0 === this.ctx || void 0 === this.timer)
                throw new Error("No webgl timer found");
              return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
            }
          }
          class c {
            constructor(t2, e2, n2, r2) {
              this.category = t2, this.name = e2, this.startTime = n2, this.endTime = r2;
            }
          }
          e.Profiler = class {
            static create(t2) {
              return void 0 === t2 ? new this() : new this(t2.maxNumberEvents, t2.flushBatchSize, t2.flushIntervalInMilliseconds);
            }
            constructor(t2, e2, n2) {
              this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === t2 ? 1e4 : t2, this._flushBatchSize = void 0 === e2 ? 10 : e2, this._flushIntervalInMilliseconds = void 0 === n2 ? 5e3 : n2;
            }
            start() {
              this._started = true, this._timingEvents = [], this._flushTime = (0, e.now)(), this._flushPointer = 0;
            }
            stop() {
              for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++)
                this.logOneEvent(this._timingEvents[this._flushPointer]);
            }
            event(t2, e2, n2, r2) {
              const i2 = this._started ? this.begin(t2, e2, r2) : void 0;
              let o2 = false;
              const a2 = n2();
              if (a2 && "function" == typeof a2.then)
                return o2 = true, new Promise((t3, e3) => {
                  a2.then(async (e4) => {
                    i2 && await i2.end(), t3(e4);
                  }, async (t4) => {
                    i2 && await i2.end(), e3(t4);
                  });
                });
              if (!o2 && i2) {
                const t3 = i2.end();
                if (t3 && "function" == typeof t3.then)
                  return new Promise((e3, n3) => {
                    t3.then(() => {
                      e3(a2);
                    }, (t4) => {
                      n3(t4);
                    });
                  });
              }
              return a2;
            }
            begin(t2, n2, r2) {
              if (!this._started)
                throw new Error("profiler is not started yet");
              if (void 0 === r2) {
                const r3 = (0, e.now)();
                return this.flush(r3), new u(t2, n2, r3, (t3) => this.endSync(t3));
              }
              {
                const e2 = r2.beginTimer();
                return new u(t2, n2, 0, async (t3) => this.end(t3), e2, r2);
              }
            }
            async end(t2) {
              const e2 = await t2.checkTimer();
              this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t2.category, t2.name, t2.startTime, e2)), this.flush(e2));
            }
            endSync(t2) {
              const n2 = (0, e.now)();
              this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t2.category, t2.name, t2.startTime, n2)), this.flush(n2));
            }
            logOneEvent(t2) {
              e.Logger.verbose(`Profiler.${t2.category}`, `${(t2.endTime - t2.startTime).toFixed(2)}ms on event '${t2.name}' at ${t2.endTime.toFixed(2)}`);
            }
            flush(t2) {
              if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || t2 - this._flushTime >= this._flushIntervalInMilliseconds) {
                for (const t3 = this._flushPointer; this._flushPointer < t3 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)
                  this.logOneEvent(this._timingEvents[this._flushPointer]);
                this._flushTime = (0, e.now)();
              }
            }
            get started() {
              return this._started;
            }
          }, e.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
        }, 2644: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.Model = void 0;
          const r = n(5686), i = n(1446), o = n(7070), a = n(9395), s = n(2517);
          var u = a.onnxruntime.experimental.fbs;
          e.Model = class {
            constructor() {
            }
            load(t2, e2, n2) {
              if (!n2)
                try {
                  return void this.loadFromOnnxFormat(t2, e2);
                } catch (t3) {
                  if (void 0 !== n2)
                    throw t3;
                }
              this.loadFromOrtFormat(t2, e2);
            }
            loadFromOnnxFormat(t2, e2) {
              const n2 = i.onnx.ModelProto.decode(t2);
              if (s.LongUtil.longToNumber(n2.irVersion) < 3)
                throw new Error("only support ONNX model with IR_VERSION>=3");
              this._opsets = n2.opsetImport.map((t3) => ({ domain: t3.domain, version: s.LongUtil.longToNumber(t3.version) })), this._graph = o.Graph.from(n2.graph, e2);
            }
            loadFromOrtFormat(t2, e2) {
              const n2 = new r.flatbuffers.ByteBuffer(t2), i2 = u.InferenceSession.getRootAsInferenceSession(n2).model();
              if (s.LongUtil.longToNumber(i2.irVersion()) < 3)
                throw new Error("only support ONNX model with IR_VERSION>=3");
              this._opsets = [];
              for (let t3 = 0; t3 < i2.opsetImportLength(); t3++) {
                const e3 = i2.opsetImport(t3);
                this._opsets.push({ domain: null == e3 ? void 0 : e3.domain(), version: s.LongUtil.longToNumber(e3.version()) });
              }
              this._graph = o.Graph.from(i2.graph(), e2);
            }
            get graph() {
              return this._graph;
            }
            get opsets() {
              return this._opsets;
            }
          };
        }, 782: (t, e) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.FLOAT_TYPES = e.INT_TYPES = e.NUMBER_TYPES = void 0, e.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], e.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], e.FLOAT_TYPES = ["float32", "float64"];
        }, 1047: (t, e) => {
          "use strict";
          function n(t2, e2) {
            if (e2.endsWith("+")) {
              const n2 = Number.parseInt(e2.substring(0, e2.length - 1), 10);
              return !isNaN(n2) && n2 <= t2;
            }
            if (2 === e2.split("-").length) {
              const n2 = e2.split("-"), r = Number.parseInt(n2[0], 10), i = Number.parseInt(n2[1], 10);
              return !isNaN(r) && !isNaN(i) && r <= t2 && t2 <= i;
            }
            return Number.parseInt(e2, 10) === t2;
          }
          Object.defineProperty(e, "__esModule", { value: true }), e.resolveOperator = void 0, e.resolveOperator = function(t2, e2, r) {
            for (const i of r) {
              const r2 = i[0], o = i[1], a = i[2], s = i[3], u = i[4];
              if (t2.opType === r2) {
                for (const t3 of e2)
                  if ((t3.domain === o || "ai.onnx" === t3.domain && "" === o) && n(t3.version, a))
                    return { opImpl: s, opInit: u };
              }
            }
            throw new TypeError(`cannot resolve operator '${t2.opType}' with opsets: ${e2.map((t3) => `${t3.domain || "ai.onnx"} v${t3.version}`).join(", ")}`);
          };
        }, 9395: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.onnxruntime = void 0;
          const r = n(5686);
          var i, o;
          i = e.onnxruntime || (e.onnxruntime = {}), function(t2) {
            let e2;
            !function(t3) {
              t3[t3.UNDEFINED = 0] = "UNDEFINED", t3[t3.FLOAT = 1] = "FLOAT", t3[t3.INT = 2] = "INT", t3[t3.STRING = 3] = "STRING", t3[t3.TENSOR = 4] = "TENSOR", t3[t3.GRAPH = 5] = "GRAPH", t3[t3.FLOATS = 6] = "FLOATS", t3[t3.INTS = 7] = "INTS", t3[t3.STRINGS = 8] = "STRINGS", t3[t3.TENSORS = 9] = "TENSORS", t3[t3.GRAPHS = 10] = "GRAPHS", t3[t3.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", t3[t3.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
            }(e2 = t2.AttributeType || (t2.AttributeType = {}));
          }((o = i.experimental || (i.experimental = {})).fbs || (o.fbs = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                let e2;
                !function(t5) {
                  t5[t5.UNKNOWN = 0] = "UNKNOWN", t5[t5.VALUE = 1] = "VALUE", t5[t5.PARAM = 2] = "PARAM";
                }(e2 = t4.DimensionValueType || (t4.DimensionValueType = {}));
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                let e2;
                !function(t5) {
                  t5[t5.UNDEFINED = 0] = "UNDEFINED", t5[t5.FLOAT = 1] = "FLOAT", t5[t5.UINT8 = 2] = "UINT8", t5[t5.INT8 = 3] = "INT8", t5[t5.UINT16 = 4] = "UINT16", t5[t5.INT16 = 5] = "INT16", t5[t5.INT32 = 6] = "INT32", t5[t5.INT64 = 7] = "INT64", t5[t5.STRING = 8] = "STRING", t5[t5.BOOL = 9] = "BOOL", t5[t5.FLOAT16 = 10] = "FLOAT16", t5[t5.DOUBLE = 11] = "DOUBLE", t5[t5.UINT32 = 12] = "UINT32", t5[t5.UINT64 = 13] = "UINT64", t5[t5.COMPLEX64 = 14] = "COMPLEX64", t5[t5.COMPLEX128 = 15] = "COMPLEX128", t5[t5.BFLOAT16 = 16] = "BFLOAT16";
                }(e2 = t4.TensorDataType || (t4.TensorDataType = {}));
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                let e2;
                !function(t5) {
                  t5[t5.Primitive = 0] = "Primitive", t5[t5.Fused = 1] = "Fused";
                }(e2 = t4.NodeType || (t4.NodeType = {}));
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                let e2;
                !function(t5) {
                  t5[t5.NONE = 0] = "NONE", t5[t5.tensor_type = 1] = "tensor_type", t5[t5.sequence_type = 2] = "sequence_type", t5[t5.map_type = 3] = "map_type";
                }(e2 = t4.TypeInfoValue || (t4.TypeInfoValue = {}));
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsShape(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsShape(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  dim(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 4);
                    return r2 ? (n3 || new t2.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  dimLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startShape(t3) {
                    t3.startObject(1);
                  }
                  static addDim(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static createDimVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startDimVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endShape(t3) {
                    return t3.endObject();
                  }
                  static createShape(t3, e4) {
                    return n2.startShape(t3), n2.addDim(t3, e4), n2.endShape(t3);
                  }
                }
                e3.Shape = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsDimension(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsDimension(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  value(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (e4 || new t2.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  denotation(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  static startDimension(t3) {
                    t3.startObject(2);
                  }
                  static addValue(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDenotation(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static endDimension(t3) {
                    return t3.endObject();
                  }
                  static createDimension(t3, e4, r2) {
                    return n2.startDimension(t3), n2.addValue(t3, e4), n2.addDenotation(t3, r2), n2.endDimension(t3);
                  }
                }
                e3.Dimension = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsDimensionValue(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsDimensionValue(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  dimType() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.readInt8(this.bb_pos + e4) : t2.experimental.fbs.DimensionValueType.UNKNOWN;
                  }
                  dimValue() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                  }
                  dimParam(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  static startDimensionValue(t3) {
                    t3.startObject(3);
                  }
                  static addDimType(e4, n3) {
                    e4.addFieldInt8(0, n3, t2.experimental.fbs.DimensionValueType.UNKNOWN);
                  }
                  static addDimValue(t3, e4) {
                    t3.addFieldInt64(1, e4, t3.createLong(0, 0));
                  }
                  static addDimParam(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static endDimensionValue(t3) {
                    return t3.endObject();
                  }
                  static createDimensionValue(t3, e4, r2, i2) {
                    return n2.startDimensionValue(t3), n2.addDimType(t3, e4), n2.addDimValue(t3, r2), n2.addDimParam(t3, i2), n2.endDimensionValue(t3);
                  }
                }
                e3.DimensionValue = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsTensorTypeAndShape(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsTensorTypeAndShape(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  elemType() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  shape(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startTensorTypeAndShape(t3) {
                    t3.startObject(2);
                  }
                  static addElemType(e4, n3) {
                    e4.addFieldInt32(0, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addShape(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static endTensorTypeAndShape(t3) {
                    return t3.endObject();
                  }
                  static createTensorTypeAndShape(t3, e4, r2) {
                    return n2.startTensorTypeAndShape(t3), n2.addElemType(t3, e4), n2.addShape(t3, r2), n2.endTensorTypeAndShape(t3);
                  }
                }
                e3.TensorTypeAndShape = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsMapType(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsMapType(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  keyType() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  valueType(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startMapType(t3) {
                    t3.startObject(2);
                  }
                  static addKeyType(e4, n3) {
                    e4.addFieldInt32(0, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addValueType(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static endMapType(t3) {
                    return t3.endObject();
                  }
                  static createMapType(t3, e4, r2) {
                    return n2.startMapType(t3), n2.addKeyType(t3, e4), n2.addValueType(t3, r2), n2.endMapType(t3);
                  }
                }
                e3.MapType = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsSequenceType(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsSequenceType(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  elemType(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startSequenceType(t3) {
                    t3.startObject(1);
                  }
                  static addElemType(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static endSequenceType(t3) {
                    return t3.endObject();
                  }
                  static createSequenceType(t3, e4) {
                    return n2.startSequenceType(t3), n2.addElemType(t3, e4), n2.endSequenceType(t3);
                  }
                }
                e3.SequenceType = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              (t3.fbs || (t3.fbs = {})).EdgeEnd = class {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(t4, e2) {
                  return this.bb_pos = t4, this.bb = e2, this;
                }
                nodeIndex() {
                  return this.bb.readUint32(this.bb_pos);
                }
                srcArgIndex() {
                  return this.bb.readInt32(this.bb_pos + 4);
                }
                dstArgIndex() {
                  return this.bb.readInt32(this.bb_pos + 8);
                }
                static createEdgeEnd(t4, e2, n2, r2) {
                  return t4.prep(4, 12), t4.writeInt32(r2), t4.writeInt32(n2), t4.writeInt32(e2), t4.offset();
                }
              };
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsNodeEdge(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsNodeEdge(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  nodeIndex() {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                  }
                  inputEdges(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new t2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * e4, this.bb) : null;
                  }
                  inputEdgesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  outputEdges(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 8);
                    return r2 ? (n3 || new t2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * e4, this.bb) : null;
                  }
                  outputEdgesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 8);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startNodeEdge(t3) {
                    t3.startObject(3);
                  }
                  static addNodeIndex(t3, e4) {
                    t3.addFieldInt32(0, e4, 0);
                  }
                  static addInputEdges(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static startInputEdgesVector(t3, e4) {
                    t3.startVector(12, e4, 4);
                  }
                  static addOutputEdges(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static startOutputEdgesVector(t3, e4) {
                    t3.startVector(12, e4, 4);
                  }
                  static endNodeEdge(t3) {
                    return t3.endObject();
                  }
                  static createNodeEdge(t3, e4, r2, i2) {
                    return n2.startNodeEdge(t3), n2.addNodeIndex(t3, e4), n2.addInputEdges(t3, r2), n2.addOutputEdges(t3, i2), n2.endNodeEdge(t3);
                  }
                }
                e3.NodeEdge = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsNode(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsNode(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  name(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  domain(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  sinceVersion() {
                    let t3 = this.bb.__offset(this.bb_pos, 10);
                    return t3 ? this.bb.readInt32(this.bb_pos + t3) : 0;
                  }
                  index() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                  }
                  opType(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 14);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  type() {
                    let e4 = this.bb.__offset(this.bb_pos, 16);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.NodeType.Primitive;
                  }
                  executionProviderType(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 18);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  inputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 20);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  inputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 20);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  outputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 22);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  outputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 22);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  attributes(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 24);
                    return r2 ? (n3 || new t2.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  attributesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 24);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  inputArgCounts(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 26);
                    return e4 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e4) + 4 * t3) : 0;
                  }
                  inputArgCountsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 26);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  inputArgCountsArray() {
                    let t3 = this.bb.__offset(this.bb_pos, 26);
                    return t3 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                  }
                  implicitInputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 28);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  implicitInputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 28);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startNode(t3) {
                    t3.startObject(13);
                  }
                  static addName(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addDomain(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static addSinceVersion(t3, e4) {
                    t3.addFieldInt32(3, e4, 0);
                  }
                  static addIndex(t3, e4) {
                    t3.addFieldInt32(4, e4, 0);
                  }
                  static addOpType(t3, e4) {
                    t3.addFieldOffset(5, e4, 0);
                  }
                  static addType(e4, n3) {
                    e4.addFieldInt32(6, n3, t2.experimental.fbs.NodeType.Primitive);
                  }
                  static addExecutionProviderType(t3, e4) {
                    t3.addFieldOffset(7, e4, 0);
                  }
                  static addInputs(t3, e4) {
                    t3.addFieldOffset(8, e4, 0);
                  }
                  static createInputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startInputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addOutputs(t3, e4) {
                    t3.addFieldOffset(9, e4, 0);
                  }
                  static createOutputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startOutputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addAttributes(t3, e4) {
                    t3.addFieldOffset(10, e4, 0);
                  }
                  static createAttributesVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startAttributesVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addInputArgCounts(t3, e4) {
                    t3.addFieldOffset(11, e4, 0);
                  }
                  static createInputArgCountsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addInt32(e4[n3]);
                    return t3.endVector();
                  }
                  static startInputArgCountsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addImplicitInputs(t3, e4) {
                    t3.addFieldOffset(12, e4, 0);
                  }
                  static createImplicitInputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startImplicitInputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endNode(t3) {
                    return t3.endObject();
                  }
                  static createNode(t3, e4, r2, i2, o2, a, s, u, c, l, p, f, d, h) {
                    return n2.startNode(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addDomain(t3, i2), n2.addSinceVersion(t3, o2), n2.addIndex(t3, a), n2.addOpType(t3, s), n2.addType(t3, u), n2.addExecutionProviderType(t3, c), n2.addInputs(t3, l), n2.addOutputs(t3, p), n2.addAttributes(t3, f), n2.addInputArgCounts(t3, d), n2.addImplicitInputs(t3, h), n2.endNode(t3);
                  }
                }
                e3.Node = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsValueInfo(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsValueInfo(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  name(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  type(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 8);
                    return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startValueInfo(t3) {
                    t3.startObject(3);
                  }
                  static addName(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addType(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static endValueInfo(t3) {
                    return t3.endObject();
                  }
                  static createValueInfo(t3, e4, r2, i2) {
                    return n2.startValueInfo(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addType(t3, i2), n2.endValueInfo(t3);
                  }
                }
                e3.ValueInfo = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsTypeInfo(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsTypeInfo(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  denotation(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  valueType() {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.readUint8(this.bb_pos + e4) : t2.experimental.fbs.TypeInfoValue.NONE;
                  }
                  value(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__union(t3, this.bb_pos + e4) : null;
                  }
                  static startTypeInfo(t3) {
                    t3.startObject(3);
                  }
                  static addDenotation(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addValueType(e4, n3) {
                    e4.addFieldInt8(1, n3, t2.experimental.fbs.TypeInfoValue.NONE);
                  }
                  static addValue(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static endTypeInfo(t3) {
                    return t3.endObject();
                  }
                  static createTypeInfo(t3, e4, r2, i2) {
                    return n2.startTypeInfo(t3), n2.addDenotation(t3, e4), n2.addValueType(t3, r2), n2.addValue(t3, i2), n2.endTypeInfo(t3);
                  }
                }
                e3.TypeInfo = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                class e2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t5, e3) {
                    return this.bb_pos = t5, this.bb = e3, this;
                  }
                  static getRootAsOperatorSetId(t5, n2) {
                    return (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                  }
                  static getSizePrefixedRootAsOperatorSetId(t5, n2) {
                    return t5.setPosition(t5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                  }
                  domain(t5) {
                    let e3 = this.bb.__offset(this.bb_pos, 4);
                    return e3 ? this.bb.__string(this.bb_pos + e3, t5) : null;
                  }
                  version() {
                    let t5 = this.bb.__offset(this.bb_pos, 6);
                    return t5 ? this.bb.readInt64(this.bb_pos + t5) : this.bb.createLong(0, 0);
                  }
                  static startOperatorSetId(t5) {
                    t5.startObject(2);
                  }
                  static addDomain(t5, e3) {
                    t5.addFieldOffset(0, e3, 0);
                  }
                  static addVersion(t5, e3) {
                    t5.addFieldInt64(1, e3, t5.createLong(0, 0));
                  }
                  static endOperatorSetId(t5) {
                    return t5.endObject();
                  }
                  static createOperatorSetId(t5, n2, r2) {
                    return e2.startOperatorSetId(t5), e2.addDomain(t5, n2), e2.addVersion(t5, r2), e2.endOperatorSetId(t5);
                  }
                }
                t4.OperatorSetId = e2;
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsTensor(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsTensor(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  name(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  dims(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                  }
                  dimsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 8);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  dataType() {
                    let e4 = this.bb.__offset(this.bb_pos, 10);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  rawData(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e4) + t3) : 0;
                  }
                  rawDataLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  rawDataArray() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                  }
                  stringData(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 14);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  stringDataLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 14);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startTensor(t3) {
                    t3.startObject(6);
                  }
                  static addName(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addDims(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static createDimsVector(t3, e4) {
                    t3.startVector(8, e4.length, 8);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addInt64(e4[n3]);
                    return t3.endVector();
                  }
                  static startDimsVector(t3, e4) {
                    t3.startVector(8, e4, 8);
                  }
                  static addDataType(e4, n3) {
                    e4.addFieldInt32(3, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addRawData(t3, e4) {
                    t3.addFieldOffset(4, e4, 0);
                  }
                  static createRawDataVector(t3, e4) {
                    t3.startVector(1, e4.length, 1);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addInt8(e4[n3]);
                    return t3.endVector();
                  }
                  static startRawDataVector(t3, e4) {
                    t3.startVector(1, e4, 1);
                  }
                  static addStringData(t3, e4) {
                    t3.addFieldOffset(5, e4, 0);
                  }
                  static createStringDataVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startStringDataVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endTensor(t3) {
                    return t3.endObject();
                  }
                  static createTensor(t3, e4, r2, i2, o2, a, s) {
                    return n2.startTensor(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addDims(t3, i2), n2.addDataType(t3, o2), n2.addRawData(t3, a), n2.addStringData(t3, s), n2.endTensor(t3);
                  }
                }
                e3.Tensor = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsSparseTensor(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsSparseTensor(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  values(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  indices(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  dims(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                  }
                  dimsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 8);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startSparseTensor(t3) {
                    t3.startObject(3);
                  }
                  static addValues(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addIndices(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addDims(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static createDimsVector(t3, e4) {
                    t3.startVector(8, e4.length, 8);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addInt64(e4[n3]);
                    return t3.endVector();
                  }
                  static startDimsVector(t3, e4) {
                    t3.startVector(8, e4, 8);
                  }
                  static endSparseTensor(t3) {
                    return t3.endObject();
                  }
                  static createSparseTensor(t3, e4, r2, i2) {
                    return n2.startSparseTensor(t3), n2.addValues(t3, e4), n2.addIndices(t3, r2), n2.addDims(t3, i2), n2.endSparseTensor(t3);
                  }
                }
                e3.SparseTensor = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsAttribute(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsAttribute(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  name(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  type() {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.AttributeType.UNDEFINED;
                  }
                  f() {
                    let t3 = this.bb.__offset(this.bb_pos, 10);
                    return t3 ? this.bb.readFloat32(this.bb_pos + t3) : 0;
                  }
                  i() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                  }
                  s(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 14);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  t(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 16);
                    return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  g(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 18);
                    return n3 ? (e4 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  floats(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 20);
                    return e4 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e4) + 4 * t3) : 0;
                  }
                  floatsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 20);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  floatsArray() {
                    let t3 = this.bb.__offset(this.bb_pos, 20);
                    return t3 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                  }
                  ints(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 22);
                    return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                  }
                  intsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 22);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  strings(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 24);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  stringsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 24);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  tensors(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 26);
                    return r2 ? (n3 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  tensorsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 26);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  graphs(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 28);
                    return r2 ? (n3 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  graphsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 28);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startAttribute(t3) {
                    t3.startObject(13);
                  }
                  static addName(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addType(e4, n3) {
                    e4.addFieldInt32(2, n3, t2.experimental.fbs.AttributeType.UNDEFINED);
                  }
                  static addF(t3, e4) {
                    t3.addFieldFloat32(3, e4, 0);
                  }
                  static addI(t3, e4) {
                    t3.addFieldInt64(4, e4, t3.createLong(0, 0));
                  }
                  static addS(t3, e4) {
                    t3.addFieldOffset(5, e4, 0);
                  }
                  static addT(t3, e4) {
                    t3.addFieldOffset(6, e4, 0);
                  }
                  static addG(t3, e4) {
                    t3.addFieldOffset(7, e4, 0);
                  }
                  static addFloats(t3, e4) {
                    t3.addFieldOffset(8, e4, 0);
                  }
                  static createFloatsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addFloat32(e4[n3]);
                    return t3.endVector();
                  }
                  static startFloatsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addInts(t3, e4) {
                    t3.addFieldOffset(9, e4, 0);
                  }
                  static createIntsVector(t3, e4) {
                    t3.startVector(8, e4.length, 8);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addInt64(e4[n3]);
                    return t3.endVector();
                  }
                  static startIntsVector(t3, e4) {
                    t3.startVector(8, e4, 8);
                  }
                  static addStrings(t3, e4) {
                    t3.addFieldOffset(10, e4, 0);
                  }
                  static createStringsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startStringsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addTensors(t3, e4) {
                    t3.addFieldOffset(11, e4, 0);
                  }
                  static createTensorsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startTensorsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addGraphs(t3, e4) {
                    t3.addFieldOffset(12, e4, 0);
                  }
                  static createGraphsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startGraphsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endAttribute(t3) {
                    return t3.endObject();
                  }
                  static createAttribute(t3, e4, r2, i2, o2, a, s, u, c, l, p, f, d, h) {
                    return n2.startAttribute(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addType(t3, i2), n2.addF(t3, o2), n2.addI(t3, a), n2.addS(t3, s), n2.addT(t3, u), n2.addG(t3, c), n2.addFloats(t3, l), n2.addInts(t3, p), n2.addStrings(t3, f), n2.addTensors(t3, d), n2.addGraphs(t3, h), n2.endAttribute(t3);
                  }
                }
                e3.Attribute = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsGraph(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsGraph(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  initializers(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 4);
                    return r2 ? (n3 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  initializersLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  nodeArgs(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new t2.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  nodeArgsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  nodes(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 8);
                    return r2 ? (n3 || new t2.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  nodesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 8);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  maxNodeIndex() {
                    let t3 = this.bb.__offset(this.bb_pos, 10);
                    return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                  }
                  nodeEdges(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 12);
                    return r2 ? (n3 || new t2.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  nodeEdgesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  inputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 14);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  inputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 14);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  outputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 16);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  outputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 16);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  sparseInitializers(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 18);
                    return r2 ? (n3 || new t2.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  sparseInitializersLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 18);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startGraph(t3) {
                    t3.startObject(8);
                  }
                  static addInitializers(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static createInitializersVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startInitializersVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addNodeArgs(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static createNodeArgsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startNodeArgsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addNodes(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static createNodesVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startNodesVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addMaxNodeIndex(t3, e4) {
                    t3.addFieldInt32(3, e4, 0);
                  }
                  static addNodeEdges(t3, e4) {
                    t3.addFieldOffset(4, e4, 0);
                  }
                  static createNodeEdgesVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startNodeEdgesVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addInputs(t3, e4) {
                    t3.addFieldOffset(5, e4, 0);
                  }
                  static createInputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startInputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addOutputs(t3, e4) {
                    t3.addFieldOffset(6, e4, 0);
                  }
                  static createOutputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startOutputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addSparseInitializers(t3, e4) {
                    t3.addFieldOffset(7, e4, 0);
                  }
                  static createSparseInitializersVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startSparseInitializersVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endGraph(t3) {
                    return t3.endObject();
                  }
                  static createGraph(t3, e4, r2, i2, o2, a, s, u, c) {
                    return n2.startGraph(t3), n2.addInitializers(t3, e4), n2.addNodeArgs(t3, r2), n2.addNodes(t3, i2), n2.addMaxNodeIndex(t3, o2), n2.addNodeEdges(t3, a), n2.addInputs(t3, s), n2.addOutputs(t3, u), n2.addSparseInitializers(t3, c), n2.endGraph(t3);
                  }
                }
                e3.Graph = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsModel(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsModel(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  irVersion() {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                  }
                  opsetImport(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new t2.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  opsetImportLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  producerName(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  producerVersion(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 10);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  domain(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  modelVersion() {
                    let t3 = this.bb.__offset(this.bb_pos, 14);
                    return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 16);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  graph(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 18);
                    return n3 ? (e4 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  graphDocString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 20);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  static startModel(t3) {
                    t3.startObject(9);
                  }
                  static addIrVersion(t3, e4) {
                    t3.addFieldInt64(0, e4, t3.createLong(0, 0));
                  }
                  static addOpsetImport(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static createOpsetImportVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startOpsetImportVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addProducerName(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static addProducerVersion(t3, e4) {
                    t3.addFieldOffset(3, e4, 0);
                  }
                  static addDomain(t3, e4) {
                    t3.addFieldOffset(4, e4, 0);
                  }
                  static addModelVersion(t3, e4) {
                    t3.addFieldInt64(5, e4, t3.createLong(0, 0));
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(6, e4, 0);
                  }
                  static addGraph(t3, e4) {
                    t3.addFieldOffset(7, e4, 0);
                  }
                  static addGraphDocString(t3, e4) {
                    t3.addFieldOffset(8, e4, 0);
                  }
                  static endModel(t3) {
                    return t3.endObject();
                  }
                  static createModel(t3, e4, r2, i2, o2, a, s, u, c, l) {
                    return n2.startModel(t3), n2.addIrVersion(t3, e4), n2.addOpsetImport(t3, r2), n2.addProducerName(t3, i2), n2.addProducerVersion(t3, o2), n2.addDomain(t3, a), n2.addModelVersion(t3, s), n2.addDocString(t3, u), n2.addGraph(t3, c), n2.addGraphDocString(t3, l), n2.endModel(t3);
                  }
                }
                e3.Model = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                class e2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t5, e3) {
                    return this.bb_pos = t5, this.bb = e3, this;
                  }
                  static getRootAsKernelCreateInfos(t5, n2) {
                    return (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                  }
                  static getSizePrefixedRootAsKernelCreateInfos(t5, n2) {
                    return t5.setPosition(t5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                  }
                  nodeIndices(t5) {
                    let e3 = this.bb.__offset(this.bb_pos, 4);
                    return e3 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e3) + 4 * t5) : 0;
                  }
                  nodeIndicesLength() {
                    let t5 = this.bb.__offset(this.bb_pos, 4);
                    return t5 ? this.bb.__vector_len(this.bb_pos + t5) : 0;
                  }
                  nodeIndicesArray() {
                    let t5 = this.bb.__offset(this.bb_pos, 4);
                    return t5 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t5), this.bb.__vector_len(this.bb_pos + t5)) : null;
                  }
                  kernelDefHashes(t5) {
                    let e3 = this.bb.__offset(this.bb_pos, 6);
                    return e3 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e3) + 8 * t5) : this.bb.createLong(0, 0);
                  }
                  kernelDefHashesLength() {
                    let t5 = this.bb.__offset(this.bb_pos, 6);
                    return t5 ? this.bb.__vector_len(this.bb_pos + t5) : 0;
                  }
                  static startKernelCreateInfos(t5) {
                    t5.startObject(2);
                  }
                  static addNodeIndices(t5, e3) {
                    t5.addFieldOffset(0, e3, 0);
                  }
                  static createNodeIndicesVector(t5, e3) {
                    t5.startVector(4, e3.length, 4);
                    for (let n2 = e3.length - 1; n2 >= 0; n2--)
                      t5.addInt32(e3[n2]);
                    return t5.endVector();
                  }
                  static startNodeIndicesVector(t5, e3) {
                    t5.startVector(4, e3, 4);
                  }
                  static addKernelDefHashes(t5, e3) {
                    t5.addFieldOffset(1, e3, 0);
                  }
                  static createKernelDefHashesVector(t5, e3) {
                    t5.startVector(8, e3.length, 8);
                    for (let n2 = e3.length - 1; n2 >= 0; n2--)
                      t5.addInt64(e3[n2]);
                    return t5.endVector();
                  }
                  static startKernelDefHashesVector(t5, e3) {
                    t5.startVector(8, e3, 8);
                  }
                  static endKernelCreateInfos(t5) {
                    return t5.endObject();
                  }
                  static createKernelCreateInfos(t5, n2, r2) {
                    return e2.startKernelCreateInfos(t5), e2.addNodeIndices(t5, n2), e2.addKernelDefHashes(t5, r2), e2.endKernelCreateInfos(t5);
                  }
                }
                t4.KernelCreateInfos = e2;
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsSubGraphSessionState(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsSubGraphSessionState(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  graphId(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  sessionState(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startSubGraphSessionState(t3) {
                    t3.startObject(2);
                  }
                  static addGraphId(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addSessionState(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static endSubGraphSessionState(t3) {
                    let e4 = t3.endObject();
                    return t3.requiredField(e4, 4), e4;
                  }
                  static createSubGraphSessionState(t3, e4, r2) {
                    return n2.startSubGraphSessionState(t3), n2.addGraphId(t3, e4), n2.addSessionState(t3, r2), n2.endSubGraphSessionState(t3);
                  }
                }
                e3.SubGraphSessionState = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsSessionState(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsSessionState(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  kernels(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (e4 || new t2.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  subGraphSessionStates(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new t2.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  subGraphSessionStatesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startSessionState(t3) {
                    t3.startObject(2);
                  }
                  static addKernels(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addSubGraphSessionStates(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static createSubGraphSessionStatesVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--)
                      t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startSubGraphSessionStatesVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endSessionState(t3) {
                    return t3.endObject();
                  }
                  static createSessionState(t3, e4, r2) {
                    return n2.startSessionState(t3), n2.addKernels(t3, e4), n2.addSubGraphSessionStates(t3, r2), n2.endSessionState(t3);
                  }
                }
                e3.SessionState = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsInferenceSession(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsInferenceSession(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static bufferHasIdentifier(t3) {
                    return t3.__has_identifier("ORTM");
                  }
                  ortVersion(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  model(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  sessionState(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 8);
                    return n3 ? (e4 || new t2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startInferenceSession(t3) {
                    t3.startObject(3);
                  }
                  static addOrtVersion(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addModel(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addSessionState(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static endInferenceSession(t3) {
                    return t3.endObject();
                  }
                  static finishInferenceSessionBuffer(t3, e4) {
                    t3.finish(e4, "ORTM");
                  }
                  static finishSizePrefixedInferenceSessionBuffer(t3, e4) {
                    t3.finish(e4, "ORTM", true);
                  }
                  static createInferenceSession(t3, e4, r2, i2) {
                    return n2.startInferenceSession(t3), n2.addOrtVersion(t3, e4), n2.addModel(t3, r2), n2.addSessionState(t3, i2), n2.endInferenceSession(t3);
                  }
                }
                e3.InferenceSession = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {}));
        }, 7448: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.OnnxjsSessionHandler = void 0;
          const r = n(1670), i = n(9162);
          e.OnnxjsSessionHandler = class {
            constructor(t2) {
              this.session = t2, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
            }
            async dispose() {
            }
            async run(t2, e2, n2) {
              const o = /* @__PURE__ */ new Map();
              for (const e3 in t2)
                if (Object.hasOwnProperty.call(t2, e3)) {
                  const n3 = t2[e3];
                  o.set(e3, new i.Tensor(n3.dims, n3.type, void 0, void 0, n3.data));
                }
              const a = await this.session.run(o), s = {};
              return a.forEach((t3, e3) => {
                s[e3] = new r.Tensor(t3.type, t3.data, t3.dims);
              }), s;
            }
            startProfiling() {
              this.session.startProfiling();
            }
            endProfiling() {
              this.session.endProfiling();
            }
          };
        }, 6919: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.Session = void 0;
          const r = n(7067), i = n(1296), o = n(7091), a = n(1036), s = n(6231), u = n(2644);
          e.Session = class {
            constructor(t2 = {}) {
              this._initialized = false, this.backendHint = t2.backendHint, this.profiler = s.Profiler.create(t2.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
            }
            get inputNames() {
              return this._model.graph.getInputNames();
            }
            get outputNames() {
              return this._model.graph.getOutputNames();
            }
            startProfiling() {
              this.profiler.start();
            }
            endProfiling() {
              this.profiler.stop();
            }
            async loadModel(t2, e2, n2) {
              await this.profiler.event("session", "Session.loadModel", async () => {
                const a2 = await (0, o.resolveBackend)(this.backendHint);
                if (this.sessionHandler = a2.createSessionHandler(this.context), this._model = new u.Model(), "string" == typeof t2) {
                  const e3 = t2.endsWith(".ort");
                  if ("undefined" == typeof fetch) {
                    const n3 = await (0, i.promisify)(r.readFile)(t2);
                    this.initialize(n3, e3);
                  } else {
                    const n3 = await fetch(t2), r2 = await n3.arrayBuffer();
                    this.initialize(new Uint8Array(r2), e3);
                  }
                } else if (ArrayBuffer.isView(t2))
                  this.initialize(t2);
                else {
                  const r2 = new Uint8Array(t2, e2 || 0, n2 || t2.byteLength);
                  this.initialize(r2);
                }
              });
            }
            initialize(t2, e2) {
              if (this._initialized)
                throw new Error("already initialized");
              this.profiler.event("session", "Session.initialize", () => {
                const n2 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
                this._model.load(t2, n2, e2), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);
              }), this._initialized = true;
            }
            async run(t2) {
              if (!this._initialized)
                throw new Error("session not initialized yet");
              return this.profiler.event("session", "Session.run", async () => {
                const e2 = this.normalizeAndValidateInputs(t2), n2 = await this._executionPlan.execute(this.sessionHandler, e2);
                return this.createOutput(n2);
              });
            }
            normalizeAndValidateInputs(t2) {
              const e2 = this._model.graph.getInputNames();
              if (Array.isArray(t2)) {
                if (t2.length !== e2.length)
                  throw new Error(`incorrect input array length: expected ${e2.length} but got ${t2.length}`);
              } else {
                if (t2.size !== e2.length)
                  throw new Error(`incorrect input map size: expected ${e2.length} but got ${t2.size}`);
                const n2 = new Array(t2.size);
                let r2 = 0;
                for (let i2 = 0; i2 < e2.length; ++i2) {
                  const o2 = t2.get(e2[i2]);
                  if (!o2)
                    throw new Error(`missing input tensor for: '${name}'`);
                  n2[r2++] = o2;
                }
                t2 = n2;
              }
              if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length)
                this.validateInputTensorDims(this.context.graphInputDims, t2, false);
              else {
                const e3 = this._model.graph.getInputIndices(), n2 = this._model.graph.getValues(), r2 = new Array(e3.length);
                for (let i2 = 0; i2 < e3.length; ++i2) {
                  const o2 = n2[e3[i2]];
                  r2[i2] = o2.type.shape.dims, this.context.graphInputTypes.push(o2.type.tensorType), this.context.graphInputDims.push(t2[i2].dims);
                }
                this.validateInputTensorDims(r2, t2, true);
              }
              return this.validateInputTensorTypes(this.context.graphInputTypes, t2), t2;
            }
            validateInputTensorTypes(t2, e2) {
              for (let n2 = 0; n2 < e2.length; n2++) {
                const r2 = t2[n2], i2 = e2[n2].type;
                if (r2 !== i2)
                  throw new Error(`input tensor[${n2}] check failed: expected type '${r2}' but got ${i2}`);
              }
            }
            validateInputTensorDims(t2, e2, n2) {
              for (let r2 = 0; r2 < e2.length; r2++) {
                const i2 = t2[r2], o2 = e2[r2].dims;
                if (!this.compareTensorDims(i2, o2, n2))
                  throw new Error(`input tensor[${r2}] check failed: expected shape '[${i2.join(",")}]' but got [${o2.join(",")}]`);
              }
            }
            compareTensorDims(t2, e2, n2) {
              if (t2.length !== e2.length)
                return false;
              for (let r2 = 0; r2 < t2.length; ++r2)
                if (t2[r2] !== e2[r2] && (!n2 || 0 !== t2[r2]))
                  return false;
              return true;
            }
            createOutput(t2) {
              const e2 = this._model.graph.getOutputNames();
              if (t2.length !== e2.length)
                throw new Error("expected number of outputs do not match number of generated outputs");
              const n2 = /* @__PURE__ */ new Map();
              for (let r2 = 0; r2 < e2.length; ++r2)
                n2.set(e2[r2], t2[r2]);
              return n2;
            }
            initializeOps(t2) {
              const e2 = t2.getNodes();
              this._ops = new Array(e2.length);
              for (let n2 = 0; n2 < e2.length; n2++)
                this._ops[n2] = this.sessionHandler.resolve(e2[n2], this._model.opsets, t2);
            }
          };
        }, 9162: function(t, e, n) {
          "use strict";
          var r = this && this.__importDefault || function(t2) {
            return t2 && t2.__esModule ? t2 : { default: t2 };
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.Tensor = void 0;
          const i = n(3442), o = r(n(3720)), a = n(1446), s = n(9395), u = n(2517);
          var c = s.onnxruntime.experimental.fbs;
          class l {
            get data() {
              if (void 0 === this.cache) {
                const t2 = this.dataProvider(this.dataId);
                if (t2.length !== this.size)
                  throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
                this.cache = t2;
              }
              return this.cache;
            }
            get stringData() {
              if ("string" !== this.type)
                throw new TypeError("data type is not string");
              return this.data;
            }
            get integerData() {
              switch (this.type) {
                case "uint8":
                case "int8":
                case "uint16":
                case "int16":
                case "int32":
                case "uint32":
                case "bool":
                  return this.data;
                default:
                  throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
              }
            }
            get floatData() {
              switch (this.type) {
                case "float32":
                case "float64":
                  return this.data;
                default:
                  throw new TypeError("data type is not float (float32, float64)");
              }
            }
            get numberData() {
              if ("string" !== this.type)
                return this.data;
              throw new TypeError("type cannot be non-number (string)");
            }
            get(t2) {
              return this.data[u.ShapeUtil.indicesToOffset(t2, this.strides)];
            }
            set(t2, e2) {
              this.data[u.ShapeUtil.indicesToOffset(t2, this.strides)] = e2;
            }
            async getData() {
              return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
            }
            get strides() {
              return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;
            }
            constructor(t2, e2, n2, r2, o2, a2 = i.Guid.create()) {
              this.dims = t2, this.type = e2, this.dataProvider = n2, this.asyncDataProvider = r2, this.cache = o2, this.dataId = a2, this.size = u.ShapeUtil.validateDimsAndCalcSize(t2);
              const s2 = this.size, c2 = void 0 === n2 && void 0 === r2 && void 0 === o2;
              if (void 0 !== o2 && o2.length !== s2)
                throw new RangeError("Input dims doesn't match data length.");
              if ("string" === e2) {
                if (!(void 0 === o2 || Array.isArray(o2) && o2.every((t3) => "string" == typeof t3)))
                  throw new TypeError("cache should be a string array");
                c2 && (this.cache = new Array(s2));
              } else {
                if (void 0 !== o2) {
                  const t3 = f(e2);
                  if (!(o2 instanceof t3))
                    throw new TypeError(`cache should be type ${t3.name}`);
                }
                if (c2) {
                  const t3 = new ArrayBuffer(s2 * function(t4) {
                    switch (t4) {
                      case "bool":
                      case "int8":
                      case "uint8":
                        return 1;
                      case "int16":
                      case "uint16":
                        return 2;
                      case "int32":
                      case "uint32":
                      case "float32":
                        return 4;
                      case "float64":
                        return 8;
                      default:
                        throw new Error(`cannot calculate sizeof() on type ${t4}`);
                    }
                  }(e2));
                  this.cache = function(t4, e3) {
                    return new (f(e3))(t4);
                  }(t3, e2);
                }
              }
            }
            static fromProto(t2) {
              if (!t2)
                throw new Error("cannot construct Value from an empty tensor");
              const e2 = u.ProtoUtil.tensorDataTypeFromProto(t2.dataType), n2 = u.ProtoUtil.tensorDimsFromProto(t2.dims), r2 = new l(n2, e2);
              if ("string" === e2)
                t2.stringData.forEach((t3, e3) => {
                  r2.data[e3] = (0, u.decodeUtf8String)(t3);
                });
              else if (t2.rawData && "number" == typeof t2.rawData.byteLength && t2.rawData.byteLength > 0) {
                const e3 = r2.data, n3 = new DataView(t2.rawData.buffer, t2.rawData.byteOffset, t2.rawData.byteLength), i2 = p(t2.dataType), o2 = t2.rawData.byteLength / i2;
                if (t2.rawData.byteLength % i2 != 0)
                  throw new Error("invalid buffer length");
                if (e3.length !== o2)
                  throw new Error("buffer length mismatch");
                for (let r3 = 0; r3 < o2; r3++) {
                  const o3 = h(n3, t2.dataType, r3 * i2);
                  e3[r3] = o3;
                }
              } else {
                let e3;
                switch (t2.dataType) {
                  case a.onnx.TensorProto.DataType.FLOAT:
                    e3 = t2.floatData;
                    break;
                  case a.onnx.TensorProto.DataType.INT32:
                  case a.onnx.TensorProto.DataType.INT16:
                  case a.onnx.TensorProto.DataType.UINT16:
                  case a.onnx.TensorProto.DataType.INT8:
                  case a.onnx.TensorProto.DataType.UINT8:
                  case a.onnx.TensorProto.DataType.BOOL:
                    e3 = t2.int32Data;
                    break;
                  case a.onnx.TensorProto.DataType.INT64:
                    e3 = t2.int64Data;
                    break;
                  case a.onnx.TensorProto.DataType.DOUBLE:
                    e3 = t2.doubleData;
                    break;
                  case a.onnx.TensorProto.DataType.UINT32:
                  case a.onnx.TensorProto.DataType.UINT64:
                    e3 = t2.uint64Data;
                    break;
                  default:
                    throw new Error("unspecific error");
                }
                if (null == e3)
                  throw new Error("failed to populate data from a tensorproto value");
                const n3 = r2.data;
                if (n3.length !== e3.length)
                  throw new Error("array length mismatch");
                for (let r3 = 0; r3 < e3.length; r3++) {
                  const i2 = e3[r3];
                  o.default.isLong(i2) ? n3[r3] = d(i2, t2.dataType) : n3[r3] = i2;
                }
              }
              return r2;
            }
            static fromData(t2, e2, n2) {
              return new l(e2, n2, void 0, void 0, t2);
            }
            static fromOrtTensor(t2) {
              if (!t2)
                throw new Error("cannot construct Value from an empty tensor");
              const e2 = u.ProtoUtil.tensorDimsFromORTFormat(t2), n2 = u.ProtoUtil.tensorDataTypeFromProto(t2.dataType()), r2 = new l(e2, n2);
              if ("string" === n2)
                for (let e3 = 0; e3 < t2.stringDataLength(); e3++)
                  r2.data[e3] = t2.stringData(e3);
              else if (t2.rawDataArray() && "number" == typeof t2.rawDataLength() && t2.rawDataLength() > 0) {
                const e3 = r2.data, n3 = new DataView(t2.rawDataArray().buffer, t2.rawDataArray().byteOffset, t2.rawDataLength()), i2 = p(t2.dataType()), o2 = t2.rawDataLength() / i2;
                if (t2.rawDataLength() % i2 != 0)
                  throw new Error("invalid buffer length");
                if (e3.length !== o2)
                  throw new Error("buffer length mismatch");
                for (let r3 = 0; r3 < o2; r3++) {
                  const o3 = h(n3, t2.dataType(), r3 * i2);
                  e3[r3] = o3;
                }
              }
              return r2;
            }
          }
          function p(t2) {
            switch (t2) {
              case a.onnx.TensorProto.DataType.UINT8:
              case a.onnx.TensorProto.DataType.INT8:
              case a.onnx.TensorProto.DataType.BOOL:
                return 1;
              case a.onnx.TensorProto.DataType.UINT16:
              case a.onnx.TensorProto.DataType.INT16:
                return 2;
              case a.onnx.TensorProto.DataType.FLOAT:
              case a.onnx.TensorProto.DataType.INT32:
              case a.onnx.TensorProto.DataType.UINT32:
                return 4;
              case a.onnx.TensorProto.DataType.INT64:
              case a.onnx.TensorProto.DataType.DOUBLE:
              case a.onnx.TensorProto.DataType.UINT64:
                return 8;
              default:
                throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t2]}`);
            }
          }
          function f(t2) {
            switch (t2) {
              case "bool":
              case "uint8":
                return Uint8Array;
              case "int8":
                return Int8Array;
              case "int16":
                return Int16Array;
              case "uint16":
                return Uint16Array;
              case "int32":
                return Int32Array;
              case "uint32":
                return Uint32Array;
              case "float32":
                return Float32Array;
              case "float64":
                return Float64Array;
              default:
                throw new Error("unspecified error");
            }
          }
          function d(t2, e2) {
            if (e2 === a.onnx.TensorProto.DataType.INT64 || e2 === c.TensorDataType.INT64) {
              if (t2.greaterThanOrEqual(2147483648) || t2.lessThan(-2147483648))
                throw new TypeError("int64 is not supported");
            } else {
              if (e2 !== a.onnx.TensorProto.DataType.UINT32 && e2 !== c.TensorDataType.UINT32 && e2 !== a.onnx.TensorProto.DataType.UINT64 && e2 !== c.TensorDataType.UINT64)
                throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e2]}`);
              if (t2.greaterThanOrEqual(4294967296) || t2.lessThan(0))
                throw new TypeError("uint64 is not supported");
            }
            return t2.toNumber();
          }
          function h(t2, e2, n2) {
            switch (e2) {
              case a.onnx.TensorProto.DataType.BOOL:
              case a.onnx.TensorProto.DataType.UINT8:
                return t2.getUint8(n2);
              case a.onnx.TensorProto.DataType.INT8:
                return t2.getInt8(n2);
              case a.onnx.TensorProto.DataType.UINT16:
                return t2.getUint16(n2, true);
              case a.onnx.TensorProto.DataType.INT16:
                return t2.getInt16(n2, true);
              case a.onnx.TensorProto.DataType.FLOAT:
                return t2.getFloat32(n2, true);
              case a.onnx.TensorProto.DataType.INT32:
                return t2.getInt32(n2, true);
              case a.onnx.TensorProto.DataType.UINT32:
                return t2.getUint32(n2, true);
              case a.onnx.TensorProto.DataType.INT64:
                return d(o.default.fromBits(t2.getUint32(n2, true), t2.getUint32(n2 + 4, true), false), e2);
              case a.onnx.TensorProto.DataType.DOUBLE:
                return t2.getFloat64(n2, true);
              case a.onnx.TensorProto.DataType.UINT64:
                return d(o.default.fromBits(t2.getUint32(n2, true), t2.getUint32(n2 + 4, true), true), e2);
              default:
                throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e2]}`);
            }
          }
          e.Tensor = l;
        }, 2517: function(t, e, n) {
          "use strict";
          var r = this && this.__importDefault || function(t2) {
            return t2 && t2.__esModule ? t2 : { default: t2 };
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.decodeUtf8String = e.MAX_CLIP = e.MIN_CLIP = e.PoolConvUtil = e.ReduceUtil = e.SplitUtil = e.MathUtil = e.ShapeUtil = e.LongUtil = e.ProtoUtil = e.GemmUtil = e.arrayCopyHelper = e.BroadcastUtil = e.MatMulUtil = e.ArrayUtil = e.assert = e.checkInputsShape = void 0;
          const i = n(5686), o = r(n(3720)), a = n(1446), s = n(9162);
          e.checkInputsShape = function(t2, ...e2) {
            if (!t2 || t2.length !== e2.length)
              return false;
            for (let n2 = 0; n2 < t2.length; n2++)
              if (!t2[n2].dims || t2[n2].dims.length !== e2[n2])
                return false;
            return true;
          }, e.assert = function(t2, e2) {
            if (!t2)
              throw new Error("string" == typeof e2 ? e2 : e2());
          }, e.ArrayUtil = class {
            static arraysEqual(t2, e2) {
              if (t2.length !== e2.length)
                return false;
              for (let n2 = 0; n2 < t2.length; n2++)
                if (t2[n2] !== e2[n2])
                  return false;
              return true;
            }
          };
          class u {
            static preprocessInputShapes(t2, e2) {
              return [1 === t2.length ? [1, t2[0]] : t2, 1 === e2.length ? [e2[0], 1] : e2];
            }
            static postprocessOutputShape(t2, e2, n2) {
              1 === e2 && t2.splice(t2.length - 2, 1), 1 === n2 && t2.pop();
            }
            static calcMatMulShape(t2, e2) {
              return t2[1] !== e2[0] ? void 0 : [t2[0], e2[1]];
            }
          }
          e.MatMulUtil = u;
          class c {
            static calcShape(t2, e2, n2 = false) {
              const r2 = t2.length, i2 = e2.length;
              if (0 === r2)
                return e2;
              if (0 === i2)
                return t2;
              const o2 = Math.max(t2.length, e2.length), a2 = new Array(o2);
              if (n2) {
                if (r2 < 2 || i2 < 2)
                  return;
                const n3 = u.calcMatMulShape([t2[r2 - 2], t2[r2 - 1]], [e2[i2 - 2], e2[i2 - 1]]);
                if (void 0 === n3)
                  return;
                [a2[o2 - 2], a2[o2 - 1]] = n3;
              }
              for (let s2 = n2 ? 3 : 1; s2 <= o2; s2++) {
                const n3 = r2 - s2 < 0 ? 1 : t2[r2 - s2], u2 = i2 - s2 < 0 ? 1 : e2[i2 - s2];
                if (n3 !== u2 && n3 > 1 && u2 > 1)
                  return;
                a2[o2 - s2] = Math.max(n3, u2);
              }
              return a2;
            }
            static index(t2, e2) {
              const n2 = new Array(e2.length);
              return c.fillIndex(t2, e2, n2), n2;
            }
            static fillIndex(t2, e2, n2) {
              const r2 = t2.length - e2.length;
              for (let i2 = 0; i2 < e2.length; i2++)
                n2[i2] = t2[r2 + i2] % e2[i2];
            }
            static calc(t2, e2, n2, r2, i2) {
              const o2 = c.calcShape(t2.dims, e2.dims);
              if (o2) {
                if (r2 && !f.areEqual(o2, t2.dims))
                  return;
                const a2 = f.size(o2), u2 = r2 ? t2 : new s.Tensor(o2, i2 || t2.type);
                if (0 === o2.length)
                  u2.set([], n2(t2.get([]), e2.get([])));
                else {
                  const r3 = new Array(o2.length), i3 = new Array(t2.dims.length), s2 = new Array(e2.dims.length);
                  let l2, p2 = 0, f2 = 0, d2 = false, h2 = false;
                  0 === t2.dims.length && (p2 = t2.get([]), d2 = true), 0 === e2.dims.length && (f2 = e2.get([]), h2 = true);
                  for (let g2 = 0; g2 < a2; g2++) {
                    l2 = g2;
                    for (let t3 = o2.length - 1; t3 >= 0; t3--)
                      r3[t3] = l2 % o2[t3], l2 = Math.floor(l2 / o2[t3]);
                    d2 || (c.fillIndex(r3, t2.dims, i3), p2 = t2.get(i3)), h2 || (c.fillIndex(r3, e2.dims, s2), f2 = e2.get(s2)), u2.set(r3, n2(p2, f2));
                  }
                }
                return u2;
              }
            }
            static isValidBroadcast(t2, e2) {
              const n2 = t2.length, r2 = e2.length;
              if (n2 > r2)
                return false;
              for (let i2 = 1; i2 <= n2; i2++)
                if (1 !== t2[n2 - i2] && t2[n2 - i2] !== e2[r2 - i2])
                  return false;
              return true;
            }
            static getBroadcastDims(t2, e2) {
              const n2 = t2.length, r2 = [];
              for (let i2 = 0; i2 < n2; i2++) {
                const o2 = n2 - 1 - i2, a2 = t2[o2] || 1;
                (e2[e2.length - 1 - i2] || 1) > 1 && 1 === a2 && r2.unshift(o2);
              }
              return r2;
            }
          }
          e.BroadcastUtil = c, e.arrayCopyHelper = function(t2, e2, n2, r2, i2) {
            if (r2 < 0 || r2 >= e2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= t2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + i2 > e2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + i2 > t2.length)
              throw new Error("target array is too small to hold result");
            for (let o2 = 0; o2 < i2; o2++)
              t2[n2 + o2] = e2[r2 + o2];
          }, e.GemmUtil = class {
            static getShapeOfGemmResult(t2, e2, n2, r2, i2) {
              if (2 !== t2.length || 2 !== n2.length)
                throw new Error("shape need to be of size 2");
              let o2, a2, s2;
              e2 ? (o2 = t2[1], a2 = t2[0]) : (o2 = t2[0], a2 = t2[1]);
              let u2 = -1;
              if (r2 ? (s2 = n2[0], u2 = 1) : (s2 = n2[1], u2 = 0), n2[u2] !== a2)
                throw new Error("dimension mismatch");
              if (o2 <= 0 || s2 <= 0 || a2 <= 0)
                throw new Error("invalid shape specified");
              if (i2 && !c.isValidBroadcast(i2, [o2, s2]))
                throw new Error("gemm: invalid bias shape for broadcast");
              return [o2, s2, a2];
            }
          };
          class l {
            static tensorDataTypeFromProto(t2) {
              switch (t2) {
                case a.onnx.TensorProto.DataType.INT8:
                  return "int8";
                case a.onnx.TensorProto.DataType.UINT8:
                  return "uint8";
                case a.onnx.TensorProto.DataType.BOOL:
                  return "bool";
                case a.onnx.TensorProto.DataType.INT16:
                  return "int16";
                case a.onnx.TensorProto.DataType.UINT16:
                  return "uint16";
                case a.onnx.TensorProto.DataType.INT32:
                  return "int32";
                case a.onnx.TensorProto.DataType.UINT32:
                  return "uint32";
                case a.onnx.TensorProto.DataType.FLOAT:
                  return "float32";
                case a.onnx.TensorProto.DataType.DOUBLE:
                  return "float64";
                case a.onnx.TensorProto.DataType.STRING:
                  return "string";
                case a.onnx.TensorProto.DataType.INT64:
                  return "int32";
                case a.onnx.TensorProto.DataType.UINT64:
                  return "uint32";
                default:
                  throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t2]}`);
              }
            }
            static tensorDataTypeStringToEnum(t2) {
              switch (t2) {
                case "int8":
                  return a.onnx.TensorProto.DataType.INT8;
                case "uint8":
                  return a.onnx.TensorProto.DataType.UINT8;
                case "bool":
                  return a.onnx.TensorProto.DataType.BOOL;
                case "int16":
                  return a.onnx.TensorProto.DataType.INT16;
                case "uint16":
                  return a.onnx.TensorProto.DataType.UINT16;
                case "int32":
                  return a.onnx.TensorProto.DataType.INT32;
                case "uint32":
                  return a.onnx.TensorProto.DataType.UINT32;
                case "float32":
                  return a.onnx.TensorProto.DataType.FLOAT;
                case "float64":
                  return a.onnx.TensorProto.DataType.DOUBLE;
                case "string":
                  return a.onnx.TensorProto.DataType.STRING;
                case "int64":
                  return a.onnx.TensorProto.DataType.INT64;
                case "uint64":
                  return a.onnx.TensorProto.DataType.UINT64;
                default:
                  throw new Error(`unsupported data type: ${t2}`);
              }
            }
            static tensorDimsFromProto(t2) {
              return t2.map((t3) => o.default.isLong(t3) ? t3.toNumber() : t3);
            }
            static tensorValueTypeFromProto(t2) {
              return { tensorType: l.tensorDataTypeFromProto(t2.elemType), shape: { dims: l.tensorDimsFromProto(t2.shape.dim.map((t3) => t3.dimValue)) } };
            }
            static tensorDimsFromORTFormat(t2) {
              const e2 = [];
              for (let n2 = 0; n2 < t2.dimsLength(); n2++)
                e2.push(p.longToNumber(t2.dims(n2)));
              return e2;
            }
            static tensorAttributesFromORTFormat(t2) {
              const e2 = [];
              for (let n2 = 0; n2 < t2.attributesLength(); n2++)
                e2.push(t2.attributes(n2));
              return e2;
            }
          }
          e.ProtoUtil = l;
          class p {
            static longToNumber(t2, e2) {
              return o.default.isLong(t2) ? t2.toNumber() : t2 instanceof i.flatbuffers.Long ? o.default.fromValue({ low: t2.low, high: t2.high, unsigned: null != e2 && e2 }).toNumber() : t2;
            }
            static isLong(t2) {
              return o.default.isLong(t2) || t2 instanceof i.flatbuffers.Long;
            }
          }
          e.LongUtil = p;
          class f {
            static size(t2) {
              return f.getSizeFromDimensionRange(t2, 0, t2.length);
            }
            static sizeFromDimension(t2, e2) {
              if (e2 < 0 || e2 > t2.length)
                throw new Error(`invalid dimension of ${e2} for sizeFromDimension as Tensor has ${t2.length} dimensions.`);
              return f.getSizeFromDimensionRange(t2, e2, t2.length);
            }
            static sizeToDimension(t2, e2) {
              if (e2 < 0 || e2 > t2.length)
                throw new Error(`invalid dimension of ${e2} for sizeToDimension as Tensor has ${t2.length} dimensions.`);
              return f.getSizeFromDimensionRange(t2, 0, e2);
            }
            static getSizeFromDimensionRange(t2, e2, n2) {
              let r2 = 1;
              for (let i2 = e2; i2 < n2; i2++) {
                if (t2[i2] <= 0)
                  throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
                r2 *= t2[i2];
              }
              return r2;
            }
            static computeStrides(t2) {
              const e2 = t2.length;
              if (0 === e2)
                return [];
              if (1 === e2)
                return [1];
              const n2 = new Array(e2);
              n2[e2 - 1] = 1, n2[e2 - 2] = t2[e2 - 1];
              for (let r2 = e2 - 3; r2 >= 0; --r2)
                n2[r2] = n2[r2 + 1] * t2[r2 + 1];
              return n2;
            }
            static transpose(t2) {
              return t2.slice().reverse();
            }
            static indicesToOffset(t2, e2, n2) {
              void 0 === n2 && (n2 = t2.length);
              let r2 = 0;
              for (let i2 = 0; i2 < n2; ++i2)
                r2 += e2[i2] * t2[i2];
              return r2;
            }
            static offsetToIndices(t2, e2) {
              const n2 = e2.length;
              if (0 === n2)
                return [];
              if (1 === n2)
                return [t2 * e2[0]];
              const r2 = new Array(e2.length);
              for (let n3 = 0; n3 < r2.length - 1; ++n3)
                r2[n3] = Math.floor(t2 / e2[n3]), t2 -= r2[n3] * e2[n3];
              return r2[r2.length - 1] = t2, r2;
            }
            static normalizeAxis(t2, e2) {
              if (t2 < -e2 && t2 >= e2)
                throw new Error("unsupported axis for this operation.");
              return t2 < 0 ? t2 + e2 : t2;
            }
            static normalizeAxes(t2, e2) {
              return t2.map((t3) => this.normalizeAxis(t3, e2));
            }
            static incrementIndex(t2, e2, n2) {
              if (0 === e2.length || 0 === t2.length)
                throw new Error("Index incrementing unsupported for scalar Tensor");
              if (void 0 === n2)
                n2 = e2.length;
              else if (n2 <= 0 || n2 > e2.length)
                throw new Error("Incorrect axis to increment on");
              for (let r2 = n2 - 1; r2 >= 0 && (t2[r2]++, !(t2[r2] < e2[r2])); --r2)
                t2[r2] = 0;
            }
            static calculateReshapedDims(t2, e2) {
              if (0 === e2.length) {
                if (0 === t2.length || 1 === f.size(t2))
                  return [];
                throw new Error("cannot reshape to a scalar Tensor");
              }
              const n2 = e2.length, r2 = new Array(n2);
              let i2 = -1, o2 = 1;
              for (let a3 = 0; a3 < n2; a3++) {
                if (e2[a3] < -1)
                  throw new Error("a dimension in shape hints cannot be less than -1");
                if (-1 === e2[a3]) {
                  if (-1 !== i2)
                    throw new Error("at most one dimension in shape hints can be -1");
                  i2 = a3;
                } else {
                  if (0 === e2[a3]) {
                    if (a3 >= t2.length)
                      throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                    r2[a3] = t2[a3];
                  } else
                    r2[a3] = e2[a3];
                  o2 *= r2[a3];
                }
              }
              const a2 = f.size(t2);
              if (-1 !== i2) {
                if (a2 % o2 != 0)
                  throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t2}] Output shape: [${e2}]`);
                r2[i2] = a2 / o2;
              } else if (o2 !== a2)
                throw new Error("reshapedDims and originalDims don't have matching sizes");
              return r2;
            }
            static sortBasedOnPerm(t2, e2) {
              return e2 ? e2.map((e3) => t2[e3]) : t2.slice().reverse();
            }
            static padShape(t2, e2) {
              const n2 = t2.length;
              return t2.map((t3, r2) => t3 + e2[r2] + e2[r2 + n2]);
            }
            static areEqual(t2, e2) {
              return t2.length === e2.length && t2.every((t3, n2) => t3 === e2[n2]);
            }
            static validateDimsAndCalcSize(t2) {
              if (t2.length > 6)
                throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
              let e2 = 1;
              for (const n2 of t2) {
                if (!Number.isInteger(n2))
                  throw new TypeError(`Invalid shape: ${n2} is not an integer`);
                if (n2 < 0 || n2 > 2147483647)
                  throw new TypeError(`Invalid shape: length ${n2} is not allowed`);
                e2 *= n2;
              }
              return e2;
            }
            static flattenShape(t2, e2) {
              e2 < 0 && (e2 += t2.length);
              const n2 = t2.reduce((t3, e3) => t3 * e3, 1), r2 = t2.slice(e2).reduce((t3, e3) => t3 * e3, 1);
              return [n2 / r2, r2];
            }
            static squeezeShape(t2, e2) {
              const n2 = new Array();
              e2 = f.normalizeAxes(e2, t2.length);
              for (let r2 = 0; r2 < t2.length; r2++) {
                const i2 = e2.indexOf(r2) >= 0;
                if (i2 && 1 !== t2[r2])
                  throw new Error("squeeze an axis of size different than 1");
                (0 === e2.length && t2[r2] > 1 || e2.length > 0 && !i2) && n2.push(t2[r2]);
              }
              return n2;
            }
            static unsqueezeShape(t2, e2) {
              const n2 = new Array(t2.length + e2.length);
              n2.fill(0);
              for (let t3 = 0; t3 < e2.length; t3++) {
                const r3 = f.normalizeAxis(e2[t3], n2.length);
                if (r3 >= n2.length)
                  throw new Error("'axes' has an out of range axis");
                if (0 !== n2[r3])
                  throw new Error("'axes' has a duplicate axis");
                n2[r3] = 1;
              }
              let r2 = 0;
              for (let e3 = 0; e3 < n2.length; e3++)
                0 === n2[e3] && (n2[e3] = t2[r2++]);
              if (r2 !== t2.length)
                throw new Error("the unsqueezed dimension could not be established");
              return n2;
            }
          }
          e.ShapeUtil = f, e.MathUtil = class {
            static sqr(t2, e2, n2, r2, i2) {
              if (r2 < 0 || r2 >= e2.length)
                throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= t2.length)
                throw new Error("targetIndex out of bounds");
              if (r2 + i2 > e2.length)
                throw new Error("source indices to be copied are outside bounds");
              if (n2 + i2 > t2.length)
                throw new Error("target array is too small to hold result");
              for (let o2 = 0; o2 < i2; o2++)
                t2[n2 + o2] += Math.pow(e2[r2 + o2], 2);
            }
            static axpy(t2, e2, n2, r2, i2, o2) {
              if (r2 < 0 || r2 >= e2.length)
                throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= t2.length)
                throw new Error("targetIndex out of bounds");
              if (r2 + i2 > e2.length)
                throw new Error("source indices to be copied are outside bounds");
              if (n2 + i2 > t2.length)
                throw new Error("target array is too small to hold result");
              for (let a2 = 0; a2 < i2; a2++)
                t2[n2 + a2] += o2 * e2[r2 + a2];
            }
            static powx(t2, e2, n2, r2, i2, o2) {
              if (r2 < 0 || r2 >= e2.length)
                throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= t2.length)
                throw new Error("targetIndex out of bounds");
              if (r2 + i2 > e2.length)
                throw new Error("source indices to be copied are outside bounds");
              if (n2 + i2 > t2.length)
                throw new Error("target array is too small to hold result");
              for (let a2 = 0; a2 < i2; a2++)
                t2[n2 + a2] = Math.pow(e2[r2 + a2], o2);
            }
            static mul(t2, e2, n2, r2, i2) {
              if (r2 < 0 || r2 >= e2.length)
                throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= t2.length)
                throw new Error("targetIndex out of bounds");
              if (r2 + i2 > e2.length)
                throw new Error("source indices to be copied are outside bounds");
              if (n2 + i2 > t2.length)
                throw new Error("target array is too small to hold result");
              for (let o2 = 0; o2 < i2; o2++)
                t2[n2 + o2] = e2[r2 + o2] * t2[n2 + o2];
            }
          };
          class d {
            static splitShape(t2, e2, n2, r2) {
              if (0 === n2.length) {
                if (!r2)
                  throw new Error("need to know number of outputs when the 'split' attribute is not specified");
                d.determineSplit(t2[e2], r2, n2);
              }
              const i2 = [], o2 = [0];
              for (let r3 = 0; r3 < n2.length; ++r3) {
                0 !== r3 && o2.push(o2[r3 - 1] + n2[r3 - 1]);
                const a2 = t2.slice();
                a2[e2] = n2[r3], i2.push(a2);
              }
              return [i2, o2];
            }
            static determineSplit(t2, e2, n2) {
              if (t2 % e2 != 0)
                throw new Error("cannot split tensor to equal sized parts");
              for (let r2 = 0; r2 < e2; ++r2)
                n2.push(t2 / e2);
            }
          }
          e.SplitUtil = d;
          class h {
            static calcReduce(t2, e2, n2, r2, i2) {
              const o2 = t2.dims.slice(0);
              0 === e2.length && o2.forEach((t3, n3) => e2.push(n3));
              const a2 = h.calcReduceShape(o2, e2, true), u2 = f.size(a2), l2 = new s.Tensor(a2, t2.type), p2 = f.computeStrides(a2), d2 = f.computeStrides(o2), g2 = new Array(o2.length);
              for (let n3 = 0; n3 < u2; n3++) {
                const a3 = f.offsetToIndices(n3, p2);
                c.fillIndex(a3, o2, g2), l2.set(a3, h.calcReduceByAxis(t2.numberData, e2, o2, 0, f.indicesToOffset(g2, d2), r2, i2));
              }
              return n2 ? l2 : new s.Tensor(h.calcReduceShape(o2, e2, n2), l2.type, void 0, void 0, l2.data, l2.dataId);
            }
            static calcReduceByAxis(t2, e2, n2, r2, i2, o2, a2) {
              let s2 = 0;
              if (r2 >= e2.length)
                return o2(t2[i2]);
              const u2 = e2[r2], c2 = u2 >= n2.length ? 1 : f.size(n2.slice(u2 + 1));
              for (let l2 = 0; l2 < n2[u2]; l2++)
                s2 = 0 === l2 ? h.calcReduceByAxis(t2, e2, n2, r2 + 1, i2, o2, a2) : a2(s2, h.calcReduceByAxis(t2, e2, n2, r2 + 1, i2, o2, a2)), i2 += c2;
              return s2;
            }
            static calcReduceShape(t2, e2, n2) {
              const r2 = t2.slice();
              for (let t3 = 0; t3 < e2.length; t3++)
                r2[e2[t3]] = n2 ? 1 : 0;
              return r2.filter((t3) => 0 !== t3);
            }
          }
          e.ReduceUtil = h;
          class g {
            static adjustPoolAttributes(t2, e2, n2, r2, i2, o2) {
              if (!t2 && n2.length !== e2.length - 2)
                throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
              if (t2)
                for (let t3 = 0; t3 < e2.length - 2; t3++)
                  t3 >= n2.length ? n2.push(e2[t3 + 2]) : n2[t3] = e2[t3 + 2];
              for (let t3 = 0; t3 < n2.length; t3++)
                if (t3 < r2.length) {
                  if (r2[t3] < 0)
                    throw new Error("strides should be greater than or equal to 1");
                } else
                  r2.push(1);
              for (let t3 = 0; t3 < n2.length; t3++)
                if (t3 < i2.length) {
                  if (i2[t3] < 0)
                    throw new Error("dilations should be greater than or equal to 1");
                } else
                  i2.push(1);
              for (let t3 = 0; t3 < 2 * n2.length; t3++)
                if (t3 < o2.length) {
                  if (o2[t3] < 0)
                    throw new Error("pad should be greater than or equal to 1");
                } else
                  o2.push(0);
              for (let t3 = 0; t3 < n2.length; t3++) {
                if (n2[t3] <= 0)
                  throw new Error("kernel shapes need to be greater than 0");
                if (o2[t3] >= n2[t3] || o2[t3 + n2.length] >= n2[t3])
                  throw new Error("pads should be smaller than kernel");
              }
            }
            static adjustPadsBasedOnAutoPad(t2, e2, n2, r2, i2, o2) {
              if (o2) {
                if (i2.length !== 2 * (t2.length - 2))
                  throw new Error("length of pads should be twice the length of data dimensions");
                if (e2.length !== t2.length - 2)
                  throw new Error("length of strides should be the length of data dimensions");
                if (r2.length !== t2.length - 2)
                  throw new Error("length of kernel shapes should be the length of data dimensions");
                for (let a2 = 0; a2 < t2.length - 2; a2++)
                  g.adjustPadAndReturnShape(t2[a2 + 2], e2[a2], n2[a2], r2[a2], i2, a2, a2 + t2.length - 2, o2);
              }
            }
            static computePoolOutputShape(t2, e2, n2, r2, i2, o2, a2) {
              if (e2.length <= 0)
                throw new Error("input shape must be of size greater than 0");
              const s2 = [e2[0], e2[1]];
              return g.computeShapeHelper(t2, e2, s2, n2, r2, i2, o2, a2), s2;
            }
            static computeConvOutputShape(t2, e2, n2, r2, i2, o2, a2) {
              if (t2.length <= 0 || e2.length <= 0)
                throw new Error("invalid input tensor dims or invalid filter tensor dims");
              const s2 = [t2[0], e2[0]];
              return g.computeShapeHelper(false, t2, s2, n2, r2, i2, o2, a2), s2;
            }
            static computeShapeHelper(t2, e2, n2, r2, i2, o2, a2, s2) {
              if (t2)
                for (let t3 = 0; t3 < e2.length - 2; t3++)
                  n2.push(1);
              else
                for (let t3 = 0; t3 < e2.length - 2; t3++)
                  n2.push(g.adjustPadAndReturnShape(e2[t3 + 2], r2[t3], i2[t3], o2[t3], a2, t3, t3 + e2.length - 2, s2));
            }
            static adjustPadAndReturnShape(t2, e2, n2, r2, i2, o2, a2, s2) {
              const u2 = n2 * (r2 - 1) + 1;
              if (!s2 || "NOTSET" === s2)
                return Math.floor((t2 + i2[o2] + i2[a2] - u2) / e2 + 1);
              switch (s2) {
                case "VALID":
                  return i2[o2] = 0, i2[a2] = 0, Math.floor((t2 - u2) / e2 + 1);
                case "SAME_LOWER":
                case "SAME_UPPER":
                  if (1 !== n2)
                    throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                  {
                    const n3 = ((t2 + e2 - 1) / e2 - 1) * e2 + r2 - t2;
                    return i2[o2] = "SAME_LOWER" === s2 ? Math.floor((n3 + 1) / 2) : Math.floor(n3 / 2), i2[a2] = n3 - i2[o2], Math.floor((t2 + n3 - r2) / e2 + 1);
                  }
                default:
                  throw new Error("Unsupported AutoPad type");
              }
            }
          }
          e.PoolConvUtil = g, e.MIN_CLIP = -34028234663852886e22, e.MAX_CLIP = 34028234663852886e22, e.decodeUtf8String = function(t2) {
            return new TextDecoder().decode(t2);
          };
        }, 7967: (t, e) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.iterateExtraOptions = void 0, e.iterateExtraOptions = (t2, n, r, i) => {
            if ("object" == typeof t2 && null !== t2) {
              if (r.has(t2))
                throw new Error("Circular reference in options");
              r.add(t2);
            }
            Object.entries(t2).forEach(([t3, o]) => {
              const a = n ? n + t3 : t3;
              if ("object" == typeof o)
                (0, e.iterateExtraOptions)(o, a + ".", r, i);
              else if ("string" == typeof o || "number" == typeof o)
                i(a, o.toString());
              else {
                if ("boolean" != typeof o)
                  throw new Error("Can't handle extra config type: " + typeof o);
                i(a, o ? "1" : "0");
              }
            });
          };
        }, 2157: function(t, e, n) {
          "use strict";
          var r, i = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), o = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
            Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
          } : function(t2, e2) {
            t2.default = e2;
          }), a = this && this.__importStar || function(t2) {
            if (t2 && t2.__esModule)
              return t2;
            var e2 = {};
            if (null != t2)
              for (var n2 in t2)
                "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && i(e2, t2, n2);
            return o(e2, t2), e2;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = e.initWasm = void 0;
          const s = n(1670), u = a(n(349)), c = n(6361), l = () => !!s.env.wasm.proxy && "undefined" != typeof document;
          let p, f, d, h = false, g = false, b = false;
          const m = [], y = [], _ = [], v = [], w = [], x = [], T = () => {
            if (h || !g || b || !p)
              throw new Error("worker not ready");
          }, S = (t2) => {
            switch (t2.data.type) {
              case "init-wasm":
                h = false, t2.data.err ? (b = true, f[1](t2.data.err)) : (g = true, f[0]());
                break;
              case "init-ort":
                t2.data.err ? d[1](t2.data.err) : d[0]();
                break;
              case "create_allocate":
                t2.data.err ? m.shift()[1](t2.data.err) : m.shift()[0](t2.data.out);
                break;
              case "create_finalize":
                t2.data.err ? y.shift()[1](t2.data.err) : y.shift()[0](t2.data.out);
                break;
              case "create":
                t2.data.err ? _.shift()[1](t2.data.err) : _.shift()[0](t2.data.out);
                break;
              case "release":
                t2.data.err ? v.shift()[1](t2.data.err) : v.shift()[0]();
                break;
              case "run":
                t2.data.err ? w.shift()[1](t2.data.err) : w.shift()[0](t2.data.out);
                break;
              case "end-profiling":
                t2.data.err ? x.shift()[1](t2.data.err) : x.shift()[0]();
            }
          }, O = "undefined" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;
          e.initWasm = async () => {
            if (l()) {
              if (g)
                return;
              if (h)
                throw new Error("multiple calls to 'initWasm()' detected.");
              if (b)
                throw new Error("previous call to 'initWasm()' failed.");
              return h = true, void 0 === s.env.wasm.wasmPaths && O && 0 !== O.indexOf("blob:") && (s.env.wasm.wasmPaths = O.substr(0, +O.lastIndexOf("/") + 1)), new Promise((t2, e2) => {
                null == p || p.terminate(), p = n(9710).Z(), p.onmessage = S, f = [t2, e2];
                const r2 = { type: "init-wasm", in: s.env.wasm };
                p.postMessage(r2);
              });
            }
            return (0, c.initializeWebAssembly)(s.env.wasm);
          }, e.initOrt = async (t2, e2) => {
            if (l())
              return T(), new Promise((n2, r2) => {
                d = [n2, r2];
                const i2 = { type: "init-ort", in: { numThreads: t2, loggingLevel: e2 } };
                p.postMessage(i2);
              });
            u.initOrt(t2, e2);
          }, e.createSessionAllocate = async (t2) => l() ? (T(), new Promise((e2, n2) => {
            m.push([e2, n2]);
            const r2 = { type: "create_allocate", in: { model: t2 } };
            p.postMessage(r2, [t2.buffer]);
          })) : u.createSessionAllocate(t2), e.createSessionFinalize = async (t2, e2) => l() ? (T(), new Promise((n2, r2) => {
            y.push([n2, r2]);
            const i2 = { type: "create_finalize", in: { modeldata: t2, options: e2 } };
            p.postMessage(i2);
          })) : u.createSessionFinalize(t2, e2), e.createSession = async (t2, e2) => l() ? (T(), new Promise((n2, r2) => {
            _.push([n2, r2]);
            const i2 = { type: "create", in: { model: t2, options: e2 } };
            p.postMessage(i2, [t2.buffer]);
          })) : u.createSession(t2, e2), e.releaseSession = async (t2) => {
            if (l())
              return T(), new Promise((e2, n2) => {
                v.push([e2, n2]);
                const r2 = { type: "release", in: t2 };
                p.postMessage(r2);
              });
            u.releaseSession(t2);
          }, e.run = async (t2, e2, n2, r2, i2) => l() ? (T(), new Promise((o2, a2) => {
            w.push([o2, a2]);
            const s2 = { type: "run", in: { sessionId: t2, inputIndices: e2, inputs: n2, outputIndices: r2, options: i2 } };
            p.postMessage(s2, u.extractTransferableBuffers(n2));
          })) : u.run(t2, e2, n2, r2, i2), e.endProfiling = async (t2) => {
            if (l())
              return T(), new Promise((e2, n2) => {
                x.push([e2, n2]);
                const r2 = { type: "end-profiling", in: t2 };
                p.postMessage(r2);
              });
            u.endProfiling(t2);
          };
        }, 586: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.setRunOptions = void 0;
          const r = n(7967), i = n(4983), o = n(6361);
          e.setRunOptions = (t2) => {
            const e2 = (0, o.getInstance)();
            let n2 = 0;
            const a = [], s = t2 || {};
            try {
              if (void 0 === (null == t2 ? void 0 : t2.logSeverityLevel))
                s.logSeverityLevel = 2;
              else if ("number" != typeof t2.logSeverityLevel || !Number.isInteger(t2.logSeverityLevel) || t2.logSeverityLevel < 0 || t2.logSeverityLevel > 4)
                throw new Error(`log serverity level is not valid: ${t2.logSeverityLevel}`);
              if (void 0 === (null == t2 ? void 0 : t2.logVerbosityLevel))
                s.logVerbosityLevel = 0;
              else if ("number" != typeof t2.logVerbosityLevel || !Number.isInteger(t2.logVerbosityLevel))
                throw new Error(`log verbosity level is not valid: ${t2.logVerbosityLevel}`);
              void 0 === (null == t2 ? void 0 : t2.terminate) && (s.terminate = false);
              let o2 = 0;
              if (void 0 !== (null == t2 ? void 0 : t2.tag) && (o2 = (0, i.allocWasmString)(t2.tag, a)), n2 = e2._OrtCreateRunOptions(s.logSeverityLevel, s.logVerbosityLevel, !!s.terminate, o2), 0 === n2)
                throw new Error("Can't create run options");
              return void 0 !== (null == t2 ? void 0 : t2.extra) && (0, r.iterateExtraOptions)(t2.extra, "", /* @__PURE__ */ new WeakSet(), (t3, r2) => {
                const o3 = (0, i.allocWasmString)(t3, a), s2 = (0, i.allocWasmString)(r2, a);
                if (0 !== e2._OrtAddRunConfigEntry(n2, o3, s2))
                  throw new Error(`Can't set a run config entry: ${t3} - ${r2}`);
              }), [n2, a];
            } catch (t3) {
              throw 0 !== n2 && e2._OrtReleaseRunOptions(n2), a.forEach(e2._free), t3;
            }
          };
        }, 2306: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.OnnxruntimeWebAssemblySessionHandler = void 0;
          const r = n(2806), i = n(1670), o = n(2850), a = n(2157);
          let s;
          e.OnnxruntimeWebAssemblySessionHandler = class {
            async createSessionAllocate(t2) {
              const e2 = await fetch(t2), n2 = await e2.arrayBuffer();
              return (0, a.createSessionAllocate)(new Uint8Array(n2));
            }
            async loadModel(t2, e2) {
              if (s || (await (0, a.initOrt)(i.env.wasm.numThreads, ((t3) => {
                switch (t3) {
                  case "verbose":
                    return 0;
                  case "info":
                    return 1;
                  case "warning":
                    return 2;
                  case "error":
                    return 3;
                  case "fatal":
                    return 4;
                  default:
                    throw new Error(`unsupported logging level: ${t3}`);
                }
              })(i.env.logLevel)), s = true), "string" == typeof t2)
                if ("undefined" == typeof fetch) {
                  const n2 = await (0, o.promisify)(r.readFile)(t2);
                  [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n2, e2);
                } else {
                  const n2 = await this.createSessionAllocate(t2);
                  [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n2, e2);
                }
              else
                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(t2, e2);
            }
            async dispose() {
              return (0, a.releaseSession)(this.sessionId);
            }
            async run(t2, e2, n2) {
              const r2 = [], o2 = [];
              Object.entries(t2).forEach((t3) => {
                const e3 = t3[0], n3 = t3[1], i2 = this.inputNames.indexOf(e3);
                if (-1 === i2)
                  throw new Error(`invalid input '${e3}'`);
                r2.push(n3), o2.push(i2);
              });
              const s2 = [];
              Object.entries(e2).forEach((t3) => {
                const e3 = t3[0], n3 = this.outputNames.indexOf(e3);
                if (-1 === n3)
                  throw new Error(`invalid output '${e3}'`);
                s2.push(n3);
              });
              const u = await (0, a.run)(this.sessionId, o2, r2.map((t3) => [t3.type, t3.dims, t3.data]), s2, n2), c = {};
              for (let t3 = 0; t3 < u.length; t3++)
                c[this.outputNames[s2[t3]]] = new i.Tensor(u[t3][0], u[t3][2], u[t3][1]);
              return c;
            }
            startProfiling() {
            }
            endProfiling() {
              (0, a.endProfiling)(this.sessionId);
            }
          };
        }, 4919: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.setSessionOptions = void 0;
          const r = n(7967), i = n(4983), o = n(6361);
          e.setSessionOptions = (t2) => {
            const e2 = (0, o.getInstance)();
            let n2 = 0;
            const a = [], s = t2 || {};
            ((t3) => {
              t3.extra || (t3.extra = {}), t3.extra.session || (t3.extra.session = {});
              const e3 = t3.extra.session;
              e3.use_ort_model_bytes_directly || (e3.use_ort_model_bytes_directly = "1");
            })(s);
            try {
              void 0 === (null == t2 ? void 0 : t2.graphOptimizationLevel) && (s.graphOptimizationLevel = "all");
              const u = ((t3) => {
                switch (t3) {
                  case "disabled":
                    return 0;
                  case "basic":
                    return 1;
                  case "extended":
                    return 2;
                  case "all":
                    return 99;
                  default:
                    throw new Error(`unsupported graph optimization level: ${t3}`);
                }
              })(s.graphOptimizationLevel);
              void 0 === (null == t2 ? void 0 : t2.enableCpuMemArena) && (s.enableCpuMemArena = true), void 0 === (null == t2 ? void 0 : t2.enableMemPattern) && (s.enableMemPattern = true), void 0 === (null == t2 ? void 0 : t2.executionMode) && (s.executionMode = "sequential");
              const c = ((t3) => {
                switch (t3) {
                  case "sequential":
                    return 0;
                  case "parallel":
                    return 1;
                  default:
                    throw new Error(`unsupported execution mode: ${t3}`);
                }
              })(s.executionMode);
              let l = 0;
              if (void 0 !== (null == t2 ? void 0 : t2.logId) && (l = (0, i.allocWasmString)(t2.logId, a)), void 0 === (null == t2 ? void 0 : t2.logSeverityLevel))
                s.logSeverityLevel = 2;
              else if ("number" != typeof t2.logSeverityLevel || !Number.isInteger(t2.logSeverityLevel) || t2.logSeverityLevel < 0 || t2.logSeverityLevel > 4)
                throw new Error(`log serverity level is not valid: ${t2.logSeverityLevel}`);
              if (void 0 === (null == t2 ? void 0 : t2.logVerbosityLevel))
                s.logVerbosityLevel = 0;
              else if ("number" != typeof t2.logVerbosityLevel || !Number.isInteger(t2.logVerbosityLevel))
                throw new Error(`log verbosity level is not valid: ${t2.logVerbosityLevel}`);
              if (void 0 === (null == t2 ? void 0 : t2.enableProfiling) && (s.enableProfiling = false), n2 = e2._OrtCreateSessionOptions(u, !!s.enableCpuMemArena, !!s.enableMemPattern, c, !!s.enableProfiling, 0, l, s.logSeverityLevel, s.logVerbosityLevel), 0 === n2)
                throw new Error("Can't create session options");
              return (null == t2 ? void 0 : t2.executionProviders) && ((t3, e3, n3) => {
                for (const r2 of e3) {
                  let e4 = "string" == typeof r2 ? r2 : r2.name;
                  switch (e4) {
                    case "xnnpack":
                      e4 = "XNNPACK";
                      break;
                    case "wasm":
                    case "cpu":
                      continue;
                    default:
                      throw new Error(`not supported EP: ${e4}`);
                  }
                  const a2 = (0, i.allocWasmString)(e4, n3);
                  if (0 !== (0, o.getInstance)()._OrtAppendExecutionProvider(t3, a2))
                    throw new Error(`Can't append execution provider: ${e4}`);
                }
              })(n2, t2.executionProviders, a), void 0 !== (null == t2 ? void 0 : t2.extra) && (0, r.iterateExtraOptions)(t2.extra, "", /* @__PURE__ */ new WeakSet(), (t3, r2) => {
                const o2 = (0, i.allocWasmString)(t3, a), s2 = (0, i.allocWasmString)(r2, a);
                if (0 !== e2._OrtAddSessionConfigEntry(n2, o2, s2))
                  throw new Error(`Can't set a session config entry: ${t3} - ${r2}`);
              }), [n2, a];
            } catch (t3) {
              throw 0 !== n2 && e2._OrtReleaseSessionOptions(n2), a.forEach(e2._free), t3;
            }
          };
        }, 4983: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.allocWasmString = void 0;
          const r = n(6361);
          e.allocWasmString = (t2, e2) => {
            const n2 = (0, r.getInstance)(), i = n2.lengthBytesUTF8(t2) + 1, o = n2._malloc(i);
            return n2.stringToUTF8(t2, o, i), e2.push(o), o;
          };
        }, 349: (t, e, n) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.extractTransferableBuffers = e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = void 0;
          const r = n(586), i = n(4919), o = n(4983), a = n(6361);
          e.initOrt = (t2, e2) => {
            const n2 = (0, a.getInstance)()._OrtInit(t2, e2);
            if (0 !== n2)
              throw new Error(`Can't initialize onnxruntime. error code = ${n2}`);
          };
          const s = /* @__PURE__ */ new Map();
          e.createSessionAllocate = (t2) => {
            const e2 = (0, a.getInstance)(), n2 = e2._malloc(t2.byteLength);
            return e2.HEAPU8.set(t2, n2), [n2, t2.byteLength];
          }, e.createSessionFinalize = (t2, e2) => {
            const n2 = (0, a.getInstance)();
            let r2 = 0, o2 = 0, u2 = [];
            try {
              if ([o2, u2] = (0, i.setSessionOptions)(e2), r2 = n2._OrtCreateSession(t2[0], t2[1], o2), 0 === r2)
                throw new Error("Can't create a session");
            } finally {
              n2._free(t2[0]), n2._OrtReleaseSessionOptions(o2), u2.forEach(n2._free);
            }
            const c2 = n2._OrtGetInputCount(r2), l2 = n2._OrtGetOutputCount(r2), p = [], f = [], d = [], h = [];
            for (let t3 = 0; t3 < c2; t3++) {
              const e3 = n2._OrtGetInputName(r2, t3);
              if (0 === e3)
                throw new Error("Can't get an input name");
              f.push(e3), p.push(n2.UTF8ToString(e3));
            }
            for (let t3 = 0; t3 < l2; t3++) {
              const e3 = n2._OrtGetOutputName(r2, t3);
              if (0 === e3)
                throw new Error("Can't get an output name");
              h.push(e3), d.push(n2.UTF8ToString(e3));
            }
            return s.set(r2, [r2, f, h]), [r2, p, d];
          }, e.createSession = (t2, n2) => {
            const r2 = (0, e.createSessionAllocate)(t2);
            return (0, e.createSessionFinalize)(r2, n2);
          }, e.releaseSession = (t2) => {
            const e2 = (0, a.getInstance)(), n2 = s.get(t2);
            if (!n2)
              throw new Error("invalid session id");
            const r2 = n2[0], i2 = n2[1], o2 = n2[2];
            i2.forEach(e2._OrtFree), o2.forEach(e2._OrtFree), e2._OrtReleaseSession(r2), s.delete(t2);
          };
          const u = (t2) => {
            switch (t2) {
              case "int8":
                return 3;
              case "uint8":
                return 2;
              case "bool":
                return 9;
              case "int16":
                return 5;
              case "uint16":
                return 4;
              case "int32":
                return 6;
              case "uint32":
                return 12;
              case "float32":
                return 1;
              case "float64":
                return 11;
              case "string":
                return 8;
              case "int64":
                return 7;
              case "uint64":
                return 13;
              default:
                throw new Error(`unsupported data type: ${t2}`);
            }
          }, c = (t2) => {
            switch (t2) {
              case 3:
                return "int8";
              case 2:
                return "uint8";
              case 9:
                return "bool";
              case 5:
                return "int16";
              case 4:
                return "uint16";
              case 6:
                return "int32";
              case 12:
                return "uint32";
              case 1:
                return "float32";
              case 11:
                return "float64";
              case 8:
                return "string";
              case 7:
                return "int64";
              case 13:
                return "uint64";
              default:
                throw new Error(`unsupported data type: ${t2}`);
            }
          }, l = (t2) => {
            switch (t2) {
              case "float32":
                return Float32Array;
              case "uint8":
              case "bool":
                return Uint8Array;
              case "int8":
                return Int8Array;
              case "uint16":
                return Uint16Array;
              case "int16":
                return Int16Array;
              case "int32":
                return Int32Array;
              case "float64":
                return Float64Array;
              case "uint32":
                return Uint32Array;
              case "int64":
                return BigInt64Array;
              case "uint64":
                return BigUint64Array;
              default:
                throw new Error(`unsupported type: ${t2}`);
            }
          };
          e.run = (t2, e2, n2, i2, p) => {
            const f = (0, a.getInstance)(), d = s.get(t2);
            if (!d)
              throw new Error("invalid session id");
            const h = d[0], g = d[1], b = d[2], m = e2.length, y = i2.length;
            let _ = 0, v = [];
            const w = [], x = [];
            try {
              [_, v] = (0, r.setRunOptions)(p);
              for (let t4 = 0; t4 < m; t4++) {
                const e3 = n2[t4][0], r2 = n2[t4][1], i3 = n2[t4][2];
                let a3, s3;
                if (Array.isArray(i3)) {
                  s3 = 4 * i3.length, a3 = f._malloc(s3), x.push(a3);
                  let t5 = a3 / 4;
                  for (let e4 = 0; e4 < i3.length; e4++) {
                    if ("string" != typeof i3[e4])
                      throw new TypeError(`tensor data at index ${e4} is not a string`);
                    f.HEAPU32[t5++] = (0, o.allocWasmString)(i3[e4], x);
                  }
                } else
                  s3 = i3.byteLength, a3 = f._malloc(s3), x.push(a3), f.HEAPU8.set(new Uint8Array(i3.buffer, i3.byteOffset, s3), a3);
                const c2 = f.stackSave(), l2 = f.stackAlloc(4 * r2.length);
                try {
                  let t5 = l2 / 4;
                  r2.forEach((e4) => f.HEAP32[t5++] = e4);
                  const n3 = f._OrtCreateTensor(u(e3), a3, s3, l2, r2.length);
                  if (0 === n3)
                    throw new Error("Can't create a tensor");
                  w.push(n3);
                } finally {
                  f.stackRestore(c2);
                }
              }
              const t3 = f.stackSave(), a2 = f.stackAlloc(4 * m), s2 = f.stackAlloc(4 * m), d2 = f.stackAlloc(4 * y), T = f.stackAlloc(4 * y);
              try {
                let n3 = a2 / 4, r2 = s2 / 4, o2 = d2 / 4, u2 = T / 4;
                for (let t4 = 0; t4 < m; t4++)
                  f.HEAPU32[n3++] = w[t4], f.HEAPU32[r2++] = g[e2[t4]];
                for (let t4 = 0; t4 < y; t4++)
                  f.HEAPU32[o2++] = 0, f.HEAPU32[u2++] = b[i2[t4]];
                let p2 = f._OrtRun(h, s2, a2, m, T, y, d2, _);
                const v2 = [];
                if (0 === p2)
                  for (let t4 = 0; t4 < y; t4++) {
                    const e3 = f.HEAPU32[d2 / 4 + t4], n4 = f.stackSave(), r3 = f.stackAlloc(16);
                    let i3, o3 = 0;
                    try {
                      if (p2 = f._OrtGetTensorData(e3, r3, r3 + 4, r3 + 8, r3 + 12), 0 !== p2)
                        throw new Error(`Can't access output tensor data. error code = ${p2}`);
                      let t5 = r3 / 4;
                      const a3 = f.HEAPU32[t5++];
                      o3 = f.HEAPU32[t5++];
                      const s3 = f.HEAPU32[t5++], u3 = f.HEAPU32[t5++], d3 = [];
                      for (let t6 = 0; t6 < u3; t6++)
                        d3.push(f.HEAPU32[s3 / 4 + t6]);
                      f._OrtFree(s3);
                      const h2 = 0 === d3.length ? 1 : d3.reduce((t6, e4) => t6 * e4);
                      if (i3 = c(a3), "string" === i3) {
                        const t6 = [];
                        let e4 = o3 / 4;
                        for (let n5 = 0; n5 < h2; n5++) {
                          const r4 = f.HEAPU32[e4++], i4 = n5 === h2 - 1 ? void 0 : f.HEAPU32[e4] - r4;
                          t6.push(f.UTF8ToString(r4, i4));
                        }
                        v2.push([i3, d3, t6]);
                      } else {
                        const t6 = new (l(i3))(h2);
                        new Uint8Array(t6.buffer, t6.byteOffset, t6.byteLength).set(f.HEAPU8.subarray(o3, o3 + t6.byteLength)), v2.push([i3, d3, t6]);
                      }
                    } finally {
                      f.stackRestore(n4), "string" === i3 && o3 && f._free(o3), f._OrtReleaseTensor(e3);
                    }
                  }
                if (0 === p2)
                  return v2;
                throw new Error(`failed to call OrtRun(). error code = ${p2}.`);
              } finally {
                f.stackRestore(t3);
              }
            } finally {
              w.forEach(f._OrtReleaseTensor), x.forEach(f._free), f._OrtReleaseRunOptions(_), v.forEach(f._free);
            }
          }, e.endProfiling = (t2) => {
            const e2 = (0, a.getInstance)(), n2 = s.get(t2);
            if (!n2)
              throw new Error("invalid session id");
            const r2 = n2[0], i2 = e2._OrtEndProfiling(r2);
            if (0 === i2)
              throw new Error("Can't get an profile file name");
            e2._OrtFree(i2);
          }, e.extractTransferableBuffers = (t2) => {
            const e2 = [];
            for (const n2 of t2) {
              const t3 = n2[2];
              !Array.isArray(t3) && t3.buffer && e2.push(t3.buffer);
            }
            return e2;
          };
        }, 6361: function(t, e, n) {
          "use strict";
          var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
            Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
          } : function(t2, e2) {
            t2.default = e2;
          }), o = this && this.__importStar || function(t2) {
            if (t2 && t2.__esModule)
              return t2;
            var e2 = {};
            if (null != t2)
              for (var n2 in t2)
                "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
            return i(e2, t2), e2;
          }, a = this && this.__importDefault || function(t2) {
            return t2 && t2.__esModule ? t2 : { default: t2 };
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.dispose = e.getInstance = e.initializeWebAssembly = void 0;
          const s = o(n(6449)), u = a(n(932)), c = n(3474);
          let l, p = false, f = false, d = false;
          const h = (t2, e2) => e2 ? t2 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : t2 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm";
          e.initializeWebAssembly = async (t2) => {
            if (p)
              return Promise.resolve();
            if (f)
              throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
            if (d)
              throw new Error("previous call to 'initializeWebAssembly()' failed.");
            f = true;
            const e2 = t2.initTimeout, r2 = t2.numThreads, i2 = t2.simd, o2 = r2 > 1 && (() => {
              try {
                return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
              } catch (t3) {
                return false;
              }
            })(), a2 = i2 && (() => {
              try {
                return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
              } catch (t3) {
                return false;
              }
            })(), g = "string" == typeof t2.wasmPaths ? t2.wasmPaths : void 0, b = h(false, o2), m = h(a2, o2), y = "object" == typeof t2.wasmPaths ? t2.wasmPaths[m] : void 0;
            let _ = false;
            const v = [];
            if (e2 > 0 && v.push(new Promise((t3) => {
              setTimeout(() => {
                _ = true, t3();
              }, e2);
            })), v.push(new Promise((t3, e3) => {
              const r3 = o2 ? c : u.default, i3 = { locateFile: (t4, e4) => o2 && t4.endsWith(".worker.js") && "undefined" != typeof Blob ? URL.createObjectURL(new Blob([n(4154)], { type: "text/javascript" })) : t4 === b ? null != y ? y : (null != g ? g : e4) + m : e4 + t4 };
              if (o2)
                if ("undefined" == typeof Blob)
                  i3.mainScriptUrlOrBlob = s.join("/", "ort-wasm-threaded.js");
                else {
                  const t4 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r3.toString()}})();`;
                  i3.mainScriptUrlOrBlob = new Blob([t4], { type: "text/javascript" });
                }
              r3(i3).then((e4) => {
                f = false, p = true, l = e4, t3();
              }, (t4) => {
                f = false, d = true, e3(t4);
              });
            })), await Promise.race(v), _)
              throw new Error(`WebAssembly backend initializing failed due to timeout: ${e2}ms`);
          }, e.getInstance = () => {
            if (p && l)
              return l;
            throw new Error("WebAssembly is not initialized yet.");
          }, e.dispose = () => {
            var t2;
            !p || f || d || (f = true, null === (t2 = l.PThread) || void 0 === t2 || t2.terminateAllThreads(), l = void 0, f = false, p = false, d = true);
          };
        }, 9710: (t, e, n) => {
          "use strict";
          n.d(e, { Z: () => o });
          var r = n(477), i = n.n(r);
          function o() {
            return i()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n', "Worker", void 0, void 0);
          }
        }, 477: (t) => {
          "use strict";
          t.exports = function(t2, e, n, r) {
            var i = self || window;
            try {
              try {
                var o;
                try {
                  o = new i.Blob([t2]);
                } catch (e2) {
                  (o = new (i.BlobBuilder || i.WebKitBlobBuilder || i.MozBlobBuilder || i.MSBlobBuilder)()).append(t2), o = o.getBlob();
                }
                var a = i.URL || i.webkitURL, s = a.createObjectURL(o), u = new i[e](s, n);
                return a.revokeObjectURL(s), u;
              } catch (r2) {
                return new i[e]("data:application/javascript,".concat(encodeURIComponent(t2)), n);
              }
            } catch (t3) {
              if (!r)
                throw Error("Inline worker is not supported");
              return new i[e](r, n);
            }
          };
        }, 4154: (t) => {
          "use strict";
          t.exports = '"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n';
        }, 1670: (t) => {
          "use strict";
          t.exports = __WEBPACK_EXTERNAL_MODULE__1670__;
        }, 7067: () => {
        }, 1296: () => {
        }, 1384: () => {
        }, 3993: () => {
        }, 908: () => {
        }, 6953: () => {
        }, 9925: () => {
        }, 2806: () => {
        }, 6449: () => {
        }, 2850: () => {
        }, 5381: () => {
        }, 5686: (t, e, n) => {
          "use strict";
          n.r(e), n.d(e, { flatbuffers: () => r });
          var r = {};
          r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function(t2, e2) {
            this.low = 0 | t2, this.high = 0 | e2;
          }, r.Long.create = function(t2, e2) {
            return 0 == t2 && 0 == e2 ? r.Long.ZERO : new r.Long(t2, e2);
          }, r.Long.prototype.toFloat64 = function() {
            return (this.low >>> 0) + 4294967296 * this.high;
          }, r.Long.prototype.equals = function(t2) {
            return this.low == t2.low && this.high == t2.high;
          }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function(t2) {
            if (t2)
              e2 = t2;
            else
              var e2 = 1024;
            this.bb = r.ByteBuffer.allocate(e2), this.space = e2, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
          }, r.Builder.prototype.clear = function() {
            this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
          }, r.Builder.prototype.forceDefaults = function(t2) {
            this.force_defaults = t2;
          }, r.Builder.prototype.dataBuffer = function() {
            return this.bb;
          }, r.Builder.prototype.asUint8Array = function() {
            return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
          }, r.Builder.prototype.prep = function(t2, e2) {
            t2 > this.minalign && (this.minalign = t2);
            for (var n2 = 1 + ~(this.bb.capacity() - this.space + e2) & t2 - 1; this.space < n2 + t2 + e2; ) {
              var i = this.bb.capacity();
              this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;
            }
            this.pad(n2);
          }, r.Builder.prototype.pad = function(t2) {
            for (var e2 = 0; e2 < t2; e2++)
              this.bb.writeInt8(--this.space, 0);
          }, r.Builder.prototype.writeInt8 = function(t2) {
            this.bb.writeInt8(this.space -= 1, t2);
          }, r.Builder.prototype.writeInt16 = function(t2) {
            this.bb.writeInt16(this.space -= 2, t2);
          }, r.Builder.prototype.writeInt32 = function(t2) {
            this.bb.writeInt32(this.space -= 4, t2);
          }, r.Builder.prototype.writeInt64 = function(t2) {
            this.bb.writeInt64(this.space -= 8, t2);
          }, r.Builder.prototype.writeFloat32 = function(t2) {
            this.bb.writeFloat32(this.space -= 4, t2);
          }, r.Builder.prototype.writeFloat64 = function(t2) {
            this.bb.writeFloat64(this.space -= 8, t2);
          }, r.Builder.prototype.addInt8 = function(t2) {
            this.prep(1, 0), this.writeInt8(t2);
          }, r.Builder.prototype.addInt16 = function(t2) {
            this.prep(2, 0), this.writeInt16(t2);
          }, r.Builder.prototype.addInt32 = function(t2) {
            this.prep(4, 0), this.writeInt32(t2);
          }, r.Builder.prototype.addInt64 = function(t2) {
            this.prep(8, 0), this.writeInt64(t2);
          }, r.Builder.prototype.addFloat32 = function(t2) {
            this.prep(4, 0), this.writeFloat32(t2);
          }, r.Builder.prototype.addFloat64 = function(t2) {
            this.prep(8, 0), this.writeFloat64(t2);
          }, r.Builder.prototype.addFieldInt8 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addInt8(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldInt16 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addInt16(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldInt32 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addInt32(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldInt64 = function(t2, e2, n2) {
            !this.force_defaults && e2.equals(n2) || (this.addInt64(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldFloat32 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addFloat32(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldFloat64 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addFloat64(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldOffset = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addOffset(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldStruct = function(t2, e2, n2) {
            e2 != n2 && (this.nested(e2), this.slot(t2));
          }, r.Builder.prototype.nested = function(t2) {
            if (t2 != this.offset())
              throw new Error("FlatBuffers: struct must be serialized inline.");
          }, r.Builder.prototype.notNested = function() {
            if (this.isNested)
              throw new Error("FlatBuffers: object serialization must not be nested.");
          }, r.Builder.prototype.slot = function(t2) {
            this.vtable[t2] = this.offset();
          }, r.Builder.prototype.offset = function() {
            return this.bb.capacity() - this.space;
          }, r.Builder.growByteBuffer = function(t2) {
            var e2 = t2.capacity();
            if (3221225472 & e2)
              throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
            var n2 = e2 << 1, i = r.ByteBuffer.allocate(n2);
            return i.setPosition(n2 - e2), i.bytes().set(t2.bytes(), n2 - e2), i;
          }, r.Builder.prototype.addOffset = function(t2) {
            this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - t2 + r.SIZEOF_INT);
          }, r.Builder.prototype.startObject = function(t2) {
            this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t2;
            for (var e2 = 0; e2 < t2; e2++)
              this.vtable[e2] = 0;
            this.isNested = true, this.object_start = this.offset();
          }, r.Builder.prototype.endObject = function() {
            if (null == this.vtable || !this.isNested)
              throw new Error("FlatBuffers: endObject called without startObject");
            this.addInt32(0);
            for (var t2 = this.offset(), e2 = this.vtable_in_use - 1; e2 >= 0 && 0 == this.vtable[e2]; e2--)
              ;
            for (var n2 = e2 + 1; e2 >= 0; e2--)
              this.addInt16(0 != this.vtable[e2] ? t2 - this.vtable[e2] : 0);
            this.addInt16(t2 - this.object_start);
            var i = (n2 + 2) * r.SIZEOF_SHORT;
            this.addInt16(i);
            var o = 0, a = this.space;
            t:
              for (e2 = 0; e2 < this.vtables.length; e2++) {
                var s = this.bb.capacity() - this.vtables[e2];
                if (i == this.bb.readInt16(s)) {
                  for (var u = r.SIZEOF_SHORT; u < i; u += r.SIZEOF_SHORT)
                    if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u))
                      continue t;
                  o = this.vtables[e2];
                  break;
                }
              }
            return o ? (this.space = this.bb.capacity() - t2, this.bb.writeInt32(this.space, o - t2)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t2, this.offset() - t2)), this.isNested = false, t2;
          }, r.Builder.prototype.finish = function(t2, e2, n2) {
            var i = n2 ? r.SIZE_PREFIX_LENGTH : 0;
            if (e2) {
              var o = e2;
              if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + i), o.length != r.FILE_IDENTIFIER_LENGTH)
                throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
              for (var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--)
                this.writeInt8(o.charCodeAt(a));
            }
            this.prep(this.minalign, r.SIZEOF_INT + i), this.addOffset(t2), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
          }, r.Builder.prototype.finishSizePrefixed = function(t2, e2) {
            this.finish(t2, e2, true);
          }, r.Builder.prototype.requiredField = function(t2, e2) {
            var n2 = this.bb.capacity() - t2, r2 = n2 - this.bb.readInt32(n2);
            if (0 == this.bb.readInt16(r2 + e2))
              throw new Error("FlatBuffers: field " + e2 + " must be set");
          }, r.Builder.prototype.startVector = function(t2, e2, n2) {
            this.notNested(), this.vector_num_elems = e2, this.prep(r.SIZEOF_INT, t2 * e2), this.prep(n2, t2 * e2);
          }, r.Builder.prototype.endVector = function() {
            return this.writeInt32(this.vector_num_elems), this.offset();
          }, r.Builder.prototype.createString = function(t2) {
            if (t2 instanceof Uint8Array)
              var e2 = t2;
            else {
              e2 = [];
              for (var n2 = 0; n2 < t2.length; ) {
                var r2, i = t2.charCodeAt(n2++);
                (r2 = i < 55296 || i >= 56320 ? i : (i << 10) + t2.charCodeAt(n2++) + -56613888) < 128 ? e2.push(r2) : (r2 < 2048 ? e2.push(r2 >> 6 & 31 | 192) : (r2 < 65536 ? e2.push(r2 >> 12 & 15 | 224) : e2.push(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128), e2.push(r2 >> 6 & 63 | 128)), e2.push(63 & r2 | 128));
              }
            }
            this.addInt8(0), this.startVector(1, e2.length, 1), this.bb.setPosition(this.space -= e2.length), n2 = 0;
            for (var o = this.space, a = this.bb.bytes(); n2 < e2.length; n2++)
              a[o++] = e2[n2];
            return this.endVector();
          }, r.Builder.prototype.createLong = function(t2, e2) {
            return r.Long.create(t2, e2);
          }, r.ByteBuffer = function(t2) {
            this.bytes_ = t2, this.position_ = 0;
          }, r.ByteBuffer.allocate = function(t2) {
            return new r.ByteBuffer(new Uint8Array(t2));
          }, r.ByteBuffer.prototype.clear = function() {
            this.position_ = 0;
          }, r.ByteBuffer.prototype.bytes = function() {
            return this.bytes_;
          }, r.ByteBuffer.prototype.position = function() {
            return this.position_;
          }, r.ByteBuffer.prototype.setPosition = function(t2) {
            this.position_ = t2;
          }, r.ByteBuffer.prototype.capacity = function() {
            return this.bytes_.length;
          }, r.ByteBuffer.prototype.readInt8 = function(t2) {
            return this.readUint8(t2) << 24 >> 24;
          }, r.ByteBuffer.prototype.readUint8 = function(t2) {
            return this.bytes_[t2];
          }, r.ByteBuffer.prototype.readInt16 = function(t2) {
            return this.readUint16(t2) << 16 >> 16;
          }, r.ByteBuffer.prototype.readUint16 = function(t2) {
            return this.bytes_[t2] | this.bytes_[t2 + 1] << 8;
          }, r.ByteBuffer.prototype.readInt32 = function(t2) {
            return this.bytes_[t2] | this.bytes_[t2 + 1] << 8 | this.bytes_[t2 + 2] << 16 | this.bytes_[t2 + 3] << 24;
          }, r.ByteBuffer.prototype.readUint32 = function(t2) {
            return this.readInt32(t2) >>> 0;
          }, r.ByteBuffer.prototype.readInt64 = function(t2) {
            return new r.Long(this.readInt32(t2), this.readInt32(t2 + 4));
          }, r.ByteBuffer.prototype.readUint64 = function(t2) {
            return new r.Long(this.readUint32(t2), this.readUint32(t2 + 4));
          }, r.ByteBuffer.prototype.readFloat32 = function(t2) {
            return r.int32[0] = this.readInt32(t2), r.float32[0];
          }, r.ByteBuffer.prototype.readFloat64 = function(t2) {
            return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(t2), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(t2 + 4), r.float64[0];
          }, r.ByteBuffer.prototype.writeInt8 = function(t2, e2) {
            this.bytes_[t2] = e2;
          }, r.ByteBuffer.prototype.writeUint8 = function(t2, e2) {
            this.bytes_[t2] = e2;
          }, r.ByteBuffer.prototype.writeInt16 = function(t2, e2) {
            this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8;
          }, r.ByteBuffer.prototype.writeUint16 = function(t2, e2) {
            this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8;
          }, r.ByteBuffer.prototype.writeInt32 = function(t2, e2) {
            this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8, this.bytes_[t2 + 2] = e2 >> 16, this.bytes_[t2 + 3] = e2 >> 24;
          }, r.ByteBuffer.prototype.writeUint32 = function(t2, e2) {
            this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8, this.bytes_[t2 + 2] = e2 >> 16, this.bytes_[t2 + 3] = e2 >> 24;
          }, r.ByteBuffer.prototype.writeInt64 = function(t2, e2) {
            this.writeInt32(t2, e2.low), this.writeInt32(t2 + 4, e2.high);
          }, r.ByteBuffer.prototype.writeUint64 = function(t2, e2) {
            this.writeUint32(t2, e2.low), this.writeUint32(t2 + 4, e2.high);
          }, r.ByteBuffer.prototype.writeFloat32 = function(t2, e2) {
            r.float32[0] = e2, this.writeInt32(t2, r.int32[0]);
          }, r.ByteBuffer.prototype.writeFloat64 = function(t2, e2) {
            r.float64[0] = e2, this.writeInt32(t2, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(t2 + 4, r.int32[r.isLittleEndian ? 1 : 0]);
          }, r.ByteBuffer.prototype.getBufferIdentifier = function() {
            if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH)
              throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
            for (var t2 = "", e2 = 0; e2 < r.FILE_IDENTIFIER_LENGTH; e2++)
              t2 += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + e2));
            return t2;
          }, r.ByteBuffer.prototype.__offset = function(t2, e2) {
            var n2 = t2 - this.readInt32(t2);
            return e2 < this.readInt16(n2) ? this.readInt16(n2 + e2) : 0;
          }, r.ByteBuffer.prototype.__union = function(t2, e2) {
            return t2.bb_pos = e2 + this.readInt32(e2), t2.bb = this, t2;
          }, r.ByteBuffer.prototype.__string = function(t2, e2) {
            t2 += this.readInt32(t2);
            var n2 = this.readInt32(t2), i = "", o = 0;
            if (t2 += r.SIZEOF_INT, e2 === r.Encoding.UTF8_BYTES)
              return this.bytes_.subarray(t2, t2 + n2);
            for (; o < n2; ) {
              var a, s = this.readUint8(t2 + o++);
              if (s < 192)
                a = s;
              else {
                var u = this.readUint8(t2 + o++);
                if (s < 224)
                  a = (31 & s) << 6 | 63 & u;
                else {
                  var c = this.readUint8(t2 + o++);
                  a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & c : (7 & s) << 18 | (63 & u) << 12 | (63 & c) << 6 | 63 & this.readUint8(t2 + o++);
                }
              }
              a < 65536 ? i += String.fromCharCode(a) : (a -= 65536, i += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));
            }
            return i;
          }, r.ByteBuffer.prototype.__indirect = function(t2) {
            return t2 + this.readInt32(t2);
          }, r.ByteBuffer.prototype.__vector = function(t2) {
            return t2 + this.readInt32(t2) + r.SIZEOF_INT;
          }, r.ByteBuffer.prototype.__vector_len = function(t2) {
            return this.readInt32(t2 + this.readInt32(t2));
          }, r.ByteBuffer.prototype.__has_identifier = function(t2) {
            if (t2.length != r.FILE_IDENTIFIER_LENGTH)
              throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
            for (var e2 = 0; e2 < r.FILE_IDENTIFIER_LENGTH; e2++)
              if (t2.charCodeAt(e2) != this.readInt8(this.position_ + r.SIZEOF_INT + e2))
                return false;
            return true;
          }, r.ByteBuffer.prototype.createLong = function(t2, e2) {
            return r.Long.create(t2, e2);
          };
        } }, __webpack_module_cache__ = {};
        function __webpack_require__(t) {
          var e = __webpack_module_cache__[t];
          if (void 0 !== e)
            return e.exports;
          var n = __webpack_module_cache__[t] = { exports: {} };
          return __webpack_modules__[t].call(n.exports, n, n.exports, __webpack_require__), n.exports;
        }
        __webpack_require__.n = (t) => {
          var e = t && t.__esModule ? () => t.default : () => t;
          return __webpack_require__.d(e, { a: e }), e;
        }, __webpack_require__.d = (t, e) => {
          for (var n in e)
            __webpack_require__.o(e, n) && !__webpack_require__.o(t, n) && Object.defineProperty(t, n, { enumerable: true, get: e[n] });
        }, __webpack_require__.g = function() {
          if ("object" == typeof globalThis)
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (t) {
            if ("object" == typeof window)
              return window;
          }
        }(), __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = (t) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: true });
        };
        var __webpack_exports__ = __webpack_require__(6018);
        return __webpack_exports__;
      })());
    }
  });

  // node_modules/@xenova/transformers/src/backends/onnx.js
  var require_onnx = __commonJS({
    "node_modules/@xenova/transformers/src/backends/onnx.js"(exports2, module2) {
      var ONNX;
      var executionProviders = ["wasm"];
      if (typeof process !== "undefined") {
        try {
          ONNX = require_dist();
        } catch (err) {
          console.warn(
            "Node.js environment detected, but `onnxruntime-node` was not found. Using `onnxruntime-web` as a fallback. We recommend installing `onnxruntime-node` as it generally improves performance (up to 5X)."
          );
          global.self = global;
          ONNX = require_ort_web_min();
          ONNX.env.wasm.numThreads = 1;
        }
        executionProviders.unshift("cpu");
      } else {
        ONNX = require_ort_web_min();
      }
      module2.exports = {
        ONNX,
        executionProviders
      };
    }
  });

  // node_modules/@xenova/transformers/src/env.js
  var require_env = __commonJS({
    "node_modules/@xenova/transformers/src/env.js"(exports2, module2) {
      var fs = require_fs();
      var path = require_path();
      var { env: onnx_env } = require_onnx().ONNX;
      var CACHE_AVAILABLE = typeof self !== "undefined" && "caches" in self;
      var FS_AVAILABLE = !isEmpty(fs);
      var PATH_AVAILABLE = !isEmpty(path);
      var RUNNING_LOCALLY = FS_AVAILABLE && PATH_AVAILABLE;
      var DEFAULT_LOCAL_PATH = "/models/onnx/quantized/";
      var localURL = RUNNING_LOCALLY ? path.join(path.dirname(__dirname), DEFAULT_LOCAL_PATH) : DEFAULT_LOCAL_PATH;
      onnx_env.wasm.wasmPaths = RUNNING_LOCALLY ? path.join(path.dirname(__dirname), "/dist/") : "https://cdn.jsdelivr.net/npm/@xenova/transformers/dist/";
      var env = {
        // access onnxruntime-web's environment variables
        onnx: onnx_env,
        // whether to support loading models from the HuggingFace hub
        remoteModels: true,
        // URL to load models from
        remoteURL: "https://huggingface.co/Xenova/transformers.js/resolve/main/quantized/",
        // Local URL to load models from.
        localURL,
        // Whether to use Cache API to cache models. By default, it is true if available.
        useCache: CACHE_AVAILABLE,
        // Whether to use the file system to load files. By default, it is true available.
        useFS: FS_AVAILABLE
      };
      function isEmpty(obj) {
        return Object.keys(obj).length === 0;
      }
      module2.exports = {
        env
      };
    }
  });

  // node_modules/@xenova/transformers/src/utils.js
  var require_utils = __commonJS({
    "node_modules/@xenova/transformers/src/utils.js"(exports2, module2) {
      var fs = require_fs();
      var { env } = require_env();
      var FileResponse = class {
        constructor(filePath) {
          this.filePath = filePath;
          this.headers = {};
          this.headers.get = (x) => this.headers[x];
          this.exists = fs.existsSync(filePath);
          if (this.exists) {
            this.status = 200;
            this.statusText = "OK";
            let stats = fs.statSync(filePath);
            this.headers["content-length"] = stats.size;
            this.updateContentType();
            let self2 = this;
            this.body = new ReadableStream({
              start(controller) {
                self2.arrayBuffer().then((buffer) => {
                  controller.enqueue(new Uint8Array(buffer));
                  controller.close();
                });
              }
            });
          } else {
            this.status = 404;
            this.statusText = "Not Found";
            this.body = null;
          }
        }
        updateContentType() {
          const extension = this.filePath.split(".").pop().toLowerCase();
          switch (extension) {
            case "txt":
              this.headers["content-type"] = "text/plain";
              break;
            case "html":
              this.headers["content-type"] = "text/html";
              break;
            case "css":
              this.headers["content-type"] = "text/css";
              break;
            case "js":
              this.headers["content-type"] = "text/javascript";
              break;
            case "json":
              this.headers["content-type"] = "application/json";
              break;
            case "png":
              this.headers["content-type"] = "image/png";
              break;
            case "jpg":
            case "jpeg":
              this.headers["content-type"] = "image/jpeg";
              break;
            case "gif":
              this.headers["content-type"] = "image/gif";
              break;
            default:
              this.headers["content-type"] = "application/octet-stream";
              break;
          }
        }
        clone() {
          return new FileResponse(this.filePath, {
            status: this.status,
            statusText: this.statusText,
            headers: this.headers
          });
        }
        async arrayBuffer() {
          const data = await fs.promises.readFile(this.filePath);
          return data.buffer;
        }
        async blob() {
          const data = await fs.promises.readFile(this.filePath);
          return new Blob([data], { type: this.headers["content-type"] });
        }
        async text() {
          const data = await fs.promises.readFile(this.filePath, "utf8");
          return data;
        }
        async json() {
          return JSON.parse(await this.text());
        }
      };
      function isValidHttpUrl(string) {
        let url;
        try {
          url = new URL(string);
        } catch (_) {
          return false;
        }
        return url.protocol === "http:" || url.protocol === "https:";
      }
      async function getFile(url) {
        if (env.useFS && !isValidHttpUrl(url)) {
          return new FileResponse(url);
        } else {
          return fetch(url);
        }
      }
      function dispatchCallback(progressCallback, data) {
        if (progressCallback !== null)
          progressCallback(data);
      }
      async function getModelFile(modelPath, fileName, progressCallback = null, fatal = true) {
        dispatchCallback(progressCallback, {
          status: "initiate",
          name: modelPath,
          file: fileName
        });
        let cache;
        if (env.useCache) {
          cache = await caches.open("transformers-cache");
        }
        const request = pathJoin(modelPath, fileName);
        let response;
        let responseToCache;
        if (!env.useCache || (response = await cache.match(request)) === void 0) {
          response = await getFile(request);
          if (response.status === 404) {
            if (fatal) {
              throw Error(`File not found. Could not locate "${request}".`);
            } else {
              return null;
            }
          }
          if (env.useCache) {
            responseToCache = response.clone();
          }
        }
        dispatchCallback(progressCallback, {
          status: "download",
          name: modelPath,
          file: fileName
        });
        const buffer = await readResponse(response, (data) => {
          dispatchCallback(progressCallback, {
            status: "progress",
            ...data,
            name: modelPath,
            file: fileName
          });
        });
        if (responseToCache !== void 0 && await cache.match(request) === void 0) {
          cache.put(request, responseToCache);
        }
        dispatchCallback(progressCallback, {
          status: "done",
          name: modelPath,
          file: fileName
        });
        return buffer;
      }
      async function fetchJSON(modelPath, fileName, progressCallback = null, fatal = true) {
        let buffer = await getModelFile(modelPath, fileName, progressCallback, fatal);
        if (buffer === null) {
          return {};
        }
        let decoder = new TextDecoder("utf-8");
        let jsonData = decoder.decode(buffer);
        return JSON.parse(jsonData);
      }
      async function readResponse(response, progressCallback) {
        const contentLength = response.headers.get("Content-Length");
        if (contentLength === null) {
          console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");
        }
        let total = parseInt(contentLength ?? "0");
        let buffer = new Uint8Array(total);
        let loaded = 0;
        const reader = response.body.getReader();
        async function read() {
          const { done, value } = await reader.read();
          if (done)
            return;
          let newLoaded = loaded + value.length;
          if (newLoaded > total) {
            total = newLoaded;
            let newBuffer = new Uint8Array(total);
            newBuffer.set(buffer);
            buffer = newBuffer;
          }
          buffer.set(value, loaded);
          loaded = newLoaded;
          const progress = loaded / total * 100;
          progressCallback({
            progress,
            loaded,
            total
          });
          return read();
        }
        await read();
        return buffer;
      }
      function pathJoin(...parts) {
        parts = parts.map((part, index) => {
          if (index) {
            part = part.replace(new RegExp("^/"), "");
          }
          if (index !== parts.length - 1) {
            part = part.replace(new RegExp("/$"), "");
          }
          return part;
        });
        return parts.join("/");
      }
      function reverseDictionary(data) {
        return Object.fromEntries(Object.entries(data).map(([key, value]) => [value, key]));
      }
      function indexOfMax(arr) {
        if (arr.length === 0) {
          return -1;
        }
        var max = arr[0];
        var maxIndex = 0;
        for (var i = 1; i < arr.length; ++i) {
          if (arr[i] > max) {
            maxIndex = i;
            max = arr[i];
          }
        }
        return maxIndex;
      }
      function softmax(arr) {
        const max = Math.max(...arr);
        const exps = arr.map((x) => Math.exp(x - max));
        const sumExps = exps.reduce((acc, val) => acc + val, 0);
        const softmaxArr = exps.map((x) => x / sumExps);
        return softmaxArr;
      }
      function log_softmax(arr) {
        const softmaxArr = softmax(arr);
        const logSoftmaxArr = softmaxArr.map((x) => Math.log(x));
        return logSoftmaxArr;
      }
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function getTopItems(items, top_k = 0) {
        items = Array.from(items).map((x, i) => [i, x]).sort((a, b) => b[1] - a[1]);
        if (top_k > 0) {
          items = items.slice(0, top_k);
        }
        return items;
      }
      function dot(arr1, arr2) {
        return arr1.reduce((acc, val, i) => acc + val * arr2[i], 0);
      }
      function cos_sim(arr1, arr2) {
        const dotProduct = dot(arr1, arr2);
        const magnitudeA = magnitude(arr1);
        const magnitudeB = magnitude(arr2);
        const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);
        return cosineSimilarity;
      }
      function magnitude(arr) {
        return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));
      }
      var Callable = class extends Function {
        constructor() {
          let closure = function(...args) {
            return closure._call(...args);
          };
          return Object.setPrototypeOf(closure, new.target.prototype);
        }
        _call(...args) {
          throw Error("Must implement _call method in subclass");
        }
      };
      function isString(text) {
        return typeof text === "string" || text instanceof String;
      }
      function isIntegralNumber(x) {
        return Number.isInteger(x) || typeof x === "bigint";
      }
      function exists(x) {
        return x !== void 0 && x !== null;
      }
      module2.exports = {
        Callable,
        getModelFile,
        dispatchCallback,
        fetchJSON,
        pathJoin,
        reverseDictionary,
        indexOfMax,
        softmax,
        log_softmax,
        escapeRegExp,
        getTopItems,
        dot,
        cos_sim,
        magnitude,
        getFile,
        isIntegralNumber,
        isString,
        exists
      };
    }
  });

  // node_modules/@xenova/transformers/src/tensor_utils.js
  var require_tensor_utils = __commonJS({
    "node_modules/@xenova/transformers/src/tensor_utils.js"(exports2, module2) {
      var { ONNX } = require_onnx();
      var Tensor = class extends ONNX.Tensor {
        constructor(...args) {
          if (args[0] instanceof ONNX.Tensor) {
            super(args[0].type, args[0].data, args[0].dims);
          } else {
            super(...args);
          }
        }
        *[Symbol.iterator]() {
          const [iterLength, ...iterDims] = this.dims;
          if (iterDims.length > 0) {
            const iterSize = iterDims.reduce((a, b) => a * b);
            for (let i = 0; i < iterLength; ++i) {
              yield this._subarray(i, iterSize, iterDims);
            }
          } else {
            yield* this.data;
          }
        }
        get(index) {
          const iterDims = this.dims.slice(1);
          if (iterDims.length > 0) {
            const iterSize = iterDims.reduce((a, b) => a * b);
            return this._subarray(index, iterSize, iterDims);
          } else {
            return this.data[index];
          }
        }
        indexOf(item) {
          for (let index = 0; index < this.data.length; ++index) {
            if (this.data[index] == item) {
              return index;
            }
          }
          return -1;
        }
        _subarray(index, iterSize, iterDims) {
          let data = this.data.subarray(index * iterSize, (index + 1) * iterSize);
          return new Tensor(this.type, data, iterDims);
        }
        tolist() {
          return reshape(this.data, this.dims);
        }
        // TODO add .slice()
      };
      function reshape(data, dimensions) {
        const totalElements = data.length;
        const dimensionSize = dimensions.reduce((a, b) => a * b);
        if (totalElements !== dimensionSize) {
          throw Error(`cannot reshape array of size ${totalElements} into shape (${dimensions})`);
        }
        let reshapedArray = data;
        for (let i = dimensions.length - 1; i >= 0; i--) {
          reshapedArray = reshapedArray.reduce((acc, val) => {
            let lastArray = acc[acc.length - 1];
            if (lastArray.length < dimensions[i]) {
              lastArray.push(val);
            } else {
              acc.push([val]);
            }
            return acc;
          }, [[]]);
        }
        return reshapedArray[0];
      }
      function transpose(tensor, axes) {
        const shape = new Array(axes.length);
        const stride = new Array(axes.length);
        for (let i = axes.length - 1, s = 1; i >= 0; --i) {
          stride[i] = s;
          shape[i] = tensor.dims[axes[i]];
          s *= shape[i];
        }
        const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);
        const transposedData = new tensor.data.constructor(tensor.data.length);
        for (let i = 0; i < tensor.data.length; ++i) {
          let newIndex = 0;
          for (let j = tensor.dims.length - 1, k = i; j >= 0; --j) {
            newIndex += k % tensor.dims[j] * invStride[j];
            k = Math.floor(k / tensor.dims[j]);
          }
          transposedData[newIndex] = tensor.data[i];
        }
        return new Tensor(tensor.type, transposedData, shape);
      }
      function cat(tensors) {
        if (tensors.length === 0) {
          return tensors[0];
        }
        let tensorType = tensors[0].type;
        let tensorShape = [...tensors[0].dims];
        tensorShape[0] = tensors.length;
        let total = 0;
        for (let t of tensors) {
          total += t.data.length;
        }
        let data = new tensors[0].data.constructor(total);
        let offset = 0;
        for (let t of tensors) {
          data.set(t.data, offset);
          offset += t.data.length;
        }
        return new Tensor(tensorType, data, tensorShape);
      }
      module2.exports = {
        Tensor,
        transpose,
        cat
      };
    }
  });

  // node_modules/@xenova/transformers/src/tokenizers.js
  var require_tokenizers = __commonJS({
    "node_modules/@xenova/transformers/src/tokenizers.js"(exports2, module2) {
      var {
        Callable,
        fetchJSON,
        reverseDictionary,
        escapeRegExp,
        isIntegralNumber
      } = require_utils();
      var { Tensor } = require_tensor_utils();
      var TokenizerModel = class extends Callable {
        constructor(config) {
          super();
          this.config = config;
        }
        static fromConfig(config, ...args) {
          switch (config.type) {
            case "WordPiece":
              return new WordPieceTokenizer(config);
            case "Unigram":
              return new Unigram(config, ...args);
            case "BPE":
              return new BPE(config, ...args);
            default:
              throw new Error(`Unknown TokenizerModel type: ${config.type}`);
          }
        }
        _call(tokens) {
          return this.encode(tokens);
        }
        encode(tokens) {
          throw Error("encode should be implemented in subclass.");
        }
        convert_tokens_to_ids(tokens) {
          return tokens.map((t) => this.tokens_to_ids[t] ?? this.unk_token_id);
        }
        convert_ids_to_tokens(ids) {
          return ids.map((i) => this.vocab[i] ?? this.unk_token);
        }
      };
      var WordPieceTokenizer = class extends TokenizerModel {
        constructor(config) {
          super(config);
          this.tokens_to_ids = config.vocab;
          this.unk_token_id = this.tokens_to_ids[config.unk_token];
          this.unk_token = config.unk_token;
          let e = Object.entries(this.tokens_to_ids);
          this.vocab = Array(e.length);
          for (const [key, value] of e) {
            this.vocab[value] = key;
          }
        }
        encode(tokens) {
          let outputTokens = [];
          for (let token of tokens) {
            let chars = [...token];
            let isUnknown = false;
            let start = 0;
            let subTokens = [];
            while (start < chars.length) {
              let end = chars.length;
              let currentSubstring = null;
              while (start < end) {
                let substr = chars.slice(start, end).join("");
                if (start > 0) {
                  substr = this.config.continuing_subword_prefix + substr;
                }
                if (this.vocab.includes(substr)) {
                  currentSubstring = substr;
                  break;
                }
                --end;
              }
              if (currentSubstring == null) {
                isUnknown = true;
                break;
              }
              subTokens.push(currentSubstring);
              start = end;
            }
            if (isUnknown) {
              outputTokens.push(this.unknownToken);
            } else {
              outputTokens.push(...subTokens);
            }
          }
          return outputTokens;
        }
      };
      var Unigram = class extends TokenizerModel {
        constructor(config, moreConfig) {
          super(config);
          this.vocab = config.vocab.map((x) => x[0]);
          this.scores = config.vocab.map((x) => x[1]);
          this.unk_token_id = config.unk_id;
          this.unk_token = this.vocab[config.unk_id];
          this.tokens_to_ids = Object.fromEntries(this.vocab.map((x, i) => [x, i]));
          this.bosToken = " ";
          this.bosTokenId = this.tokens_to_ids[this.bosToken];
          this.eosToken = moreConfig.eos_token;
          this.eosTokenId = this.tokens_to_ids[this.eosToken];
          this.unkToken = this.vocab[this.unk_token_id];
          this.minScore = Math.min(...this.scores);
          this.unkScore = this.minScore - 10;
          this.scores[this.unk_token_id] = this.unkScore;
          this.trie = new CharTrie();
          this.trie.push(...this.vocab);
        }
        populateNodes(lattice) {
          const sentence = lattice.sentence;
          const len = sentence.length;
          let beginPos = 0;
          while (beginPos < len) {
            const mblen = 1;
            let hasSingleNode = false;
            const tokens = [];
            for (let token of this.trie.commonPrefixSearch(sentence.slice(beginPos))) {
              tokens.push(token);
              const tokenId = this.tokens_to_ids[token];
              const tokenScore = this.scores[tokenId];
              const n = token.length;
              lattice.insert(beginPos, n, tokenScore, tokenId);
              if (!hasSingleNode && n == mblen) {
                hasSingleNode = true;
              }
            }
            if (!hasSingleNode) {
              lattice.insert(beginPos, mblen, this.unkScore, this.unk_token_id);
            }
            beginPos += mblen;
          }
        }
        tokenize(normalized) {
          const lattice = new TokenLattice(normalized, this.bosTokenId, this.eosTokenId);
          this.populateNodes(lattice);
          return lattice.tokens();
        }
        encode(tokens) {
          let toReturn = [];
          for (let token of tokens) {
            const tokenized = this.tokenize(token);
            toReturn.push(...tokenized);
          }
          return toReturn;
        }
      };
      var BYTES_TO_UNICODE = (() => {
        const bs = [
          ...Array.from({ length: "~".charCodeAt(0) - "!".charCodeAt(0) + 1 }, (_, i) => i + "!".charCodeAt(0)),
          ...Array.from({ length: "\xAC".charCodeAt(0) - "\xA1".charCodeAt(0) + 1 }, (_, i) => i + "\xA1".charCodeAt(0)),
          ...Array.from({ length: "\xFF".charCodeAt(0) - "\xAE".charCodeAt(0) + 1 }, (_, i) => i + "\xAE".charCodeAt(0))
        ];
        let cs = bs.slice();
        let n = 0;
        for (let b = 0; b < 256; b++) {
          if (!bs.includes(b)) {
            bs.push(b);
            cs.push(256 + n);
            n += 1;
          }
        }
        cs = cs.map((n2) => String.fromCharCode(n2));
        return Object.fromEntries(bs.map((b, i) => [b, cs[i]]));
      })();
      var UNICODE_TO_BYTES = reverseDictionary(BYTES_TO_UNICODE);
      var BPE = class extends TokenizerModel {
        constructor(config) {
          super(config);
          this.tokens_to_ids = config.vocab;
          this.unk_token_id = this.tokens_to_ids[config.unk_token];
          this.unk_token = config.unk_token;
          let e = Object.entries(this.tokens_to_ids);
          this.vocab = Array(e.length);
          for (const [key, value] of e) {
            this.vocab[value] = key;
          }
          this.bpe_ranks = Object.fromEntries(config.merges.map((x, i) => [x, i]));
          this.merges = config.merges.map((x) => x.split(/\s+/));
          this.byte_encoder = BYTES_TO_UNICODE;
          this.text_encoder = new TextEncoder();
          this.cache = {};
        }
        get_pairs(word) {
          let pairs = /* @__PURE__ */ new Set();
          let prev_char = word[0];
          for (let i = 1; i < word.length; i++) {
            let char = word[i];
            pairs.add(`${prev_char} ${char}`);
            prev_char = char;
          }
          return [...pairs];
        }
        bpe(token) {
          if (token in this.cache) {
            return this.cache[token];
          }
          let word = Array.from(token);
          let pairs = this.get_pairs(word);
          if (!pairs.length) {
            return token;
          }
          while (true) {
            let bigram = pairs.reduce((a, b) => {
              let c = this.bpe_ranks[a] ?? Infinity;
              let d = this.bpe_ranks[b] ?? Infinity;
              return c <= d ? a : b;
            });
            if (!(bigram in this.bpe_ranks)) {
              break;
            }
            let [first, second] = bigram.split(/\s+/g);
            let new_word = [];
            let i = 0;
            let j = -1;
            while (i < word.length) {
              try {
                j = word.indexOf(first, i);
                if (j === -1)
                  throw "Error";
              } catch (e) {
                new_word.push(...word.slice(i));
                break;
              }
              new_word.push(...word.slice(i, j));
              i = j;
              if (word[i] === first && i < word.length - 1 && word[i + 1] === second) {
                new_word.push(first + second);
                i += 2;
              } else {
                new_word.push(word[i]);
                i += 1;
              }
            }
            word = new_word;
            if (word.length === 1) {
              break;
            } else {
              pairs = this.get_pairs(word);
            }
          }
          let final_word = word.join(" ");
          this.cache[token] = final_word;
          return final_word;
        }
        encode(tokens) {
          let outputTokens = [];
          for (let token of tokens) {
            token = Array.from(this.text_encoder.encode(token), (byte) => this.byte_encoder[byte]).join("");
            let bpe_token_list = this.bpe(token).split(" ");
            outputTokens.push(...bpe_token_list);
          }
          return outputTokens;
        }
      };
      var Normalizer = class extends Callable {
        constructor(config) {
          super();
          this.config = config;
        }
        static fromConfig(config) {
          if (config === null)
            return null;
          switch (config.type) {
            case "BertNormalizer":
              return new BertNormalizer(config);
            case "Precompiled":
              return new Precompiled(config);
            case "Sequence":
              return new NormalizerSequence(config);
            case "Replace":
              return new Replace(config);
            case "NFC":
              return new NFC(config);
            case "NFKD":
              return new NFKD(config);
            case "StripAccents":
              return new StripAccents(config);
            case "Lowercase":
              return new Lowercase(config);
            default:
              throw new Error(`Unknown Normalizer type: ${config.type}`);
          }
        }
        normalize(text) {
          throw Error("normalize should be implemented in subclass.");
        }
        _call(text) {
          return this.normalize(text);
        }
      };
      var Replace = class extends Normalizer {
        normalize(text) {
          if (this.config.pattern.Regex) {
            text = text.replace(new RegExp(this.config.pattern.Regex, "g"), this.config.content);
          } else if (this.config.pattern.String) {
            text = text.replace(this.config.pattern.String, this.config.content);
          } else {
            console.warn("Unknown pattern type:", this.config.pattern);
          }
          return text;
        }
      };
      var NFC = class extends Normalizer {
        normalize(text) {
          text = text.normalize("NFC");
          return text;
        }
      };
      var NFKD = class extends Normalizer {
        normalize(text) {
          text = text.normalize("NFKD");
          return text;
        }
      };
      var StripAccents = class extends Normalizer {
        normalize(text) {
          text = text.replace(/[\u0300-\u036f]/g, "");
          return text;
        }
      };
      var Lowercase = class extends Normalizer {
        normalize(text) {
          text = text.toLowerCase();
          return text;
        }
      };
      var NormalizerSequence = class extends Normalizer {
        constructor(config) {
          super(config);
          this.normalizers = config.normalizers.map((x) => Normalizer.fromConfig(x));
        }
        normalize(text) {
          for (let normalizer of this.normalizers) {
            text = normalizer.normalize(text);
          }
          return text;
        }
      };
      var BertNormalizer = class extends Normalizer {
        _tokenize_chinese_chars(text) {
          let output = [];
          for (let i = 0; i < text.length; ++i) {
            let char = text[i];
            let cp = char.charCodeAt(0);
            if (this._is_chinese_char(cp)) {
              output.push(" ");
              output.push(char);
              output.push(" ");
            } else {
              output.push(char);
            }
          }
          return output.join("");
        }
        _is_chinese_char(cp) {
          return cp >= 19968 && cp <= 40959 || cp >= 13312 && cp <= 19903 || cp >= 131072 && cp <= 173791 || cp >= 173824 && cp <= 177983 || cp >= 177984 && cp <= 178207 || cp >= 178208 && cp <= 183983 || cp >= 63744 && cp <= 64255 || cp >= 194560 && cp <= 195103;
        }
        stripAccents(text) {
          return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }
        normalize(text) {
          if (this.config.handle_chinese_chars) {
            text = this._tokenize_chinese_chars(text);
          }
          if (this.config.lowercase) {
            text = text.toLowerCase();
            if (this.config.strip_accents !== false) {
              text = this.stripAccents(text);
            }
          } else if (this.config.strip_accents) {
            text = this.stripAccents(text);
          }
          return text;
        }
      };
      var PreTokenizer = class extends Callable {
        static fromConfig(config) {
          switch (config.type) {
            case "BertPreTokenizer":
              return new BertPreTokenizer(config);
            case "Sequence":
              return new PreTokenizerSequence(config);
            case "WhitespaceSplit":
              return new WhitespaceSplit(config);
            case "Metaspace":
              return new MetaspacePreTokenizer(config);
            case "ByteLevel":
              return new ByteLevelPreTokenizer(config);
            case "Split":
              return new SplitPreTokenizer(config);
            default:
              throw new Error(`Unknown PreTokenizer type: ${config.type}`);
          }
        }
        pre_tokenize_text(text) {
          throw Error("pre_tokenize_text should be implemented in subclass.");
        }
        pre_tokenize(text) {
          let result = [];
          if (Array.isArray(text)) {
            result = text.map((x) => this.pre_tokenize_text(x));
          } else {
            result = this.pre_tokenize_text(text);
          }
          return result.flat();
        }
        _call(text) {
          return this.pre_tokenize(text);
        }
      };
      var BertPreTokenizer = class extends PreTokenizer {
        constructor(config) {
          super();
          this.pattern = /\b\w+\b|[^\s\w]+/g;
        }
        pre_tokenize_text(text) {
          return text.trim().match(this.pattern) || [];
        }
      };
      var ByteLevelPreTokenizer = class extends PreTokenizer {
        constructor(config) {
          super();
          this.pattern = /'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu;
        }
        pre_tokenize_text(text) {
          return text.match(this.pattern) || [];
        }
      };
      var SplitPreTokenizer = class extends PreTokenizer {
        constructor(config) {
          super();
          this.config = config;
        }
        pre_tokenize_text(text) {
          if (this.config.pattern.Regex) {
            return text.match(new RegExp(this.config.pattern.Regex, "gu")) || [];
          } else if (this.config.pattern.String) {
            return text.match(this.config.pattern.String) || [];
          } else {
            console.warn("Unknown pattern type:", this.config.pattern);
          }
          return [];
        }
      };
      var PostProcessor = class extends Callable {
        static fromConfig(config) {
          switch (config.type) {
            case "TemplateProcessing":
              return new TemplateProcessing(config);
            case "ByteLevel":
              return new ByteLevelPostProcessor(config);
            case "RobertaProcessing":
              return new RobertaProcessing(config);
            default:
              throw new Error(`Unknown PostProcessor type: ${config.type}`);
          }
        }
        post_process(tokens, ...args) {
          throw Error("post_process should be implemented in subclass.");
        }
        _call(tokens, ...args) {
          return this.post_process(tokens, ...args);
        }
      };
      var RobertaProcessing = class extends PostProcessor {
        constructor(config) {
          super();
          this.config = config;
        }
        post_process(tokens, tokens_pair = null) {
          tokens = [this.config.cls[0], ...tokens, this.config.sep[0]];
          if (tokens_pair !== null) {
            tokens = [...tokens, this.config.sep[0], ...tokens_pair, this.config.sep[0]];
          }
          return tokens;
        }
      };
      var TemplateProcessing = class extends PostProcessor {
        constructor(config) {
          super();
          this.config = config;
        }
        post_process(tokens, tokens_pair = null) {
          let type = tokens_pair === null ? this.config.single : this.config.pair;
          let toReturn = [];
          for (let item of type) {
            if ("SpecialToken" in item) {
              toReturn.push(item.SpecialToken.id);
            } else if ("Sequence" in item) {
              if (item.Sequence.id === "A") {
                toReturn.push(...tokens);
              } else if (item.Sequence.id === "B") {
                toReturn.push(...tokens_pair);
              }
            }
          }
          return toReturn;
        }
      };
      var ByteLevelPostProcessor = class extends PostProcessor {
        constructor(config) {
          super();
          this.config = config;
        }
        post_process(tokens) {
          return tokens;
        }
      };
      var Decoder = class extends Callable {
        constructor(config) {
          super();
          this.config = config;
        }
        static fromConfig(config) {
          switch (config.type) {
            case "WordPiece":
              return new WordPieceDecoder(config);
            case "Metaspace":
              return new MetaspaceDecoder(config);
            case "ByteLevel":
              return new ByteLevelDecoder(config);
            default:
              throw new Error(`Unknown Decoder type: ${config.type}`);
          }
        }
        convert_tokens_to_string(tokens) {
          return tokens.join("").trim();
        }
        _call(tokens) {
          return this.decode(tokens);
        }
        decode(tokens) {
          throw Error("decode should be implemented in subclass.");
        }
      };
      var WordPieceDecoder = class extends Decoder {
        constructor(config) {
          super(config);
          this.convertRegex = new RegExp(` ${config.prefix}`, "g");
        }
        convert_tokens_to_string(tokens) {
          return tokens.join(" ").replace(this.convertRegex, "").trim();
        }
        decode(tokens) {
          return this.convert_tokens_to_string(tokens);
        }
      };
      var ByteLevelDecoder = class extends Decoder {
        constructor(config) {
          super(config);
          this.byte_decoder = UNICODE_TO_BYTES;
          this.text_decoder = new TextDecoder("utf-8", {
            fatal: false,
            ignoreBOM: true,
            ignoreEncoding: false
          });
        }
        convert_tokens_to_string(tokens) {
          let text = tokens.join("");
          if (this.config.trim_offsets) {
            text = text.trim();
          } else if (this.config.add_prefix_space) {
            text = " " + text;
          }
          let byteArray = new Uint8Array([...text].map((c) => this.byte_decoder[c]));
          let decoded_text = this.text_decoder.decode(byteArray);
          return decoded_text;
        }
        decode(tokens) {
          let sub_texts = [];
          let current_sub_text = [];
          for (let token of tokens) {
            if (this.added_tokens.includes(token)) {
              if (current_sub_text.length > 0) {
                sub_texts.push(this.convert_tokens_to_string(current_sub_text));
                current_sub_text = [];
              }
              sub_texts.push(token);
            } else {
              current_sub_text.push(token);
            }
          }
          if (current_sub_text.length > 0) {
            sub_texts.push(this.convert_tokens_to_string(current_sub_text));
          }
          let text = sub_texts.join("");
          return text;
        }
      };
      var MetaspacePreTokenizer = class extends PreTokenizer {
        constructor(config) {
          super();
          this.addPrefixSpace = config.add_prefix_space;
          this.replacement = config.replacement;
          this.strRep = config.str_rep || this.replacement;
        }
        pre_tokenize(normalizedTokens) {
          if (typeof normalizedTokens === "string" || normalizedTokens instanceof String) {
            normalizedTokens = normalizedTokens.split(/\s+/);
          }
          const result = [];
          for (let token of normalizedTokens) {
            let normalized = token.replace(" ", this.strRep);
            if (this.addPrefixSpace && !normalized.startsWith(this.replacement)) {
              normalized = this.strRep + normalized;
            }
            result.push(normalized);
          }
          return result;
        }
      };
      var MetaspaceDecoder = class extends Decoder {
        constructor(config) {
          super(config);
          this.addPrefixSpace = config.add_prefix_space;
          this.replacement = config.replacement;
        }
        decode(tokens) {
          let result = [];
          let i = 0;
          for (let token of tokens) {
            let normalized = token.replace(this.replacement, " ");
            if (this.addPrefixSpace && i == 0 && normalized.startsWith(" ")) {
              normalized = normalized.substring(1);
            }
            result.push(normalized);
            ++i;
          }
          return this.convert_tokens_to_string(result);
        }
      };
      var Precompiled = class extends Normalizer {
        constructor(config) {
          super(config);
          this.charsmap = config.precompiled_charsmap;
        }
        normalize(text) {
          return text;
        }
      };
      var PreTokenizerSequence = class extends PreTokenizer {
        constructor(config) {
          super();
          this.tokenizers = config.pretokenizers.map((x) => PreTokenizer.fromConfig(x));
        }
        pre_tokenize_text(text) {
          for (let tokenizer of this.tokenizers) {
            text = tokenizer.pre_tokenize(text);
          }
          return text;
        }
      };
      var WhitespaceSplit = class extends PreTokenizer {
        constructor(config) {
          super();
        }
        pre_tokenize_text(text) {
          return text.split(/\s+/);
        }
      };
      var AutoTokenizer = class {
        // Helper class to determine tokenizer type from tokenizer.json
        static async from_pretrained(modelPath, progressCallback = null) {
          let [tokenizerJSON, tokenizerConfig] = await Promise.all([
            fetchJSON(modelPath, "tokenizer.json", progressCallback),
            fetchJSON(modelPath, "tokenizer_config.json", progressCallback)
          ]);
          switch (tokenizerConfig.tokenizer_class) {
            case "T5Tokenizer":
              return new T5Tokenizer(tokenizerJSON, tokenizerConfig);
            case "DistilBertTokenizer":
              return new DistilBertTokenizer(tokenizerJSON, tokenizerConfig);
            case "BertTokenizer":
              return new BertTokenizer(tokenizerJSON, tokenizerConfig);
            case "AlbertTokenizer":
              return new AlbertTokenizer(tokenizerJSON, tokenizerConfig);
            case "GPT2Tokenizer":
              return new GPT2Tokenizer(tokenizerJSON, tokenizerConfig);
            case "BartTokenizer":
              return new BartTokenizer(tokenizerJSON, tokenizerConfig);
            case "RobertaTokenizer":
              return new RobertaTokenizer(tokenizerJSON, tokenizerConfig);
            case "WhisperTokenizer":
              return new WhisperTokenizer(tokenizerJSON, tokenizerConfig);
            case "CodeGenTokenizer":
              return new CodeGenTokenizer(tokenizerJSON, tokenizerConfig);
            case "CLIPTokenizer":
              return new CLIPTokenizer(tokenizerJSON, tokenizerConfig);
            default:
              console.warn(`Unknown tokenizer class "${tokenizerConfig.tokenizer_class}", attempting to construct from base class.`);
              return new PreTrainedTokenizer(tokenizerJSON, tokenizerConfig);
          }
        }
      };
      var PreTrainedTokenizer = class extends Callable {
        constructor(tokenizerJSON, tokenizerConfig) {
          super();
          this.tokenizerJSON = tokenizerJSON;
          this.tokenizerConfig = tokenizerConfig;
          this.normalizer = Normalizer.fromConfig(tokenizerJSON.normalizer);
          this.pre_tokenizer = PreTokenizer.fromConfig(tokenizerJSON.pre_tokenizer);
          this.model = TokenizerModel.fromConfig(tokenizerJSON.model, tokenizerConfig);
          this.post_processor = PostProcessor.fromConfig(tokenizerJSON.post_processor);
          this.decoder = Decoder.fromConfig(tokenizerJSON.decoder);
          this.decoder.added_tokens = [];
          this.special_tokens = [];
          this.all_special_ids = [];
          for (let addedToken of tokenizerJSON.added_tokens) {
            let id = addedToken.id;
            let content = addedToken.content;
            this.decoder.added_tokens.push(content);
            this.model.tokens_to_ids[content] = id;
            this.model.vocab[id] = content;
            if (addedToken.special) {
              this.special_tokens.push(content);
              this.all_special_ids.push(id);
            }
          }
          this.special_tokens_regex = new RegExp(
            "(" + this.special_tokens.map(escapeRegExp).join("|") + ")"
          );
          this.mask_token = this.getToken("mask_token");
          this.mask_token_id = this.model.tokens_to_ids[this.mask_token];
          this.pad_token = this.getToken("pad_token", "eos_token");
          this.pad_token_id = this.model.tokens_to_ids[this.pad_token];
          this.sep_token = this.getToken("sep_token");
          this.sep_token_id = this.model.tokens_to_ids[this.sep_token];
          this.model_max_length = this.tokenizerConfig.model_max_length;
          this.remove_space = this.tokenizerConfig.remove_space;
          this.padding_side = "right";
        }
        getToken(...keys) {
          for (let key of keys) {
            let item = this.tokenizerConfig[key];
            if (!item)
              continue;
            if (typeof item === "object") {
              if (item.__type === "AddedToken") {
                return item.content;
              } else {
                throw Error(`Unknown token: ${item}`);
              }
            } else {
              return item;
            }
          }
          return null;
        }
        static async from_pretrained(modelPath, progressCallback = null) {
          let [tokenizerJSON, tokenizerConfig] = await Promise.all([
            fetchJSON(modelPath, "tokenizer.json", progressCallback),
            fetchJSON(modelPath, "tokenizer_config.json", progressCallback)
          ]);
          return new this(tokenizerJSON, tokenizerConfig);
        }
        prepare_model_inputs(inputs) {
          return inputs;
        }
        _call(text, {
          text_pair = null,
          // add_special_tokens = true, // TODO
          padding = false,
          truncation = null,
          max_length = null,
          return_tensor = true
          // Different to HF
        } = {}) {
          let tokens;
          if (Array.isArray(text)) {
            if (text.length === 0) {
              throw Error("text array must be non-empty");
            }
            if (text_pair !== null) {
              if (!Array.isArray(text_pair)) {
                throw Error("text_pair must also be an array");
              } else if (text.length !== text_pair.length) {
                throw Error("text and text_pair must have the same length");
              }
              tokens = text.map(
                (text2, i) => this.encode(text2, text_pair[i])
              );
            } else {
              tokens = text.map((x) => this.encode(x));
            }
          } else {
            if (text === null) {
              throw Error("text may not be null");
            }
            tokens = [this.encode(text, text_pair)];
          }
          let maxLengthOfBatch = Math.max(...tokens.map((x) => x.length));
          if (max_length === null) {
            max_length = maxLengthOfBatch;
          }
          max_length = Math.min(max_length, this.model_max_length);
          let attention_mask = [];
          if (padding || truncation) {
            for (let i = 0; i < tokens.length; ++i) {
              if (tokens[i].length === max_length) {
                attention_mask.push(new Array(tokens[i].length).fill(1));
                continue;
              } else if (tokens[i].length > max_length) {
                if (truncation) {
                  tokens[i] = tokens[i].slice(0, max_length);
                }
                attention_mask.push(new Array(tokens[i].length).fill(1));
              } else {
                if (padding) {
                  let diff = max_length - tokens[i].length;
                  if (this.padding_side === "right") {
                    attention_mask.push(
                      new Array(tokens[i].length).fill(1).concat(new Array(diff).fill(0))
                    );
                    tokens[i].push(...new Array(diff).fill(this.pad_token_id));
                  } else {
                    attention_mask.push(
                      new Array(diff).fill(0).concat(new Array(tokens[i].length).fill(1))
                    );
                    tokens[i].unshift(...new Array(diff).fill(this.pad_token_id));
                  }
                } else {
                  attention_mask.push(new Array(tokens[i].length).fill(1));
                }
              }
            }
          } else {
            attention_mask = tokens.map((x) => new Array(x.length).fill(1));
          }
          if (return_tensor) {
            if (!(padding && truncation)) {
              if (tokens.some((x) => x.length !== tokens[0].length)) {
                throw Error(
                  "Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length."
                );
              }
            }
            let dims = [tokens.length, tokens[0].length];
            tokens = new Tensor(
              "int64",
              BigInt64Array.from(tokens.flat().map(BigInt)),
              dims
            );
            attention_mask = new Tensor(
              "int64",
              BigInt64Array.from(attention_mask.flat().map(BigInt)),
              dims
            );
          }
          let modelInputs = {
            input_ids: tokens,
            attention_mask
          };
          modelInputs = this.prepare_model_inputs(modelInputs);
          return modelInputs;
        }
        _encode_text(text) {
          if (text === null)
            return null;
          const sections = text.split(this.special_tokens_regex).filter((x) => x);
          let tokens = sections.map((x) => {
            if (this.special_tokens.includes(x)) {
              return x;
            } else {
              if (this.remove_space === true) {
                x = x.trim().split(/\s+/).join(" ");
              }
              if (this.normalizer !== null) {
                x = this.normalizer(x);
              }
              let sectionTokens = this.pre_tokenizer(x);
              return this.model(sectionTokens);
            }
          }).flat();
          return tokens;
        }
        encode(text, text_pair = null) {
          let tokens = this._encode_text(text);
          let tokens2 = this._encode_text(text_pair);
          let combinedTokens = this.post_processor(tokens, tokens2);
          let ids = this.model.convert_tokens_to_ids(combinedTokens);
          return ids;
        }
        clean_up_tokenization(text) {
          return text.replace(/ \./g, ".").replace(/ \?/g, "?").replace(/ \!/g, "!").replace(/ ,/g, ",").replace(/ \' /g, "'").replace(/ n\'t/g, "n't").replace(/ \'m/g, "'m").replace(/ \'s/g, "'s").replace(/ \'ve/g, "'ve").replace(/ \'re/g, "'re");
        }
        batch_decode(batch, decode_args = {}) {
          return batch.map((x) => this.decode(x, decode_args));
        }
        decode(token_ids, decode_args = {}) {
          if (!Array.isArray(token_ids) || token_ids.length === 0 || !isIntegralNumber(token_ids[0])) {
            throw Error("token_ids must be a non-empty array of integers.");
          }
          return this.decode_single(
            token_ids,
            decode_args
          );
        }
        decode_single(token_ids, {
          skip_special_tokens = false,
          clean_up_tokenization_spaces = true
        }) {
          let tokens = this.model.convert_ids_to_tokens(token_ids);
          if (skip_special_tokens) {
            tokens = tokens.filter((x) => !this.special_tokens.includes(x));
          }
          let decoded = this.decoder(tokens);
          if (this.decoder.cleanup !== void 0 && this.decoder.cleanup !== clean_up_tokenization_spaces) {
            console.warn(`clean_up_tokenization_spaces disagrees with decoder's cleanup setting. Overriding to use decoder's cleanup setting (${this.decoder.cleanup})`);
            clean_up_tokenization_spaces = this.decoder.cleanup;
          }
          if (clean_up_tokenization_spaces) {
            decoded = this.clean_up_tokenization(decoded);
          }
          return decoded;
        }
      };
      var BertTokenizer = class extends PreTrainedTokenizer {
        prepare_model_inputs(inputs) {
          inputs.token_type_ids = new Tensor(
            "int64",
            new BigInt64Array(inputs.input_ids.data.length),
            inputs.input_ids.dims
          );
          return inputs;
        }
      };
      var AlbertTokenizer = class extends PreTrainedTokenizer {
        prepare_model_inputs(inputs) {
          inputs.token_type_ids = new Tensor(
            "int64",
            new BigInt64Array(inputs.input_ids.data.length),
            inputs.input_ids.dims
          );
          return inputs;
        }
      };
      var DistilBertTokenizer = class extends PreTrainedTokenizer {
      };
      var T5Tokenizer = class extends PreTrainedTokenizer {
      };
      var GPT2Tokenizer = class extends PreTrainedTokenizer {
      };
      var BartTokenizer = class extends PreTrainedTokenizer {
      };
      var RobertaTokenizer = class extends PreTrainedTokenizer {
      };
      var WhisperTokenizer = class extends PreTrainedTokenizer {
        _decode_asr(sequences, {
          return_timestamps = false,
          return_language = false,
          time_precision = null,
          force_full_sequences = true
        } = {}) {
          if (time_precision === null) {
            throw Error("Must specify time_precision");
          }
          let last_language = null;
          function new_chunk() {
            return { "language": last_language, "timestamp": [null, null], "text": "" };
          }
          const chunks = [];
          let chunk = new_chunk();
          let time_offset = 0;
          const timestamp_begin = this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0] + 1;
          let previous_tokens = [];
          let skip = false;
          let right_stride_start = null;
          const all_special_ids = new Set(this.all_special_ids);
          for (let output of sequences) {
            const token_ids = output.tokens;
            let last_timestamp = null;
            let first_timestamp = timestamp_begin;
            if ("stride" in output) {
              const [chunk_len, stride_left, stride_right] = output.stride;
              time_offset -= stride_left;
              right_stride_start = chunk_len - stride_right;
              if (stride_left) {
                first_timestamp = stride_left / time_precision + timestamp_begin;
              }
              if (stride_right) {
                for (let i = token_ids.length - 1; i >= 0; --i) {
                  const token = token_ids[i];
                  if (token >= timestamp_begin) {
                    if (last_timestamp !== null && (token - timestamp_begin) * time_precision < right_stride_start) {
                      break;
                    }
                    last_timestamp = token;
                  }
                }
              }
            }
            let current_tokens = [];
            for (const token of token_ids) {
              if (all_special_ids.has(token)) {
                const text = this.decode([token]);
                if (text[0] === "[" && text[text.length - 1] === "]") {
                  const language = this.LANGUAGES[text.slice(1, -1)];
                  if (language !== void 0) {
                    if (last_language !== null && language !== last_language && !return_timestamps) {
                      previous_tokens.push(current_tokens);
                      const resolved_tokens = this.findLongestCommonSequence(previous_tokens);
                      const resolved_text = this.decode(resolved_tokens);
                      chunk.text = resolved_text;
                      chunks.push(chunk);
                      previous_tokens = [];
                      current_tokens = [];
                      chunk = new_chunk();
                    }
                    last_language = chunk.language = language;
                  } else {
                  }
                }
              } else if (token >= timestamp_begin) {
                const time = (token - timestamp_begin) * time_precision + time_offset;
                const rounded_time = Math.round(time * 100) / 100;
                if (last_timestamp !== null && token >= last_timestamp) {
                  skip = true;
                } else if (skip || previous_tokens.length > 0 && token < first_timestamp) {
                  skip = false;
                } else if (chunk.timestamp[0] === null) {
                  chunk.timestamp[0] = rounded_time;
                } else {
                  if (rounded_time === chunk.timestamp[0]) {
                  } else {
                    chunk.timestamp[1] = time;
                    previous_tokens.push(current_tokens);
                    const resolved_tokens = this.findLongestCommonSequence(previous_tokens);
                    const resolved_text = this.decode(resolved_tokens);
                    chunk.text = resolved_text;
                    chunks.push(chunk);
                    previous_tokens = [];
                    current_tokens = [];
                    chunk = new_chunk();
                  }
                }
              } else {
                current_tokens.push(token);
              }
            }
            if ("stride" in output) {
              const [chunk_len, stride_left, stride_right] = output.stride;
              time_offset += chunk_len - stride_right;
            }
            if (current_tokens.length > 0) {
              previous_tokens.push(current_tokens);
            } else if (previous_tokens.every((p) => p.length === 0)) {
              chunk = new_chunk();
              previous_tokens = [];
              current_tokens = [];
            }
          }
          if (previous_tokens.length > 0) {
            if (force_full_sequences && return_timestamps) {
              throw new Error("There was an error while processing timestamps, we haven't found a timestamp as last token.");
            }
            const resolved_tokens = this.findLongestCommonSequence(previous_tokens);
            const resolved_text = this.decode(resolved_tokens);
            chunk.text = resolved_text;
            chunks.push(chunk);
          }
          let optional = {};
          const full_text = chunks.map((chunk2) => chunk2.text).join("");
          if (return_timestamps || return_language) {
            for (let i = 0; i < chunks.length; i++) {
              const chunk2 = chunks[i];
              if (!return_timestamps) {
                delete chunk2["timestamp"];
              }
              if (!return_language) {
                delete chunk2["language"];
              }
            }
            optional = { "chunks": chunks };
          }
          return [full_text, optional];
        }
        findLongestCommonSequence(sequences) {
          let leftSequence = sequences[0];
          let leftLength = leftSequence.length;
          let totalSequence = [];
          for (let i = 1; i < sequences.length; i++) {
            const rightSequence = sequences[i];
            let max = 0;
            let maxIndices = [leftLength, leftLength, 0, 0];
            const rightLength = rightSequence.length;
            for (let j = 1; j < leftLength + rightLength; j++) {
              const eps = j / 1e4;
              const leftStart2 = Math.max(0, leftLength - j);
              const leftStop2 = Math.min(leftLength, leftLength + rightLength - j);
              const left = leftSequence.slice(leftStart2, leftStop2);
              const rightStart2 = Math.max(0, j - leftLength);
              const rightStop2 = Math.min(rightLength, j);
              const right = rightSequence.slice(rightStart2, rightStop2);
              if (left.length !== right.length) {
                throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");
              }
              const matches = left.filter((elem, idx) => elem === right[idx]).length;
              const matching = matches / j + eps;
              if (matches > 1 && matching > max) {
                max = matching;
                maxIndices = [leftStart2, leftStop2, rightStart2, rightStop2];
              }
            }
            const [leftStart, leftStop, rightStart, rightStop] = maxIndices;
            const leftMid = Math.floor((leftStop + leftStart) / 2);
            const rightMid = Math.floor((rightStop + rightStart) / 2);
            totalSequence.push(...leftSequence.slice(0, leftMid));
            leftSequence = rightSequence.slice(rightMid);
            leftLength = leftSequence.length;
          }
          totalSequence.push(...leftSequence);
          return totalSequence;
        }
      };
      __publicField(WhisperTokenizer, "LANGUAGES", {
        "en": "english",
        "zh": "chinese",
        "de": "german",
        "es": "spanish",
        "ru": "russian",
        "ko": "korean",
        "fr": "french",
        "ja": "japanese",
        "pt": "portuguese",
        "tr": "turkish",
        "pl": "polish",
        "ca": "catalan",
        "nl": "dutch",
        "ar": "arabic",
        "sv": "swedish",
        "it": "italian",
        "id": "indonesian",
        "hi": "hindi",
        "fi": "finnish",
        "vi": "vietnamese",
        "he": "hebrew",
        "uk": "ukrainian",
        "el": "greek",
        "ms": "malay",
        "cs": "czech",
        "ro": "romanian",
        "da": "danish",
        "hu": "hungarian",
        "ta": "tamil",
        "no": "norwegian",
        "th": "thai",
        "ur": "urdu",
        "hr": "croatian",
        "bg": "bulgarian",
        "lt": "lithuanian",
        "la": "latin",
        "mi": "maori",
        "ml": "malayalam",
        "cy": "welsh",
        "sk": "slovak",
        "te": "telugu",
        "fa": "persian",
        "lv": "latvian",
        "bn": "bengali",
        "sr": "serbian",
        "az": "azerbaijani",
        "sl": "slovenian",
        "kn": "kannada",
        "et": "estonian",
        "mk": "macedonian",
        "br": "breton",
        "eu": "basque",
        "is": "icelandic",
        "hy": "armenian",
        "ne": "nepali",
        "mn": "mongolian",
        "bs": "bosnian",
        "kk": "kazakh",
        "sq": "albanian",
        "sw": "swahili",
        "gl": "galician",
        "mr": "marathi",
        "pa": "punjabi",
        "si": "sinhala",
        "km": "khmer",
        "sn": "shona",
        "yo": "yoruba",
        "so": "somali",
        "af": "afrikaans",
        "oc": "occitan",
        "ka": "georgian",
        "be": "belarusian",
        "tg": "tajik",
        "sd": "sindhi",
        "gu": "gujarati",
        "am": "amharic",
        "yi": "yiddish",
        "lo": "lao",
        "uz": "uzbek",
        "fo": "faroese",
        "ht": "haitian creole",
        "ps": "pashto",
        "tk": "turkmen",
        "nn": "nynorsk",
        "mt": "maltese",
        "sa": "sanskrit",
        "lb": "luxembourgish",
        "my": "myanmar",
        "bo": "tibetan",
        "tl": "tagalog",
        "mg": "malagasy",
        "as": "assamese",
        "tt": "tatar",
        "haw": "hawaiian",
        "ln": "lingala",
        "ha": "hausa",
        "ba": "bashkir",
        "jw": "javanese",
        "su": "sundanese"
      });
      var CodeGenTokenizer = class extends PreTrainedTokenizer {
      };
      var CLIPTokenizer = class extends PreTrainedTokenizer {
      };
      var CharTrie = class {
        constructor() {
          this.root = CharTrieNode.default();
        }
        push(...texts) {
          for (let text of texts) {
            let node = this.root;
            for (let ch of text) {
              let child = node.children.get(ch);
              if (child === void 0) {
                child = CharTrieNode.default();
                node.children.set(ch, child);
              }
              node = child;
            }
            node.isLeaf = true;
          }
        }
        *commonPrefixSearch(text) {
          let node = this.root;
          let prefix = "";
          for (let i = 0; i < text.length && node !== void 0; i++) {
            const ch = text[i];
            prefix += ch;
            node = node.children.get(ch);
            if (node !== void 0 && node.isLeaf) {
              yield prefix;
            }
          }
        }
      };
      var CharTrieNode = class {
        constructor(isLeaf, children) {
          this.isLeaf = isLeaf;
          this.children = children;
        }
        static default() {
          return new CharTrieNode(false, /* @__PURE__ */ new Map());
        }
      };
      var TokenLattice = class {
        constructor(sentence, bosTokenId, eosTokenId) {
          this.sentence = sentence;
          this.len = sentence.length;
          this.bosTokenId = bosTokenId;
          this.eosTokenId = eosTokenId;
          this.nodes = [];
          this.beginNodes = new Array(this.len + 1);
          this.endNodes = new Array(this.len + 1);
          for (let i = 0; i < this.len + 1; i++) {
            this.beginNodes[i] = [];
            this.endNodes[i] = [];
          }
          const bos = new TokenLatticeNode(this.bosTokenId, 0, 0, 0, 0);
          const eos = new TokenLatticeNode(this.eosTokenId, 1, this.len, 0, 0);
          this.nodes.push(bos.clone());
          this.nodes.push(eos.clone());
          this.beginNodes[this.len].push(eos);
          this.endNodes[0].push(bos);
        }
        insert(pos, length, score, tokenId) {
          const nodeId = this.nodes.length;
          const node = new TokenLatticeNode(tokenId, nodeId, pos, length, score);
          this.beginNodes[pos].push(node);
          this.endNodes[pos + length].push(node);
          this.nodes.push(node);
        }
        viterbi() {
          const len = this.len;
          let pos = 0;
          while (pos <= len) {
            if (this.beginNodes[pos].length == 0) {
              return [];
            }
            for (let rnode of this.beginNodes[pos]) {
              rnode.prev = null;
              let bestScore = 0;
              let bestNode = null;
              for (let lnode of this.endNodes[pos]) {
                const score = lnode.backtraceScore + rnode.score;
                if (bestNode === null || score > bestScore) {
                  bestNode = lnode.clone();
                  bestScore = score;
                }
              }
              if (bestNode !== null) {
                rnode.prev = bestNode;
                rnode.backtraceScore = bestScore;
              } else {
                return [];
              }
            }
            pos++;
          }
          const results = [];
          const root = this.beginNodes[len][0];
          const prev = root.prev;
          if (prev === null) {
            return [];
          }
          let node = prev.clone();
          while (node.prev !== null) {
            results.push(node.clone());
            const n = node.clone();
            node = n.prev.clone();
          }
          results.reverse();
          return results;
        }
        piece(node) {
          return this.sentence.slice(node.pos, node.pos + node.length);
        }
        tokens() {
          const nodes = this.viterbi();
          return nodes.map((x) => this.piece(x));
        }
        tokenIds() {
          const nodes = this.viterbi();
          return nodes.map((x) => x.tokenId);
        }
      };
      var TokenLatticeNode = class {
        constructor(tokenId, nodeId, pos, length, score) {
          this.tokenId = tokenId;
          this.nodeId = nodeId;
          this.pos = pos;
          this.length = length;
          this.score = score;
          this.prev = null;
          this.backtraceScore = 0;
        }
        clone() {
          const n = new TokenLatticeNode(this.tokenId, this.nodeId, this.pos, this.length, this.score);
          n.prev = this.prev;
          n.backtraceScore = this.backtraceScore;
          return n;
        }
      };
      module2.exports = {
        AutoTokenizer,
        BertTokenizer,
        DistilBertTokenizer,
        T5Tokenizer,
        GPT2Tokenizer
      };
    }
  });

  // node_modules/@xenova/transformers/src/samplers.js
  var require_samplers = __commonJS({
    "node_modules/@xenova/transformers/src/samplers.js"(exports2, module2) {
      var {
        Callable,
        indexOfMax,
        softmax,
        log_softmax,
        getTopItems
      } = require_utils();
      var Sampler = class extends Callable {
        constructor(temperature) {
          super();
          this.temperature = temperature;
        }
        _call(logits, index = -1) {
          return this.sample(logits, index);
        }
        sample(logits, index) {
          throw Error("sample should be implemented in subclasses.");
        }
        getLogits(logits, index) {
          let vocabSize = logits.dims[2];
          let logs = logits.data;
          if (index === -1) {
            logs = logs.slice(-vocabSize);
          } else {
            let startIndex = index * vocabSize;
            logs = logs.slice(startIndex, startIndex + vocabSize);
          }
          if (this.temperature > 0) {
            logs = logs.map((x) => x / this.temperature);
          }
          return logs;
        }
        randomSelect(probabilities) {
          let sumProbabilities = probabilities.reduce((acc, curr) => acc + curr, 0);
          let r = Math.random() * sumProbabilities;
          for (let i = 0; i < probabilities.length; ++i) {
            r -= probabilities[i];
            if (r <= 0) {
              return i;
            }
          }
          return 0;
        }
        static getSampler(options) {
          if (options.num_beams > 1) {
            return new BeamSearchSampler(
              options.temperature,
              options.num_beams,
              options.do_sample,
              options.top_k
            );
          } else if (options.top_k > 0 || options.do_sample) {
            return new TopKSampler(
              options.temperature,
              options.top_k
            );
          } else {
            return new GreedySampler(options.temperature);
          }
        }
      };
      var GreedySampler = class extends Sampler {
        sample(logits, index = -1) {
          let logs = this.getLogits(logits, index);
          let argmax = indexOfMax(logs);
          return [
            [argmax, 0]
          ];
        }
      };
      var TopKSampler = class extends Sampler {
        constructor(temperature, k) {
          super(temperature);
          this.k = k;
        }
        sample(logits, index = -1) {
          let [batchSize, seqLength, vocabSize] = logits.dims;
          let k = vocabSize;
          if (this.k > 0) {
            k = Math.min(this.k, k);
          }
          let logs = this.getLogits(logits, index);
          let topLogits = getTopItems(logs, k);
          let probabilities = softmax(topLogits.map((x) => x[1]));
          let sampledIndex = this.randomSelect(probabilities);
          let tokenId = topLogits[sampledIndex][0];
          let score = Math.log(probabilities[sampledIndex]);
          return [
            [tokenId, score]
          ];
        }
      };
      var BeamSearchSampler = class extends Sampler {
        constructor(temperature, num_beams, do_sample, top_k) {
          super(temperature);
          this.num_beams = num_beams;
          this.do_sample = do_sample;
          this.top_k = top_k;
        }
        sample(logits, index = -1) {
          let logs = this.getLogits(logits, index);
          if (this.do_sample || this.top_k > 0) {
            const [batchSize, seqLength, vocabSize] = logits.dims;
            let k = vocabSize;
            if (this.top_k > 0) {
              k = Math.min(this.top_k, k);
            }
            const topLogits = getTopItems(logs, k);
            const probabilities = softmax(topLogits.map((x) => x[1]));
            return Array.from({ length: this.num_beams }, () => {
              const sampledIndex = this.randomSelect(probabilities);
              const tokenId = topLogits[sampledIndex][0];
              return [tokenId, Math.log(probabilities[sampledIndex])];
            });
          } else {
            const logProbabilities = log_softmax(logs);
            const topLogits = getTopItems(logProbabilities, this.num_beams);
            return topLogits;
          }
        }
      };
      module2.exports = {
        Sampler,
        GreedySampler,
        TopKSampler,
        BeamSearchSampler
      };
    }
  });

  // node_modules/@xenova/transformers/src/generation.js
  var require_generation = __commonJS({
    "node_modules/@xenova/transformers/src/generation.js"(exports2, module2) {
      var {
        Callable,
        exists,
        log_softmax
      } = require_utils();
      var LogitsProcessorList = class extends Callable {
        constructor() {
          super();
          this.processors = [];
        }
        push(item) {
          this.processors.push(item);
        }
        extend(items) {
          this.processors.push(...items);
        }
        _call(input_ids, batchedLogits) {
          for (let logits of batchedLogits) {
            this.processors.forEach(
              (func) => func(input_ids, logits)
            );
          }
        }
        [Symbol.iterator]() {
          return this.processors.values();
        }
      };
      var LogitsProcessor = class extends Callable {
        _call(input_ids, logits) {
          throw Error("`_call` should be implemented in a subclass");
        }
      };
      var ForceTokensLogitsProcessor = class extends LogitsProcessor {
        constructor(forced_decoder_ids) {
          super();
          this.force_token_map = Object.fromEntries(forced_decoder_ids ?? []);
        }
        _call(input_ids, logits) {
          let map = this.force_token_map[input_ids.length];
          if (exists(map)) {
            logits.data.fill(-Infinity);
            logits.data[map] = 0;
          }
          return logits;
        }
      };
      var ForcedBOSTokenLogitsProcessor = class extends LogitsProcessor {
        constructor(bos_token_id) {
          super();
          this.bos_token_id = bos_token_id;
        }
        _call(input_ids, logits) {
          if (input_ids.length === 1) {
            logits.data.fill(-Infinity);
            logits.data[this.bos_token_id] = 0;
          }
        }
      };
      var ForcedEOSTokenLogitsProcessor = class extends LogitsProcessor {
        _call(input_ids, logits) {
        }
      };
      var WhisperTimeStampLogitsProcessor = class extends LogitsProcessor {
        constructor(generate_config) {
          super();
          this.eos_token_id = generate_config.eos_token_id;
          this.no_timestamps_token_id = generate_config.no_timestamps_token_id;
          this.timestamp_begin = this.no_timestamps_token_id + 1;
          this.begin_index = (generate_config.forced_decoder_ids || []).length + 2;
          if (generate_config.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id) {
            this.begin_index -= 1;
          }
          this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;
        }
        _call(input_ids, logits) {
          logits.data[this.no_timestamps_token_id] = -Infinity;
          if (input_ids.length === this.begin_index - 1) {
            logits.data.fill(-Infinity);
            logits.data[this.timestamp_begin] = 0;
            return logits;
          }
          const seq = input_ids.slice(this.begin_index);
          const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;
          const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;
          if (last_was_timestamp) {
            if (penultimate_was_timestamp) {
              logits.data.subarray(this.timestamp_begin).fill(-Infinity);
            } else {
              logits.data.subarray(0, this.eos_token_id).fill(-Infinity);
            }
          }
          if (input_ids.length === this.begin_index && this.max_initial_timestamp_index !== null) {
            const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;
            logits.data.subarray(last_allowed + 1).fill(-Infinity);
          }
          const logprobs = log_softmax(logits.data);
          const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));
          const max_text_token_logprob = Math.max(...logprobs.subarray(0, this.timestamp_begin));
          if (timestamp_logprob > max_text_token_logprob) {
            logits.data.subarray(0, this.timestamp_begin).fill(-Infinity);
          }
          return logits;
        }
      };
      var GenerationConfig = class {
        constructor(kwargs = {}) {
          this.max_length = kwargs.max_length ?? 20;
          this.max_new_tokens = kwargs.max_new_tokens ?? null;
          this.min_length = kwargs.min_length ?? 0;
          this.min_new_tokens = kwargs.min_new_tokens ?? null;
          this.early_stopping = kwargs.early_stopping ?? false;
          this.max_time = kwargs.max_time ?? null;
          this.do_sample = kwargs.do_sample ?? false;
          this.num_beams = kwargs.num_beams ?? 1;
          this.num_beam_groups = kwargs.num_beam_groups ?? 1;
          this.penalty_alpha = kwargs.penalty_alpha ?? null;
          this.use_cache = kwargs.use_cache ?? true;
          this.temperature = kwargs.temperature ?? 1;
          this.top_k = kwargs.top_k ?? 50;
          this.top_p = kwargs.top_p ?? 1;
          this.typical_p = kwargs.typical_p ?? 1;
          this.epsilon_cutoff = kwargs.epsilon_cutoff ?? 0;
          this.eta_cutoff = kwargs.eta_cutoff ?? 0;
          this.diversity_penalty = kwargs.diversity_penalty ?? 0;
          this.repetition_penalty = kwargs.repetition_penalty ?? 1;
          this.encoder_repetition_penalty = kwargs.encoder_repetition_penalty ?? 1;
          this.length_penalty = kwargs.length_penalty ?? 1;
          this.no_repeat_ngram_size = kwargs.no_repeat_ngram_size ?? 0;
          this.bad_words_ids = kwargs.bad_words_ids ?? null;
          this.force_words_ids = kwargs.force_words_ids ?? null;
          this.renormalize_logits = kwargs.renormalize_logits ?? false;
          this.constraints = kwargs.constraints ?? null;
          this.forced_bos_token_id = kwargs.forced_bos_token_id ?? null;
          this.forced_eos_token_id = kwargs.forced_eos_token_id ?? null;
          this.remove_invalid_values = kwargs.remove_invalid_values ?? false;
          this.exponential_decay_length_penalty = kwargs.exponential_decay_length_penalty ?? null;
          this.suppress_tokens = kwargs.suppress_tokens ?? null;
          this.begin_suppress_tokens = kwargs.begin_suppress_tokens ?? null;
          this.forced_decoder_ids = kwargs.forced_decoder_ids ?? null;
          this.num_return_sequences = kwargs.num_return_sequences ?? 1;
          this.output_attentions = kwargs.output_attentions ?? false;
          this.output_hidden_states = kwargs.output_hidden_states ?? false;
          this.output_scores = kwargs.output_scores ?? false;
          this.return_dict_in_generate = kwargs.return_dict_in_generate ?? false;
          this.pad_token_id = kwargs.pad_token_id ?? null;
          this.bos_token_id = kwargs.bos_token_id ?? null;
          this.eos_token_id = kwargs.eos_token_id ?? null;
          this.encoder_no_repeat_ngram_size = kwargs.encoder_no_repeat_ngram_size ?? 0;
          this.decoder_start_token_id = kwargs.decoder_start_token_id ?? null;
          this.generation_kwargs = kwargs.generation_kwargs ?? {};
        }
      };
      module2.exports = {
        LogitsProcessor,
        LogitsProcessorList,
        GenerationConfig,
        ForcedBOSTokenLogitsProcessor,
        ForcedEOSTokenLogitsProcessor,
        WhisperTimeStampLogitsProcessor,
        ForceTokensLogitsProcessor
      };
    }
  });

  // node_modules/@xenova/transformers/src/models.js
  var require_models = __commonJS({
    "node_modules/@xenova/transformers/src/models.js"(exports2, module2) {
      var {
        Callable,
        getModelFile,
        fetchJSON,
        dispatchCallback,
        isIntegralNumber,
        exists
      } = require_utils();
      var {
        Sampler
      } = require_samplers();
      var {
        LogitsProcessorList,
        GenerationConfig,
        ForceTokensLogitsProcessor,
        ForcedBOSTokenLogitsProcessor,
        ForcedEOSTokenLogitsProcessor,
        WhisperTimeStampLogitsProcessor
      } = require_generation();
      var { executionProviders, ONNX } = require_onnx();
      var { Tensor } = require_tensor_utils();
      var { InferenceSession, Tensor: ONNXTensor } = ONNX;
      async function constructSession(modelPath, fileName, progressCallback = null) {
        let buffer = await getModelFile(modelPath, fileName, progressCallback);
        try {
          return await InferenceSession.create(buffer, {
            executionProviders
          });
        } catch (err) {
          console.warn(err);
          console.warn(
            "Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "
          );
          return await InferenceSession.create(buffer, {
            executionProviders: ["wasm"]
          });
        }
      }
      async function sessionRun(session, inputs) {
        let output = await session.run(inputs);
        output = replaceTensors(output);
        return output;
      }
      function replaceTensors(obj) {
        for (let prop in obj) {
          if (obj[prop] instanceof ONNXTensor) {
            obj[prop] = new Tensor(obj[prop]);
          }
        }
        return obj;
      }
      function _prepare_attention_mask(self2, tokens) {
        let pad_token_id = self2.config.pad_token_id ?? null;
        let eos_token_id = self2.config.eos_token_id ?? null;
        if (isIntegralNumber(eos_token_id)) {
          eos_token_id = [eos_token_id];
        }
        let is_pad_token_in_inputs = tokens.indexOf(pad_token_id) !== -1;
        let is_pad_token_not_equal_to_eos_token_id = eos_token_id === null || !eos_token_id.includes(pad_token_id);
        if (is_pad_token_in_inputs && is_pad_token_not_equal_to_eos_token_id) {
          let data = BigInt64Array.from(
            // Note: != so that int matches bigint
            tokens.data.map((x) => x != pad_token_id)
          );
          return new Tensor("int64", data, tokens.dims);
        } else {
          return new Tensor(
            "int64",
            new BigInt64Array(tokens.data.length).fill(1n),
            tokens.dims
          );
        }
      }
      function boolTensor(value) {
        return new Tensor("bool", [value], [1]);
      }
      async function seq2seqLoadModel(modelPath, progressCallback) {
        let info = await Promise.all([
          fetchJSON(modelPath, "config.json", progressCallback),
          constructSession(modelPath, "encoder_model.onnx", progressCallback),
          constructSession(modelPath, "decoder_model_merged.onnx", progressCallback),
          fetchJSON(modelPath, "generation_config.json", progressCallback, false)
        ]);
        dispatchCallback(progressCallback, {
          status: "loaded",
          name: modelPath
        });
        return info;
      }
      async function seq2seq_forward(self2, model_inputs, {
        encoder_input_name = "input_ids",
        add_decoder_pkv = true
      } = {}) {
        let encoderOutputs = model_inputs.encoder_outputs;
        let pastKeyValues = model_inputs.past_key_values;
        if (encoderOutputs === null) {
          const encoderFeeds = {
            [encoder_input_name]: model_inputs[encoder_input_name]
          };
          if (self2.session.inputNames.includes("attention_mask")) {
            encoderFeeds.attention_mask = model_inputs.attention_mask;
          }
          const encoderResults = await sessionRun(self2.session, encoderFeeds);
          encoderOutputs = encoderResults.last_hidden_state;
        }
        let decoderFeeds = {
          input_ids: model_inputs.decoder_input_ids,
          encoder_hidden_states: encoderOutputs,
          use_cache_branch: boolTensor(pastKeyValues !== null)
        };
        if (self2.decoder_merged_session.inputNames.includes("encoder_attention_mask")) {
          decoderFeeds.encoder_attention_mask = model_inputs.attention_mask;
        }
        self2.addPastKeyValues(decoderFeeds, pastKeyValues, add_decoder_pkv);
        const decoderResults = await sessionRun(self2.decoder_merged_session, decoderFeeds);
        let logits = decoderResults.logits;
        pastKeyValues = self2.getPastKeyValues(decoderResults);
        return new Seq2SeqLMOutput(logits, pastKeyValues, encoderOutputs);
      }
      function seq2seqStartBeams(self2, inputTokenIds, numOutputTokens, requires_attention_mask = true) {
        let beams = [];
        let beamId = 0;
        for (let tokens of inputTokenIds) {
          tokens.dims = [1, ...tokens.dims];
          let start = {
            inputs: tokens,
            encoder_outputs: null,
            past_key_values: null,
            // decoder_input_ids == output_token_ids
            output_token_ids: [self2.config.decoder_start_token_id],
            done: false,
            score: 0,
            id: beamId++
            // assign unique id to beams
          };
          if (requires_attention_mask) {
            start.attention_mask = _prepare_attention_mask(self2, tokens);
          }
          beams.push(start);
        }
        return beams;
      }
      async function seq2seqRunBeam(self2, beam, {
        input_name = "input_ids"
      } = {}) {
        let model_inputs = {
          [input_name]: beam.inputs,
          decoder_input_ids: self2.toI64Tensor(beam.output_token_ids.slice(-1)),
          encoder_outputs: beam.encoder_outputs,
          past_key_values: beam.past_key_values
        };
        if (beam.attention_mask) {
          model_inputs.attention_mask = beam.attention_mask;
        }
        let output = await self2.forward(model_inputs);
        beam.past_key_values = output.past_key_values;
        beam.encoder_outputs = output.encoder_outputs;
        return output;
      }
      async function textgen_forward(self2, model_inputs) {
        let past_key_values = model_inputs.past_key_values;
        let decoderFeeds = {
          input_ids: model_inputs.input_ids,
          attention_mask: model_inputs.attention_mask,
          use_cache_branch: boolTensor(past_key_values !== null)
        };
        self2.addPastKeyValues(decoderFeeds, past_key_values);
        let decoderResults = await sessionRun(self2.session, decoderFeeds);
        let logits = decoderResults.logits;
        past_key_values = self2.getPastKeyValues(decoderResults);
        return { logits, past_key_values };
      }
      function textgenStartBeams(self2, inputTokenIds, numOutputTokens, inputs_attention_mask) {
        let beams = [];
        let beamId = 0;
        for (let tokens of inputTokenIds) {
          tokens.dims = [1, ...tokens.dims];
          let attn_mask;
          if (inputs_attention_mask) {
            attn_mask = inputs_attention_mask.get(beamId);
            attn_mask.dims = [1, ...attn_mask.dims];
          } else {
            attn_mask = _prepare_attention_mask(self2, tokens);
          }
          let start = {
            input: tokens,
            model_input_ids: tokens,
            attention_mask: attn_mask,
            past_key_values: null,
            output_token_ids: [],
            num_output_tokens: numOutputTokens,
            done: false,
            score: 0,
            id: beamId++
            // assign unique id to beams
          };
          beams.push(start);
        }
        return beams;
      }
      async function textgenRunBeam(self2, beam) {
        let attnMaskData = new BigInt64Array(beam.input.data.length + beam.output_token_ids.length).fill(1n);
        let model_inputs = {
          input_ids: beam.model_input_ids,
          attention_mask: new Tensor(
            "int64",
            attnMaskData,
            [1, attnMaskData.length]
          ),
          past_key_values: beam.past_key_values
        };
        let output = await self2.forward(model_inputs);
        beam.past_key_values = output.past_key_values;
        return output;
      }
      function textgenUpdatebeam(beam, newTokenId) {
        beam.output_token_ids = [...beam.output_token_ids, newTokenId];
        beam.model_input_ids = new Tensor("int64", [BigInt(newTokenId)], [1, 1]);
      }
      var PreTrainedModel = class extends Callable {
        constructor(config, session) {
          super();
          this.config = config;
          this.session = session;
        }
        async dispose() {
          let promises = [];
          for (let key of Object.keys(this)) {
            let item = this[key];
            if (item instanceof InferenceSession) {
              promises.push(item.handler.dispose());
            }
          }
          return await Promise.all(promises);
        }
        static async from_pretrained(modelPath, progressCallback = null) {
          let config = await fetchJSON(modelPath, "config.json", progressCallback);
          let modelName = config.is_encoder_decoder ? "encoder_model.onnx" : "model.onnx";
          let session = await constructSession(modelPath, modelName, progressCallback);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          return new this(config, session);
        }
        toI64Tensor(items) {
          if (items instanceof Tensor) {
            return items;
          }
          if (items.length === 0) {
            throw Error("items must be non-empty");
          }
          if (Array.isArray(items[0])) {
            if (items.some((x) => x.length !== items[0].length)) {
              throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");
            }
            return new Tensor(
              "int64",
              BigInt64Array.from(items.flat().map((x) => BigInt(x))),
              [items.length, items[0].length]
            );
          } else {
            return new Tensor(
              "int64",
              BigInt64Array.from(items.map((x) => BigInt(x))),
              [1, items.length]
            );
          }
        }
        async _call(model_inputs) {
          return await sessionRun(this.session, model_inputs);
        }
        async forward(model_inputs) {
          throw Error("forward should be implemented in subclasses.");
        }
        /**
         * @param {GenerationConfig} generation_config 
         * @param {number} input_ids_seq_length 
         * @returns {LogitsProcessorList}
         */
        _get_logits_processor(generation_config, input_ids_seq_length, logits_processor = null) {
          const processors = new LogitsProcessorList();
          if (generation_config.forced_bos_token_id !== null) {
            processors.push(new ForcedBOSTokenLogitsProcessor(generation_config.forced_bos_token_id));
          }
          if (generation_config.forced_eos_token_id !== null) {
            processors.push(new ForcedEOSTokenLogitsProcessor(
              generation_config.max_length,
              generation_config.forced_eos_token_id
            ));
          }
          if (generation_config.forced_decoder_ids !== null) {
            processors.push(new ForceTokensLogitsProcessor(generation_config.forced_decoder_ids));
          }
          if (logits_processor !== null) {
            processors.extend(logits_processor);
          }
          return processors;
        }
        _get_generation_config(generation_config) {
          let gen_config = new GenerationConfig();
          Object.assign(gen_config, this.generation_config);
          if (generation_config !== null) {
            Object.assign(gen_config, generation_config);
          }
          return gen_config;
        }
        async generate(inputs, generation_config = null, logits_processor = null, {
          inputs_attention_mask = null
        } = {}) {
          if (inputs.length === 0) {
            throw Error("Must supply a non-empty array of input token ids.");
          }
          generation_config = this._get_generation_config(generation_config);
          logits_processor = logits_processor ?? new LogitsProcessorList();
          logits_processor = this._get_logits_processor(
            generation_config,
            inputs.length,
            logits_processor
          );
          let numOutputTokens = 1;
          const maxOutputTokens = numOutputTokens + (generation_config.max_new_tokens ?? Infinity);
          let sampler = Sampler.getSampler(generation_config);
          let beams = this.getStartBeams(inputs, numOutputTokens, inputs_attention_mask);
          while (beams.some((x) => !x.done) && numOutputTokens < maxOutputTokens) {
            let newest_beams = [];
            for (let beam of beams) {
              if (beam.done) {
                newest_beams.push(beam);
                continue;
              }
              let output = await this.runBeam(beam);
              logits_processor(beam.output_token_ids, output.logits);
              let sampledTokens = sampler(output.logits);
              for (let [newTokenId, logProb] of sampledTokens) {
                let newBeam = { ...beam };
                this.updateBeam(newBeam, newTokenId);
                newBeam.score += logProb;
                if (newTokenId === this.config.eos_token_id) {
                  newBeam.done = true;
                }
                newest_beams.push(newBeam);
              }
            }
            ++numOutputTokens;
            newest_beams = this.groupBeams(newest_beams).map(
              (group) => group.sort((a, b) => b.score - a.score).slice(0, generation_config.num_beams)
              // remove outside beam width
            );
            beams = newest_beams.flat();
            if (generation_config.callback_function) {
              generation_config.callback_function(beams);
            }
          }
          return this.groupBeams(beams).map(
            (batch) => {
              if (generation_config.num_return_sequences > 1) {
                return batch.slice(0, generation_config.num_return_sequences).map((x) => x.output_token_ids);
              } else {
                return [batch[0].output_token_ids];
              }
            }
          );
        }
        groupBeams(beams) {
          const groups = {};
          for (const obj of beams) {
            if (groups[obj.id] === void 0) {
              groups[obj.id] = [obj];
            } else {
              groups[obj.id].push(obj);
            }
          }
          return Object.values(groups);
        }
        getPastKeyValues(decoderResults) {
          const pkvs = {};
          for (const name2 in decoderResults) {
            if (name2.startsWith("present")) {
              pkvs[name2.replace("present", "past_key_values")] = decoderResults[name2];
            }
          }
          return pkvs;
        }
        addPastKeyValues(decoderFeeds, pastKeyValues, hasDecoder = false) {
          if (pastKeyValues === null) {
            if (hasDecoder) {
              let encoder_dims = [1, this.num_encoder_heads, 0, this.encoder_dim_kv];
              for (let i = 0; i < this.num_encoder_layers; ++i) {
                decoderFeeds[`past_key_values.${i}.encoder.key`] = new Tensor("float32", [], encoder_dims);
                decoderFeeds[`past_key_values.${i}.encoder.value`] = new Tensor("float32", [], encoder_dims);
              }
              let decoder_dims = [1, this.num_decoder_heads, 0, this.decoder_dim_kv];
              for (let i = 0; i < this.num_decoder_layers; ++i) {
                decoderFeeds[`past_key_values.${i}.decoder.key`] = new Tensor("float32", [], decoder_dims);
                decoderFeeds[`past_key_values.${i}.decoder.value`] = new Tensor("float32", [], decoder_dims);
              }
            } else {
              let dims = [1, this.num_heads, 0, this.dim_kv];
              for (let i = 0; i < this.num_layers; ++i) {
                decoderFeeds[`past_key_values.${i}.key`] = new Tensor("float32", [], dims);
                decoderFeeds[`past_key_values.${i}.value`] = new Tensor("float32", [], dims);
              }
            }
          } else {
            Object.assign(decoderFeeds, pastKeyValues);
          }
        }
      };
      var BertPreTrainedModel = class extends PreTrainedModel {
      };
      var BertModel = class extends BertPreTrainedModel {
      };
      var BertForMaskedLM = class extends BertPreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new MaskedLMOutput(logits);
        }
      };
      var BertForSequenceClassification = class extends BertPreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new SequenceClassifierOutput(logits);
        }
      };
      var BertForQuestionAnswering = class extends BertPreTrainedModel {
        async _call(model_inputs) {
          let outputs = await super._call(model_inputs);
          return new QuestionAnsweringModelOutput(outputs.start_logits, outputs.end_logits);
        }
      };
      var DistilBertPreTrainedModel = class extends PreTrainedModel {
      };
      var DistilBertModel = class extends DistilBertPreTrainedModel {
      };
      var DistilBertForSequenceClassification = class extends DistilBertPreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new SequenceClassifierOutput(logits);
        }
      };
      var DistilBertForQuestionAnswering = class extends DistilBertPreTrainedModel {
        async _call(model_inputs) {
          let outputs = await super._call(model_inputs);
          return new QuestionAnsweringModelOutput(outputs.start_logits, outputs.end_logits);
        }
      };
      var DistilBertForMaskedLM = class extends DistilBertPreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new MaskedLMOutput(logits);
        }
      };
      var AlbertPreTrainedModel = class extends PreTrainedModel {
      };
      var AlbertModel = class extends AlbertPreTrainedModel {
      };
      var AlbertForSequenceClassification = class extends AlbertPreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new SequenceClassifierOutput(logits);
        }
      };
      var AlbertForQuestionAnswering = class extends AlbertPreTrainedModel {
        async _call(model_inputs) {
          let outputs = await super._call(model_inputs);
          return new QuestionAnsweringModelOutput(outputs.start_logits, outputs.end_logits);
        }
      };
      var AlbertForMaskedLM = class extends AlbertPreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new MaskedLMOutput(logits);
        }
      };
      var T5PreTrainedModel = class extends PreTrainedModel {
      };
      var T5Model = class extends T5PreTrainedModel {
        async generate(...args) {
          throw Error(
            "The current model class (T5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'T5ForConditionalGeneration'}"
          );
        }
      };
      var T5ForConditionalGeneration = class extends T5PreTrainedModel {
        constructor(config, session, decoder_merged_session, generation_config) {
          super(config, session);
          this.decoder_merged_session = decoder_merged_session;
          this.generation_config = generation_config;
          this.num_decoder_layers = this.config.num_decoder_layers;
          this.num_decoder_heads = this.config.num_heads;
          this.decoder_dim_kv = this.config.d_kv;
          this.num_encoder_layers = this.config.num_layers;
          this.num_encoder_heads = this.config.num_heads;
          this.encoder_dim_kv = this.config.d_kv;
        }
        static async from_pretrained(modelPath, progressCallback = null) {
          let info = await seq2seqLoadModel(modelPath, progressCallback);
          return new this(...info);
        }
        getStartBeams(inputs, numOutputTokens, ...args) {
          return seq2seqStartBeams(this, inputs, numOutputTokens);
        }
        async runBeam(beam) {
          return await seq2seqRunBeam(this, beam);
        }
        updateBeam(beam, newTokenId) {
          beam.output_token_ids = [...beam.output_token_ids, newTokenId];
        }
        async forward(model_inputs) {
          return await seq2seq_forward(this, model_inputs);
        }
      };
      var BartPretrainedModel = class extends PreTrainedModel {
      };
      var BartModel = class extends BartPretrainedModel {
        async generate(...args) {
          throw Error(
            "The current model class (BartModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'BartForConditionalGeneration'}"
          );
        }
      };
      var BartForConditionalGeneration = class extends BartPretrainedModel {
        constructor(config, session, decoder_merged_session, generation_config) {
          super(config, session);
          this.decoder_merged_session = decoder_merged_session;
          this.generation_config = generation_config;
          this.num_decoder_layers = this.config.decoder_layers;
          this.num_decoder_heads = this.config.decoder_attention_heads;
          this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
          this.num_encoder_layers = this.config.encoder_layers;
          this.num_encoder_heads = this.config.encoder_attention_heads;
          this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
        static async from_pretrained(modelPath, progressCallback = null) {
          let info = await seq2seqLoadModel(modelPath, progressCallback);
          return new this(...info);
        }
        getStartBeams(inputs, numOutputTokens, ...args) {
          return seq2seqStartBeams(this, inputs, numOutputTokens);
        }
        async runBeam(beam) {
          return await seq2seqRunBeam(this, beam);
        }
        updateBeam(beam, newTokenId) {
          beam.output_token_ids = [...beam.output_token_ids, newTokenId];
        }
        async forward(model_inputs) {
          return await seq2seq_forward(this, model_inputs);
        }
      };
      var RobertaPreTrainedModel = class extends PreTrainedModel {
      };
      var RobertaModel = class extends RobertaPreTrainedModel {
      };
      var RobertaForMaskedLM = class extends RobertaPreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new MaskedLMOutput(logits);
        }
      };
      var RobertaForSequenceClassification = class extends RobertaPreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new SequenceClassifierOutput(logits);
        }
      };
      var RobertaForQuestionAnswering = class extends RobertaPreTrainedModel {
        async _call(model_inputs) {
          let outputs = await super._call(model_inputs);
          return new QuestionAnsweringModelOutput(outputs.start_logits, outputs.end_logits);
        }
      };
      var WhisperPreTrainedModel = class extends PreTrainedModel {
      };
      var WhisperModel = class extends WhisperPreTrainedModel {
        async generate(...args) {
          throw Error(
            "The current model class (WhisperModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'WhisperForConditionalGeneration'}"
          );
        }
      };
      var WhisperForConditionalGeneration = class extends WhisperPreTrainedModel {
        constructor(config, session, decoder_merged_session, generation_config) {
          super(config, session);
          this.decoder_merged_session = decoder_merged_session;
          this.generation_config = generation_config;
          this.num_decoder_layers = this.config.decoder_layers;
          this.num_decoder_heads = this.config.decoder_attention_heads;
          this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
          this.num_encoder_layers = this.config.encoder_layers;
          this.num_encoder_heads = this.config.encoder_attention_heads;
          this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
        }
        async generate(inputs, generation_config = null, logits_processor = null) {
          generation_config = this._get_generation_config(generation_config);
          generation_config.return_timestamps ??= false;
          if (generation_config.return_timestamps) {
            logits_processor = [new WhisperTimeStampLogitsProcessor(generation_config)];
          }
          return super.generate(inputs, generation_config, logits_processor);
        }
        static async from_pretrained(modelPath, progressCallback = null) {
          let info = await seq2seqLoadModel(modelPath, progressCallback);
          return new this(...info);
        }
        getStartBeams(inputTokenIds, numOutputTokens, ...args) {
          return seq2seqStartBeams(this, inputTokenIds, numOutputTokens, false);
        }
        async runBeam(beam) {
          return await seq2seqRunBeam(this, beam, {
            input_name: "input_features"
          });
        }
        updateBeam(beam, newTokenId) {
          beam.output_token_ids = [...beam.output_token_ids, newTokenId];
        }
        async forward(model_inputs) {
          return await seq2seq_forward(this, model_inputs, {
            encoder_input_name: "input_features"
          });
        }
      };
      var VisionEncoderDecoderModel = class extends PreTrainedModel {
        constructor(config, session, decoder_merged_session) {
          super(config, session);
          this.decoder_merged_session = decoder_merged_session;
          this.num_layers = this.config.decoder.n_layer;
          this.num_heads = this.config.decoder.n_head;
          this.dim_kv = this.config.decoder.n_embd / this.num_heads;
        }
        static async from_pretrained(modelPath, progressCallback = null) {
          let [config, session, decoder_merged_session] = await Promise.all([
            fetchJSON(modelPath, "config.json", progressCallback),
            constructSession(modelPath, "encoder_model.onnx", progressCallback),
            constructSession(modelPath, "decoder_merged_session.onnx", progressCallback)
          ]);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          return new this(config, session, decoder_merged_session);
        }
        getStartBeams(inputs, numOutputTokens, ...args) {
          return seq2seqStartBeams(this, inputs, numOutputTokens);
        }
        async runBeam(beam) {
          return seq2seqRunBeam(this, beam, {
            input_name: "pixel_values"
          });
        }
        updateBeam(beam, newTokenId) {
          beam.output_token_ids = [...beam.output_token_ids, newTokenId];
        }
        async forward(model_inputs) {
          return await seq2seq_forward(this, model_inputs, {
            encoder_input_name: "pixel_values",
            add_decoder_pkv: false
          });
        }
      };
      var CLIPPreTrainedModel = class extends PreTrainedModel {
      };
      var CLIPModel = class extends CLIPPreTrainedModel {
      };
      var GPT2PreTrainedModel = class extends PreTrainedModel {
      };
      var GPT2Model = class extends GPT2PreTrainedModel {
        async generate(...args) {
          throw Error(
            "The current model class (GPT2Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPT2LMHeadModel'}"
          );
        }
      };
      var GPT2LMHeadModel = class extends GPT2PreTrainedModel {
        constructor(config, session) {
          super(config, session);
          this.config.pad_token_id = this.config.eos_token_id;
          this.num_heads = this.config.n_head;
          this.num_layers = this.config.n_layer;
          this.dim_kv = this.config.n_embd / this.num_heads;
        }
        getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {
          return textgenStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask);
        }
        async runBeam(beam) {
          return await textgenRunBeam(this, beam);
        }
        updateBeam(beam, newTokenId) {
          return textgenUpdatebeam(beam, newTokenId);
        }
        async forward(model_inputs) {
          return await textgen_forward(this, model_inputs);
        }
      };
      var CodeGenPreTrainedModel = class extends PreTrainedModel {
      };
      var CodeGenModel = class extends CodeGenPreTrainedModel {
        async generate(...args) {
          throw Error(
            "The current model class (CodeGenModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'CodeGenForCausalLM'}"
          );
        }
      };
      var CodeGenForCausalLM = class extends CodeGenPreTrainedModel {
        constructor(config, session) {
          super(config, session);
          this.config.pad_token_id = this.config.eos_token_id;
          this.num_heads = this.config.n_head;
          this.num_layers = this.config.n_layer;
          this.dim_kv = this.config.n_embd / this.num_heads;
        }
        getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {
          return textgenStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask);
        }
        async runBeam(beam) {
          return await textgenRunBeam(this, beam);
        }
        updateBeam(beam, newTokenId) {
          return textgenUpdatebeam(beam, newTokenId);
        }
        async forward(model_inputs) {
          return await textgen_forward(this, model_inputs);
        }
      };
      var ViTForImageClassification = class extends PreTrainedModel {
        async _call(model_inputs) {
          let logits = (await super._call(model_inputs)).logits;
          return new SequenceClassifierOutput(logits);
        }
      };
      var AutoModel = class {
        // Helper class to determine model type from config
        static async from_pretrained(modelPath, progressCallback = null) {
          let config = await fetchJSON(modelPath, "config.json", progressCallback);
          let modelName = config.is_encoder_decoder ? "encoder_model.onnx" : "model.onnx";
          let session = await constructSession(modelPath, modelName, progressCallback);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          switch (config.model_type) {
            case "bert":
              return new BertModel(config, session);
            case "albert":
              return new AlbertModel(config, session);
            case "distilbert":
              return new DistilBertModel(config, session);
            case "t5":
              return new T5Model(config, session);
            case "gpt2":
              return new GPT2Model(config, session);
            case "codegen":
              return new CodeGenModel(config, session);
            case "bart":
              return new BartModel(config, session);
            case "roberta":
              return new RobertaModel(config, session);
            case "whisper":
              return new WhisperModel(config, session);
            case "clip":
              return new CLIPModel(config, session);
            default:
              console.warn(`Unknown model class "${config.model_type}", attempting to construct from base class.`);
              return new PreTrainedModel(config, session);
          }
        }
      };
      var AutoModelForSequenceClassification = class {
        static async from_pretrained(modelPath, progressCallback = null) {
          let [config, session] = await Promise.all([
            fetchJSON(modelPath, "config.json", progressCallback),
            constructSession(modelPath, "model.onnx", progressCallback)
          ]);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          switch (config.model_type) {
            case "bert":
              return new BertForSequenceClassification(config, session);
            case "albert":
              return new AlbertForSequenceClassification(config, session);
            case "distilbert":
              return new DistilBertForSequenceClassification(config, session);
            case "roberta":
              return new RobertaForSequenceClassification(config, session);
            default:
              throw Error(`Unsupported model type: ${config.model_type}`);
          }
        }
      };
      var AutoModelForSeq2SeqLM = class {
        static async from_pretrained(modelPath, progressCallback = null) {
          let info = await seq2seqLoadModel(modelPath, progressCallback);
          let config = info[0];
          let cls = this.modelClassMapping[config.model_type];
          if (!cls) {
            throw Error(`Unsupported model type: ${config.model_type}`);
          }
          return new cls(...info);
        }
      };
      __publicField(AutoModelForSeq2SeqLM, "modelClassMapping", {
        "t5": T5ForConditionalGeneration,
        "bart": BartForConditionalGeneration,
        "whisper": WhisperForConditionalGeneration
      });
      var AutoModelForCausalLM = class {
        static async from_pretrained(modelPath, progressCallback = null) {
          let [config, session] = await Promise.all([
            fetchJSON(modelPath, "config.json", progressCallback),
            constructSession(modelPath, "decoder_model_merged.onnx", progressCallback)
          ]);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          switch (config.model_type) {
            case "gpt2":
              return new GPT2LMHeadModel(
                config,
                session
              );
            case "codegen":
              return new CodeGenForCausalLM(
                config,
                session
              );
            default:
              throw Error(`Unsupported model type: ${config.model_type}`);
          }
        }
      };
      var AutoModelForMaskedLM = class {
        static async from_pretrained(modelPath, progressCallback = null) {
          let config = await fetchJSON(modelPath, "config.json", progressCallback);
          let modelName = config.is_encoder_decoder ? "encoder_model.onnx" : "model.onnx";
          let session = await constructSession(modelPath, modelName, progressCallback);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          switch (config.model_type) {
            case "bert":
              return new BertForMaskedLM(config, session);
            case "albert":
              return new AlbertForMaskedLM(config, session);
            case "distilbert":
              return new DistilBertForMaskedLM(config, session);
            case "roberta":
              return new RobertaForMaskedLM(config, session);
            default:
              console.warn(`Unknown model class "${config.model_type}", attempting to construct from base class.`);
              return new PreTrainedModel(config, session);
          }
        }
      };
      var AutoModelForQuestionAnswering = class {
        static async from_pretrained(modelPath, progressCallback = null) {
          let [config, session] = await Promise.all([
            fetchJSON(modelPath, "config.json", progressCallback),
            constructSession(modelPath, "model.onnx", progressCallback)
          ]);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          switch (config.model_type) {
            case "bert":
              return new BertForQuestionAnswering(config, session);
            case "albert":
              return new AlbertForQuestionAnswering(config, session);
            case "distilbert":
              return new DistilBertForQuestionAnswering(config, session);
            case "roberta":
              return new RobertaForQuestionAnswering(config, session);
            default:
              throw Error(`Unsupported model type: ${config.model_type}`);
          }
        }
      };
      var AutoModelForVision2Seq = class {
        static async from_pretrained(modelPath, progressCallback = null) {
          let [config, session, decoder_merged_session] = await Promise.all([
            fetchJSON(modelPath, "config.json", progressCallback),
            constructSession(modelPath, "encoder_model.onnx", progressCallback),
            constructSession(modelPath, "decoder_model_merged.onnx", progressCallback)
          ]);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          switch (config.model_type) {
            case "vision-encoder-decoder":
              return new VisionEncoderDecoderModel(
                config,
                session,
                decoder_merged_session
              );
            default:
              throw Error(`Unsupported model type: ${config.model_type}`);
          }
        }
      };
      var AutoModelForImageClassification = class {
        static async from_pretrained(modelPath, progressCallback = null) {
          let [config, session] = await Promise.all([
            fetchJSON(modelPath, "config.json", progressCallback),
            constructSession(modelPath, "model.onnx", progressCallback)
          ]);
          dispatchCallback(progressCallback, {
            status: "loaded",
            name: modelPath
          });
          switch (config.model_type) {
            case "vit":
              return new ViTForImageClassification(
                config,
                session
              );
            default:
              throw Error(`Unsupported model type: ${config.model_type}`);
          }
        }
      };
      var Seq2SeqLMOutput = class {
        constructor(logits, past_key_values, encoder_outputs) {
          this.logits = logits;
          this.past_key_values = past_key_values;
          this.encoder_outputs = encoder_outputs;
        }
      };
      var SequenceClassifierOutput = class {
        constructor(logits) {
          this.logits = logits;
        }
      };
      var MaskedLMOutput = class {
        constructor(logits) {
          this.logits = logits;
        }
      };
      var QuestionAnsweringModelOutput = class {
        constructor(start_logits, end_logits) {
          this.start_logits = start_logits;
          this.end_logits = end_logits;
        }
      };
      module2.exports = {
        AutoModel,
        AutoModelForSeq2SeqLM,
        AutoModelForSequenceClassification,
        AutoModelForCausalLM,
        AutoModelForMaskedLM,
        AutoModelForQuestionAnswering,
        AutoModelForVision2Seq,
        AutoModelForImageClassification,
        T5ForConditionalGeneration
      };
    }
  });

  // node_modules/@xenova/transformers/src/fft.js
  var require_fft = __commonJS({
    "node_modules/@xenova/transformers/src/fft.js"(exports2, module2) {
      var FFT = class {
        constructor(size) {
          this.size = size | 0;
          if (this.size <= 1 || (this.size & this.size - 1) !== 0)
            throw new Error("FFT size must be a power of two and bigger than 1");
          this._csize = size << 1;
          this.table = new Float64Array(this.size * 2);
          for (let i = 0; i < this.table.length; i += 2) {
            const angle = Math.PI * i / this.size;
            this.table[i] = Math.cos(angle);
            this.table[i + 1] = -Math.sin(angle);
          }
          let power = 0;
          for (let t = 1; this.size > t; t <<= 1)
            ++power;
          this._width = power % 2 === 0 ? power - 1 : power;
          this._bitrev = new Int32Array(1 << this._width);
          for (let j = 0; j < this._bitrev.length; ++j) {
            this._bitrev[j] = 0;
            for (let shift = 0; shift < this._width; shift += 2) {
              const revShift = this._width - shift - 2;
              this._bitrev[j] |= (j >>> shift & 3) << revShift;
            }
          }
        }
        createComplexArray() {
          return new Float64Array(this._csize);
        }
        fromComplexArray(complex, storage) {
          const res = storage || new Array(complex.length >>> 1);
          for (let i = 0; i < complex.length; i += 2)
            res[i >>> 1] = complex[i];
          return res;
        }
        toComplexArray(input, storage) {
          const res = storage || this.createComplexArray();
          for (let i = 0; i < res.length; i += 2) {
            res[i] = input[i >>> 1];
            res[i + 1] = 0;
          }
          return res;
        }
        completeSpectrum(spectrum) {
          const size = this._csize;
          const half = size >>> 1;
          for (let i = 2; i < half; i += 2) {
            spectrum[size - i] = spectrum[i];
            spectrum[size - i + 1] = -spectrum[i + 1];
          }
        }
        transform(out, data) {
          if (out === data)
            throw new Error("Input and output buffers must be different");
          this._transform4(
            out,
            data,
            1
            /* DONE */
          );
        }
        realTransform(out, data) {
          if (out === data)
            throw new Error("Input and output buffers must be different");
          this._realTransform4(
            out,
            data,
            1
            /* DONE */
          );
        }
        inverseTransform(out, data) {
          if (out === data)
            throw new Error("Input and output buffers must be different");
          this._transform4(
            out,
            data,
            -1
            /* DONE */
          );
          for (let i = 0; i < out.length; ++i)
            out[i] /= this.size;
        }
        _transform4(out, data, inv) {
          const size = this._csize;
          const width = this._width;
          let step = 1 << width;
          let len = size / step << 1;
          let outOff;
          let t;
          let bitrev = this._bitrev;
          if (len === 4) {
            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
              const off = bitrev[t];
              this._singleTransform2(data, out, outOff, off, step);
            }
          } else {
            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
              const off = bitrev[t];
              this._singleTransform4(data, out, outOff, off, step, inv);
            }
          }
          for (step >>= 2; step >= 2; step >>= 2) {
            len = size / step << 1;
            let quarterLen = len >>> 2;
            for (outOff = 0; outOff < size; outOff += len) {
              let limit = outOff + quarterLen;
              for (let i = outOff, k = 0; i < limit; i += 2, k += step) {
                const A = i;
                const B = A + quarterLen;
                const C = B + quarterLen;
                const D = C + quarterLen;
                const Ar = out[A];
                const Ai = out[A + 1];
                const Br = out[B];
                const Bi = out[B + 1];
                const Cr = out[C];
                const Ci = out[C + 1];
                const Dr = out[D];
                const Di = out[D + 1];
                const tableBr = this.table[k];
                const tableBi = inv * this.table[k + 1];
                const MBr = Br * tableBr - Bi * tableBi;
                const MBi = Br * tableBi + Bi * tableBr;
                const tableCr = this.table[2 * k];
                const tableCi = inv * this.table[2 * k + 1];
                const MCr = Cr * tableCr - Ci * tableCi;
                const MCi = Cr * tableCi + Ci * tableCr;
                const tableDr = this.table[3 * k];
                const tableDi = inv * this.table[3 * k + 1];
                const MDr = Dr * tableDr - Di * tableDi;
                const MDi = Dr * tableDi + Di * tableDr;
                const T0r = Ar + MCr;
                const T0i = Ai + MCi;
                const T1r = Ar - MCr;
                const T1i = Ai - MCi;
                const T2r = MBr + MDr;
                const T2i = MBi + MDi;
                const T3r = inv * (MBr - MDr);
                const T3i = inv * (MBi - MDi);
                out[A] = T0r + T2r;
                out[A + 1] = T0i + T2i;
                out[B] = T1r + T3i;
                out[B + 1] = T1i - T3r;
                out[C] = T0r - T2r;
                out[C + 1] = T0i - T2i;
                out[D] = T1r - T3i;
                out[D + 1] = T1i + T3r;
              }
            }
          }
        }
        _singleTransform2(data, out, outOff, off, step) {
          const evenR = data[off];
          const evenI = data[off + 1];
          const oddR = data[off + step];
          const oddI = data[off + step + 1];
          out[outOff] = evenR + oddR;
          out[outOff + 1] = evenI + oddI;
          out[outOff + 2] = evenR - oddR;
          out[outOff + 3] = evenI - oddI;
        }
        _singleTransform4(data, out, outOff, off, step, inv) {
          const step2 = step * 2;
          const step3 = step * 3;
          const Ar = data[off];
          const Ai = data[off + 1];
          const Br = data[off + step];
          const Bi = data[off + step + 1];
          const Cr = data[off + step2];
          const Ci = data[off + step2 + 1];
          const Dr = data[off + step3];
          const Di = data[off + step3 + 1];
          const T0r = Ar + Cr;
          const T0i = Ai + Ci;
          const T1r = Ar - Cr;
          const T1i = Ai - Ci;
          const T2r = Br + Dr;
          const T2i = Bi + Di;
          const T3r = inv * (Br - Dr);
          const T3i = inv * (Bi - Di);
          out[outOff] = T0r + T2r;
          out[outOff + 1] = T0i + T2i;
          out[outOff + 2] = T1r + T3i;
          out[outOff + 3] = T1i - T3r;
          out[outOff + 4] = T0r - T2r;
          out[outOff + 5] = T0i - T2i;
          out[outOff + 6] = T1r - T3i;
          out[outOff + 7] = T1i + T3r;
        }
        _realTransform4(out, data, inv) {
          const size = this._csize;
          const width = this._width;
          let step = 1 << width;
          let len = size / step << 1;
          var outOff;
          var t;
          var bitrev = this._bitrev;
          if (len === 4) {
            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
              const off = bitrev[t];
              this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);
            }
          } else {
            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
              const off = bitrev[t];
              this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);
            }
          }
          for (step >>= 2; step >= 2; step >>= 2) {
            len = size / step << 1;
            const halfLen = len >>> 1;
            const quarterLen = halfLen >>> 1;
            const hquarterLen = quarterLen >>> 1;
            for (outOff = 0; outOff < size; outOff += len) {
              for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {
                const A = outOff + i;
                const B = A + quarterLen;
                const C = B + quarterLen;
                const D = C + quarterLen;
                const Ar = out[A];
                const Ai = out[A + 1];
                const Br = out[B];
                const Bi = out[B + 1];
                const Cr = out[C];
                const Ci = out[C + 1];
                const Dr = out[D];
                const Di = out[D + 1];
                const tableBr = this.table[k];
                const tableBi = inv * this.table[k + 1];
                const MBr = Br * tableBr - Bi * tableBi;
                const MBi = Br * tableBi + Bi * tableBr;
                const tableCr = this.table[2 * k];
                const tableCi = inv * this.table[2 * k + 1];
                const MCr = Cr * tableCr - Ci * tableCi;
                const MCi = Cr * tableCi + Ci * tableCr;
                const tableDr = this.table[3 * k];
                const tableDi = inv * this.table[3 * k + 1];
                const MDr = Dr * tableDr - Di * tableDi;
                const MDi = Dr * tableDi + Di * tableDr;
                const T0r = Ar + MCr;
                const T0i = Ai + MCi;
                const T1r = Ar - MCr;
                const T1i = Ai - MCi;
                const T2r = MBr + MDr;
                const T2i = MBi + MDi;
                const T3r = inv * (MBr - MDr);
                const T3i = inv * (MBi - MDi);
                out[A] = T0r + T2r;
                out[A + 1] = T0i + T2i;
                out[B] = T1r + T3i;
                out[B + 1] = T1i - T3r;
                if (i === 0) {
                  out[C] = T0r - T2r;
                  out[C + 1] = T0i - T2i;
                  continue;
                }
                if (i === hquarterLen)
                  continue;
                const SA = outOff + quarterLen - i;
                const SB = outOff + halfLen - i;
                out[SA] = T1r + -inv * T3i;
                out[SA + 1] = -T1i - inv * T3r;
                out[SB] = T0r + -inv * T2r;
                out[SB + 1] = -T0i + inv * T2i;
              }
            }
          }
        }
        _singleRealTransform2(data, out, outOff, off, step) {
          const evenR = data[off];
          const oddR = data[off + step];
          out[outOff] = evenR + oddR;
          out[outOff + 1] = 0;
          out[outOff + 2] = evenR - oddR;
          out[outOff + 3] = 0;
        }
        _singleRealTransform4(data, out, outOff, off, step, inv) {
          const step2 = step * 2;
          const step3 = step * 3;
          const Ar = data[off];
          const Br = data[off + step];
          const Cr = data[off + step2];
          const Dr = data[off + step3];
          const T0r = Ar + Cr;
          const T1r = Ar - Cr;
          const T2r = Br + Dr;
          const T3r = inv * (Br - Dr);
          out[outOff] = T0r + T2r;
          out[outOff + 1] = 0;
          out[outOff + 2] = T1r;
          out[outOff + 3] = -T3r;
          out[outOff + 4] = T0r - T2r;
          out[outOff + 5] = 0;
          out[outOff + 6] = T1r;
          out[outOff + 7] = T3r;
        }
      };
      module2.exports = FFT;
    }
  });

  // node_modules/jimp/browser/lib/jimp.js
  var require_jimp = __commonJS({
    "node_modules/jimp/browser/lib/jimp.js"(exports, module) {
      (() => {
        var __webpack_modules__ = { 236: (t, e, r) => {
          var i = r(4618);
          function n(t2, e2) {
            var r2 = new i(t2, e2);
            return function(t3) {
              return r2.convert(t3);
            };
          }
          n.BIN = "01", n.OCT = "01234567", n.DEC = "0123456789", n.HEX = "0123456789abcdef", t.exports = n;
        }, 4618: (t) => {
          "use strict";
          function e(t2, e2) {
            if (!(t2 && e2 && t2.length && e2.length))
              throw new Error("Bad alphabet");
            this.srcAlphabet = t2, this.dstAlphabet = e2;
          }
          e.prototype.convert = function(t2) {
            var e2, r, i, n = {}, a = this.srcAlphabet.length, o = this.dstAlphabet.length, s = t2.length, h = "string" == typeof t2 ? "" : [];
            if (!this.isValid(t2))
              throw new Error('Number "' + t2 + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
            if (this.srcAlphabet === this.dstAlphabet)
              return t2;
            for (e2 = 0; e2 < s; e2++)
              n[e2] = this.srcAlphabet.indexOf(t2[e2]);
            do {
              for (r = 0, i = 0, e2 = 0; e2 < s; e2++)
                (r = r * a + n[e2]) >= o ? (n[i++] = parseInt(r / o, 10), r %= o) : i > 0 && (n[i++] = 0);
              s = i, h = this.dstAlphabet.slice(r, r + 1).concat(h);
            } while (0 !== i);
            return h;
          }, e.prototype.isValid = function(t2) {
            for (var e2 = 0; e2 < t2.length; ++e2)
              if (-1 === this.srcAlphabet.indexOf(t2[e2]))
                return false;
            return true;
          }, t.exports = e;
        }, 5766: (t, e) => {
          "use strict";
          e.byteLength = function(t2) {
            var e2 = h(t2), r2 = e2[0], i2 = e2[1];
            return 3 * (r2 + i2) / 4 - i2;
          }, e.toByteArray = function(t2) {
            var e2, r2, a2 = h(t2), o2 = a2[0], s2 = a2[1], f2 = new n(function(t3, e3, r3) {
              return 3 * (e3 + r3) / 4 - r3;
            }(0, o2, s2)), u = 0, l = s2 > 0 ? o2 - 4 : o2;
            for (r2 = 0; r2 < l; r2 += 4)
              e2 = i[t2.charCodeAt(r2)] << 18 | i[t2.charCodeAt(r2 + 1)] << 12 | i[t2.charCodeAt(r2 + 2)] << 6 | i[t2.charCodeAt(r2 + 3)], f2[u++] = e2 >> 16 & 255, f2[u++] = e2 >> 8 & 255, f2[u++] = 255 & e2;
            return 2 === s2 && (e2 = i[t2.charCodeAt(r2)] << 2 | i[t2.charCodeAt(r2 + 1)] >> 4, f2[u++] = 255 & e2), 1 === s2 && (e2 = i[t2.charCodeAt(r2)] << 10 | i[t2.charCodeAt(r2 + 1)] << 4 | i[t2.charCodeAt(r2 + 2)] >> 2, f2[u++] = e2 >> 8 & 255, f2[u++] = 255 & e2), f2;
          }, e.fromByteArray = function(t2) {
            for (var e2, i2 = t2.length, n2 = i2 % 3, a2 = [], o2 = 16383, s2 = 0, h2 = i2 - n2; s2 < h2; s2 += o2)
              a2.push(f(t2, s2, s2 + o2 > h2 ? h2 : s2 + o2));
            return 1 === n2 ? (e2 = t2[i2 - 1], a2.push(r[e2 >> 2] + r[e2 << 4 & 63] + "==")) : 2 === n2 && (e2 = (t2[i2 - 2] << 8) + t2[i2 - 1], a2.push(r[e2 >> 10] + r[e2 >> 4 & 63] + r[e2 << 2 & 63] + "=")), a2.join("");
          };
          for (var r = [], i = [], n = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, s = a.length; o < s; ++o)
            r[o] = a[o], i[a.charCodeAt(o)] = o;
          function h(t2) {
            var e2 = t2.length;
            if (e2 % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var r2 = t2.indexOf("=");
            return -1 === r2 && (r2 = e2), [r2, r2 === e2 ? 0 : 4 - r2 % 4];
          }
          function f(t2, e2, i2) {
            for (var n2, a2, o2 = [], s2 = e2; s2 < i2; s2 += 3)
              n2 = (t2[s2] << 16 & 16711680) + (t2[s2 + 1] << 8 & 65280) + (255 & t2[s2 + 2]), o2.push(r[(a2 = n2) >> 18 & 63] + r[a2 >> 12 & 63] + r[a2 >> 6 & 63] + r[63 & a2]);
            return o2.join("");
          }
          i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
        }, 486: (t, e, r) => {
          var i = r(5433), n = r(1651);
          t.exports = { encode: i, decode: n };
        }, 1651: (t, e, r) => {
          var i = r(8834).lW;
          function n(t2, e2) {
            if (this.pos = 0, this.buffer = t2, this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), "BM" != this.flag)
              throw new Error("Invalid BMP File");
            this.parseHeader(), this.parseRGBA();
          }
          n.prototype.parseHeader = function() {
            if (this.fileSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.reserved = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.offset = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.headerSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.width = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.height = this.buffer.readInt32LE(this.pos), this.pos += 4, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compress = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.rawSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.hr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.vr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.colors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.importantColors = this.buffer.readUInt32LE(this.pos), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
              var t2 = 0 === this.colors ? 1 << this.bitPP : this.colors;
              this.palette = new Array(t2);
              for (var e2 = 0; e2 < t2; e2++) {
                var r2 = this.buffer.readUInt8(this.pos++), i2 = this.buffer.readUInt8(this.pos++), n2 = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++);
                this.palette[e2] = { red: n2, green: i2, blue: r2, quad: a };
              }
            }
            this.height < 0 && (this.height *= -1, this.bottom_up = false);
          }, n.prototype.parseRGBA = function() {
            var t2 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
            this.data = new i(e2), this[t2]();
          }, n.prototype.bit1 = function() {
            var t2 = Math.ceil(this.width / 8), e2 = t2 % 4, r2 = this.height >= 0 ? this.height - 1 : -this.height;
            for (r2 = this.height - 1; r2 >= 0; r2--) {
              for (var i2 = this.bottom_up ? r2 : this.height - 1 - r2, n2 = 0; n2 < t2; n2++)
                for (var a = this.buffer.readUInt8(this.pos++), o = i2 * this.width * 4 + 8 * n2 * 4, s = 0; s < 8 && 8 * n2 + s < this.width; s++) {
                  var h = this.palette[a >> 7 - s & 1];
                  this.data[o + 4 * s] = 0, this.data[o + 4 * s + 1] = h.blue, this.data[o + 4 * s + 2] = h.green, this.data[o + 4 * s + 3] = h.red;
                }
              0 != e2 && (this.pos += 4 - e2);
            }
          }, n.prototype.bit4 = function() {
            if (2 == this.compress) {
              let f2 = function(e3) {
                var r3 = this.palette[e3];
                this.data[t2] = 0, this.data[t2 + 1] = r3.blue, this.data[t2 + 2] = r3.green, this.data[t2 + 3] = r3.red, t2 += 4;
              };
              var f = f2;
              this.data.fill(255);
              for (var t2 = 0, e2 = this.bottom_up ? this.height - 1 : 0, r2 = false; t2 < this.data.length; ) {
                var i2 = this.buffer.readUInt8(this.pos++), n2 = this.buffer.readUInt8(this.pos++);
                if (0 == i2) {
                  if (0 == n2) {
                    this.bottom_up ? e2-- : e2++, t2 = e2 * this.width * 4, r2 = false;
                    continue;
                  }
                  if (1 == n2)
                    break;
                  if (2 == n2) {
                    var a = this.buffer.readUInt8(this.pos++), o = this.buffer.readUInt8(this.pos++);
                    this.bottom_up ? e2 -= o : e2 += o, t2 += o * this.width * 4 + 4 * a;
                  } else {
                    for (var s = this.buffer.readUInt8(this.pos++), h = 0; h < n2; h++)
                      r2 ? f2.call(this, 15 & s) : f2.call(this, (240 & s) >> 4), 1 & h && h + 1 < n2 && (s = this.buffer.readUInt8(this.pos++)), r2 = !r2;
                    1 == (n2 + 1 >> 1 & 1) && this.pos++;
                  }
                } else
                  for (h = 0; h < i2; h++)
                    r2 ? f2.call(this, 15 & n2) : f2.call(this, (240 & n2) >> 4), r2 = !r2;
              }
            } else {
              var u = Math.ceil(this.width / 2), l = u % 4;
              for (o = this.height - 1; o >= 0; o--) {
                var c = this.bottom_up ? o : this.height - 1 - o;
                for (a = 0; a < u; a++) {
                  n2 = this.buffer.readUInt8(this.pos++), t2 = c * this.width * 4 + 2 * a * 4;
                  var d = n2 >> 4, p = 15 & n2, m = this.palette[d];
                  if (this.data[t2] = 0, this.data[t2 + 1] = m.blue, this.data[t2 + 2] = m.green, this.data[t2 + 3] = m.red, 2 * a + 1 >= this.width)
                    break;
                  m = this.palette[p], this.data[t2 + 4] = 0, this.data[t2 + 4 + 1] = m.blue, this.data[t2 + 4 + 2] = m.green, this.data[t2 + 4 + 3] = m.red;
                }
                0 != l && (this.pos += 4 - l);
              }
            }
          }, n.prototype.bit8 = function() {
            if (1 == this.compress) {
              let h2 = function(e3) {
                var r3 = this.palette[e3];
                this.data[t2] = 0, this.data[t2 + 1] = r3.blue, this.data[t2 + 2] = r3.green, this.data[t2 + 3] = r3.red, t2 += 4;
              };
              var h = h2;
              this.data.fill(255);
              for (var t2 = 0, e2 = this.bottom_up ? this.height - 1 : 0; t2 < this.data.length; ) {
                var r2 = this.buffer.readUInt8(this.pos++), i2 = this.buffer.readUInt8(this.pos++);
                if (0 == r2) {
                  if (0 == i2) {
                    this.bottom_up ? e2-- : e2++, t2 = e2 * this.width * 4;
                    continue;
                  }
                  if (1 == i2)
                    break;
                  if (2 == i2) {
                    var n2 = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++);
                    this.bottom_up ? e2 -= a : e2 += a, t2 += a * this.width * 4 + 4 * n2;
                  } else {
                    for (var o = 0; o < i2; o++) {
                      var s = this.buffer.readUInt8(this.pos++);
                      h2.call(this, s);
                    }
                    true & i2 && this.pos++;
                  }
                } else
                  for (o = 0; o < r2; o++)
                    h2.call(this, i2);
              }
            } else {
              var f = this.width % 4;
              for (a = this.height - 1; a >= 0; a--) {
                var u = this.bottom_up ? a : this.height - 1 - a;
                for (n2 = 0; n2 < this.width; n2++)
                  if (i2 = this.buffer.readUInt8(this.pos++), t2 = u * this.width * 4 + 4 * n2, i2 < this.palette.length) {
                    var l = this.palette[i2];
                    this.data[t2] = 0, this.data[t2 + 1] = l.blue, this.data[t2 + 2] = l.green, this.data[t2 + 3] = l.red;
                  } else
                    this.data[t2] = 0, this.data[t2 + 1] = 255, this.data[t2 + 2] = 255, this.data[t2 + 3] = 255;
                0 != f && (this.pos += 4 - f);
              }
            }
          }, n.prototype.bit15 = function() {
            for (var t2 = this.width % 3, e2 = parseInt("11111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
              for (var i2 = this.bottom_up ? r2 : this.height - 1 - r2, n2 = 0; n2 < this.width; n2++) {
                var a = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var o = (a & e2) / e2 * 255 | 0, s = (a >> 5 & e2) / e2 * 255 | 0, h = (a >> 10 & e2) / e2 * 255 | 0, f = a >> 15 ? 255 : 0, u = i2 * this.width * 4 + 4 * n2;
                this.data[u] = f, this.data[u + 1] = o, this.data[u + 2] = s, this.data[u + 3] = h;
              }
              this.pos += t2;
            }
          }, n.prototype.bit16 = function() {
            var t2 = this.width % 2 * 2;
            this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31, this.mask0 = 0, 3 == this.compress && (this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4);
            for (var e2 = [0, 0, 0], r2 = 0; r2 < 16; r2++)
              this.maskRed >> r2 & 1 && e2[0]++, this.maskGreen >> r2 & 1 && e2[1]++, this.maskBlue >> r2 & 1 && e2[2]++;
            e2[1] += e2[0], e2[2] += e2[1], e2[0] = 8 - e2[0], e2[1] -= 8, e2[2] -= 8;
            for (var i2 = this.height - 1; i2 >= 0; i2--) {
              for (var n2 = this.bottom_up ? i2 : this.height - 1 - i2, a = 0; a < this.width; a++) {
                var o = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var s = (o & this.maskBlue) << e2[0], h = (o & this.maskGreen) >> e2[1], f = (o & this.maskRed) >> e2[2], u = n2 * this.width * 4 + 4 * a;
                this.data[u] = 0, this.data[u + 1] = s, this.data[u + 2] = h, this.data[u + 3] = f;
              }
              this.pos += t2;
            }
          }, n.prototype.bit24 = function() {
            for (var t2 = this.height - 1; t2 >= 0; t2--) {
              for (var e2 = this.bottom_up ? t2 : this.height - 1 - t2, r2 = 0; r2 < this.width; r2++) {
                var i2 = this.buffer.readUInt8(this.pos++), n2 = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++), o = e2 * this.width * 4 + 4 * r2;
                this.data[o] = 0, this.data[o + 1] = i2, this.data[o + 2] = n2, this.data[o + 3] = a;
              }
              this.pos += this.width % 4;
            }
          }, n.prototype.bit32 = function() {
            if (3 == this.compress) {
              this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4;
              for (var t2 = this.height - 1; t2 >= 0; t2--)
                for (var e2 = this.bottom_up ? t2 : this.height - 1 - t2, r2 = 0; r2 < this.width; r2++) {
                  var i2 = this.buffer.readUInt8(this.pos++), n2 = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++), o = this.buffer.readUInt8(this.pos++), s = e2 * this.width * 4 + 4 * r2;
                  this.data[s] = i2, this.data[s + 1] = n2, this.data[s + 2] = a, this.data[s + 3] = o;
                }
            } else
              for (t2 = this.height - 1; t2 >= 0; t2--)
                for (e2 = this.bottom_up ? t2 : this.height - 1 - t2, r2 = 0; r2 < this.width; r2++)
                  n2 = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++), o = this.buffer.readUInt8(this.pos++), i2 = this.buffer.readUInt8(this.pos++), s = e2 * this.width * 4 + 4 * r2, this.data[s] = i2, this.data[s + 1] = n2, this.data[s + 2] = a, this.data[s + 3] = o;
          }, n.prototype.getData = function() {
            return this.data;
          }, t.exports = function(t2) {
            return new n(t2);
          };
        }, 5433: (t, e, r) => {
          var i = r(8834).lW;
          function n(t2) {
            this.buffer = t2.data, this.width = t2.width, this.height = t2.height, this.extraBytes = this.width % 4, this.rgbSize = this.height * (3 * this.width + this.extraBytes), this.headerInfoSize = 40, this.data = [], this.flag = "BM", this.reserved = 0, this.offset = 54, this.fileSize = this.rgbSize + this.offset, this.planes = 1, this.bitPP = 24, this.compress = 0, this.hr = 0, this.vr = 0, this.colors = 0, this.importantColors = 0;
          }
          n.prototype.encode = function() {
            var t2 = new i(this.offset + this.rgbSize);
            this.pos = 0, t2.write(this.flag, this.pos, 2), this.pos += 2, t2.writeUInt32LE(this.fileSize, this.pos), this.pos += 4, t2.writeUInt32LE(this.reserved, this.pos), this.pos += 4, t2.writeUInt32LE(this.offset, this.pos), this.pos += 4, t2.writeUInt32LE(this.headerInfoSize, this.pos), this.pos += 4, t2.writeUInt32LE(this.width, this.pos), this.pos += 4, t2.writeInt32LE(-this.height, this.pos), this.pos += 4, t2.writeUInt16LE(this.planes, this.pos), this.pos += 2, t2.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, t2.writeUInt32LE(this.compress, this.pos), this.pos += 4, t2.writeUInt32LE(this.rgbSize, this.pos), this.pos += 4, t2.writeUInt32LE(this.hr, this.pos), this.pos += 4, t2.writeUInt32LE(this.vr, this.pos), this.pos += 4, t2.writeUInt32LE(this.colors, this.pos), this.pos += 4, t2.writeUInt32LE(this.importantColors, this.pos), this.pos += 4;
            for (var e2 = 0, r2 = 3 * this.width + this.extraBytes, n2 = 0; n2 < this.height; n2++) {
              for (var a = 0; a < this.width; a++) {
                var o = this.pos + n2 * r2 + 3 * a;
                e2++, t2[o] = this.buffer[e2++], t2[o + 1] = this.buffer[e2++], t2[o + 2] = this.buffer[e2++];
              }
              if (this.extraBytes > 0) {
                var s = this.pos + n2 * r2 + 3 * this.width;
                t2.fill(0, s, s + this.extraBytes);
              }
            }
            return t2;
          }, t.exports = function(t2, e2) {
            return void 0 === e2 && (e2 = 100), { data: new n(t2).encode(), width: t2.width, height: t2.height };
          };
        }, 5137: (t, e, r) => {
          var i = r(8834).lW;
          t.exports = function(t2, e2) {
            if (i.isBuffer(t2) && i.isBuffer(e2)) {
              if ("function" == typeof t2.equals)
                return t2.equals(e2);
              if (t2.length !== e2.length)
                return false;
              for (var r2 = 0; r2 < t2.length; r2++)
                if (t2[r2] !== e2[r2])
                  return false;
              return true;
            }
          };
        }, 8834: (t, e, r) => {
          "use strict";
          var i = r(5766), n = r(4181);
          e.lW = s, e.h2 = 50;
          var a = 2147483647;
          function o(t2) {
            if (t2 > a)
              throw new RangeError('The value "' + t2 + '" is invalid for option "size"');
            var e2 = new Uint8Array(t2);
            return e2.__proto__ = s.prototype, e2;
          }
          function s(t2, e2, r2) {
            if ("number" == typeof t2) {
              if ("string" == typeof e2)
                throw new TypeError('The "string" argument must be of type string. Received type number');
              return u(t2);
            }
            return h(t2, e2, r2);
          }
          function h(t2, e2, r2) {
            if ("string" == typeof t2)
              return function(t3, e3) {
                if ("string" == typeof e3 && "" !== e3 || (e3 = "utf8"), !s.isEncoding(e3))
                  throw new TypeError("Unknown encoding: " + e3);
                var r3 = 0 | d(t3, e3), i3 = o(r3), n3 = i3.write(t3, e3);
                return n3 !== r3 && (i3 = i3.slice(0, n3)), i3;
              }(t2, e2);
            if (ArrayBuffer.isView(t2))
              return l(t2);
            if (null == t2)
              throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t2);
            if (F(t2, ArrayBuffer) || t2 && F(t2.buffer, ArrayBuffer))
              return function(t3, e3, r3) {
                if (e3 < 0 || t3.byteLength < e3)
                  throw new RangeError('"offset" is outside of buffer bounds');
                if (t3.byteLength < e3 + (r3 || 0))
                  throw new RangeError('"length" is outside of buffer bounds');
                var i3;
                return (i3 = void 0 === e3 && void 0 === r3 ? new Uint8Array(t3) : void 0 === r3 ? new Uint8Array(t3, e3) : new Uint8Array(t3, e3, r3)).__proto__ = s.prototype, i3;
              }(t2, e2, r2);
            if ("number" == typeof t2)
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            var i2 = t2.valueOf && t2.valueOf();
            if (null != i2 && i2 !== t2)
              return s.from(i2, e2, r2);
            var n2 = function(t3) {
              if (s.isBuffer(t3)) {
                var e3 = 0 | c(t3.length), r3 = o(e3);
                return 0 === r3.length || t3.copy(r3, 0, 0, e3), r3;
              }
              return void 0 !== t3.length ? "number" != typeof t3.length || j(t3.length) ? o(0) : l(t3) : "Buffer" === t3.type && Array.isArray(t3.data) ? l(t3.data) : void 0;
            }(t2);
            if (n2)
              return n2;
            if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t2[Symbol.toPrimitive])
              return s.from(t2[Symbol.toPrimitive]("string"), e2, r2);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t2);
          }
          function f(t2) {
            if ("number" != typeof t2)
              throw new TypeError('"size" argument must be of type number');
            if (t2 < 0)
              throw new RangeError('The value "' + t2 + '" is invalid for option "size"');
          }
          function u(t2) {
            return f(t2), o(t2 < 0 ? 0 : 0 | c(t2));
          }
          function l(t2) {
            for (var e2 = t2.length < 0 ? 0 : 0 | c(t2.length), r2 = o(e2), i2 = 0; i2 < e2; i2 += 1)
              r2[i2] = 255 & t2[i2];
            return r2;
          }
          function c(t2) {
            if (t2 >= a)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
            return 0 | t2;
          }
          function d(t2, e2) {
            if (s.isBuffer(t2))
              return t2.length;
            if (ArrayBuffer.isView(t2) || F(t2, ArrayBuffer))
              return t2.byteLength;
            if ("string" != typeof t2)
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t2);
            var r2 = t2.length, i2 = arguments.length > 2 && true === arguments[2];
            if (!i2 && 0 === r2)
              return 0;
            for (var n2 = false; ; )
              switch (e2) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r2;
                case "utf8":
                case "utf-8":
                  return D(t2).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * r2;
                case "hex":
                  return r2 >>> 1;
                case "base64":
                  return z(t2).length;
                default:
                  if (n2)
                    return i2 ? -1 : D(t2).length;
                  e2 = ("" + e2).toLowerCase(), n2 = true;
              }
          }
          function p(t2, e2, r2) {
            var i2 = false;
            if ((void 0 === e2 || e2 < 0) && (e2 = 0), e2 > this.length)
              return "";
            if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0)
              return "";
            if ((r2 >>>= 0) <= (e2 >>>= 0))
              return "";
            for (t2 || (t2 = "utf8"); ; )
              switch (t2) {
                case "hex":
                  return T(this, e2, r2);
                case "utf8":
                case "utf-8":
                  return S(this, e2, r2);
                case "ascii":
                  return A(this, e2, r2);
                case "latin1":
                case "binary":
                  return I(this, e2, r2);
                case "base64":
                  return k(this, e2, r2);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return B(this, e2, r2);
                default:
                  if (i2)
                    throw new TypeError("Unknown encoding: " + t2);
                  t2 = (t2 + "").toLowerCase(), i2 = true;
              }
          }
          function m(t2, e2, r2) {
            var i2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = i2;
          }
          function g(t2, e2, r2, i2, n2) {
            if (0 === t2.length)
              return -1;
            if ("string" == typeof r2 ? (i2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), j(r2 = +r2) && (r2 = n2 ? 0 : t2.length - 1), r2 < 0 && (r2 = t2.length + r2), r2 >= t2.length) {
              if (n2)
                return -1;
              r2 = t2.length - 1;
            } else if (r2 < 0) {
              if (!n2)
                return -1;
              r2 = 0;
            }
            if ("string" == typeof e2 && (e2 = s.from(e2, i2)), s.isBuffer(e2))
              return 0 === e2.length ? -1 : b(t2, e2, r2, i2, n2);
            if ("number" == typeof e2)
              return e2 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? n2 ? Uint8Array.prototype.indexOf.call(t2, e2, r2) : Uint8Array.prototype.lastIndexOf.call(t2, e2, r2) : b(t2, [e2], r2, i2, n2);
            throw new TypeError("val must be string, number or Buffer");
          }
          function b(t2, e2, r2, i2, n2) {
            var a2, o2 = 1, s2 = t2.length, h2 = e2.length;
            if (void 0 !== i2 && ("ucs2" === (i2 = String(i2).toLowerCase()) || "ucs-2" === i2 || "utf16le" === i2 || "utf-16le" === i2)) {
              if (t2.length < 2 || e2.length < 2)
                return -1;
              o2 = 2, s2 /= 2, h2 /= 2, r2 /= 2;
            }
            function f2(t3, e3) {
              return 1 === o2 ? t3[e3] : t3.readUInt16BE(e3 * o2);
            }
            if (n2) {
              var u2 = -1;
              for (a2 = r2; a2 < s2; a2++)
                if (f2(t2, a2) === f2(e2, -1 === u2 ? 0 : a2 - u2)) {
                  if (-1 === u2 && (u2 = a2), a2 - u2 + 1 === h2)
                    return u2 * o2;
                } else
                  -1 !== u2 && (a2 -= a2 - u2), u2 = -1;
            } else
              for (r2 + h2 > s2 && (r2 = s2 - h2), a2 = r2; a2 >= 0; a2--) {
                for (var l2 = true, c2 = 0; c2 < h2; c2++)
                  if (f2(t2, a2 + c2) !== f2(e2, c2)) {
                    l2 = false;
                    break;
                  }
                if (l2)
                  return a2;
              }
            return -1;
          }
          function _(t2, e2, r2, i2) {
            r2 = Number(r2) || 0;
            var n2 = t2.length - r2;
            i2 ? (i2 = Number(i2)) > n2 && (i2 = n2) : i2 = n2;
            var a2 = e2.length;
            i2 > a2 / 2 && (i2 = a2 / 2);
            for (var o2 = 0; o2 < i2; ++o2) {
              var s2 = parseInt(e2.substr(2 * o2, 2), 16);
              if (j(s2))
                return o2;
              t2[r2 + o2] = s2;
            }
            return o2;
          }
          function y(t2, e2, r2, i2) {
            return N(D(e2, t2.length - r2), t2, r2, i2);
          }
          function w(t2, e2, r2, i2) {
            return N(function(t3) {
              for (var e3 = [], r3 = 0; r3 < t3.length; ++r3)
                e3.push(255 & t3.charCodeAt(r3));
              return e3;
            }(e2), t2, r2, i2);
          }
          function v(t2, e2, r2, i2) {
            return w(t2, e2, r2, i2);
          }
          function x(t2, e2, r2, i2) {
            return N(z(e2), t2, r2, i2);
          }
          function E(t2, e2, r2, i2) {
            return N(function(t3, e3) {
              for (var r3, i3, n2, a2 = [], o2 = 0; o2 < t3.length && !((e3 -= 2) < 0); ++o2)
                i3 = (r3 = t3.charCodeAt(o2)) >> 8, n2 = r3 % 256, a2.push(n2), a2.push(i3);
              return a2;
            }(e2, t2.length - r2), t2, r2, i2);
          }
          function k(t2, e2, r2) {
            return 0 === e2 && r2 === t2.length ? i.fromByteArray(t2) : i.fromByteArray(t2.slice(e2, r2));
          }
          function S(t2, e2, r2) {
            r2 = Math.min(t2.length, r2);
            for (var i2 = [], n2 = e2; n2 < r2; ) {
              var a2, o2, s2, h2, f2 = t2[n2], u2 = null, l2 = f2 > 239 ? 4 : f2 > 223 ? 3 : f2 > 191 ? 2 : 1;
              if (n2 + l2 <= r2)
                switch (l2) {
                  case 1:
                    f2 < 128 && (u2 = f2);
                    break;
                  case 2:
                    128 == (192 & (a2 = t2[n2 + 1])) && (h2 = (31 & f2) << 6 | 63 & a2) > 127 && (u2 = h2);
                    break;
                  case 3:
                    a2 = t2[n2 + 1], o2 = t2[n2 + 2], 128 == (192 & a2) && 128 == (192 & o2) && (h2 = (15 & f2) << 12 | (63 & a2) << 6 | 63 & o2) > 2047 && (h2 < 55296 || h2 > 57343) && (u2 = h2);
                    break;
                  case 4:
                    a2 = t2[n2 + 1], o2 = t2[n2 + 2], s2 = t2[n2 + 3], 128 == (192 & a2) && 128 == (192 & o2) && 128 == (192 & s2) && (h2 = (15 & f2) << 18 | (63 & a2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && h2 < 1114112 && (u2 = h2);
                }
              null === u2 ? (u2 = 65533, l2 = 1) : u2 > 65535 && (u2 -= 65536, i2.push(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), i2.push(u2), n2 += l2;
            }
            return function(t3) {
              var e3 = t3.length;
              if (e3 <= M)
                return String.fromCharCode.apply(String, t3);
              for (var r3 = "", i3 = 0; i3 < e3; )
                r3 += String.fromCharCode.apply(String, t3.slice(i3, i3 += M));
              return r3;
            }(i2);
          }
          s.TYPED_ARRAY_SUPPORT = function() {
            try {
              var t2 = new Uint8Array(1);
              return t2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, 42 === t2.foo();
            } catch (t3) {
              return false;
            }
          }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
            if (s.isBuffer(this))
              return this.buffer;
          } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
            if (s.isBuffer(this))
              return this.byteOffset;
          } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(t2, e2, r2) {
            return h(t2, e2, r2);
          }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(t2, e2, r2) {
            return function(t3, e3, r3) {
              return f(t3), t3 <= 0 ? o(t3) : void 0 !== e3 ? "string" == typeof r3 ? o(t3).fill(e3, r3) : o(t3).fill(e3) : o(t3);
            }(t2, e2, r2);
          }, s.allocUnsafe = function(t2) {
            return u(t2);
          }, s.allocUnsafeSlow = function(t2) {
            return u(t2);
          }, s.isBuffer = function(t2) {
            return null != t2 && true === t2._isBuffer && t2 !== s.prototype;
          }, s.compare = function(t2, e2) {
            if (F(t2, Uint8Array) && (t2 = s.from(t2, t2.offset, t2.byteLength)), F(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), !s.isBuffer(t2) || !s.isBuffer(e2))
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (t2 === e2)
              return 0;
            for (var r2 = t2.length, i2 = e2.length, n2 = 0, a2 = Math.min(r2, i2); n2 < a2; ++n2)
              if (t2[n2] !== e2[n2]) {
                r2 = t2[n2], i2 = e2[n2];
                break;
              }
            return r2 < i2 ? -1 : i2 < r2 ? 1 : 0;
          }, s.isEncoding = function(t2) {
            switch (String(t2).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, s.concat = function(t2, e2) {
            if (!Array.isArray(t2))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === t2.length)
              return s.alloc(0);
            var r2;
            if (void 0 === e2)
              for (e2 = 0, r2 = 0; r2 < t2.length; ++r2)
                e2 += t2[r2].length;
            var i2 = s.allocUnsafe(e2), n2 = 0;
            for (r2 = 0; r2 < t2.length; ++r2) {
              var a2 = t2[r2];
              if (F(a2, Uint8Array) && (a2 = s.from(a2)), !s.isBuffer(a2))
                throw new TypeError('"list" argument must be an Array of Buffers');
              a2.copy(i2, n2), n2 += a2.length;
            }
            return i2;
          }, s.byteLength = d, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
            var t2 = this.length;
            if (t2 % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var e2 = 0; e2 < t2; e2 += 2)
              m(this, e2, e2 + 1);
            return this;
          }, s.prototype.swap32 = function() {
            var t2 = this.length;
            if (t2 % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var e2 = 0; e2 < t2; e2 += 4)
              m(this, e2, e2 + 3), m(this, e2 + 1, e2 + 2);
            return this;
          }, s.prototype.swap64 = function() {
            var t2 = this.length;
            if (t2 % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var e2 = 0; e2 < t2; e2 += 8)
              m(this, e2, e2 + 7), m(this, e2 + 1, e2 + 6), m(this, e2 + 2, e2 + 5), m(this, e2 + 3, e2 + 4);
            return this;
          }, s.prototype.toString = function() {
            var t2 = this.length;
            return 0 === t2 ? "" : 0 === arguments.length ? S(this, 0, t2) : p.apply(this, arguments);
          }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(t2) {
            if (!s.isBuffer(t2))
              throw new TypeError("Argument must be a Buffer");
            return this === t2 || 0 === s.compare(this, t2);
          }, s.prototype.inspect = function() {
            var t2 = "", r2 = e.h2;
            return t2 = this.toString("hex", 0, r2).replace(/(.{2})/g, "$1 ").trim(), this.length > r2 && (t2 += " ... "), "<Buffer " + t2 + ">";
          }, s.prototype.compare = function(t2, e2, r2, i2, n2) {
            if (F(t2, Uint8Array) && (t2 = s.from(t2, t2.offset, t2.byteLength)), !s.isBuffer(t2))
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t2);
            if (void 0 === e2 && (e2 = 0), void 0 === r2 && (r2 = t2 ? t2.length : 0), void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = this.length), e2 < 0 || r2 > t2.length || i2 < 0 || n2 > this.length)
              throw new RangeError("out of range index");
            if (i2 >= n2 && e2 >= r2)
              return 0;
            if (i2 >= n2)
              return -1;
            if (e2 >= r2)
              return 1;
            if (this === t2)
              return 0;
            for (var a2 = (n2 >>>= 0) - (i2 >>>= 0), o2 = (r2 >>>= 0) - (e2 >>>= 0), h2 = Math.min(a2, o2), f2 = this.slice(i2, n2), u2 = t2.slice(e2, r2), l2 = 0; l2 < h2; ++l2)
              if (f2[l2] !== u2[l2]) {
                a2 = f2[l2], o2 = u2[l2];
                break;
              }
            return a2 < o2 ? -1 : o2 < a2 ? 1 : 0;
          }, s.prototype.includes = function(t2, e2, r2) {
            return -1 !== this.indexOf(t2, e2, r2);
          }, s.prototype.indexOf = function(t2, e2, r2) {
            return g(this, t2, e2, r2, true);
          }, s.prototype.lastIndexOf = function(t2, e2, r2) {
            return g(this, t2, e2, r2, false);
          }, s.prototype.write = function(t2, e2, r2, i2) {
            if (void 0 === e2)
              i2 = "utf8", r2 = this.length, e2 = 0;
            else if (void 0 === r2 && "string" == typeof e2)
              i2 = e2, r2 = this.length, e2 = 0;
            else {
              if (!isFinite(e2))
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              e2 >>>= 0, isFinite(r2) ? (r2 >>>= 0, void 0 === i2 && (i2 = "utf8")) : (i2 = r2, r2 = void 0);
            }
            var n2 = this.length - e2;
            if ((void 0 === r2 || r2 > n2) && (r2 = n2), t2.length > 0 && (r2 < 0 || e2 < 0) || e2 > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            i2 || (i2 = "utf8");
            for (var a2 = false; ; )
              switch (i2) {
                case "hex":
                  return _(this, t2, e2, r2);
                case "utf8":
                case "utf-8":
                  return y(this, t2, e2, r2);
                case "ascii":
                  return w(this, t2, e2, r2);
                case "latin1":
                case "binary":
                  return v(this, t2, e2, r2);
                case "base64":
                  return x(this, t2, e2, r2);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return E(this, t2, e2, r2);
                default:
                  if (a2)
                    throw new TypeError("Unknown encoding: " + i2);
                  i2 = ("" + i2).toLowerCase(), a2 = true;
              }
          }, s.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          var M = 4096;
          function A(t2, e2, r2) {
            var i2 = "";
            r2 = Math.min(t2.length, r2);
            for (var n2 = e2; n2 < r2; ++n2)
              i2 += String.fromCharCode(127 & t2[n2]);
            return i2;
          }
          function I(t2, e2, r2) {
            var i2 = "";
            r2 = Math.min(t2.length, r2);
            for (var n2 = e2; n2 < r2; ++n2)
              i2 += String.fromCharCode(t2[n2]);
            return i2;
          }
          function T(t2, e2, r2) {
            var i2, n2 = t2.length;
            (!e2 || e2 < 0) && (e2 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
            for (var a2 = "", o2 = e2; o2 < r2; ++o2)
              a2 += (i2 = t2[o2]) < 16 ? "0" + i2.toString(16) : i2.toString(16);
            return a2;
          }
          function B(t2, e2, r2) {
            for (var i2 = t2.slice(e2, r2), n2 = "", a2 = 0; a2 < i2.length; a2 += 2)
              n2 += String.fromCharCode(i2[a2] + 256 * i2[a2 + 1]);
            return n2;
          }
          function R(t2, e2, r2) {
            if (t2 % 1 != 0 || t2 < 0)
              throw new RangeError("offset is not uint");
            if (t2 + e2 > r2)
              throw new RangeError("Trying to access beyond buffer length");
          }
          function P(t2, e2, r2, i2, n2, a2) {
            if (!s.isBuffer(t2))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e2 > n2 || e2 < a2)
              throw new RangeError('"value" argument is out of bounds');
            if (r2 + i2 > t2.length)
              throw new RangeError("Index out of range");
          }
          function O(t2, e2, r2, i2, n2, a2) {
            if (r2 + i2 > t2.length)
              throw new RangeError("Index out of range");
            if (r2 < 0)
              throw new RangeError("Index out of range");
          }
          function L(t2, e2, r2, i2, a2) {
            return e2 = +e2, r2 >>>= 0, a2 || O(t2, 0, r2, 4), n.write(t2, e2, r2, i2, 23, 4), r2 + 4;
          }
          function C(t2, e2, r2, i2, a2) {
            return e2 = +e2, r2 >>>= 0, a2 || O(t2, 0, r2, 8), n.write(t2, e2, r2, i2, 52, 8), r2 + 8;
          }
          s.prototype.slice = function(t2, e2) {
            var r2 = this.length;
            (t2 = ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), (e2 = void 0 === e2 ? r2 : ~~e2) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), e2 < t2 && (e2 = t2);
            var i2 = this.subarray(t2, e2);
            return i2.__proto__ = s.prototype, i2;
          }, s.prototype.readUIntLE = function(t2, e2, r2) {
            t2 >>>= 0, e2 >>>= 0, r2 || R(t2, e2, this.length);
            for (var i2 = this[t2], n2 = 1, a2 = 0; ++a2 < e2 && (n2 *= 256); )
              i2 += this[t2 + a2] * n2;
            return i2;
          }, s.prototype.readUIntBE = function(t2, e2, r2) {
            t2 >>>= 0, e2 >>>= 0, r2 || R(t2, e2, this.length);
            for (var i2 = this[t2 + --e2], n2 = 1; e2 > 0 && (n2 *= 256); )
              i2 += this[t2 + --e2] * n2;
            return i2;
          }, s.prototype.readUInt8 = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 1, this.length), this[t2];
          }, s.prototype.readUInt16LE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 2, this.length), this[t2] | this[t2 + 1] << 8;
          }, s.prototype.readUInt16BE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 2, this.length), this[t2] << 8 | this[t2 + 1];
          }, s.prototype.readUInt32LE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 4, this.length), (this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16) + 16777216 * this[t2 + 3];
          }, s.prototype.readUInt32BE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 4, this.length), 16777216 * this[t2] + (this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3]);
          }, s.prototype.readIntLE = function(t2, e2, r2) {
            t2 >>>= 0, e2 >>>= 0, r2 || R(t2, e2, this.length);
            for (var i2 = this[t2], n2 = 1, a2 = 0; ++a2 < e2 && (n2 *= 256); )
              i2 += this[t2 + a2] * n2;
            return i2 >= (n2 *= 128) && (i2 -= Math.pow(2, 8 * e2)), i2;
          }, s.prototype.readIntBE = function(t2, e2, r2) {
            t2 >>>= 0, e2 >>>= 0, r2 || R(t2, e2, this.length);
            for (var i2 = e2, n2 = 1, a2 = this[t2 + --i2]; i2 > 0 && (n2 *= 256); )
              a2 += this[t2 + --i2] * n2;
            return a2 >= (n2 *= 128) && (a2 -= Math.pow(2, 8 * e2)), a2;
          }, s.prototype.readInt8 = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 1, this.length), 128 & this[t2] ? -1 * (255 - this[t2] + 1) : this[t2];
          }, s.prototype.readInt16LE = function(t2, e2) {
            t2 >>>= 0, e2 || R(t2, 2, this.length);
            var r2 = this[t2] | this[t2 + 1] << 8;
            return 32768 & r2 ? 4294901760 | r2 : r2;
          }, s.prototype.readInt16BE = function(t2, e2) {
            t2 >>>= 0, e2 || R(t2, 2, this.length);
            var r2 = this[t2 + 1] | this[t2] << 8;
            return 32768 & r2 ? 4294901760 | r2 : r2;
          }, s.prototype.readInt32LE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 4, this.length), this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16 | this[t2 + 3] << 24;
          }, s.prototype.readInt32BE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 4, this.length), this[t2] << 24 | this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3];
          }, s.prototype.readFloatLE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 4, this.length), n.read(this, t2, true, 23, 4);
          }, s.prototype.readFloatBE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 4, this.length), n.read(this, t2, false, 23, 4);
          }, s.prototype.readDoubleLE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 8, this.length), n.read(this, t2, true, 52, 8);
          }, s.prototype.readDoubleBE = function(t2, e2) {
            return t2 >>>= 0, e2 || R(t2, 8, this.length), n.read(this, t2, false, 52, 8);
          }, s.prototype.writeUIntLE = function(t2, e2, r2, i2) {
            t2 = +t2, e2 >>>= 0, r2 >>>= 0, i2 || P(this, t2, e2, r2, Math.pow(2, 8 * r2) - 1, 0);
            var n2 = 1, a2 = 0;
            for (this[e2] = 255 & t2; ++a2 < r2 && (n2 *= 256); )
              this[e2 + a2] = t2 / n2 & 255;
            return e2 + r2;
          }, s.prototype.writeUIntBE = function(t2, e2, r2, i2) {
            t2 = +t2, e2 >>>= 0, r2 >>>= 0, i2 || P(this, t2, e2, r2, Math.pow(2, 8 * r2) - 1, 0);
            var n2 = r2 - 1, a2 = 1;
            for (this[e2 + n2] = 255 & t2; --n2 >= 0 && (a2 *= 256); )
              this[e2 + n2] = t2 / a2 & 255;
            return e2 + r2;
          }, s.prototype.writeUInt8 = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 1, 255, 0), this[e2] = 255 & t2, e2 + 1;
          }, s.prototype.writeUInt16LE = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 2, 65535, 0), this[e2] = 255 & t2, this[e2 + 1] = t2 >>> 8, e2 + 2;
          }, s.prototype.writeUInt16BE = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 2, 65535, 0), this[e2] = t2 >>> 8, this[e2 + 1] = 255 & t2, e2 + 2;
          }, s.prototype.writeUInt32LE = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 4, 4294967295, 0), this[e2 + 3] = t2 >>> 24, this[e2 + 2] = t2 >>> 16, this[e2 + 1] = t2 >>> 8, this[e2] = 255 & t2, e2 + 4;
          }, s.prototype.writeUInt32BE = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 4, 4294967295, 0), this[e2] = t2 >>> 24, this[e2 + 1] = t2 >>> 16, this[e2 + 2] = t2 >>> 8, this[e2 + 3] = 255 & t2, e2 + 4;
          }, s.prototype.writeIntLE = function(t2, e2, r2, i2) {
            if (t2 = +t2, e2 >>>= 0, !i2) {
              var n2 = Math.pow(2, 8 * r2 - 1);
              P(this, t2, e2, r2, n2 - 1, -n2);
            }
            var a2 = 0, o2 = 1, s2 = 0;
            for (this[e2] = 255 & t2; ++a2 < r2 && (o2 *= 256); )
              t2 < 0 && 0 === s2 && 0 !== this[e2 + a2 - 1] && (s2 = 1), this[e2 + a2] = (t2 / o2 >> 0) - s2 & 255;
            return e2 + r2;
          }, s.prototype.writeIntBE = function(t2, e2, r2, i2) {
            if (t2 = +t2, e2 >>>= 0, !i2) {
              var n2 = Math.pow(2, 8 * r2 - 1);
              P(this, t2, e2, r2, n2 - 1, -n2);
            }
            var a2 = r2 - 1, o2 = 1, s2 = 0;
            for (this[e2 + a2] = 255 & t2; --a2 >= 0 && (o2 *= 256); )
              t2 < 0 && 0 === s2 && 0 !== this[e2 + a2 + 1] && (s2 = 1), this[e2 + a2] = (t2 / o2 >> 0) - s2 & 255;
            return e2 + r2;
          }, s.prototype.writeInt8 = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 1, 127, -128), t2 < 0 && (t2 = 255 + t2 + 1), this[e2] = 255 & t2, e2 + 1;
          }, s.prototype.writeInt16LE = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 2, 32767, -32768), this[e2] = 255 & t2, this[e2 + 1] = t2 >>> 8, e2 + 2;
          }, s.prototype.writeInt16BE = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 2, 32767, -32768), this[e2] = t2 >>> 8, this[e2 + 1] = 255 & t2, e2 + 2;
          }, s.prototype.writeInt32LE = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 4, 2147483647, -2147483648), this[e2] = 255 & t2, this[e2 + 1] = t2 >>> 8, this[e2 + 2] = t2 >>> 16, this[e2 + 3] = t2 >>> 24, e2 + 4;
          }, s.prototype.writeInt32BE = function(t2, e2, r2) {
            return t2 = +t2, e2 >>>= 0, r2 || P(this, t2, e2, 4, 2147483647, -2147483648), t2 < 0 && (t2 = 4294967295 + t2 + 1), this[e2] = t2 >>> 24, this[e2 + 1] = t2 >>> 16, this[e2 + 2] = t2 >>> 8, this[e2 + 3] = 255 & t2, e2 + 4;
          }, s.prototype.writeFloatLE = function(t2, e2, r2) {
            return L(this, t2, e2, true, r2);
          }, s.prototype.writeFloatBE = function(t2, e2, r2) {
            return L(this, t2, e2, false, r2);
          }, s.prototype.writeDoubleLE = function(t2, e2, r2) {
            return C(this, t2, e2, true, r2);
          }, s.prototype.writeDoubleBE = function(t2, e2, r2) {
            return C(this, t2, e2, false, r2);
          }, s.prototype.copy = function(t2, e2, r2, i2) {
            if (!s.isBuffer(t2))
              throw new TypeError("argument should be a Buffer");
            if (r2 || (r2 = 0), i2 || 0 === i2 || (i2 = this.length), e2 >= t2.length && (e2 = t2.length), e2 || (e2 = 0), i2 > 0 && i2 < r2 && (i2 = r2), i2 === r2)
              return 0;
            if (0 === t2.length || 0 === this.length)
              return 0;
            if (e2 < 0)
              throw new RangeError("targetStart out of bounds");
            if (r2 < 0 || r2 >= this.length)
              throw new RangeError("Index out of range");
            if (i2 < 0)
              throw new RangeError("sourceEnd out of bounds");
            i2 > this.length && (i2 = this.length), t2.length - e2 < i2 - r2 && (i2 = t2.length - e2 + r2);
            var n2 = i2 - r2;
            if (this === t2 && "function" == typeof Uint8Array.prototype.copyWithin)
              this.copyWithin(e2, r2, i2);
            else if (this === t2 && r2 < e2 && e2 < i2)
              for (var a2 = n2 - 1; a2 >= 0; --a2)
                t2[a2 + e2] = this[a2 + r2];
            else
              Uint8Array.prototype.set.call(t2, this.subarray(r2, i2), e2);
            return n2;
          }, s.prototype.fill = function(t2, e2, r2, i2) {
            if ("string" == typeof t2) {
              if ("string" == typeof e2 ? (i2 = e2, e2 = 0, r2 = this.length) : "string" == typeof r2 && (i2 = r2, r2 = this.length), void 0 !== i2 && "string" != typeof i2)
                throw new TypeError("encoding must be a string");
              if ("string" == typeof i2 && !s.isEncoding(i2))
                throw new TypeError("Unknown encoding: " + i2);
              if (1 === t2.length) {
                var n2 = t2.charCodeAt(0);
                ("utf8" === i2 && n2 < 128 || "latin1" === i2) && (t2 = n2);
              }
            } else
              "number" == typeof t2 && (t2 &= 255);
            if (e2 < 0 || this.length < e2 || this.length < r2)
              throw new RangeError("Out of range index");
            if (r2 <= e2)
              return this;
            var a2;
            if (e2 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, t2 || (t2 = 0), "number" == typeof t2)
              for (a2 = e2; a2 < r2; ++a2)
                this[a2] = t2;
            else {
              var o2 = s.isBuffer(t2) ? t2 : s.from(t2, i2), h2 = o2.length;
              if (0 === h2)
                throw new TypeError('The value "' + t2 + '" is invalid for argument "value"');
              for (a2 = 0; a2 < r2 - e2; ++a2)
                this[a2 + e2] = o2[a2 % h2];
            }
            return this;
          };
          var U = /[^+/0-9A-Za-z-_]/g;
          function D(t2, e2) {
            var r2;
            e2 = e2 || 1 / 0;
            for (var i2 = t2.length, n2 = null, a2 = [], o2 = 0; o2 < i2; ++o2) {
              if ((r2 = t2.charCodeAt(o2)) > 55295 && r2 < 57344) {
                if (!n2) {
                  if (r2 > 56319) {
                    (e2 -= 3) > -1 && a2.push(239, 191, 189);
                    continue;
                  }
                  if (o2 + 1 === i2) {
                    (e2 -= 3) > -1 && a2.push(239, 191, 189);
                    continue;
                  }
                  n2 = r2;
                  continue;
                }
                if (r2 < 56320) {
                  (e2 -= 3) > -1 && a2.push(239, 191, 189), n2 = r2;
                  continue;
                }
                r2 = 65536 + (n2 - 55296 << 10 | r2 - 56320);
              } else
                n2 && (e2 -= 3) > -1 && a2.push(239, 191, 189);
              if (n2 = null, r2 < 128) {
                if ((e2 -= 1) < 0)
                  break;
                a2.push(r2);
              } else if (r2 < 2048) {
                if ((e2 -= 2) < 0)
                  break;
                a2.push(r2 >> 6 | 192, 63 & r2 | 128);
              } else if (r2 < 65536) {
                if ((e2 -= 3) < 0)
                  break;
                a2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
              } else {
                if (!(r2 < 1114112))
                  throw new Error("Invalid code point");
                if ((e2 -= 4) < 0)
                  break;
                a2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
              }
            }
            return a2;
          }
          function z(t2) {
            return i.toByteArray(function(t3) {
              if ((t3 = (t3 = t3.split("=")[0]).trim().replace(U, "")).length < 2)
                return "";
              for (; t3.length % 4 != 0; )
                t3 += "=";
              return t3;
            }(t2));
          }
          function N(t2, e2, r2, i2) {
            for (var n2 = 0; n2 < i2 && !(n2 + r2 >= e2.length || n2 >= t2.length); ++n2)
              e2[n2 + r2] = t2[n2];
            return n2;
          }
          function F(t2, e2) {
            return t2 instanceof e2 || null != t2 && null != t2.constructor && null != t2.constructor.name && t2.constructor.name === e2.name;
          }
          function j(t2) {
            return t2 != t2;
          }
        }, 4181: (t, e) => {
          e.read = function(t2, e2, r, i, n) {
            var a, o, s = 8 * n - i - 1, h = (1 << s) - 1, f = h >> 1, u = -7, l = r ? n - 1 : 0, c = r ? -1 : 1, d = t2[e2 + l];
            for (l += c, a = d & (1 << -u) - 1, d >>= -u, u += s; u > 0; a = 256 * a + t2[e2 + l], l += c, u -= 8)
              ;
            for (o = a & (1 << -u) - 1, a >>= -u, u += i; u > 0; o = 256 * o + t2[e2 + l], l += c, u -= 8)
              ;
            if (0 === a)
              a = 1 - f;
            else {
              if (a === h)
                return o ? NaN : 1 / 0 * (d ? -1 : 1);
              o += Math.pow(2, i), a -= f;
            }
            return (d ? -1 : 1) * o * Math.pow(2, a - i);
          }, e.write = function(t2, e2, r, i, n, a) {
            var o, s, h, f = 8 * a - n - 1, u = (1 << f) - 1, l = u >> 1, c = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = i ? 0 : a - 1, p = i ? 1 : -1, m = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
            for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (s = isNaN(e2) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e2) / Math.LN2), e2 * (h = Math.pow(2, -o)) < 1 && (o--, h *= 2), (e2 += o + l >= 1 ? c / h : c * Math.pow(2, 1 - l)) * h >= 2 && (o++, h /= 2), o + l >= u ? (s = 0, o = u) : o + l >= 1 ? (s = (e2 * h - 1) * Math.pow(2, n), o += l) : (s = e2 * Math.pow(2, l - 1) * Math.pow(2, n), o = 0)); n >= 8; t2[r + d] = 255 & s, d += p, s /= 256, n -= 8)
              ;
            for (o = o << n | s, f += n; f > 0; t2[r + d] = 255 & o, d += p, o /= 256, f -= 8)
              ;
            t2[r + d - p] |= 128 * m;
          };
        }, 869: (t) => {
          t.exports = null;
        }, 2699: (t) => {
          "use strict";
          var e, r = "object" == typeof Reflect ? Reflect : null, i = r && "function" == typeof r.apply ? r.apply : function(t2, e2, r2) {
            return Function.prototype.apply.call(t2, e2, r2);
          };
          e = r && "function" == typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function(t2) {
            return Object.getOwnPropertyNames(t2).concat(Object.getOwnPropertySymbols(t2));
          } : function(t2) {
            return Object.getOwnPropertyNames(t2);
          };
          var n = Number.isNaN || function(t2) {
            return t2 != t2;
          };
          function a() {
            a.init.call(this);
          }
          t.exports = a, t.exports.once = function(t2, e2) {
            return new Promise(function(r2, i2) {
              function n2(r3) {
                t2.removeListener(e2, a2), i2(r3);
              }
              function a2() {
                "function" == typeof t2.removeListener && t2.removeListener("error", n2), r2([].slice.call(arguments));
              }
              m(t2, e2, a2, { once: true }), "error" !== e2 && function(t3, e3, r3) {
                "function" == typeof t3.on && m(t3, "error", e3, { once: true });
              }(t2, n2);
            });
          }, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
          var o = 10;
          function s(t2) {
            if ("function" != typeof t2)
              throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t2);
          }
          function h(t2) {
            return void 0 === t2._maxListeners ? a.defaultMaxListeners : t2._maxListeners;
          }
          function f(t2, e2, r2, i2) {
            var n2, a2, o2, f2;
            if (s(r2), void 0 === (a2 = t2._events) ? (a2 = t2._events = /* @__PURE__ */ Object.create(null), t2._eventsCount = 0) : (void 0 !== a2.newListener && (t2.emit("newListener", e2, r2.listener ? r2.listener : r2), a2 = t2._events), o2 = a2[e2]), void 0 === o2)
              o2 = a2[e2] = r2, ++t2._eventsCount;
            else if ("function" == typeof o2 ? o2 = a2[e2] = i2 ? [r2, o2] : [o2, r2] : i2 ? o2.unshift(r2) : o2.push(r2), (n2 = h(t2)) > 0 && o2.length > n2 && !o2.warned) {
              o2.warned = true;
              var u2 = new Error("Possible EventEmitter memory leak detected. " + o2.length + " " + String(e2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
              u2.name = "MaxListenersExceededWarning", u2.emitter = t2, u2.type = e2, u2.count = o2.length, f2 = u2, console && console.warn && console.warn(f2);
            }
            return t2;
          }
          function u() {
            if (!this.fired)
              return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
          }
          function l(t2, e2, r2) {
            var i2 = { fired: false, wrapFn: void 0, target: t2, type: e2, listener: r2 }, n2 = u.bind(i2);
            return n2.listener = r2, i2.wrapFn = n2, n2;
          }
          function c(t2, e2, r2) {
            var i2 = t2._events;
            if (void 0 === i2)
              return [];
            var n2 = i2[e2];
            return void 0 === n2 ? [] : "function" == typeof n2 ? r2 ? [n2.listener || n2] : [n2] : r2 ? function(t3) {
              for (var e3 = new Array(t3.length), r3 = 0; r3 < e3.length; ++r3)
                e3[r3] = t3[r3].listener || t3[r3];
              return e3;
            }(n2) : p(n2, n2.length);
          }
          function d(t2) {
            var e2 = this._events;
            if (void 0 !== e2) {
              var r2 = e2[t2];
              if ("function" == typeof r2)
                return 1;
              if (void 0 !== r2)
                return r2.length;
            }
            return 0;
          }
          function p(t2, e2) {
            for (var r2 = new Array(e2), i2 = 0; i2 < e2; ++i2)
              r2[i2] = t2[i2];
            return r2;
          }
          function m(t2, e2, r2, i2) {
            if ("function" == typeof t2.on)
              i2.once ? t2.once(e2, r2) : t2.on(e2, r2);
            else {
              if ("function" != typeof t2.addEventListener)
                throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t2);
              t2.addEventListener(e2, function n2(a2) {
                i2.once && t2.removeEventListener(e2, n2), r2(a2);
              });
            }
          }
          Object.defineProperty(a, "defaultMaxListeners", { enumerable: true, get: function() {
            return o;
          }, set: function(t2) {
            if ("number" != typeof t2 || t2 < 0 || n(t2))
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t2 + ".");
            o = t2;
          } }), a.init = function() {
            void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
          }, a.prototype.setMaxListeners = function(t2) {
            if ("number" != typeof t2 || t2 < 0 || n(t2))
              throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t2 + ".");
            return this._maxListeners = t2, this;
          }, a.prototype.getMaxListeners = function() {
            return h(this);
          }, a.prototype.emit = function(t2) {
            for (var e2 = [], r2 = 1; r2 < arguments.length; r2++)
              e2.push(arguments[r2]);
            var n2 = "error" === t2, a2 = this._events;
            if (void 0 !== a2)
              n2 = n2 && void 0 === a2.error;
            else if (!n2)
              return false;
            if (n2) {
              var o2;
              if (e2.length > 0 && (o2 = e2[0]), o2 instanceof Error)
                throw o2;
              var s2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
              throw s2.context = o2, s2;
            }
            var h2 = a2[t2];
            if (void 0 === h2)
              return false;
            if ("function" == typeof h2)
              i(h2, this, e2);
            else {
              var f2 = h2.length, u2 = p(h2, f2);
              for (r2 = 0; r2 < f2; ++r2)
                i(u2[r2], this, e2);
            }
            return true;
          }, a.prototype.addListener = function(t2, e2) {
            return f(this, t2, e2, false);
          }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(t2, e2) {
            return f(this, t2, e2, true);
          }, a.prototype.once = function(t2, e2) {
            return s(e2), this.on(t2, l(this, t2, e2)), this;
          }, a.prototype.prependOnceListener = function(t2, e2) {
            return s(e2), this.prependListener(t2, l(this, t2, e2)), this;
          }, a.prototype.removeListener = function(t2, e2) {
            var r2, i2, n2, a2, o2;
            if (s(e2), void 0 === (i2 = this._events))
              return this;
            if (void 0 === (r2 = i2[t2]))
              return this;
            if (r2 === e2 || r2.listener === e2)
              0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete i2[t2], i2.removeListener && this.emit("removeListener", t2, r2.listener || e2));
            else if ("function" != typeof r2) {
              for (n2 = -1, a2 = r2.length - 1; a2 >= 0; a2--)
                if (r2[a2] === e2 || r2[a2].listener === e2) {
                  o2 = r2[a2].listener, n2 = a2;
                  break;
                }
              if (n2 < 0)
                return this;
              0 === n2 ? r2.shift() : function(t3, e3) {
                for (; e3 + 1 < t3.length; e3++)
                  t3[e3] = t3[e3 + 1];
                t3.pop();
              }(r2, n2), 1 === r2.length && (i2[t2] = r2[0]), void 0 !== i2.removeListener && this.emit("removeListener", t2, o2 || e2);
            }
            return this;
          }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(t2) {
            var e2, r2, i2;
            if (void 0 === (r2 = this._events))
              return this;
            if (void 0 === r2.removeListener)
              return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r2[t2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r2[t2]), this;
            if (0 === arguments.length) {
              var n2, a2 = Object.keys(r2);
              for (i2 = 0; i2 < a2.length; ++i2)
                "removeListener" !== (n2 = a2[i2]) && this.removeAllListeners(n2);
              return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
            }
            if ("function" == typeof (e2 = r2[t2]))
              this.removeListener(t2, e2);
            else if (void 0 !== e2)
              for (i2 = e2.length - 1; i2 >= 0; i2--)
                this.removeListener(t2, e2[i2]);
            return this;
          }, a.prototype.listeners = function(t2) {
            return c(this, t2, true);
          }, a.prototype.rawListeners = function(t2) {
            return c(this, t2, false);
          }, a.listenerCount = function(t2, e2) {
            return "function" == typeof t2.listenerCount ? t2.listenerCount(e2) : d.call(t2, e2);
          }, a.prototype.listenerCount = d, a.prototype.eventNames = function() {
            return this._eventsCount > 0 ? e(this._events) : [];
          };
        }, 6551: (t, e, r) => {
          var i = r(453);
          t.exports = { create: function(t2, e2) {
            if (t2 instanceof (e2 = e2 || (0, eval)("this")).ArrayBuffer) {
              var n = r(909);
              return new i(new n(t2, 0, t2.byteLength, true, e2));
            }
            var a = r(3684);
            return new i(new a(t2, 0, t2.length, true));
          } };
        }, 3684: (t) => {
          function e(t2, e2, r, i) {
            this.buffer = t2, this.offset = e2 || 0, r = "number" == typeof r ? r : t2.length, this.endPosition = this.offset + r, this.setBigEndian(i);
          }
          e.prototype = { setBigEndian: function(t2) {
            this.bigEndian = !!t2;
          }, nextUInt8: function() {
            var t2 = this.buffer.readUInt8(this.offset);
            return this.offset += 1, t2;
          }, nextInt8: function() {
            var t2 = this.buffer.readInt8(this.offset);
            return this.offset += 1, t2;
          }, nextUInt16: function() {
            var t2 = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
            return this.offset += 2, t2;
          }, nextUInt32: function() {
            var t2 = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
            return this.offset += 4, t2;
          }, nextInt16: function() {
            var t2 = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
            return this.offset += 2, t2;
          }, nextInt32: function() {
            var t2 = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
            return this.offset += 4, t2;
          }, nextFloat: function() {
            var t2 = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
            return this.offset += 4, t2;
          }, nextDouble: function() {
            var t2 = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
            return this.offset += 8, t2;
          }, nextBuffer: function(t2) {
            var e2 = this.buffer.slice(this.offset, this.offset + t2);
            return this.offset += t2, e2;
          }, remainingLength: function() {
            return this.endPosition - this.offset;
          }, nextString: function(t2) {
            var e2 = this.buffer.toString("utf8", this.offset, this.offset + t2);
            return this.offset += t2, e2;
          }, mark: function() {
            var t2 = this;
            return { openWithOffset: function(r) {
              return r = (r || 0) + this.offset, new e(t2.buffer, r, t2.endPosition - r, t2.bigEndian);
            }, offset: this.offset };
          }, offsetFrom: function(t2) {
            return this.offset - t2.offset;
          }, skip: function(t2) {
            this.offset += t2;
          }, branch: function(t2, r) {
            return r = "number" == typeof r ? r : this.endPosition - (this.offset + t2), new e(this.buffer, this.offset + t2, r, this.bigEndian);
          } }, t.exports = e;
        }, 565: (t) => {
          function e(t2) {
            return parseInt(t2, 10);
          }
          var r = 3600, i = 60;
          function n(t2, r2) {
            t2 = t2.map(e), r2 = r2.map(e);
            var i2 = t2[0], n2 = t2[1] - 1, a2 = t2[2], o2 = r2[0], s = r2[1], h = r2[2];
            return Date.UTC(i2, n2, a2, o2, s, h, 0) / 1e3;
          }
          function a(t2) {
            var a2 = t2.substr(0, 10).split("-"), o2 = t2.substr(11, 8).split(":"), s = t2.substr(19, 6).split(":").map(e), h = s[0] * r + s[1] * i, f = n(a2, o2);
            if ("number" == typeof (f -= h) && !isNaN(f))
              return f;
          }
          function o(t2) {
            var e2 = t2.split(" "), r2 = n(e2[0].split(":"), e2[1].split(":"));
            if ("number" == typeof r2 && !isNaN(r2))
              return r2;
          }
          t.exports = { parseDateWithSpecFormat: o, parseDateWithTimezoneFormat: a, parseExifDate: function(t2) {
            var e2 = 19 === t2.length && ":" === t2.charAt(4);
            return 25 === t2.length && "T" === t2.charAt(10) ? a(t2) : e2 ? o(t2) : void 0;
          } };
        }, 909: (t) => {
          function e(t2, e2, r, i, n, a) {
            this.global = n, e2 = e2 || 0, r = r || t2.byteLength - e2, this.arrayBuffer = t2.slice(e2, e2 + r), this.view = new n.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(i), this.offset = 0, this.parentOffset = (a || 0) + e2;
          }
          e.prototype = { setBigEndian: function(t2) {
            this.littleEndian = !t2;
          }, nextUInt8: function() {
            var t2 = this.view.getUint8(this.offset);
            return this.offset += 1, t2;
          }, nextInt8: function() {
            var t2 = this.view.getInt8(this.offset);
            return this.offset += 1, t2;
          }, nextUInt16: function() {
            var t2 = this.view.getUint16(this.offset, this.littleEndian);
            return this.offset += 2, t2;
          }, nextUInt32: function() {
            var t2 = this.view.getUint32(this.offset, this.littleEndian);
            return this.offset += 4, t2;
          }, nextInt16: function() {
            var t2 = this.view.getInt16(this.offset, this.littleEndian);
            return this.offset += 2, t2;
          }, nextInt32: function() {
            var t2 = this.view.getInt32(this.offset, this.littleEndian);
            return this.offset += 4, t2;
          }, nextFloat: function() {
            var t2 = this.view.getFloat32(this.offset, this.littleEndian);
            return this.offset += 4, t2;
          }, nextDouble: function() {
            var t2 = this.view.getFloat64(this.offset, this.littleEndian);
            return this.offset += 8, t2;
          }, nextBuffer: function(t2) {
            var e2 = this.arrayBuffer.slice(this.offset, this.offset + t2);
            return this.offset += t2, e2;
          }, remainingLength: function() {
            return this.arrayBuffer.byteLength - this.offset;
          }, nextString: function(t2) {
            var e2 = this.arrayBuffer.slice(this.offset, this.offset + t2);
            return e2 = String.fromCharCode.apply(null, new this.global.Uint8Array(e2)), this.offset += t2, e2;
          }, mark: function() {
            var t2 = this;
            return { openWithOffset: function(r) {
              return r = (r || 0) + this.offset, new e(t2.arrayBuffer, r, t2.arrayBuffer.byteLength - r, !t2.littleEndian, t2.global, t2.parentOffset);
            }, offset: this.offset, getParentOffset: function() {
              return t2.parentOffset;
            } };
          }, offsetFrom: function(t2) {
            return this.parentOffset + this.offset - (t2.offset + t2.getParentOffset());
          }, skip: function(t2) {
            this.offset += t2;
          }, branch: function(t2, r) {
            return r = "number" == typeof r ? r : this.arrayBuffer.byteLength - (this.offset + t2), new e(this.arrayBuffer, this.offset + t2, r, !this.littleEndian, this.global, this.parentOffset);
          } }, t.exports = e;
        }, 3332: (t) => {
          t.exports = { exif: { 1: "InteropIndex", 2: "InteropVersion", 11: "ProcessingSoftware", 254: "SubfileType", 255: "OldSubfileType", 256: "ImageWidth", 257: "ImageHeight", 258: "BitsPerSample", 259: "Compression", 262: "PhotometricInterpretation", 263: "Thresholding", 264: "CellWidth", 265: "CellLength", 266: "FillOrder", 269: "DocumentName", 270: "ImageDescription", 271: "Make", 272: "Model", 273: "StripOffsets", 274: "Orientation", 277: "SamplesPerPixel", 278: "RowsPerStrip", 279: "StripByteCounts", 280: "MinSampleValue", 281: "MaxSampleValue", 282: "XResolution", 283: "YResolution", 284: "PlanarConfiguration", 285: "PageName", 286: "XPosition", 287: "YPosition", 288: "FreeOffsets", 289: "FreeByteCounts", 290: "GrayResponseUnit", 291: "GrayResponseCurve", 292: "T4Options", 293: "T6Options", 296: "ResolutionUnit", 297: "PageNumber", 300: "ColorResponseUnit", 301: "TransferFunction", 305: "Software", 306: "ModifyDate", 315: "Artist", 316: "HostComputer", 317: "Predictor", 318: "WhitePoint", 319: "PrimaryChromaticities", 320: "ColorMap", 321: "HalftoneHints", 322: "TileWidth", 323: "TileLength", 324: "TileOffsets", 325: "TileByteCounts", 326: "BadFaxLines", 327: "CleanFaxData", 328: "ConsecutiveBadFaxLines", 330: "SubIFD", 332: "InkSet", 333: "InkNames", 334: "NumberofInks", 336: "DotRange", 337: "TargetPrinter", 338: "ExtraSamples", 339: "SampleFormat", 340: "SMinSampleValue", 341: "SMaxSampleValue", 342: "TransferRange", 343: "ClipPath", 344: "XClipPathUnits", 345: "YClipPathUnits", 346: "Indexed", 347: "JPEGTables", 351: "OPIProxy", 400: "GlobalParametersIFD", 401: "ProfileType", 402: "FaxProfile", 403: "CodingMethods", 404: "VersionYear", 405: "ModeNumber", 433: "Decode", 434: "DefaultImageColor", 435: "T82Options", 437: "JPEGTables", 512: "JPEGProc", 513: "ThumbnailOffset", 514: "ThumbnailLength", 515: "JPEGRestartInterval", 517: "JPEGLosslessPredictors", 518: "JPEGPointTransforms", 519: "JPEGQTables", 520: "JPEGDCTables", 521: "JPEGACTables", 529: "YCbCrCoefficients", 530: "YCbCrSubSampling", 531: "YCbCrPositioning", 532: "ReferenceBlackWhite", 559: "StripRowCounts", 700: "ApplicationNotes", 999: "USPTOMiscellaneous", 4096: "RelatedImageFileFormat", 4097: "RelatedImageWidth", 4098: "RelatedImageHeight", 18246: "Rating", 18247: "XP_DIP_XML", 18248: "StitchInfo", 18249: "RatingPercent", 32781: "ImageID", 32931: "WangTag1", 32932: "WangAnnotation", 32933: "WangTag3", 32934: "WangTag4", 32995: "Matteing", 32996: "DataType", 32997: "ImageDepth", 32998: "TileDepth", 33405: "Model2", 33421: "CFARepeatPatternDim", 33422: "CFAPattern2", 33423: "BatteryLevel", 33424: "KodakIFD", 33432: "Copyright", 33434: "ExposureTime", 33437: "FNumber", 33445: "MDFileTag", 33446: "MDScalePixel", 33447: "MDColorTable", 33448: "MDLabName", 33449: "MDSampleInfo", 33450: "MDPrepDate", 33451: "MDPrepTime", 33452: "MDFileUnits", 33550: "PixelScale", 33589: "AdventScale", 33590: "AdventRevision", 33628: "UIC1Tag", 33629: "UIC2Tag", 33630: "UIC3Tag", 33631: "UIC4Tag", 33723: "IPTC-NAA", 33918: "IntergraphPacketData", 33919: "IntergraphFlagRegisters", 33920: "IntergraphMatrix", 33921: "INGRReserved", 33922: "ModelTiePoint", 34016: "Site", 34017: "ColorSequence", 34018: "IT8Header", 34019: "RasterPadding", 34020: "BitsPerRunLength", 34021: "BitsPerExtendedRunLength", 34022: "ColorTable", 34023: "ImageColorIndicator", 34024: "BackgroundColorIndicator", 34025: "ImageColorValue", 34026: "BackgroundColorValue", 34027: "PixelIntensityRange", 34028: "TransparencyIndicator", 34029: "ColorCharacterization", 34030: "HCUsage", 34031: "TrapIndicator", 34032: "CMYKEquivalent", 34118: "SEMInfo", 34152: "AFCP_IPTC", 34232: "PixelMagicJBIGOptions", 34264: "ModelTransform", 34306: "WB_GRGBLevels", 34310: "LeafData", 34377: "PhotoshopSettings", 34665: "ExifOffset", 34675: "ICC_Profile", 34687: "TIFF_FXExtensions", 34688: "MultiProfiles", 34689: "SharedData", 34690: "T88Options", 34732: "ImageLayer", 34735: "GeoTiffDirectory", 34736: "GeoTiffDoubleParams", 34737: "GeoTiffAsciiParams", 34850: "ExposureProgram", 34852: "SpectralSensitivity", 34853: "GPSInfo", 34855: "ISO", 34856: "Opto-ElectricConvFactor", 34857: "Interlace", 34858: "TimeZoneOffset", 34859: "SelfTimerMode", 34864: "SensitivityType", 34865: "StandardOutputSensitivity", 34866: "RecommendedExposureIndex", 34867: "ISOSpeed", 34868: "ISOSpeedLatitudeyyy", 34869: "ISOSpeedLatitudezzz", 34908: "FaxRecvParams", 34909: "FaxSubAddress", 34910: "FaxRecvTime", 34954: "LeafSubIFD", 36864: "ExifVersion", 36867: "DateTimeOriginal", 36868: "CreateDate", 37121: "ComponentsConfiguration", 37122: "CompressedBitsPerPixel", 37377: "ShutterSpeedValue", 37378: "ApertureValue", 37379: "BrightnessValue", 37380: "ExposureCompensation", 37381: "MaxApertureValue", 37382: "SubjectDistance", 37383: "MeteringMode", 37384: "LightSource", 37385: "Flash", 37386: "FocalLength", 37387: "FlashEnergy", 37388: "SpatialFrequencyResponse", 37389: "Noise", 37390: "FocalPlaneXResolution", 37391: "FocalPlaneYResolution", 37392: "FocalPlaneResolutionUnit", 37393: "ImageNumber", 37394: "SecurityClassification", 37395: "ImageHistory", 37396: "SubjectArea", 37397: "ExposureIndex", 37398: "TIFF-EPStandardID", 37399: "SensingMethod", 37434: "CIP3DataFile", 37435: "CIP3Sheet", 37436: "CIP3Side", 37439: "StoNits", 37500: "MakerNote", 37510: "UserComment", 37520: "SubSecTime", 37521: "SubSecTimeOriginal", 37522: "SubSecTimeDigitized", 37679: "MSDocumentText", 37680: "MSPropertySetStorage", 37681: "MSDocumentTextPosition", 37724: "ImageSourceData", 40091: "XPTitle", 40092: "XPComment", 40093: "XPAuthor", 40094: "XPKeywords", 40095: "XPSubject", 40960: "FlashpixVersion", 40961: "ColorSpace", 40962: "ExifImageWidth", 40963: "ExifImageHeight", 40964: "RelatedSoundFile", 40965: "InteropOffset", 41483: "FlashEnergy", 41484: "SpatialFrequencyResponse", 41485: "Noise", 41486: "FocalPlaneXResolution", 41487: "FocalPlaneYResolution", 41488: "FocalPlaneResolutionUnit", 41489: "ImageNumber", 41490: "SecurityClassification", 41491: "ImageHistory", 41492: "SubjectLocation", 41493: "ExposureIndex", 41494: "TIFF-EPStandardID", 41495: "SensingMethod", 41728: "FileSource", 41729: "SceneType", 41730: "CFAPattern", 41985: "CustomRendered", 41986: "ExposureMode", 41987: "WhiteBalance", 41988: "DigitalZoomRatio", 41989: "FocalLengthIn35mmFormat", 41990: "SceneCaptureType", 41991: "GainControl", 41992: "Contrast", 41993: "Saturation", 41994: "Sharpness", 41995: "DeviceSettingDescription", 41996: "SubjectDistanceRange", 42016: "ImageUniqueID", 42032: "OwnerName", 42033: "SerialNumber", 42034: "LensInfo", 42035: "LensMake", 42036: "LensModel", 42037: "LensSerialNumber", 42112: "GDALMetadata", 42113: "GDALNoData", 42240: "Gamma", 44992: "ExpandSoftware", 44993: "ExpandLens", 44994: "ExpandFilm", 44995: "ExpandFilterLens", 44996: "ExpandScanner", 44997: "ExpandFlashLamp", 48129: "PixelFormat", 48130: "Transformation", 48131: "Uncompressed", 48132: "ImageType", 48256: "ImageWidth", 48257: "ImageHeight", 48258: "WidthResolution", 48259: "HeightResolution", 48320: "ImageOffset", 48321: "ImageByteCount", 48322: "AlphaOffset", 48323: "AlphaByteCount", 48324: "ImageDataDiscard", 48325: "AlphaDataDiscard", 50215: "OceScanjobDesc", 50216: "OceApplicationSelector", 50217: "OceIDNumber", 50218: "OceImageLogic", 50255: "Annotations", 50341: "PrintIM", 50560: "USPTOOriginalContentType", 50706: "DNGVersion", 50707: "DNGBackwardVersion", 50708: "UniqueCameraModel", 50709: "LocalizedCameraModel", 50710: "CFAPlaneColor", 50711: "CFALayout", 50712: "LinearizationTable", 50713: "BlackLevelRepeatDim", 50714: "BlackLevel", 50715: "BlackLevelDeltaH", 50716: "BlackLevelDeltaV", 50717: "WhiteLevel", 50718: "DefaultScale", 50719: "DefaultCropOrigin", 50720: "DefaultCropSize", 50721: "ColorMatrix1", 50722: "ColorMatrix2", 50723: "CameraCalibration1", 50724: "CameraCalibration2", 50725: "ReductionMatrix1", 50726: "ReductionMatrix2", 50727: "AnalogBalance", 50728: "AsShotNeutral", 50729: "AsShotWhiteXY", 50730: "BaselineExposure", 50731: "BaselineNoise", 50732: "BaselineSharpness", 50733: "BayerGreenSplit", 50734: "LinearResponseLimit", 50735: "CameraSerialNumber", 50736: "DNGLensInfo", 50737: "ChromaBlurRadius", 50738: "AntiAliasStrength", 50739: "ShadowScale", 50740: "DNGPrivateData", 50741: "MakerNoteSafety", 50752: "RawImageSegmentation", 50778: "CalibrationIlluminant1", 50779: "CalibrationIlluminant2", 50780: "BestQualityScale", 50781: "RawDataUniqueID", 50784: "AliasLayerMetadata", 50827: "OriginalRawFileName", 50828: "OriginalRawFileData", 50829: "ActiveArea", 50830: "MaskedAreas", 50831: "AsShotICCProfile", 50832: "AsShotPreProfileMatrix", 50833: "CurrentICCProfile", 50834: "CurrentPreProfileMatrix", 50879: "ColorimetricReference", 50898: "PanasonicTitle", 50899: "PanasonicTitle2", 50931: "CameraCalibrationSig", 50932: "ProfileCalibrationSig", 50933: "ProfileIFD", 50934: "AsShotProfileName", 50935: "NoiseReductionApplied", 50936: "ProfileName", 50937: "ProfileHueSatMapDims", 50938: "ProfileHueSatMapData1", 50939: "ProfileHueSatMapData2", 50940: "ProfileToneCurve", 50941: "ProfileEmbedPolicy", 50942: "ProfileCopyright", 50964: "ForwardMatrix1", 50965: "ForwardMatrix2", 50966: "PreviewApplicationName", 50967: "PreviewApplicationVersion", 50968: "PreviewSettingsName", 50969: "PreviewSettingsDigest", 50970: "PreviewColorSpace", 50971: "PreviewDateTime", 50972: "RawImageDigest", 50973: "OriginalRawFileDigest", 50974: "SubTileBlockSize", 50975: "RowInterleaveFactor", 50981: "ProfileLookTableDims", 50982: "ProfileLookTableData", 51008: "OpcodeList1", 51009: "OpcodeList2", 51022: "OpcodeList3", 51041: "NoiseProfile", 51043: "TimeCodes", 51044: "FrameRate", 51058: "TStop", 51081: "ReelName", 51089: "OriginalDefaultFinalSize", 51090: "OriginalBestQualitySize", 51091: "OriginalDefaultCropSize", 51105: "CameraLabel", 51107: "ProfileHueSatMapEncoding", 51108: "ProfileLookTableEncoding", 51109: "BaselineExposureOffset", 51110: "DefaultBlackRender", 51111: "NewRawImageDigest", 51112: "RawToPreviewGain", 51125: "DefaultUserCrop", 59932: "Padding", 59933: "OffsetSchema", 65e3: "OwnerName", 65001: "SerialNumber", 65002: "Lens", 65024: "KDC_IFD", 65100: "RawFile", 65101: "Converter", 65102: "WhiteBalance", 65105: "Exposure", 65106: "Shadows", 65107: "Brightness", 65108: "Contrast", 65109: "Saturation", 65110: "Sharpness", 65111: "Smoothness", 65112: "MoireFilter" }, gps: { 0: "GPSVersionID", 1: "GPSLatitudeRef", 2: "GPSLatitude", 3: "GPSLongitudeRef", 4: "GPSLongitude", 5: "GPSAltitudeRef", 6: "GPSAltitude", 7: "GPSTimeStamp", 8: "GPSSatellites", 9: "GPSStatus", 10: "GPSMeasureMode", 11: "GPSDOP", 12: "GPSSpeedRef", 13: "GPSSpeed", 14: "GPSTrackRef", 15: "GPSTrack", 16: "GPSImgDirectionRef", 17: "GPSImgDirection", 18: "GPSMapDatum", 19: "GPSDestLatitudeRef", 20: "GPSDestLatitude", 21: "GPSDestLongitudeRef", 22: "GPSDestLongitude", 23: "GPSDestBearingRef", 24: "GPSDestBearing", 25: "GPSDestDistanceRef", 26: "GPSDestDistance", 27: "GPSProcessingMethod", 28: "GPSAreaInformation", 29: "GPSDateStamp", 30: "GPSDifferential", 31: "GPSHPositioningError" } };
        }, 592: (t) => {
          function e(t2, e2) {
            switch (t2) {
              case 1:
                return e2.nextUInt8();
              case 3:
              case 8:
                return e2.nextUInt16();
              case 4:
              case 9:
                return e2.nextUInt32();
              case 5:
                return [e2.nextUInt32(), e2.nextUInt32()];
              case 6:
                return e2.nextInt8();
              case 10:
                return [e2.nextInt32(), e2.nextInt32()];
              case 11:
                return e2.nextFloat();
              case 12:
                return e2.nextDouble();
              default:
                throw new Error("Invalid format while decoding: " + t2);
            }
          }
          function r(t2, r2) {
            var i2, n, a = r2.nextUInt16(), o = r2.nextUInt16(), s = function(t3) {
              switch (t3) {
                case 1:
                case 2:
                case 6:
                case 7:
                  return 1;
                case 3:
                case 8:
                  return 2;
                case 4:
                case 9:
                case 11:
                  return 4;
                case 5:
                case 10:
                case 12:
                  return 8;
                default:
                  return 0;
              }
            }(o), h = r2.nextUInt32(), f = s * h;
            if (f > 4 && (r2 = t2.openWithOffset(r2.nextUInt32())), 2 === o) {
              var u = (i2 = r2.nextString(h)).indexOf("\0");
              -1 !== u && (i2 = i2.substr(0, u));
            } else if (7 === o)
              i2 = r2.nextBuffer(h);
            else if (0 !== o)
              for (i2 = [], n = 0; n < h; ++n)
                i2.push(e(o, r2));
            return f < 4 && r2.skip(4 - f), [a, i2, o];
          }
          function i(t2, e2, i2) {
            var n, a, o = e2.nextUInt16();
            for (a = 0; a < o; ++a)
              i2((n = r(t2, e2))[0], n[1], n[2]);
          }
          t.exports = { IFD0: 1, IFD1: 2, GPSIFD: 3, SubIFD: 4, InteropIFD: 5, parseTags: function(t2, e2) {
            var r2, n, a, o;
            try {
              r2 = function(t3) {
                if ("Exif\0\0" !== t3.nextString(6))
                  throw new Error("Invalid EXIF header");
                var e3 = t3.mark(), r3 = t3.nextUInt16();
                if (18761 === r3)
                  t3.setBigEndian(false);
                else {
                  if (19789 !== r3)
                    throw new Error("Invalid TIFF header");
                  t3.setBigEndian(true);
                }
                if (42 !== t3.nextUInt16())
                  throw new Error("Invalid TIFF data");
                return e3;
              }(t2);
            } catch (t3) {
              return false;
            }
            var s = r2.openWithOffset(t2.nextUInt32()), h = this.IFD0;
            i(r2, s, function(t3, r3, i2) {
              switch (t3) {
                case 34853:
                  a = r3[0];
                  break;
                case 34665:
                  n = r3[0];
                  break;
                default:
                  e2(h, t3, r3, i2);
              }
            });
            var f = s.nextUInt32();
            if (0 !== f) {
              var u = r2.openWithOffset(f);
              i(r2, u, e2.bind(null, this.IFD1));
            }
            if (a) {
              var l = r2.openWithOffset(a);
              i(r2, l, e2.bind(null, this.GPSIFD));
            }
            if (n) {
              var c = r2.openWithOffset(n), d = this.InteropIFD;
              i(r2, c, function(t3, r3, i2) {
                40965 === t3 ? o = r3[0] : e2(d, t3, r3, i2);
              });
            }
            if (o) {
              var p = r2.openWithOffset(o);
              i(r2, p, e2.bind(null, this.InteropIFD));
            }
            return true;
          } };
        }, 656: (t) => {
          t.exports = { parseSections: function(t2, e) {
            var r, i;
            for (t2.setBigEndian(true); t2.remainingLength() > 0 && 218 !== i; ) {
              if (255 !== t2.nextUInt8())
                throw new Error("Invalid JPEG section offset");
              r = (i = t2.nextUInt8()) >= 208 && i <= 217 || 218 === i ? 0 : t2.nextUInt16() - 2, e(i, t2.branch(0, r)), t2.skip(r);
            }
          }, getSizeFromSOFSection: function(t2) {
            return t2.skip(1), { height: t2.nextUInt16(), width: t2.nextUInt16() };
          }, getSectionName: function(t2) {
            var e, r;
            switch (t2) {
              case 216:
                e = "SOI";
                break;
              case 196:
                e = "DHT";
                break;
              case 219:
                e = "DQT";
                break;
              case 221:
                e = "DRI";
                break;
              case 218:
                e = "SOS";
                break;
              case 254:
                e = "COM";
                break;
              case 217:
                e = "EOI";
                break;
              default:
                t2 >= 224 && t2 <= 239 ? (e = "APP", r = t2 - 224) : t2 >= 192 && t2 <= 207 && 196 !== t2 && 200 !== t2 && 204 !== t2 ? (e = "SOF", r = t2 - 192) : t2 >= 208 && t2 <= 215 && (e = "RST", r = t2 - 208);
            }
            var i = { name: e };
            return "number" == typeof r && (i.index = r), i;
          } };
        }, 453: (t, e, r) => {
          var i = r(656), n = r(592), a = r(3814);
          function o(t2, e2, r2, i2, n2, a2, o2) {
            this.startMarker = t2, this.tags = e2, this.imageSize = r2, this.thumbnailOffset = i2, this.thumbnailLength = n2, this.thumbnailType = a2, this.app1Offset = o2;
          }
          function s(t2) {
            this.stream = t2, this.flags = { readBinaryTags: false, resolveTagNames: true, simplifyValues: true, imageSize: true, hidePointers: true, returnTags: true };
          }
          o.prototype = { hasThumbnail: function(t2) {
            return !(!this.thumbnailOffset || !this.thumbnailLength || "string" == typeof t2 && ("image/jpeg" === t2.toLowerCase().trim() ? 6 !== this.thumbnailType : "image/tiff" !== t2.toLowerCase().trim() || 1 !== this.thumbnailType));
          }, getThumbnailOffset: function() {
            return this.app1Offset + 6 + this.thumbnailOffset;
          }, getThumbnailLength: function() {
            return this.thumbnailLength;
          }, getThumbnailBuffer: function() {
            return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
          }, _getThumbnailStream: function() {
            return this.startMarker.openWithOffset(this.getThumbnailOffset());
          }, getImageSize: function() {
            return this.imageSize;
          }, getThumbnailSize: function() {
            var t2, e2 = this._getThumbnailStream();
            return i.parseSections(e2, function(e3, r2) {
              "SOF" === i.getSectionName(e3).name && (t2 = i.getSizeFromSOFSection(r2));
            }), t2;
          } }, s.prototype = { enableBinaryFields: function(t2) {
            return this.flags.readBinaryTags = !!t2, this;
          }, enablePointers: function(t2) {
            return this.flags.hidePointers = !t2, this;
          }, enableTagNames: function(t2) {
            return this.flags.resolveTagNames = !!t2, this;
          }, enableImageSize: function(t2) {
            return this.flags.imageSize = !!t2, this;
          }, enableReturnTags: function(t2) {
            return this.flags.returnTags = !!t2, this;
          }, enableSimpleValues: function(t2) {
            return this.flags.simplifyValues = !!t2, this;
          }, parse: function() {
            var t2, e2, s2, h, f, u, l, c, d, p = this.stream.mark(), m = p.openWithOffset(0), g = this.flags;
            return g.resolveTagNames && (l = r(3332)), g.resolveTagNames ? (t2 = {}, c = function(e3) {
              return t2[e3.name];
            }, d = function(e3, r2) {
              t2[e3.name] = r2;
            }) : (t2 = [], c = function(e3) {
              var r2;
              for (r2 = 0; r2 < t2.length; ++r2)
                if (t2[r2].type === e3.type && t2[r2].section === e3.section)
                  return t2.value;
            }, d = function(e3, r2) {
              var i2;
              for (i2 = 0; i2 < t2.length; ++i2)
                if (t2[i2].type === e3.type && t2[i2].section === e3.section)
                  return void (t2.value = r2);
            }), i.parseSections(m, function(r2, o2) {
              var c2 = o2.offsetFrom(p);
              225 === r2 ? n.parseTags(o2, function(e3, r3, i2, o3) {
                if (g.readBinaryTags || 7 !== o3) {
                  if (513 === r3) {
                    if (s2 = i2[0], g.hidePointers)
                      return;
                  } else if (514 === r3) {
                    if (h = i2[0], g.hidePointers)
                      return;
                  } else if (259 === r3 && (f = i2[0], g.hidePointers))
                    return;
                  if (g.returnTags)
                    if (g.simplifyValues && (i2 = a.simplifyValue(i2, o3)), g.resolveTagNames) {
                      var u2 = (e3 === n.GPSIFD ? l.gps : l.exif)[r3];
                      u2 || (u2 = l.exif[r3]), t2.hasOwnProperty(u2) || (t2[u2] = i2);
                    } else
                      t2.push({ section: e3, type: r3, value: i2 });
                }
              }) && (u = c2) : g.imageSize && "SOF" === i.getSectionName(r2).name && (e2 = i.getSizeFromSOFSection(o2));
            }), g.simplifyValues && (a.castDegreeValues(c, d), a.castDateValues(c, d)), new o(p, t2, e2, s2, h, f, u);
          } }, t.exports = s;
        }, 3814: (t, e, r) => {
          var i = r(592), n = r(565), a = [{ section: i.GPSIFD, type: 2, name: "GPSLatitude", refType: 1, refName: "GPSLatitudeRef", posVal: "N" }, { section: i.GPSIFD, type: 4, name: "GPSLongitude", refType: 3, refName: "GPSLongitudeRef", posVal: "E" }], o = [{ section: i.SubIFD, type: 306, name: "ModifyDate" }, { section: i.SubIFD, type: 36867, name: "DateTimeOriginal" }, { section: i.SubIFD, type: 36868, name: "CreateDate" }, { section: i.SubIFD, type: 306, name: "ModifyDate" }];
          t.exports = { castDegreeValues: function(t2, e2) {
            a.forEach(function(r2) {
              var i2 = t2(r2);
              if (i2) {
                var n2 = t2({ section: r2.section, type: r2.refType, name: r2.refName }) === r2.posVal ? 1 : -1, a2 = (i2[0] + i2[1] / 60 + i2[2] / 3600) * n2;
                e2(r2, a2);
              }
            });
          }, castDateValues: function(t2, e2) {
            o.forEach(function(r2) {
              var i2 = t2(r2);
              if (i2) {
                var a2 = n.parseExifDate(i2);
                void 0 !== a2 && e2(r2, a2);
              }
            });
          }, simplifyValue: function(t2, e2) {
            return Array.isArray(t2) && 1 === (t2 = t2.map(function(t3) {
              return 10 === e2 || 5 === e2 ? t3[0] / t3[1] : t3;
            })).length && (t2 = t2[0]), t2;
          } };
        }, 8789: (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          var Buffer = __webpack_require__(8834).lW;
          const Token = __webpack_require__(5010), strtok3 = __webpack_require__(7378), { stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken } = __webpack_require__(7044), supported = __webpack_require__(4078), minimumBytes = 4100;
          async function fromStream(t) {
            const e = await strtok3.fromStream(t);
            try {
              return await fromTokenizer(e);
            } finally {
              await e.close();
            }
          }
          async function fromBuffer(t) {
            if (!(t instanceof Uint8Array || t instanceof ArrayBuffer || Buffer.isBuffer(t)))
              throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof t}\``);
            const e = t instanceof Buffer ? t : Buffer.from(t);
            if (e && e.length > 1)
              return fromTokenizer(strtok3.fromBuffer(e));
          }
          function _check(t, e, r) {
            r = { offset: 0, ...r };
            for (const [i, n] of e.entries())
              if (r.mask) {
                if (n !== (r.mask[i] & t[i + r.offset]))
                  return false;
              } else if (n !== t[i + r.offset])
                return false;
            return true;
          }
          async function fromTokenizer(t) {
            try {
              return _fromTokenizer(t);
            } catch (t2) {
              if (!(t2 instanceof strtok3.EndOfStreamError))
                throw t2;
            }
          }
          async function _fromTokenizer(t) {
            let e = Buffer.alloc(minimumBytes);
            const r = (t2, r2) => _check(e, t2, r2), i = (t2, e2) => r(stringToBytes(t2), e2);
            if (t.fileInfo.size || (t.fileInfo.size = Number.MAX_SAFE_INTEGER), await t.peekBuffer(e, { length: 12, mayBeLess: true }), r([66, 77]))
              return { ext: "bmp", mime: "image/bmp" };
            if (r([11, 119]))
              return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
            if (r([120, 1]))
              return { ext: "dmg", mime: "application/x-apple-diskimage" };
            if (r([77, 90]))
              return { ext: "exe", mime: "application/x-msdownload" };
            if (r([37, 33]))
              return await t.peekBuffer(e, { length: 24, mayBeLess: true }), i("PS-Adobe-", { offset: 2 }) && i(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
            if (r([31, 160]) || r([31, 157]))
              return { ext: "Z", mime: "application/x-compress" };
            if (r([255, 216, 255]))
              return { ext: "jpg", mime: "image/jpeg" };
            if (r([73, 73, 188]))
              return { ext: "jxr", mime: "image/vnd.ms-photo" };
            if (r([31, 139, 8]))
              return { ext: "gz", mime: "application/gzip" };
            if (r([66, 90, 104]))
              return { ext: "bz2", mime: "application/x-bzip2" };
            if (i("ID3")) {
              await t.ignore(6);
              const n = await t.readToken(uint32SyncSafeToken);
              return t.position + n > t.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await t.ignore(n), fromTokenizer(t));
            }
            if (i("MP+"))
              return { ext: "mpc", mime: "audio/x-musepack" };
            if ((67 === e[0] || 70 === e[0]) && r([87, 83], { offset: 1 }))
              return { ext: "swf", mime: "application/x-shockwave-flash" };
            if (r([71, 73, 70]))
              return { ext: "gif", mime: "image/gif" };
            if (i("FLIF"))
              return { ext: "flif", mime: "image/flif" };
            if (i("8BPS"))
              return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
            if (i("WEBP", { offset: 8 }))
              return { ext: "webp", mime: "image/webp" };
            if (i("MPCK"))
              return { ext: "mpc", mime: "audio/x-musepack" };
            if (i("FORM"))
              return { ext: "aif", mime: "audio/aiff" };
            if (i("icns", { offset: 0 }))
              return { ext: "icns", mime: "image/icns" };
            if (r([80, 75, 3, 4])) {
              try {
                for (; t.position + 30 < t.fileInfo.size; ) {
                  await t.readBuffer(e, { length: 30 });
                  const a = { compressedSize: e.readUInt32LE(18), uncompressedSize: e.readUInt32LE(22), filenameLength: e.readUInt16LE(26), extraFieldLength: e.readUInt16LE(28) };
                  if (a.filename = await t.readToken(new Token.StringType(a.filenameLength, "utf-8")), await t.ignore(a.extraFieldLength), "META-INF/mozilla.rsa" === a.filename)
                    return { ext: "xpi", mime: "application/x-xpinstall" };
                  if (a.filename.endsWith(".rels") || a.filename.endsWith(".xml"))
                    switch (a.filename.split("/")[0]) {
                      case "_rels":
                      default:
                        break;
                      case "word":
                        return { ext: "docx", mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" };
                      case "ppt":
                        return { ext: "pptx", mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation" };
                      case "xl":
                        return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
                    }
                  if (a.filename.startsWith("xl/"))
                    return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
                  if (a.filename.startsWith("3D/") && a.filename.endsWith(".model"))
                    return { ext: "3mf", mime: "model/3mf" };
                  if ("mimetype" === a.filename && a.compressedSize === a.uncompressedSize)
                    switch (await t.readToken(new Token.StringType(a.compressedSize, "utf-8"))) {
                      case "application/epub+zip":
                        return { ext: "epub", mime: "application/epub+zip" };
                      case "application/vnd.oasis.opendocument.text":
                        return { ext: "odt", mime: "application/vnd.oasis.opendocument.text" };
                      case "application/vnd.oasis.opendocument.spreadsheet":
                        return { ext: "ods", mime: "application/vnd.oasis.opendocument.spreadsheet" };
                      case "application/vnd.oasis.opendocument.presentation":
                        return { ext: "odp", mime: "application/vnd.oasis.opendocument.presentation" };
                    }
                  if (0 === a.compressedSize) {
                    let o = -1;
                    for (; o < 0 && t.position < t.fileInfo.size; )
                      await t.peekBuffer(e, { mayBeLess: true }), o = e.indexOf("504B0304", 0, "hex"), await t.ignore(o >= 0 ? o : e.length);
                  } else
                    await t.ignore(a.compressedSize);
                }
              } catch (s) {
                if (!(s instanceof strtok3.EndOfStreamError))
                  throw s;
              }
              return { ext: "zip", mime: "application/zip" };
            }
            if (i("OggS")) {
              await t.ignore(28);
              const h = Buffer.alloc(8);
              return await t.readBuffer(h), _check(h, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/opus" } : _check(h, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : _check(h, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : _check(h, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : _check(h, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : _check(h, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
            }
            if (r([80, 75]) && (3 === e[2] || 5 === e[2] || 7 === e[2]) && (4 === e[3] || 6 === e[3] || 8 === e[3]))
              return { ext: "zip", mime: "application/zip" };
            if (i("ftyp", { offset: 4 }) && 0 != (96 & e[8])) {
              const f = e.toString("binary", 8, 12).replace("\0", " ").trim();
              switch (f) {
                case "avif":
                  return { ext: "avif", mime: "image/avif" };
                case "mif1":
                  return { ext: "heic", mime: "image/heif" };
                case "msf1":
                  return { ext: "heic", mime: "image/heif-sequence" };
                case "heic":
                case "heix":
                  return { ext: "heic", mime: "image/heic" };
                case "hevc":
                case "hevx":
                  return { ext: "heic", mime: "image/heic-sequence" };
                case "qt":
                  return { ext: "mov", mime: "video/quicktime" };
                case "M4V":
                case "M4VH":
                case "M4VP":
                  return { ext: "m4v", mime: "video/x-m4v" };
                case "M4P":
                  return { ext: "m4p", mime: "video/mp4" };
                case "M4B":
                  return { ext: "m4b", mime: "audio/mp4" };
                case "M4A":
                  return { ext: "m4a", mime: "audio/x-m4a" };
                case "F4V":
                  return { ext: "f4v", mime: "video/mp4" };
                case "F4P":
                  return { ext: "f4p", mime: "video/mp4" };
                case "F4A":
                  return { ext: "f4a", mime: "audio/mp4" };
                case "F4B":
                  return { ext: "f4b", mime: "audio/mp4" };
                case "crx":
                  return { ext: "cr3", mime: "image/x-canon-cr3" };
                default:
                  return f.startsWith("3g") ? f.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
              }
            }
            if (i("MThd"))
              return { ext: "mid", mime: "audio/midi" };
            if (i("wOFF") && (r([0, 1, 0, 0], { offset: 4 }) || i("OTTO", { offset: 4 })))
              return { ext: "woff", mime: "font/woff" };
            if (i("wOF2") && (r([0, 1, 0, 0], { offset: 4 }) || i("OTTO", { offset: 4 })))
              return { ext: "woff2", mime: "font/woff2" };
            if (r([212, 195, 178, 161]) || r([161, 178, 195, 212]))
              return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
            if (i("DSD "))
              return { ext: "dsf", mime: "audio/x-dsf" };
            if (i("LZIP"))
              return { ext: "lz", mime: "application/x-lzip" };
            if (i("fLaC"))
              return { ext: "flac", mime: "audio/x-flac" };
            if (r([66, 80, 71, 251]))
              return { ext: "bpg", mime: "image/bpg" };
            if (i("wvpk"))
              return { ext: "wv", mime: "audio/wavpack" };
            if (i("%PDF")) {
              await t.ignore(1350);
              const u = 10485760, l = Buffer.alloc(Math.min(u, t.fileInfo.size));
              return await t.readBuffer(l, { mayBeLess: true }), l.includes(Buffer.from("AIPrivateData")) ? { ext: "ai", mime: "application/postscript" } : { ext: "pdf", mime: "application/pdf" };
            }
            if (r([0, 97, 115, 109]))
              return { ext: "wasm", mime: "application/wasm" };
            if (r([73, 73, 42, 0]))
              return i("CR", { offset: 8 }) ? { ext: "cr2", mime: "image/x-canon-cr2" } : r([28, 0, 254, 0], { offset: 8 }) || r([31, 0, 11, 0], { offset: 8 }) ? { ext: "nef", mime: "image/x-nikon-nef" } : r([8, 0, 0, 0], { offset: 4 }) && (r([45, 0, 254, 0], { offset: 8 }) || r([39, 0, 254, 0], { offset: 8 })) ? { ext: "dng", mime: "image/x-adobe-dng" } : (e = Buffer.alloc(24), await t.peekBuffer(e), (r([16, 251, 134, 1], { offset: 4 }) || r([8, 0, 0, 0], { offset: 4 })) && r([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? { ext: "arw", mime: "image/x-sony-arw" } : { ext: "tif", mime: "image/tiff" });
            if (r([77, 77, 0, 42]))
              return { ext: "tif", mime: "image/tiff" };
            if (i("MAC "))
              return { ext: "ape", mime: "audio/ape" };
            if (r([26, 69, 223, 163])) {
              async function c() {
                const e2 = await t.peekNumber(Token.UINT8);
                let r2 = 128, i2 = 0;
                for (; 0 == (e2 & r2) && 0 !== r2; )
                  ++i2, r2 >>= 1;
                const n = Buffer.alloc(i2 + 1);
                return await t.readBuffer(n), n;
              }
              async function d() {
                const t2 = await c(), e2 = await c();
                e2[0] ^= 128 >> e2.length - 1;
                const r2 = Math.min(6, e2.length);
                return { id: t2.readUIntBE(0, t2.length), len: e2.readUIntBE(e2.length - r2, r2) };
              }
              async function p(e2, r2) {
                for (; r2 > 0; ) {
                  const e3 = await d();
                  if (17026 === e3.id)
                    return t.readToken(new Token.StringType(e3.len, "utf-8"));
                  await t.ignore(e3.len), --r2;
                }
              }
              const m = await d();
              switch (await p(0, m.len)) {
                case "webm":
                  return { ext: "webm", mime: "video/webm" };
                case "matroska":
                  return { ext: "mkv", mime: "video/x-matroska" };
                default:
                  return;
              }
            }
            if (r([82, 73, 70, 70])) {
              if (r([65, 86, 73], { offset: 8 }))
                return { ext: "avi", mime: "video/vnd.avi" };
              if (r([87, 65, 86, 69], { offset: 8 }))
                return { ext: "wav", mime: "audio/vnd.wave" };
              if (r([81, 76, 67, 77], { offset: 8 }))
                return { ext: "qcp", mime: "audio/qcelp" };
            }
            if (i("SQLi"))
              return { ext: "sqlite", mime: "application/x-sqlite3" };
            if (r([78, 69, 83, 26]))
              return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
            if (i("Cr24"))
              return { ext: "crx", mime: "application/x-google-chrome-extension" };
            if (i("MSCF") || i("ISc("))
              return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
            if (r([237, 171, 238, 219]))
              return { ext: "rpm", mime: "application/x-rpm" };
            if (r([197, 208, 211, 198]))
              return { ext: "eps", mime: "application/eps" };
            if (r([40, 181, 47, 253]))
              return { ext: "zst", mime: "application/zstd" };
            if (r([79, 84, 84, 79, 0]))
              return { ext: "otf", mime: "font/otf" };
            if (i("#!AMR"))
              return { ext: "amr", mime: "audio/amr" };
            if (i("{\\rtf"))
              return { ext: "rtf", mime: "application/rtf" };
            if (r([70, 76, 86, 1]))
              return { ext: "flv", mime: "video/x-flv" };
            if (i("IMPM"))
              return { ext: "it", mime: "audio/x-it" };
            if (i("-lh0-", { offset: 2 }) || i("-lh1-", { offset: 2 }) || i("-lh2-", { offset: 2 }) || i("-lh3-", { offset: 2 }) || i("-lh4-", { offset: 2 }) || i("-lh5-", { offset: 2 }) || i("-lh6-", { offset: 2 }) || i("-lh7-", { offset: 2 }) || i("-lzs-", { offset: 2 }) || i("-lz4-", { offset: 2 }) || i("-lz5-", { offset: 2 }) || i("-lhd-", { offset: 2 }))
              return { ext: "lzh", mime: "application/x-lzh-compressed" };
            if (r([0, 0, 1, 186])) {
              if (r([33], { offset: 4, mask: [241] }))
                return { ext: "mpg", mime: "video/MP1S" };
              if (r([68], { offset: 4, mask: [196] }))
                return { ext: "mpg", mime: "video/MP2P" };
            }
            if (i("ITSF"))
              return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
            if (r([253, 55, 122, 88, 90, 0]))
              return { ext: "xz", mime: "application/x-xz" };
            if (i("<?xml "))
              return { ext: "xml", mime: "application/xml" };
            if (r([55, 122, 188, 175, 39, 28]))
              return { ext: "7z", mime: "application/x-7z-compressed" };
            if (r([82, 97, 114, 33, 26, 7]) && (0 === e[6] || 1 === e[6]))
              return { ext: "rar", mime: "application/x-rar-compressed" };
            if (i("solid "))
              return { ext: "stl", mime: "model/stl" };
            if (i("BLENDER"))
              return { ext: "blend", mime: "application/x-blender" };
            if (i("!<arch>"))
              return await t.ignore(8), "debian-binary" === await t.readToken(new Token.StringType(13, "ascii")) ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
            if (r([137, 80, 78, 71, 13, 10, 26, 10])) {
              async function g() {
                return { length: await t.readToken(Token.INT32_BE), type: await t.readToken(new Token.StringType(4, "binary")) };
              }
              await t.ignore(8);
              do {
                const b = await g();
                if (b.length < 0)
                  return;
                switch (b.type) {
                  case "IDAT":
                    return { ext: "png", mime: "image/png" };
                  case "acTL":
                    return { ext: "apng", mime: "image/apng" };
                  default:
                    await t.ignore(b.length + 4);
                }
              } while (t.position + 8 < t.fileInfo.size);
              return { ext: "png", mime: "image/png" };
            }
            if (r([65, 82, 82, 79, 87, 49, 0, 0]))
              return { ext: "arrow", mime: "application/x-apache-arrow" };
            if (r([103, 108, 84, 70, 2, 0, 0, 0]))
              return { ext: "glb", mime: "model/gltf-binary" };
            if (r([102, 114, 101, 101], { offset: 4 }) || r([109, 100, 97, 116], { offset: 4 }) || r([109, 111, 111, 118], { offset: 4 }) || r([119, 105, 100, 101], { offset: 4 }))
              return { ext: "mov", mime: "video/quicktime" };
            if (r([73, 73, 82, 79, 8, 0, 0, 0, 24]))
              return { ext: "orf", mime: "image/x-olympus-orf" };
            if (i("gimp xcf "))
              return { ext: "xcf", mime: "image/x-xcf" };
            if (r([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
              return { ext: "rw2", mime: "image/x-panasonic-rw2" };
            if (r([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
              async function _() {
                const e2 = Buffer.alloc(16);
                return await t.readBuffer(e2), { id: e2, size: Number(await t.readToken(Token.UINT64_LE)) };
              }
              for (await t.ignore(30); t.position + 24 < t.fileInfo.size; ) {
                const y = await _();
                let w = y.size - 24;
                if (_check(y.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
                  const v = Buffer.alloc(16);
                  if (w -= await t.readBuffer(v), _check(v, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
                    return { ext: "asf", mime: "audio/x-ms-asf" };
                  if (_check(v, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
                    return { ext: "asf", mime: "video/x-ms-asf" };
                  break;
                }
                await t.ignore(w);
              }
              return { ext: "asf", mime: "application/vnd.ms-asf" };
            }
            if (r([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
              return { ext: "ktx", mime: "image/ktx" };
            if ((r([126, 16, 4]) || r([126, 24, 4])) && r([48, 77, 73, 69], { offset: 4 }))
              return { ext: "mie", mime: "application/x-mie" };
            if (r([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
              return { ext: "shp", mime: "application/x-esri-shape" };
            if (r([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
              switch (await t.ignore(20), await t.readToken(new Token.StringType(4, "ascii"))) {
                case "jp2 ":
                  return { ext: "jp2", mime: "image/jp2" };
                case "jpx ":
                  return { ext: "jpx", mime: "image/jpx" };
                case "jpm ":
                  return { ext: "jpm", mime: "image/jpm" };
                case "mjp2":
                  return { ext: "mj2", mime: "image/mj2" };
                default:
                  return;
              }
            if (r([255, 10]) || r([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
              return { ext: "jxl", mime: "image/jxl" };
            if (r([0, 0, 1, 186]) || r([0, 0, 1, 179]))
              return { ext: "mpg", mime: "video/mpeg" };
            if (r([0, 1, 0, 0, 0]))
              return { ext: "ttf", mime: "font/ttf" };
            if (r([0, 0, 1, 0]))
              return { ext: "ico", mime: "image/x-icon" };
            if (r([0, 0, 2, 0]))
              return { ext: "cur", mime: "image/x-icon" };
            if (r([208, 207, 17, 224, 161, 177, 26, 225]))
              return { ext: "cfb", mime: "application/x-cfb" };
            if (await t.peekBuffer(e, { length: Math.min(256, t.fileInfo.size), mayBeLess: true }), i("BEGIN:")) {
              if (i("VCARD", { offset: 6 }))
                return { ext: "vcf", mime: "text/vcard" };
              if (i("VCALENDAR", { offset: 6 }))
                return { ext: "ics", mime: "text/calendar" };
            }
            if (i("FUJIFILMCCD-RAW"))
              return { ext: "raf", mime: "image/x-fujifilm-raf" };
            if (i("Extended Module:"))
              return { ext: "xm", mime: "audio/x-xm" };
            if (i("Creative Voice File"))
              return { ext: "voc", mime: "audio/x-voc" };
            if (r([4, 0, 0, 0]) && e.length >= 16) {
              const x = e.readUInt32LE(12);
              if (x > 12 && e.length >= x + 16)
                try {
                  const E = e.slice(16, x + 16).toString();
                  if (JSON.parse(E).files)
                    return { ext: "asar", mime: "application/x-asar" };
                } catch (k) {
                }
            }
            if (r([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
              return { ext: "mxf", mime: "application/mxf" };
            if (i("SCRM", { offset: 44 }))
              return { ext: "s3m", mime: "audio/x-s3m" };
            if (r([71], { offset: 4 }) && (r([71], { offset: 192 }) || r([71], { offset: 196 })))
              return { ext: "mts", mime: "video/mp2t" };
            if (r([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
              return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
            if (r([68, 73, 67, 77], { offset: 128 }))
              return { ext: "dcm", mime: "application/dicom" };
            if (r([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
              return { ext: "lnk", mime: "application/x.ms.shortcut" };
            if (r([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
              return { ext: "alias", mime: "application/x.apple.alias" };
            if (r([76, 80], { offset: 34 }) && (r([0, 0, 1], { offset: 8 }) || r([1, 0, 2], { offset: 8 }) || r([2, 0, 2], { offset: 8 })))
              return { ext: "eot", mime: "application/vnd.ms-fontobject" };
            if (r([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29]))
              return { ext: "indd", mime: "application/x-indesign" };
            if (await t.peekBuffer(e, { length: Math.min(512, t.fileInfo.size), mayBeLess: true }), tarHeaderChecksumMatches(e))
              return { ext: "tar", mime: "application/x-tar" };
            if (r([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0]))
              return { ext: "skp", mime: "application/vnd.sketchup.skp" };
            if (i("-----BEGIN PGP MESSAGE-----"))
              return { ext: "pgp", mime: "application/pgp-encrypted" };
            if (e.length >= 2 && r([255, 224], { offset: 0, mask: [255, 224] })) {
              if (r([16], { offset: 1, mask: [22] }))
                return r([8], { offset: 1, mask: [8] }), { ext: "aac", mime: "audio/aac" };
              if (r([2], { offset: 1, mask: [6] }))
                return { ext: "mp3", mime: "audio/mpeg" };
              if (r([4], { offset: 1, mask: [6] }))
                return { ext: "mp2", mime: "audio/mpeg" };
              if (r([6], { offset: 1, mask: [6] }))
                return { ext: "mp1", mime: "audio/mpeg" };
            }
          }
          const stream = (readableStream) => new Promise((resolve, reject) => {
            const stream = eval("require")("stream");
            readableStream.on("error", reject), readableStream.once("readable", async () => {
              const t = new stream.PassThrough();
              let e;
              e = stream.pipeline ? stream.pipeline(readableStream, t, () => {
              }) : readableStream.pipe(t);
              const r = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
              try {
                const e2 = await fromBuffer(r);
                t.fileType = e2;
              } catch (t2) {
                reject(t2);
              }
              resolve(e);
            });
          }), fileType = { fromStream, fromTokenizer, fromBuffer, stream };
          Object.defineProperty(fileType, "extensions", { get: () => new Set(supported.extensions) }), Object.defineProperty(fileType, "mimeTypes", { get: () => new Set(supported.mimeTypes) }), module.exports = fileType;
        }, 5025: (t, e, r) => {
          "use strict";
          const i = r(3569), n = r(8789), a = { fromFile: async function(t2) {
            const e2 = await i.fromFile(t2);
            try {
              return await n.fromTokenizer(e2);
            } finally {
              await e2.close();
            }
          } };
          Object.assign(a, n), Object.defineProperty(a, "extensions", { get: () => n.extensions }), Object.defineProperty(a, "mimeTypes", { get: () => n.mimeTypes }), t.exports = a;
        }, 4078: (t) => {
          "use strict";
          t.exports = { extensions: ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "ai", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf"], mimeTypes: ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/x-apache-arrow", "video/mp4", "audio/midi", "video/x-matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/vnd.wave", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "audio/opus", "video/ogg", "audio/ogg", "application/ogg", "audio/x-flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd"] };
        }, 7044: (t, e) => {
          "use strict";
          e.stringToBytes = (t2) => [...t2].map((t3) => t3.charCodeAt(0)), e.tarHeaderChecksumMatches = (t2, e2 = 0) => {
            const r = parseInt(t2.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
            if (isNaN(r))
              return false;
            let i = 256;
            for (let r2 = e2; r2 < e2 + 148; r2++)
              i += t2[r2];
            for (let r2 = e2 + 156; r2 < e2 + 512; r2++)
              i += t2[r2];
            return r === i;
          }, e.uint32SyncSafeToken = { get: (t2, e2) => 127 & t2[e2 + 3] | t2[e2 + 2] << 7 | t2[e2 + 1] << 14 | t2[e2] << 21, len: 4 };
        }, 3243: (t, e, r) => {
          "use strict";
          var i = r(9680), n = Object.prototype.toString, a = Object.prototype.hasOwnProperty, o = function(t2, e2, r2) {
            for (var i2 = 0, n2 = t2.length; i2 < n2; i2++)
              a.call(t2, i2) && (null == r2 ? e2(t2[i2], i2, t2) : e2.call(r2, t2[i2], i2, t2));
          }, s = function(t2, e2, r2) {
            for (var i2 = 0, n2 = t2.length; i2 < n2; i2++)
              null == r2 ? e2(t2.charAt(i2), i2, t2) : e2.call(r2, t2.charAt(i2), i2, t2);
          }, h = function(t2, e2, r2) {
            for (var i2 in t2)
              a.call(t2, i2) && (null == r2 ? e2(t2[i2], i2, t2) : e2.call(r2, t2[i2], i2, t2));
          };
          t.exports = function(t2, e2, r2) {
            if (!i(e2))
              throw new TypeError("iterator must be a function");
            var a2;
            arguments.length >= 3 && (a2 = r2), "[object Array]" === n.call(t2) ? o(t2, e2, a2) : "string" == typeof t2 ? s(t2, e2, a2) : h(t2, e2, a2);
          };
        }, 2855: (t, e) => {
          "use strict";
          function r(t2, e2, r2, i) {
            for (var n = t2[e2++], a = 1 << n, o = a + 1, s = o + 1, h = n + 1, f = (1 << h) - 1, u = 0, l = 0, c = 0, d = t2[e2++], p = new Int32Array(4096), m = null; ; ) {
              for (; u < 16 && 0 !== d; )
                l |= t2[e2++] << u, u += 8, 1 === d ? d = t2[e2++] : --d;
              if (u < h)
                break;
              var g = l & f;
              if (l >>= h, u -= h, g !== a) {
                if (g === o)
                  break;
                for (var b = g < s ? g : m, _ = 0, y = b; y > a; )
                  y = p[y] >> 8, ++_;
                var w = y;
                if (c + _ + (b !== g ? 1 : 0) > i)
                  return void console.log("Warning, gif stream longer than expected.");
                r2[c++] = w;
                var v = c += _;
                for (b !== g && (r2[c++] = w), y = b; _--; )
                  y = p[y], r2[--v] = 255 & y, y >>= 8;
                null !== m && s < 4096 && (p[s++] = m << 8 | w, s >= f + 1 && h < 12 && (++h, f = f << 1 | 1)), m = g;
              } else
                s = o + 1, f = (1 << (h = n + 1)) - 1, m = null;
            }
            return c !== i && console.log("Warning, gif stream shorter than expected."), r2;
          }
          try {
            e.GifWriter = function(t2, e2, r2, i) {
              var n = 0, a = void 0 === (i = void 0 === i ? {} : i).loop ? null : i.loop, o = void 0 === i.palette ? null : i.palette;
              if (e2 <= 0 || r2 <= 0 || e2 > 65535 || r2 > 65535)
                throw new Error("Width/Height invalid.");
              function s(t3) {
                var e3 = t3.length;
                if (e3 < 2 || e3 > 256 || e3 & e3 - 1)
                  throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
                return e3;
              }
              t2[n++] = 71, t2[n++] = 73, t2[n++] = 70, t2[n++] = 56, t2[n++] = 57, t2[n++] = 97;
              var h = 0, f = 0;
              if (null !== o) {
                for (var u = s(o); u >>= 1; )
                  ++h;
                if (u = 1 << h, --h, void 0 !== i.background) {
                  if ((f = i.background) >= u)
                    throw new Error("Background index out of range.");
                  if (0 === f)
                    throw new Error("Background index explicitly passed as 0.");
                }
              }
              if (t2[n++] = 255 & e2, t2[n++] = e2 >> 8 & 255, t2[n++] = 255 & r2, t2[n++] = r2 >> 8 & 255, t2[n++] = (null !== o ? 128 : 0) | h, t2[n++] = f, t2[n++] = 0, null !== o)
                for (var l = 0, c = o.length; l < c; ++l) {
                  var d = o[l];
                  t2[n++] = d >> 16 & 255, t2[n++] = d >> 8 & 255, t2[n++] = 255 & d;
                }
              if (null !== a) {
                if (a < 0 || a > 65535)
                  throw new Error("Loop count invalid.");
                t2[n++] = 33, t2[n++] = 255, t2[n++] = 11, t2[n++] = 78, t2[n++] = 69, t2[n++] = 84, t2[n++] = 83, t2[n++] = 67, t2[n++] = 65, t2[n++] = 80, t2[n++] = 69, t2[n++] = 50, t2[n++] = 46, t2[n++] = 48, t2[n++] = 3, t2[n++] = 1, t2[n++] = 255 & a, t2[n++] = a >> 8 & 255, t2[n++] = 0;
              }
              var p = false;
              this.addFrame = function(e3, r3, i2, a2, h2, f2) {
                if (true === p && (--n, p = false), f2 = void 0 === f2 ? {} : f2, e3 < 0 || r3 < 0 || e3 > 65535 || r3 > 65535)
                  throw new Error("x/y invalid.");
                if (i2 <= 0 || a2 <= 0 || i2 > 65535 || a2 > 65535)
                  throw new Error("Width/Height invalid.");
                if (h2.length < i2 * a2)
                  throw new Error("Not enough pixels for the frame size.");
                var u2 = true, l2 = f2.palette;
                if (null == l2 && (u2 = false, l2 = o), null == l2)
                  throw new Error("Must supply either a local or global palette.");
                for (var c2 = s(l2), d2 = 0; c2 >>= 1; )
                  ++d2;
                c2 = 1 << d2;
                var m = void 0 === f2.delay ? 0 : f2.delay, g = void 0 === f2.disposal ? 0 : f2.disposal;
                if (g < 0 || g > 3)
                  throw new Error("Disposal out of range.");
                var b = false, _ = 0;
                if (void 0 !== f2.transparent && null !== f2.transparent && (b = true, (_ = f2.transparent) < 0 || _ >= c2))
                  throw new Error("Transparent color index.");
                if ((0 !== g || b || 0 !== m) && (t2[n++] = 33, t2[n++] = 249, t2[n++] = 4, t2[n++] = g << 2 | (true === b ? 1 : 0), t2[n++] = 255 & m, t2[n++] = m >> 8 & 255, t2[n++] = _, t2[n++] = 0), t2[n++] = 44, t2[n++] = 255 & e3, t2[n++] = e3 >> 8 & 255, t2[n++] = 255 & r3, t2[n++] = r3 >> 8 & 255, t2[n++] = 255 & i2, t2[n++] = i2 >> 8 & 255, t2[n++] = 255 & a2, t2[n++] = a2 >> 8 & 255, t2[n++] = true === u2 ? 128 | d2 - 1 : 0, true === u2)
                  for (var y = 0, w = l2.length; y < w; ++y) {
                    var v = l2[y];
                    t2[n++] = v >> 16 & 255, t2[n++] = v >> 8 & 255, t2[n++] = 255 & v;
                  }
                return n = function(t3, e4, r4, i3) {
                  t3[e4++] = r4;
                  var n2 = e4++, a3 = 1 << r4, o2 = a3 - 1, s2 = a3 + 1, h3 = s2 + 1, f3 = r4 + 1, u3 = 0, l3 = 0;
                  function c3(r5) {
                    for (; u3 >= r5; )
                      t3[e4++] = 255 & l3, l3 >>= 8, u3 -= 8, e4 === n2 + 256 && (t3[n2] = 255, n2 = e4++);
                  }
                  function d3(t4) {
                    l3 |= t4 << u3, u3 += f3, c3(8);
                  }
                  var p2 = i3[0] & o2, m2 = {};
                  d3(a3);
                  for (var g2 = 1, b2 = i3.length; g2 < b2; ++g2) {
                    var _2 = i3[g2] & o2, y2 = p2 << 8 | _2, w2 = m2[y2];
                    if (void 0 === w2) {
                      for (l3 |= p2 << u3, u3 += f3; u3 >= 8; )
                        t3[e4++] = 255 & l3, l3 >>= 8, u3 -= 8, e4 === n2 + 256 && (t3[n2] = 255, n2 = e4++);
                      4096 === h3 ? (d3(a3), h3 = s2 + 1, f3 = r4 + 1, m2 = {}) : (h3 >= 1 << f3 && ++f3, m2[y2] = h3++), p2 = _2;
                    } else
                      p2 = w2;
                  }
                  return d3(p2), d3(s2), c3(1), n2 + 1 === e4 ? t3[n2] = 0 : (t3[n2] = e4 - n2 - 1, t3[e4++] = 0), e4;
                }(t2, n, d2 < 2 ? 2 : d2, h2), n;
              }, this.end = function() {
                return false === p && (t2[n++] = 59, p = true), n;
              }, this.getOutputBuffer = function() {
                return t2;
              }, this.setOutputBuffer = function(e3) {
                t2 = e3;
              }, this.getOutputBufferPosition = function() {
                return n;
              }, this.setOutputBufferPosition = function(t3) {
                n = t3;
              };
            }, e.GifReader = function(t2) {
              var e2 = 0;
              if (71 !== t2[e2++] || 73 !== t2[e2++] || 70 !== t2[e2++] || 56 !== t2[e2++] || 56 != (t2[e2++] + 1 & 253) || 97 !== t2[e2++])
                throw new Error("Invalid GIF 87a/89a header.");
              var i = t2[e2++] | t2[e2++] << 8, n = t2[e2++] | t2[e2++] << 8, a = t2[e2++], o = a >> 7, s = 1 << 1 + (7 & a);
              t2[e2++], t2[e2++];
              var h = null, f = null;
              o && (h = e2, f = s, e2 += 3 * s);
              var u = true, l = [], c = 0, d = null, p = 0, m = null;
              for (this.width = i, this.height = n; u && e2 < t2.length; )
                switch (t2[e2++]) {
                  case 33:
                    switch (t2[e2++]) {
                      case 255:
                        if (11 !== t2[e2] || 78 == t2[e2 + 1] && 69 == t2[e2 + 2] && 84 == t2[e2 + 3] && 83 == t2[e2 + 4] && 67 == t2[e2 + 5] && 65 == t2[e2 + 6] && 80 == t2[e2 + 7] && 69 == t2[e2 + 8] && 50 == t2[e2 + 9] && 46 == t2[e2 + 10] && 48 == t2[e2 + 11] && 3 == t2[e2 + 12] && 1 == t2[e2 + 13] && 0 == t2[e2 + 16])
                          e2 += 14, m = t2[e2++] | t2[e2++] << 8, e2++;
                        else
                          for (e2 += 12; ; ) {
                            if (!((I = t2[e2++]) >= 0))
                              throw Error("Invalid block size");
                            if (0 === I)
                              break;
                            e2 += I;
                          }
                        break;
                      case 249:
                        if (4 !== t2[e2++] || 0 !== t2[e2 + 4])
                          throw new Error("Invalid graphics extension block.");
                        var g = t2[e2++];
                        c = t2[e2++] | t2[e2++] << 8, d = t2[e2++], 0 == (1 & g) && (d = null), p = g >> 2 & 7, e2++;
                        break;
                      case 254:
                        for (; ; ) {
                          if (!((I = t2[e2++]) >= 0))
                            throw Error("Invalid block size");
                          if (0 === I)
                            break;
                          e2 += I;
                        }
                        break;
                      default:
                        throw new Error("Unknown graphic control label: 0x" + t2[e2 - 1].toString(16));
                    }
                    break;
                  case 44:
                    var b = t2[e2++] | t2[e2++] << 8, _ = t2[e2++] | t2[e2++] << 8, y = t2[e2++] | t2[e2++] << 8, w = t2[e2++] | t2[e2++] << 8, v = t2[e2++], x = v >> 6 & 1, E = 1 << 1 + (7 & v), k = h, S = f, M = false;
                    v >> 7 && (M = true, k = e2, S = E, e2 += 3 * E);
                    var A = e2;
                    for (e2++; ; ) {
                      var I;
                      if (!((I = t2[e2++]) >= 0))
                        throw Error("Invalid block size");
                      if (0 === I)
                        break;
                      e2 += I;
                    }
                    l.push({ x: b, y: _, width: y, height: w, has_local_palette: M, palette_offset: k, palette_size: S, data_offset: A, data_length: e2 - A, transparent_index: d, interlaced: !!x, delay: c, disposal: p });
                    break;
                  case 59:
                    u = false;
                    break;
                  default:
                    throw new Error("Unknown gif block: 0x" + t2[e2 - 1].toString(16));
                }
              this.numFrames = function() {
                return l.length;
              }, this.loopCount = function() {
                return m;
              }, this.frameInfo = function(t3) {
                if (t3 < 0 || t3 >= l.length)
                  throw new Error("Frame index out of range.");
                return l[t3];
              }, this.decodeAndBlitFrameBGRA = function(e3, n2) {
                var a2 = this.frameInfo(e3), o2 = a2.width * a2.height, s2 = new Uint8Array(o2);
                r(t2, a2.data_offset, s2, o2);
                var h2 = a2.palette_offset, f2 = a2.transparent_index;
                null === f2 && (f2 = 256);
                var u2 = a2.width, l2 = i - u2, c2 = u2, d2 = 4 * (a2.y * i + a2.x), p2 = 4 * ((a2.y + a2.height) * i + a2.x), m2 = d2, g2 = 4 * l2;
                true === a2.interlaced && (g2 += 4 * i * 7);
                for (var b2 = 8, _2 = 0, y2 = s2.length; _2 < y2; ++_2) {
                  var w2 = s2[_2];
                  if (0 === c2 && (c2 = u2, (m2 += g2) >= p2 && (g2 = 4 * l2 + 4 * i * (b2 - 1), m2 = d2 + (u2 + l2) * (b2 << 1), b2 >>= 1)), w2 === f2)
                    m2 += 4;
                  else {
                    var v2 = t2[h2 + 3 * w2], x2 = t2[h2 + 3 * w2 + 1], E2 = t2[h2 + 3 * w2 + 2];
                    n2[m2++] = E2, n2[m2++] = x2, n2[m2++] = v2, n2[m2++] = 255;
                  }
                  --c2;
                }
              }, this.decodeAndBlitFrameRGBA = function(e3, n2) {
                var a2 = this.frameInfo(e3), o2 = a2.width * a2.height, s2 = new Uint8Array(o2);
                r(t2, a2.data_offset, s2, o2);
                var h2 = a2.palette_offset, f2 = a2.transparent_index;
                null === f2 && (f2 = 256);
                var u2 = a2.width, l2 = i - u2, c2 = u2, d2 = 4 * (a2.y * i + a2.x), p2 = 4 * ((a2.y + a2.height) * i + a2.x), m2 = d2, g2 = 4 * l2;
                true === a2.interlaced && (g2 += 4 * i * 7);
                for (var b2 = 8, _2 = 0, y2 = s2.length; _2 < y2; ++_2) {
                  var w2 = s2[_2];
                  if (0 === c2 && (c2 = u2, (m2 += g2) >= p2 && (g2 = 4 * l2 + 4 * i * (b2 - 1), m2 = d2 + (u2 + l2) * (b2 << 1), b2 >>= 1)), w2 === f2)
                    m2 += 4;
                  else {
                    var v2 = t2[h2 + 3 * w2], x2 = t2[h2 + 3 * w2 + 1], E2 = t2[h2 + 3 * w2 + 2];
                    n2[m2++] = v2, n2[m2++] = x2, n2[m2++] = E2, n2[m2++] = 255;
                  }
                  --c2;
                }
              };
            };
          } catch (t2) {
          }
        }, 7604: (t, e, r) => {
          "use strict";
          var i = r(8834).lW;
          class n {
            constructor(...t2) {
              if (0 === t2.length)
                throw new Error("constructor requires parameters");
              const e2 = t2[0];
              if (null !== e2 && "object" == typeof e2)
                if (e2 instanceof n) {
                  const t3 = e2.bitmap;
                  this.bitmap = { width: t3.width, height: t3.height, data: new i(t3.width * t3.height * 4) }, t3.data.copy(this.bitmap.data);
                } else {
                  if (!(e2.width && e2.height && e2.data))
                    throw new Error("unrecognized constructor parameters");
                  this.bitmap = e2;
                }
              else {
                if ("number" != typeof e2 || "number" != typeof t2[1])
                  throw new Error("unrecognized constructor parameters");
                {
                  const r2 = e2, n2 = t2[1], a = t2[2];
                  this.bitmap = { width: r2, height: n2 }, i.isBuffer(a) ? this.bitmap.data = a : (this.bitmap.data = new i(r2 * n2 * 4), "number" == typeof a && this.fillRGBA(a));
                }
              }
            }
            blit(t2, e2, r2, i2, n2, a, o) {
              if (i2 + a > this.bitmap.width)
                throw new Error("copy exceeds width of source bitmap");
              if (e2 + a > t2.bitmap.width)
                throw new Error("copy exceeds width of target bitmap");
              if (n2 + o > this.bitmap.height)
                throw new Error("copy exceeds height of source bitmap");
              if (r2 + o > t2.bitmap.height)
                throw new Erro("copy exceeds height of target bitmap");
              const s = this.bitmap.data, h = t2.bitmap.data, f = 4 * this.bitmap.width, u = 4 * t2.bitmap.width, l = 4 * a;
              let c = n2 * f + 4 * i2, d = r2 * u + 4 * e2;
              for (; --o >= 0; )
                s.copy(h, d, c, c + l), c += f, d += u;
              return this;
            }
            fillRGBA(t2) {
              const e2 = this.bitmap.data, r2 = 4 * this.bitmap.height;
              let i2 = 0;
              for (; i2 < r2; )
                e2.writeUInt32BE(t2, i2), i2 += 4;
              for (; i2 < e2.length; )
                e2.copy(e2, i2, 0, r2), i2 += r2;
              return this;
            }
            getRGBA(t2, e2) {
              const r2 = 4 * (e2 * this.bitmap.width + t2);
              return this.bitmap.data.readUInt32BE(r2);
            }
            getRGBASet() {
              const t2 = /* @__PURE__ */ new Set(), e2 = this.bitmap.data;
              for (let r2 = 0; r2 < e2.length; r2 += 4)
                t2.add(e2.readUInt32BE(r2, true));
              return t2;
            }
            greyscale() {
              const t2 = this.bitmap.data;
              return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (e2, r2, i2) => {
                const n2 = Math.round(0.299 * t2[i2] + 0.587 * t2[i2 + 1] + 0.114 * t2[i2 + 2]);
                t2[i2] = n2, t2[i2 + 1] = n2, t2[i2 + 2] = n2;
              }), this;
            }
            reframe(t2, e2, r2, i2, a) {
              const o = t2 < 0 ? 0 : t2, s = e2 < 0 ? 0 : e2, h = r2 + o > this.bitmap.width ? this.bitmap.width - o : r2, f = i2 + s > this.bitmap.height ? this.bitmap.height - s : i2, u = t2 < 0 ? -t2 : 0, l = e2 < 0 ? -e2 : 0;
              let c;
              if (void 0 === a) {
                if (o !== t2 || s != e2 || h !== r2 || f !== i2)
                  throw new GifError("fillRGBA required for this reframing");
                c = new n(r2, i2);
              } else
                c = new n(r2, i2, a);
              return this.blit(c, u, l, o, s, h, f), this.bitmap = c.bitmap, this;
            }
            scale(t2) {
              if (1 === t2)
                return;
              if (!Number.isInteger(t2) || t2 < 1)
                throw new Error("the scale must be an integer >= 1");
              const e2 = this.bitmap.width, r2 = this.bitmap.height, n2 = e2 * t2 * 4, a = this.bitmap.data, o = new i(r2 * n2 * t2);
              let s, h = 0, f = 0;
              for (let i2 = 0; i2 < r2; ++i2) {
                s = f;
                for (let r3 = 0; r3 < e2; ++r3) {
                  const e3 = a.readUInt32BE(h, true);
                  for (let r4 = 0; r4 < t2; ++r4)
                    o.writeUInt32BE(e3, f), f += 4;
                  h += 4;
                }
                for (let e3 = 1; e3 < t2; ++e3)
                  o.copy(o, f, s, f), f += n2, s += n2;
              }
              return this.bitmap = { width: e2 * t2, height: r2 * t2, data: o }, this;
            }
            scanAllCoords(t2) {
              const e2 = this.bitmap.width, r2 = this.bitmap.data.length;
              let i2 = 0, n2 = 0;
              for (let a = 0; a < r2; a += 4)
                t2(i2, n2, a), ++i2 === e2 && (i2 = 0, ++n2);
            }
            scanAllIndexes(t2) {
              const e2 = this.bitmap.data.length;
              for (let r2 = 0; r2 < e2; r2 += 4)
                t2(r2);
            }
          }
          t.exports = n;
        }, 4364: (t, e) => {
          "use strict";
          class r {
            constructor(t2, e2, r2) {
              this.width = r2.width, this.height = r2.height, this.loops = r2.loops, this.usesTransparency = r2.usesTransparency, this.colorScope = r2.colorScope, this.frames = e2, this.buffer = t2;
            }
          }
          r.GlobalColorsPreferred = 0, r.GlobalColorsOnly = 1, r.LocalColorsOnly = 2;
          class i extends Error {
            constructor(t2) {
              super(t2), t2 instanceof Error && (this.stack = "Gif" + t2.stack);
            }
          }
          e.Gif = r, e.GifError = i;
        }, 6512: (t, e, r) => {
          "use strict";
          var i = r(4406), n = r(8834).lW;
          const a = r(2855), { Gif: o, GifError: s } = r(4364);
          let h;
          i.nextTick(() => {
            h = r(4602);
          });
          const { GifFrame: f } = r(5585), u = 100;
          function l(t2, e2) {
            const r2 = t2.indexOf(e2);
            return -1 === r2 ? null : r2;
          }
          function c(t2, e2) {
            for (var r2, i2 = 0, n2 = t2.length - 1; i2 <= n2; )
              if (t2[r2 = Math.floor((i2 + n2) / 2)] > e2)
                n2 = r2 - 1;
              else {
                if (!(t2[r2] < e2))
                  return r2;
                i2 = r2 + 1;
              }
            return null;
          }
          function d(t2) {
            const e2 = t2.colors;
            t2.usesTransparency && e2.push(0);
            const r2 = e2.length;
            let i2 = 2;
            for (; r2 > i2; )
              i2 <<= 1;
            e2.length = i2, e2.fill(0, r2);
          }
          function p(t2, e2) {
            let r2 = t2.bitmap.width * t2.bitmap.height;
            return r2 = Math.ceil(r2 * e2 / 8), r2 += Math.ceil(r2 / 255), u + r2 + 768;
          }
          function m(t2) {
            let e2 = t2.indexCount, r2 = 0;
            for (--e2; e2; )
              ++r2, e2 >>= 1;
            return r2 > 0 ? r2 : 1;
          }
          function g(t2, e2, r2, i2, a2) {
            if (r2.interlaced)
              throw new s("writing interlaced GIFs is not supported");
            const o2 = function(t3, e3, r3) {
              const i3 = r3.colors, a3 = i3.length <= 8 ? l : c, o3 = e3.bitmap.data, h3 = new n(o3.length / 4);
              let f2 = i3.length, u2 = 0, d2 = 0;
              for (; u2 < o3.length; ) {
                if (0 !== o3[u2 + 3]) {
                  const t4 = o3.readUInt32BE(u2, true) >> 8 & 16777215;
                  h3[d2] = a3(i3, t4);
                } else
                  h3[d2] = f2;
                u2 += 4, ++d2;
              }
              if (r3.usesTransparency) {
                if (256 === f2)
                  throw new s(`Frame ${t3} already has 256 colorsand so can't use transparency`);
              } else
                f2 = null;
              return { buffer: h3, transparentIndex: f2 };
            }(e2, r2, i2), h2 = { delay: r2.delayCentisecs, disposal: r2.disposalMethod, transparent: o2.transparentIndex };
            a2 && (d(i2), h2.palette = i2.colors);
            try {
              let e3, i3 = t2.getOutputBuffer(), a3 = t2.getOutputBufferPosition(), s2 = true;
              for (; s2; )
                if (e3 = t2.addFrame(r2.xOffset, r2.yOffset, r2.bitmap.width, r2.bitmap.height, o2.buffer, h2), s2 = false, e3 >= i3.length - 1) {
                  const e4 = new n(1.5 * i3.length);
                  i3.copy(e4), t2.setOutputBuffer(e4), t2.setOutputBufferPosition(a3), i3 = e4, s2 = true;
                }
              return i3;
            } catch (t3) {
              throw new s(t3);
            }
          }
          e.GifCodec = class {
            constructor(t2 = {}) {
              this._transparentRGB = null, "number" == typeof t2.transparentRGB && 0 !== t2.transparentRGB && (this._transparentRGBA = 256 * t2.transparentRGB), this._testInitialBufferSize = 0;
            }
            decodeGif(t2) {
              try {
                let e2;
                try {
                  e2 = new a.GifReader(t2);
                } catch (t3) {
                  throw new s(t3);
                }
                const r2 = e2.numFrames(), i2 = [], n2 = { width: e2.width, height: e2.height, loops: e2.loopCount(), usesTransparency: false };
                for (let t3 = 0; t3 < r2; ++t3) {
                  const r3 = this._decodeFrame(e2, t3, n2.usesTransparency);
                  i2.push(r3.frame), r3.usesTransparency && (n2.usesTransparency = true);
                }
                return Promise.resolve(new o(t2, i2, n2));
              } catch (t3) {
                return Promise.reject(t3);
              }
            }
            encodeGif(t2, e2 = {}) {
              try {
                if (null === t2 || 0 === t2.length)
                  throw new s("there are no frames");
                const r2 = h.getMaxDimensions(t2);
                return (e2 = Object.assign({}, e2)).width = r2.maxWidth, e2.height = r2.maxHeight, e2.loops = e2.loops || 0, e2.colorScope = e2.colorScope || o.GlobalColorsPreferred, Promise.resolve(this._encodeGif(t2, e2));
              } catch (t3) {
                return Promise.reject(t3);
              }
            }
            _decodeFrame(t2, e2, r2) {
              let i2, a2;
              try {
                if (i2 = t2.frameInfo(e2), a2 = new n(t2.width * t2.height * 4), t2.decodeAndBlitFrameRGBA(e2, a2), i2.width !== t2.width || i2.height !== t2.height) {
                  if (i2.y && (a2 = a2.slice(i2.y * t2.width * 4)), t2.width > i2.width)
                    for (let e3 = 0; e3 < i2.height; ++e3)
                      a2.copy(a2, e3 * i2.width * 4, 4 * (i2.x + e3 * t2.width), 4 * (i2.x + e3 * t2.width) + 4 * i2.width);
                  a2 = a2.slice(0, i2.width * i2.height * 4);
                }
              } catch (t3) {
                throw new s(t3);
              }
              let o2 = false;
              if (null === this._transparentRGBA) {
                if (!r2)
                  for (let t3 = 3; t3 < a2.length; t3 += 4)
                    0 === a2[t3] && (o2 = true, t3 = a2.length);
              } else
                for (let t3 = 3; t3 < a2.length; t3 += 4)
                  0 === a2[t3] && (a2.writeUInt32BE(this._transparentRGBA, t3 - 3), o2 = true);
              return { frame: new f(i2.width, i2.height, a2, { xOffset: i2.x, yOffset: i2.y, disposalMethod: i2.disposal, interlaced: i2.interlaced, delayCentisecs: i2.delay }), usesTransparency: o2 };
            }
            _encodeGif(t2, e2) {
              let r2;
              if (e2.colorScope === o.LocalColorsOnly)
                r2 = h.getColorInfo(t2, 0);
              else if (r2 = h.getColorInfo(t2, 256), !r2.colors) {
                if (e2.colorScope === o.GlobalColorsOnly)
                  throw new s("Too many color indexes for global color table");
                e2.colorScope = o.LocalColorsOnly;
              }
              e2.usesTransparency = r2.usesTransparency;
              const i2 = r2.palettes;
              return e2.colorScope === o.LocalColorsOnly ? function(t3, e3, r3, i3) {
                const h2 = { loop: e3.loops };
                let f2, u2 = new n(2e3);
                try {
                  f2 = new a.GifWriter(u2, e3.width, e3.height, h2);
                } catch (t4) {
                  throw new s(t4);
                }
                for (let e4 = 0; e4 < t3.length; ++e4)
                  u2 = g(f2, e4, t3[e4], i3[e4], true);
                return new o(u2.slice(0, f2.end()), t3, e3);
              }(t2, e2, 0, i2) : function(t3, e3, r3, i3) {
                const h2 = { colors: i3.colors.slice(), usesTransparency: i3.usesTransparency };
                d(h2);
                const f2 = { palette: h2.colors, loop: e3.loops };
                let u2, l2 = new n(2e3);
                try {
                  u2 = new a.GifWriter(l2, e3.width, e3.height, f2);
                } catch (t4) {
                  throw new s(t4);
                }
                for (let e4 = 0; e4 < t3.length; ++e4)
                  l2 = g(u2, e4, t3[e4], i3, false);
                return new o(l2.slice(0, u2.end()), t3, e3);
              }(t2, e2, 0, r2);
            }
            _getSizeEstimateGlobal(t2, e2) {
              if (this._testInitialBufferSize > 0)
                return this._testInitialBufferSize;
              let r2 = 968;
              const i2 = m(t2);
              return e2.forEach((t3) => {
                r2 += p(t3, i2);
              }), r2;
            }
            _getSizeEstimateLocal(t2, e2) {
              if (this._testInitialBufferSize > 0)
                return this._testInitialBufferSize;
              let r2 = 200;
              for (let i2 = 0; i2 < e2.length; ++i2) {
                const n2 = m(t2[i2]);
                r2 += p(e2[i2], n2);
              }
              return r2;
            }
          };
        }, 5585: (t, e, r) => {
          "use strict";
          const i = r(7604), { GifError: n } = r(4364);
          class a extends i {
            constructor(...t2) {
              if (super(...t2), t2[0] instanceof a) {
                const e2 = t2[0];
                this.xOffset = e2.xOffset, this.yOffset = e2.yOffset, this.disposalMethod = e2.disposalMethod, this.delayCentisecs = e2.delayCentisecs, this.interlaced = e2.interlaced;
              } else {
                const e2 = t2[t2.length - 1];
                let r2 = {};
                "object" != typeof e2 || e2 instanceof i || (r2 = e2), this.xOffset = r2.xOffset || 0, this.yOffset = r2.yOffset || 0, this.disposalMethod = void 0 !== r2.disposalMethod ? r2.disposalMethod : a.DisposeToBackgroundColor, this.delayCentisecs = r2.delayCentisecs || 8, this.interlaced = r2.interlaced || false;
              }
            }
            getPalette() {
              const t2 = /* @__PURE__ */ new Set(), e2 = this.bitmap.data;
              let r2 = 0, i2 = false;
              for (; r2 < e2.length; ) {
                if (0 === e2[r2 + 3])
                  i2 = true;
                else {
                  const i3 = e2.readUInt32BE(r2, true) >> 8 & 16777215;
                  t2.add(i3);
                }
                r2 += 4;
              }
              const n2 = new Array(t2.size), a2 = t2.values();
              for (r2 = 0; r2 < n2.length; ++r2)
                n2[r2] = a2.next().value;
              n2.sort((t3, e3) => t3 - e3);
              let o = n2.length;
              return i2 && ++o, { colors: n2, usesTransparency: i2, indexCount: o };
            }
          }
          a.DisposeToAnything = 0, a.DisposeNothing = 1, a.DisposeToBackgroundColor = 2, a.DisposeToPrevious = 3, e.GifFrame = a;
        }, 4602: (t, e, r) => {
          "use strict";
          var i = r(8834).lW;
          const n = r(8522), a = r(443), o = r(7604), { GifFrame: s } = r(5585), { GifError: h } = r(4364), { GifCodec: f } = r(6512), u = [".jpg", ".jpeg", ".png", ".bmp"], l = new f();
          function c(t2, e2, r2, i2, n2) {
            const o2 = Array.isArray(t2) ? t2 : [t2];
            if (n2) {
              if (["FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite"].indexOf(n2.ditherAlgorithm) < 0)
                throw new Error(`Invalid ditherAlgorithm '${n2.ditherAlgorithm}'`);
              void 0 === n2.serpentine && (n2.serpentine = true), void 0 === n2.minimumColorDistanceToDither && (n2.minimumColorDistanceToDither = 0), void 0 === n2.calculateErrorLikeGIMP && (n2.calculateErrorLikeGIMP = false);
            }
            const s2 = new a.distance.Euclidean(), h2 = new a.palette[e2](s2, r2, i2);
            let f2;
            f2 = n2 ? new a.image.ErrorDiffusionArray(s2, a.image.ErrorDiffusionArrayKernel[n2.ditherAlgorithm], n2.serpentine, n2.minimumColorDistanceToDither, n2.calculateErrorLikeGIMP) : new a.image.NearestColor(s2);
            const u2 = [];
            o2.forEach((t3) => {
              const e3 = t3.bitmap.data, r3 = new ArrayBuffer(e3.length), i3 = new Uint32Array(r3);
              for (let t4 = 0, r4 = 0; t4 < e3.length; t4 += 4, ++r4)
                i3[r4] = e3.readUInt32LE(t4, true);
              const n3 = a.utils.PointContainer.fromUint32Array(i3, t3.bitmap.width, t3.bitmap.height);
              h2.sample(n3), u2.push(n3);
            });
            const l2 = h2.quantize();
            for (let t3 = 0; t3 < o2.length; ++t3) {
              const e3 = o2[t3].bitmap.data, r3 = f2.quantize(u2[t3], l2).toUint32Array();
              for (let t4 = 0, i3 = 0; t4 < e3.length; t4 += 4, ++i3)
                e3.writeUInt32LE(r3[i3], t4);
            }
          }
          e.cloneFrames = function(t2) {
            let e2 = [];
            return t2.forEach((t3) => {
              e2.push(new s(t3));
            }), e2;
          }, e.getColorInfo = function(t2, e2) {
            let r2 = false;
            const i2 = [];
            for (let e3 = 0; e3 < t2.length; ++e3) {
              let n3 = t2[e3].getPalette();
              if (n3.usesTransparency && (r2 = true), n3.indexCount > 256)
                throw new h(`Frame ${e3} uses more than 256 color indexes`);
              i2.push(n3);
            }
            if (0 === e2)
              return { usesTransparency: r2, palettes: i2 };
            const n2 = /* @__PURE__ */ new Set();
            i2.forEach((t3) => {
              t3.colors.forEach((t4) => {
                n2.add(t4);
              });
            });
            let a2 = n2.size;
            if (r2 && ++a2, e2 && a2 > e2)
              return { usesTransparency: r2, palettes: i2 };
            const o2 = new Array(n2.size), s2 = n2.values();
            for (let t3 = 0; t3 < o2.length; ++t3)
              o2[t3] = s2.next().value;
            return o2.sort((t3, e3) => t3 - e3), { colors: o2, indexCount: a2, usesTransparency: r2, palettes: i2 };
          }, e.copyAsJimp = function(t2, r2) {
            return e.shareAsJimp(t2, new o(r2));
          }, e.getMaxDimensions = function(t2) {
            let e2 = 0, r2 = 0;
            return t2.forEach((t3) => {
              const i2 = t3.xOffset + t3.bitmap.width;
              i2 > e2 && (e2 = i2);
              const n2 = t3.yOffset + t3.bitmap.height;
              n2 > r2 && (r2 = n2);
            }), { maxWidth: e2, maxHeight: r2 };
          }, e.quantizeDekker = function(t2, e2, r2) {
            c(t2, "NeuQuantFloat", e2 = e2 || 256, 0, r2);
          }, e.quantizeSorokin = function(t2, e2, r2, i2) {
            let n2;
            switch (e2 = e2 || 256, r2 = r2 || "min-pop") {
              case "min-pop":
                n2 = 2;
                break;
              case "top-pop":
                n2 = 1;
                break;
              default:
                throw new Error(`Invalid quantizeSorokin histogram '${r2}'`);
            }
            c(t2, "RGBQuant", e2, n2, i2);
          }, e.quantizeWu = function(t2, e2, r2, i2) {
            if (e2 = e2 || 256, (r2 = r2 || 5) < 1 || r2 > 8)
              throw new Error("Invalid quantization quality");
            c(t2, "WuQuant", e2, r2, i2);
          }, e.read = function(t2, e2) {
            return e2 = e2 || l, i.isBuffer(t2) ? e2.decodeGif(t2) : (r2 = t2, new Promise((t3, e3) => {
              n.readFile(r2, (r3, i2) => r3 ? e3(r3) : t3(i2));
            })).then((t3) => e2.decodeGif(t3));
            var r2;
          }, e.shareAsJimp = function(t2, e2) {
            const r2 = new t2(e2.bitmap.width, e2.bitmap.height, 0);
            return r2.bitmap.data = e2.bitmap.data, r2;
          }, e.write = function(t2, e2, r2, i2) {
            i2 = i2 || l;
            const a2 = t2.match(/\.[a-zA-Z]+$/);
            if (null !== a2 && u.includes(a2[0].toLowerCase()))
              throw new Error(`GIF '${t2}' has an unexpected suffix`);
            return i2.encodeGif(e2, r2).then((e3) => function(t3, e4) {
              return new Promise((r3, i3) => {
                n.writeFile(t3, e4, (t4) => t4 ? i3(t4) : r3());
              });
            }(t2, e3.buffer).then(() => e3));
          };
        }, 9455: (t, e, r) => {
          "use strict";
          const i = r(7604), { Gif: n, GifError: a } = r(4364), { GifCodec: o } = r(6512), { GifFrame: s } = r(5585), h = r(4602);
          t.exports = { BitmapImage: i, Gif: n, GifCodec: o, GifFrame: s, GifUtil: h, GifError: a };
        }, 5048: (t, e, r) => {
          var i;
          i = "undefined" != typeof window ? window : void 0 !== r.g ? r.g : "undefined" != typeof self ? self : {}, t.exports = i;
        }, 2333: (t, e) => {
          e.read = function(t2, e2, r, i, n) {
            var a, o, s = 8 * n - i - 1, h = (1 << s) - 1, f = h >> 1, u = -7, l = r ? n - 1 : 0, c = r ? -1 : 1, d = t2[e2 + l];
            for (l += c, a = d & (1 << -u) - 1, d >>= -u, u += s; u > 0; a = 256 * a + t2[e2 + l], l += c, u -= 8)
              ;
            for (o = a & (1 << -u) - 1, a >>= -u, u += i; u > 0; o = 256 * o + t2[e2 + l], l += c, u -= 8)
              ;
            if (0 === a)
              a = 1 - f;
            else {
              if (a === h)
                return o ? NaN : 1 / 0 * (d ? -1 : 1);
              o += Math.pow(2, i), a -= f;
            }
            return (d ? -1 : 1) * o * Math.pow(2, a - i);
          }, e.write = function(t2, e2, r, i, n, a) {
            var o, s, h, f = 8 * a - n - 1, u = (1 << f) - 1, l = u >> 1, c = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = i ? 0 : a - 1, p = i ? 1 : -1, m = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
            for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (s = isNaN(e2) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e2) / Math.LN2), e2 * (h = Math.pow(2, -o)) < 1 && (o--, h *= 2), (e2 += o + l >= 1 ? c / h : c * Math.pow(2, 1 - l)) * h >= 2 && (o++, h /= 2), o + l >= u ? (s = 0, o = u) : o + l >= 1 ? (s = (e2 * h - 1) * Math.pow(2, n), o += l) : (s = e2 * Math.pow(2, l - 1) * Math.pow(2, n), o = 0)); n >= 8; t2[r + d] = 255 & s, d += p, s /= 256, n -= 8)
              ;
            for (o = o << n | s, f += n; f > 0; t2[r + d] = 255 & o, d += p, o /= 256, f -= 8)
              ;
            t2[r + d - p] |= 128 * m;
          };
        }, 443: function(t) {
          var e;
          e = function() {
            return function(t2) {
              var e2 = {};
              function r(i) {
                if (e2[i])
                  return e2[i].exports;
                var n = e2[i] = { exports: {}, id: i, loaded: false };
                return t2[i].call(n.exports, n, n.exports, r), n.loaded = true, n.exports;
              }
              return r.m = t2, r.c = e2, r.p = "", r(0);
            }([function(t2, e2, r) {
              "use strict";
              var i = r(1);
              e2.constants = i;
              var n = r(3);
              e2.conversion = n;
              var a = r(12);
              e2.distance = a;
              var o = r(20);
              e2.palette = o;
              var s = r(30);
              e2.image = s;
              var h = r(35);
              e2.quality = h;
              var f = r(37);
              e2.utils = f;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(2);
              e2.bt709 = i;
            }, function(t2, e2) {
              "use strict";
              var r, i, n;
              !function(t3) {
                t3[t3.RED = 0.2126] = "RED", t3[t3.GREEN = 0.7152] = "GREEN", t3[t3.BLUE = 0.0722] = "BLUE", t3[t3.WHITE = 1] = "WHITE";
              }(r || (r = {})), e2.Y = r, function(t3) {
                t3[t3.RED = 0.64] = "RED", t3[t3.GREEN = 0.3] = "GREEN", t3[t3.BLUE = 0.15] = "BLUE", t3[t3.WHITE = 0.3127] = "WHITE";
              }(i || (i = {})), e2.x = i, function(t3) {
                t3[t3.RED = 0.33] = "RED", t3[t3.GREEN = 0.6] = "GREEN", t3[t3.BLUE = 0.06] = "BLUE", t3[t3.WHITE = 0.329] = "WHITE";
              }(n || (n = {})), e2.y = n;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(4);
              e2.rgb2xyz = i.rgb2xyz;
              var n = r(5);
              e2.rgb2hsl = n.rgb2hsl;
              var a = r(7);
              e2.rgb2lab = a.rgb2lab;
              var o = r(9);
              e2.lab2xyz = o.lab2xyz;
              var s = r(10);
              e2.lab2rgb = s.lab2rgb;
              var h = r(8);
              e2.xyz2lab = h.xyz2lab;
              var f = r(11);
              e2.xyz2rgb = f.xyz2rgb;
            }, function(t2, e2) {
              "use strict";
              function r(t3) {
                return t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92;
              }
              e2.rgb2xyz = function(t3, e3, i) {
                return { x: 0.4124 * (t3 = r(t3 / 255)) + 0.3576 * (e3 = r(e3 / 255)) + 0.1805 * (i = r(i / 255)), y: 0.2126 * t3 + 0.7152 * e3 + 0.0722 * i, z: 0.0193 * t3 + 0.1192 * e3 + 0.9505 * i };
              };
            }, function(t2, e2, r) {
              "use strict";
              var i = r(6);
              e2.rgb2hsl = function(t3, e3, r2) {
                var n = i.min3(t3, e3, r2), a = i.max3(t3, e3, r2), o = a - n, s = (n + a) / 510, h = 0;
                s > 0 && s < 1 && (h = o / (s < 0.5 ? a + n : 510 - a - n));
                var f = 0;
                return o > 0 && (f = a === t3 ? (e3 - r2) / o : a === e3 ? 2 + (r2 - t3) / o : 4 + (t3 - e3) / o, (f *= 60) < 0 && (f += 360)), { h: f, s: h, l: s };
              };
            }, function(t2, e2) {
              "use strict";
              e2.degrees2radians = function(t3) {
                return t3 * (Math.PI / 180);
              }, e2.max3 = function(t3, e3, r) {
                var i = t3;
                return i < e3 && (i = e3), i < r && (i = r), i;
              }, e2.min3 = function(t3, e3, r) {
                var i = t3;
                return i > e3 && (i = e3), i > r && (i = r), i;
              }, e2.intInRange = function(t3, e3, r) {
                return t3 > r && (t3 = r), t3 < e3 && (t3 = e3), 0 | t3;
              }, e2.inRange0to255Rounded = function(t3) {
                return (t3 = Math.round(t3)) > 255 ? t3 = 255 : t3 < 0 && (t3 = 0), t3;
              }, e2.inRange0to255 = function(t3) {
                return t3 > 255 ? t3 = 255 : t3 < 0 && (t3 = 0), t3;
              }, e2.stableSort = function(t3, e3) {
                var r, i = typeof t3[0];
                if ("number" === i || "string" === i) {
                  for (var n = /* @__PURE__ */ Object.create(null), a = 0, o = t3.length; a < o; a++) {
                    var s = t3[a];
                    n[s] || 0 === n[s] || (n[s] = a);
                  }
                  r = t3.sort(function(t4, r2) {
                    return e3(t4, r2) || n[t4] - n[r2];
                  });
                } else {
                  var h = t3.slice(0);
                  r = t3.sort(function(t4, r2) {
                    return e3(t4, r2) || h.indexOf(t4) - h.indexOf(r2);
                  });
                }
                return r;
              };
            }, function(t2, e2, r) {
              "use strict";
              var i = r(4), n = r(8);
              e2.rgb2lab = function(t3, e3, r2) {
                var a = i.rgb2xyz(t3, e3, r2);
                return n.xyz2lab(a.x, a.y, a.z);
              };
            }, function(t2, e2) {
              "use strict";
              function r(t3) {
                return t3 > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116;
              }
              e2.xyz2lab = function(t3, e3, i) {
                if (t3 = r(t3 / 0.95047), e3 = r(e3 / 1), i = r(i / 1.08883), 116 * e3 - 16 < 0)
                  throw new Error("xxx");
                return { L: Math.max(0, 116 * e3 - 16), a: 500 * (t3 - e3), b: 200 * (e3 - i) };
              };
            }, function(t2, e2) {
              "use strict";
              function r(t3) {
                return t3 > 0.206893034 ? Math.pow(t3, 3) : (t3 - 16 / 116) / 7.787;
              }
              e2.lab2xyz = function(t3, e3, i) {
                var n = (t3 + 16) / 116, a = n - i / 200;
                return { x: 0.95047 * r(e3 / 500 + n), y: 1 * r(n), z: 1.08883 * r(a) };
              };
            }, function(t2, e2, r) {
              "use strict";
              var i = r(9), n = r(11);
              e2.lab2rgb = function(t3, e3, r2) {
                var a = i.lab2xyz(t3, e3, r2);
                return n.xyz2rgb(a.x, a.y, a.z);
              };
            }, function(t2, e2, r) {
              "use strict";
              var i = r(6);
              function n(t3) {
                return t3 > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3;
              }
              e2.xyz2rgb = function(t3, e3, r2) {
                var a = n(3.2406 * t3 + -1.5372 * e3 + -0.4986 * r2), o = n(-0.9689 * t3 + 1.8758 * e3 + 0.0415 * r2), s = n(0.0557 * t3 + -0.204 * e3 + 1.057 * r2);
                return { r: i.inRange0to255Rounded(255 * a), g: i.inRange0to255Rounded(255 * o), b: i.inRange0to255Rounded(255 * s) };
              };
            }, function(t2, e2, r) {
              "use strict";
              var i = r(13);
              e2.AbstractDistanceCalculator = i.AbstractDistanceCalculator;
              var n = r(14);
              e2.CIE94Textiles = n.CIE94Textiles, e2.CIE94GraphicArts = n.CIE94GraphicArts;
              var a = r(15);
              e2.CIEDE2000 = a.CIEDE2000;
              var o = r(16);
              e2.CMETRIC = o.CMETRIC;
              var s = r(17);
              e2.AbstractEuclidean = s.AbstractEuclidean, e2.Euclidean = s.Euclidean, e2.EuclideanRgbQuantWOAlpha = s.EuclideanRgbQuantWOAlpha, e2.EuclideanRgbQuantWithAlpha = s.EuclideanRgbQuantWithAlpha;
              var h = r(18);
              e2.AbstractManhattan = h.AbstractManhattan, e2.Manhattan = h.Manhattan, e2.ManhattanSRGB = h.ManhattanSRGB, e2.ManhattanNommyde = h.ManhattanNommyde;
              var f = r(19);
              e2.PNGQUANT = f.PNGQUANT;
            }, function(t2, e2) {
              "use strict";
              var r = function() {
                function t3() {
                  this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
                }
                return t3.prototype.setWhitePoint = function(t4, e3, r2, i) {
                  this._whitePoint = { r: t4 > 0 ? 255 / t4 : 0, g: e3 > 0 ? 255 / e3 : 0, b: r2 > 0 ? 255 / r2 : 0, a: i > 0 ? 255 / i : 0 }, this._maxDistance = this.calculateRaw(t4, e3, r2, i, 0, 0, 0, 0);
                }, t3.prototype.calculateNormalized = function(t4, e3) {
                  return this.calculateRaw(t4.r, t4.g, t4.b, t4.a, e3.r, e3.g, e3.b, e3.a) / this._maxDistance;
                }, t3.prototype._setDefaults = function() {
                }, t3;
              }();
              e2.AbstractDistanceCalculator = r;
            }, function(t2, e2, r) {
              "use strict";
              var i = this && this.__extends || function(t3, e3) {
                for (var r2 in e3)
                  e3.hasOwnProperty(r2) && (t3[r2] = e3[r2]);
                function i2() {
                  this.constructor = t3;
                }
                t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
              }, n = r(13), a = r(7), o = r(6), s = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype.calculateRaw = function(t4, e4, r2, i2, n2, s2, h2, f2) {
                  var u = a.rgb2lab(o.inRange0to255(t4 * this._whitePoint.r), o.inRange0to255(e4 * this._whitePoint.g), o.inRange0to255(r2 * this._whitePoint.b)), l = a.rgb2lab(o.inRange0to255(n2 * this._whitePoint.r), o.inRange0to255(s2 * this._whitePoint.g), o.inRange0to255(h2 * this._whitePoint.b)), c = u.L - l.L, d = u.a - l.a, p = u.b - l.b, m = Math.sqrt(u.a * u.a + u.b * u.b), g = m - Math.sqrt(l.a * l.a + l.b * l.b), b = d * d + p * p - g * g;
                  b = b < 0 ? 0 : Math.sqrt(b);
                  var _ = (f2 - i2) * this._whitePoint.a * this._kA;
                  return Math.sqrt(Math.pow(c / this._Kl, 2) + Math.pow(g / (1 + this._K1 * m), 2) + Math.pow(b / (1 + this._K2 * m), 2) + Math.pow(_, 2));
                }, e3;
              }(n.AbstractDistanceCalculator);
              e2.AbstractCIE94 = s;
              var h = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype._setDefaults = function() {
                  this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
                }, e3;
              }(s);
              e2.CIE94Textiles = h;
              var f = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype._setDefaults = function() {
                  this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
                }, e3;
              }(s);
              e2.CIE94GraphicArts = f;
            }, function(t2, e2, r) {
              "use strict";
              var i = this && this.__extends || function(t3, e3) {
                for (var r2 in e3)
                  e3.hasOwnProperty(r2) && (t3[r2] = e3[r2]);
                function i2() {
                  this.constructor = t3;
                }
                t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
              }, n = r(13), a = r(7), o = r(6), s = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype.calculateRaw = function(t4, r2, i2, n2, s2, h, f, u) {
                  var l = a.rgb2lab(o.inRange0to255(t4 * this._whitePoint.r), o.inRange0to255(r2 * this._whitePoint.g), o.inRange0to255(i2 * this._whitePoint.b)), c = a.rgb2lab(o.inRange0to255(s2 * this._whitePoint.r), o.inRange0to255(h * this._whitePoint.g), o.inRange0to255(f * this._whitePoint.b)), d = (u - n2) * this._whitePoint.a * e3._kA, p = this.calculateRawInLab(l, c);
                  return Math.sqrt(p + d * d);
                }, e3.prototype.calculateRawInLab = function(t4, r2) {
                  var i2 = t4.L, n2 = t4.a, a2 = t4.b, o2 = r2.L, s2 = r2.a, h = r2.b, f = Math.sqrt(n2 * n2 + a2 * a2), u = Math.sqrt(s2 * s2 + h * h), l = Math.pow((f + u) / 2, 7), c = 0.5 * (1 - Math.sqrt(l / (l + e3._pow25to7))), d = (1 + c) * n2, p = (1 + c) * s2, m = Math.sqrt(d * d + a2 * a2), g = Math.sqrt(p * p + h * h), b = m * g, _ = e3._calculatehp(a2, d), y = e3._calculatehp(h, p), w = Math.abs(_ - y), v = o2 - i2, x = g - m, E = e3._calculate_dHp(b, w, y, _), k = e3._calculate_ahp(b, w, _, y), S = e3._calculateT(k), M = (m + g) / 2, A = Math.pow((i2 + o2) / 2 - 50, 2), I = 1 + 0.015 * A / Math.sqrt(20 + A), T = 1 + 0.045 * M, B = 1 + 0.015 * S * M, R = e3._calculateRT(k, M), P = v / I, O = x / T, L = E / B;
                  return Math.pow(P, 2) + Math.pow(O, 2) + Math.pow(L, 2) + R * O * L;
                }, e3._calculatehp = function(t4, r2) {
                  var i2 = Math.atan2(t4, r2);
                  return i2 >= 0 ? i2 : i2 + e3._deg360InRad;
                }, e3._calculateRT = function(t4, r2) {
                  var i2 = Math.pow(r2, 7), n2 = 2 * Math.sqrt(i2 / (i2 + e3._pow25to7)), a2 = e3._deg30InRad * Math.exp(-Math.pow((t4 - e3._deg275InRad) / e3._deg25InRad, 2));
                  return -Math.sin(2 * a2) * n2;
                }, e3._calculateT = function(t4) {
                  return 1 - 0.17 * Math.cos(t4 - e3._deg30InRad) + 0.24 * Math.cos(2 * t4) + 0.32 * Math.cos(3 * t4 + e3._deg6InRad) - 0.2 * Math.cos(4 * t4 - e3._deg63InRad);
                }, e3._calculate_ahp = function(t4, r2, i2, n2) {
                  var a2 = i2 + n2;
                  return 0 == t4 ? a2 : r2 <= e3._deg180InRad ? a2 / 2 : a2 < e3._deg360InRad ? (a2 + e3._deg360InRad) / 2 : (a2 - e3._deg360InRad) / 2;
                }, e3._calculate_dHp = function(t4, r2, i2, n2) {
                  var a2;
                  return a2 = 0 == t4 ? 0 : r2 <= e3._deg180InRad ? i2 - n2 : i2 <= n2 ? i2 - n2 + e3._deg360InRad : i2 - n2 - e3._deg360InRad, 2 * Math.sqrt(t4) * Math.sin(a2 / 2);
                }, e3._kA = 25 / 255, e3._pow25to7 = Math.pow(25, 7), e3._deg360InRad = o.degrees2radians(360), e3._deg180InRad = o.degrees2radians(180), e3._deg30InRad = o.degrees2radians(30), e3._deg6InRad = o.degrees2radians(6), e3._deg63InRad = o.degrees2radians(63), e3._deg275InRad = o.degrees2radians(275), e3._deg25InRad = o.degrees2radians(25), e3;
              }(n.AbstractDistanceCalculator);
              e2.CIEDE2000 = s;
            }, function(t2, e2, r) {
              "use strict";
              var i = this && this.__extends || function(t3, e3) {
                for (var r2 in e3)
                  e3.hasOwnProperty(r2) && (t3[r2] = e3[r2]);
                function i2() {
                  this.constructor = t3;
                }
                t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
              }, n = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype.calculateRaw = function(t4, e4, r2, i2, n2, a, o, s) {
                  var h = (t4 + n2) / 2 * this._whitePoint.r, f = (t4 - n2) * this._whitePoint.r, u = (e4 - a) * this._whitePoint.g, l = (r2 - o) * this._whitePoint.b, c = ((512 + h) * f * f >> 8) + 4 * u * u + ((767 - h) * l * l >> 8), d = (s - i2) * this._whitePoint.a;
                  return Math.sqrt(c + d * d);
                }, e3;
              }(r(13).AbstractDistanceCalculator);
              e2.CMETRIC = n;
            }, function(t2, e2, r) {
              "use strict";
              var i = this && this.__extends || function(t3, e3) {
                for (var r2 in e3)
                  e3.hasOwnProperty(r2) && (t3[r2] = e3[r2]);
                function i2() {
                  this.constructor = t3;
                }
                t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
              }, n = r(13), a = r(2), o = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype.calculateRaw = function(t4, e4, r2, i2, n2, a2, o2, s2) {
                  var h2 = n2 - t4, f2 = a2 - e4, u = o2 - r2, l = s2 - i2;
                  return Math.sqrt(this._kR * h2 * h2 + this._kG * f2 * f2 + this._kB * u * u + this._kA * l * l);
                }, e3;
              }(n.AbstractDistanceCalculator);
              e2.AbstractEuclidean = o;
              var s = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype._setDefaults = function() {
                  this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                }, e3;
              }(o);
              e2.Euclidean = s;
              var h = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype._setDefaults = function() {
                  this._kR = a.Y.RED, this._kG = a.Y.GREEN, this._kB = a.Y.BLUE, this._kA = 1;
                }, e3;
              }(o);
              e2.EuclideanRgbQuantWithAlpha = h;
              var f = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype._setDefaults = function() {
                  this._kR = a.Y.RED, this._kG = a.Y.GREEN, this._kB = a.Y.BLUE, this._kA = 0;
                }, e3;
              }(o);
              e2.EuclideanRgbQuantWOAlpha = f;
            }, function(t2, e2, r) {
              "use strict";
              var i = this && this.__extends || function(t3, e3) {
                for (var r2 in e3)
                  e3.hasOwnProperty(r2) && (t3[r2] = e3[r2]);
                function i2() {
                  this.constructor = t3;
                }
                t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
              }, n = r(13), a = r(2), o = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype.calculateRaw = function(t4, e4, r2, i2, n2, a2, o2, s2) {
                  var h2 = n2 - t4, f2 = a2 - e4, u = o2 - r2, l = s2 - i2;
                  return h2 < 0 && (h2 = 0 - h2), f2 < 0 && (f2 = 0 - f2), u < 0 && (u = 0 - u), l < 0 && (l = 0 - l), this._kR * h2 + this._kG * f2 + this._kB * u + this._kA * l;
                }, e3;
              }(n.AbstractDistanceCalculator);
              e2.AbstractManhattan = o;
              var s = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype._setDefaults = function() {
                  this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                }, e3;
              }(o);
              e2.Manhattan = s;
              var h = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype._setDefaults = function() {
                  this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
                }, e3;
              }(o);
              e2.ManhattanNommyde = h;
              var f = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype._setDefaults = function() {
                  this._kR = a.Y.RED, this._kG = a.Y.GREEN, this._kB = a.Y.BLUE, this._kA = 1;
                }, e3;
              }(o);
              e2.ManhattanSRGB = f;
            }, function(t2, e2, r) {
              "use strict";
              var i = this && this.__extends || function(t3, e3) {
                for (var r2 in e3)
                  e3.hasOwnProperty(r2) && (t3[r2] = e3[r2]);
                function i2() {
                  this.constructor = t3;
                }
                t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
              }, n = function(t3) {
                function e3() {
                  t3.apply(this, arguments);
                }
                return i(e3, t3), e3.prototype.calculateRaw = function(t4, e4, r2, i2, n2, a, o, s) {
                  var h = (s - i2) * this._whitePoint.a;
                  return this._colordifference_ch(t4 * this._whitePoint.r, n2 * this._whitePoint.r, h) + this._colordifference_ch(e4 * this._whitePoint.g, a * this._whitePoint.g, h) + this._colordifference_ch(r2 * this._whitePoint.b, o * this._whitePoint.b, h);
                }, e3.prototype._colordifference_ch = function(t4, e4, r2) {
                  var i2 = t4 - e4, n2 = i2 + r2;
                  return i2 * i2 + n2 * n2;
                }, e3;
              }(r(13).AbstractDistanceCalculator);
              e2.PNGQUANT = n;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(21);
              e2.NeuQuant = i.NeuQuant;
              var n = r(25);
              e2.NeuQuantFloat = n.NeuQuantFloat;
              var a = r(26);
              e2.RGBQuant = a.RGBQuant;
              var o = r(27);
              e2.ColorHistogram = o.ColorHistogram;
              var s = r(29);
              e2.WuQuant = s.WuQuant, e2.WuColorCube = s.WuColorCube;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(22), n = r(24), a = 3, o = function() {
                function t3(t4) {
                  this.r = this.g = this.b = this.a = t4;
                }
                return t3.prototype.toPoint = function() {
                  return n.Point.createByRGBA(this.r >> a, this.g >> a, this.b >> a, this.a >> a);
                }, t3.prototype.subtract = function(t4, e3, r2, i2) {
                  this.r -= 0 | t4, this.g -= 0 | e3, this.b -= 0 | r2, this.a -= 0 | i2;
                }, t3;
              }(), s = function() {
                function t3(t4, e3) {
                  void 0 === e3 && (e3 = 256), this._distance = t4, this._pointArray = [], this._sampleFactor = 1, this._networkSize = e3, this._distance.setWhitePoint(255 << a, 255 << a, 255 << a, 255 << a);
                }
                return t3.prototype.sample = function(t4) {
                  this._pointArray = this._pointArray.concat(t4.getPointArray());
                }, t3.prototype.quantize = function() {
                  return this._init(), this._learn(), this._buildPalette();
                }, t3.prototype._init = function() {
                  this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                  for (var e3 = 0; e3 < this._networkSize; e3++)
                    this._network[e3] = new o((e3 << a + 8) / this._networkSize | 0), this._freq[e3] = t3._initialBias / this._networkSize | 0, this._bias[e3] = 0;
                }, t3.prototype._learn = function() {
                  var e3 = this._sampleFactor, r2 = this._pointArray.length;
                  r2 < t3._minpicturebytes && (e3 = 1);
                  var i2, n2 = 30 + (e3 - 1) / 3 | 0, o2 = r2 / e3 | 0, s2 = o2 / t3._nCycles | 0, h = t3._initAlpha, f = (this._networkSize >> 3) * t3._radiusBias, u = f >> t3._radiusBiasShift;
                  u <= 1 && (u = 0);
                  for (var l = 0; l < u; l++)
                    this._radPower[l] = h * ((u * u - l * l) * t3._radBias / (u * u)) >>> 0;
                  i2 = r2 < t3._minpicturebytes ? 1 : r2 % t3._prime1 != 0 ? t3._prime1 : r2 % t3._prime2 != 0 ? t3._prime2 : r2 % t3._prime3 != 0 ? t3._prime3 : t3._prime4, l = 0;
                  for (var c = 0; l < o2; ) {
                    var d = this._pointArray[c], p = d.b << a, m = d.g << a, g = d.r << a, b = d.a << a, _ = this._contest(p, m, g, b);
                    if (this._alterSingle(h, _, p, m, g, b), 0 !== u && this._alterNeighbour(u, _, p, m, g, b), (c += i2) >= r2 && (c -= r2), 0 === s2 && (s2 = 1), ++l % s2 == 0) {
                      h -= h / n2 | 0, (u = (f -= f / t3._radiusDecrease | 0) >> t3._radiusBiasShift) <= 1 && (u = 0);
                      for (var y = 0; y < u; y++)
                        this._radPower[y] = h * ((u * u - y * y) * t3._radBias / (u * u)) >>> 0;
                    }
                  }
                }, t3.prototype._buildPalette = function() {
                  var t4 = new i.Palette();
                  return this._network.forEach(function(e3) {
                    t4.add(e3.toPoint());
                  }), t4.sort(), t4;
                }, t3.prototype._alterNeighbour = function(e3, r2, i2, n2, a2, o2) {
                  var s2 = r2 - e3;
                  s2 < -1 && (s2 = -1);
                  var h = r2 + e3;
                  h > this._networkSize && (h = this._networkSize);
                  for (var f = r2 + 1, u = r2 - 1, l = 1; f < h || u > s2; ) {
                    var c, d = this._radPower[l++] / t3._alphaRadBias;
                    f < h && (c = this._network[f++]).subtract(d * (c.r - a2), d * (c.g - n2), d * (c.b - i2), d * (c.a - o2)), u > s2 && (c = this._network[u--]).subtract(d * (c.r - a2), d * (c.g - n2), d * (c.b - i2), d * (c.a - o2));
                  }
                }, t3.prototype._alterSingle = function(e3, r2, i2, n2, a2, o2) {
                  e3 /= t3._initAlpha;
                  var s2 = this._network[r2];
                  s2.subtract(e3 * (s2.r - a2), e3 * (s2.g - n2), e3 * (s2.b - i2), e3 * (s2.a - o2));
                }, t3.prototype._contest = function(e3, r2, i2, n2) {
                  for (var o2 = 1020 << a, s2 = ~(1 << 31), h = s2, f = -1, u = f, l = 0; l < this._networkSize; l++) {
                    var c = this._network[l], d = this._distance.calculateNormalized(c, { r: i2, g: r2, b: e3, a: n2 }) * o2 | 0;
                    d < s2 && (s2 = d, f = l);
                    var p = d - (this._bias[l] >> t3._initialBiasShift - a);
                    p < h && (h = p, u = l);
                    var m = this._freq[l] >> t3._betaShift;
                    this._freq[l] -= m, this._bias[l] += m << t3._gammaShift;
                  }
                  return this._freq[f] += t3._beta, this._bias[f] -= t3._betaGamma, u;
                }, t3._prime1 = 499, t3._prime2 = 491, t3._prime3 = 487, t3._prime4 = 503, t3._minpicturebytes = t3._prime4, t3._nCycles = 100, t3._initialBiasShift = 16, t3._initialBias = 1 << t3._initialBiasShift, t3._gammaShift = 10, t3._betaShift = 10, t3._beta = t3._initialBias >> t3._betaShift, t3._betaGamma = t3._initialBias << t3._gammaShift - t3._betaShift, t3._radiusBiasShift = 6, t3._radiusBias = 1 << t3._radiusBiasShift, t3._radiusDecrease = 30, t3._alphaBiasShift = 10, t3._initAlpha = 1 << t3._alphaBiasShift, t3._radBiasShift = 8, t3._radBias = 1 << t3._radBiasShift, t3._alphaRadBiasShift = t3._alphaBiasShift + t3._radBiasShift, t3._alphaRadBias = 1 << t3._alphaRadBiasShift, t3;
              }();
              e2.NeuQuant = s;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(23), n = r(5);
              function a(t3, e3) {
                for (var r2 = 360 / e3, i2 = 1, n2 = r2 - r2 / 2; i2 < e3; i2++, n2 += r2)
                  if (t3 >= n2 && t3 < n2 + r2)
                    return i2;
                return 0;
              }
              e2.hueGroup = a;
              var o = function() {
                function t3() {
                  this._pointArray = [], this._i32idx = {}, this._pointContainer = new i.PointContainer(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
                }
                return t3.prototype.add = function(t4) {
                  this._pointArray.push(t4), this._pointContainer.setWidth(this._pointArray.length);
                }, t3.prototype.has = function(t4) {
                  for (var e3 = this._pointArray.length - 1; e3 >= 0; e3--)
                    if (t4.uint32 === this._pointArray[e3].uint32)
                      return true;
                  return false;
                }, t3.prototype.getNearestColor = function(t4, e3) {
                  return this._pointArray[0 | this.getNearestIndex(t4, e3)];
                }, t3.prototype.getPointContainer = function() {
                  return this._pointContainer;
                }, t3.prototype._nearestPointFromCache = function(t4) {
                  return "number" == typeof this._i32idx[t4] ? this._i32idx[t4] : -1;
                }, t3.prototype.getNearestIndex = function(t4, e3) {
                  var r2 = this._nearestPointFromCache("" + e3.uint32);
                  if (r2 >= 0)
                    return r2;
                  var i2 = Number.MAX_VALUE;
                  r2 = 0;
                  for (var n2 = 0, a2 = this._pointArray.length; n2 < a2; n2++) {
                    var o2 = this._pointArray[n2], s = t4.calculateRaw(e3.r, e3.g, e3.b, e3.a, o2.r, o2.g, o2.b, o2.a);
                    s < i2 && (i2 = s, r2 = n2);
                  }
                  return this._i32idx[e3.uint32] = r2, r2;
                }, t3.prototype.sort = function() {
                  this._i32idx = {}, this._pointArray.sort(function(t4, e3) {
                    var r2 = n.rgb2hsl(t4.r, t4.g, t4.b), i2 = n.rgb2hsl(e3.r, e3.g, e3.b), o2 = t4.r === t4.g && t4.g === t4.b ? 0 : 1 + a(r2.h, 10), s = (e3.r === e3.g && e3.g === e3.b ? 0 : 1 + a(i2.h, 10)) - o2;
                    if (s)
                      return -s;
                    var h = t4.getLuminosity(true), f = e3.getLuminosity(true);
                    if (f - h != 0)
                      return f - h;
                    var u = (100 * i2.s | 0) - (100 * r2.s | 0);
                    return u ? -u : 0;
                  });
                }, t3;
              }();
              e2.Palette = o;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(24), n = function() {
                function t3() {
                  this._width = 0, this._height = 0, this._pointArray = [];
                }
                return t3.prototype.getWidth = function() {
                  return this._width;
                }, t3.prototype.getHeight = function() {
                  return this._height;
                }, t3.prototype.setWidth = function(t4) {
                  this._width = t4;
                }, t3.prototype.setHeight = function(t4) {
                  this._height = t4;
                }, t3.prototype.getPointArray = function() {
                  return this._pointArray;
                }, t3.prototype.clone = function() {
                  var e3 = new t3();
                  e3._width = this._width, e3._height = this._height;
                  for (var r2 = 0, n2 = this._pointArray.length; r2 < n2; r2++)
                    e3._pointArray[r2] = i.Point.createByUint32(0 | this._pointArray[r2].uint32);
                  return e3;
                }, t3.prototype.toUint32Array = function() {
                  for (var t4 = this._pointArray.length, e3 = new Uint32Array(t4), r2 = 0; r2 < t4; r2++)
                    e3[r2] = this._pointArray[r2].uint32;
                  return e3;
                }, t3.prototype.toUint8Array = function() {
                  return new Uint8Array(this.toUint32Array().buffer);
                }, t3.fromHTMLImageElement = function(e3) {
                  var r2 = e3.naturalWidth, i2 = e3.naturalHeight, n2 = document.createElement("canvas");
                  return n2.width = r2, n2.height = i2, n2.getContext("2d").drawImage(e3, 0, 0, r2, i2, 0, 0, r2, i2), t3.fromHTMLCanvasElement(n2);
                }, t3.fromHTMLCanvasElement = function(e3) {
                  var r2 = e3.width, i2 = e3.height, n2 = e3.getContext("2d").getImageData(0, 0, r2, i2);
                  return t3.fromImageData(n2);
                }, t3.fromNodeCanvas = function(e3) {
                  return t3.fromHTMLCanvasElement(e3);
                }, t3.fromImageData = function(e3) {
                  var r2 = e3.width, i2 = e3.height;
                  return t3.fromCanvasPixelArray(e3.data, r2, i2);
                }, t3.fromArray = function(e3, r2, i2) {
                  var n2 = new Uint8Array(e3);
                  return t3.fromUint8Array(n2, r2, i2);
                }, t3.fromCanvasPixelArray = function(e3, r2, i2) {
                  return t3.fromArray(e3, r2, i2);
                }, t3.fromUint8Array = function(e3, r2, i2) {
                  return t3.fromUint32Array(new Uint32Array(e3.buffer), r2, i2);
                }, t3.fromUint32Array = function(e3, r2, n2) {
                  var a = new t3();
                  a._width = r2, a._height = n2;
                  for (var o = 0, s = e3.length; o < s; o++)
                    a._pointArray[o] = i.Point.createByUint32(0 | e3[o]);
                  return a;
                }, t3;
              }();
              e2.PointContainer = n;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(2), n = function() {
                function t3() {
                  this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
                }
                return t3.createByQuadruplet = function(e3) {
                  var r2 = new t3();
                  return r2.r = 0 | e3[0], r2.g = 0 | e3[1], r2.b = 0 | e3[2], r2.a = 0 | e3[3], r2._loadUINT32(), r2._loadQuadruplet(), r2;
                }, t3.createByRGBA = function(e3, r2, i2, n2) {
                  var a = new t3();
                  return a.r = 0 | e3, a.g = 0 | r2, a.b = 0 | i2, a.a = 0 | n2, a._loadUINT32(), a._loadQuadruplet(), a;
                }, t3.createByUint32 = function(e3) {
                  var r2 = new t3();
                  return r2.uint32 = e3 >>> 0, r2._loadRGBA(), r2._loadQuadruplet(), r2;
                }, t3.prototype.from = function(t4) {
                  this.r = t4.r, this.g = t4.g, this.b = t4.b, this.a = t4.a, this.uint32 = t4.uint32, this.rgba[0] = t4.r, this.rgba[1] = t4.g, this.rgba[2] = t4.b, this.rgba[3] = t4.a;
                }, t3.prototype.getLuminosity = function(t4) {
                  var e3 = this.r, r2 = this.g, n2 = this.b;
                  return t4 && (e3 = Math.min(255, 255 - this.a + this.a * e3 / 255), r2 = Math.min(255, 255 - this.a + this.a * r2 / 255), n2 = Math.min(255, 255 - this.a + this.a * n2 / 255)), e3 * i.Y.RED + r2 * i.Y.GREEN + n2 * i.Y.BLUE;
                }, t3.prototype._loadUINT32 = function() {
                  this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
                }, t3.prototype._loadRGBA = function() {
                  this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
                }, t3.prototype._loadQuadruplet = function() {
                  this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
                }, t3;
              }();
              e2.Point = n;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(22), n = r(24), a = 3, o = function() {
                function t3(t4) {
                  this.r = this.g = this.b = this.a = t4;
                }
                return t3.prototype.toPoint = function() {
                  return n.Point.createByRGBA(this.r >> a, this.g >> a, this.b >> a, this.a >> a);
                }, t3.prototype.subtract = function(t4, e3, r2, i2) {
                  this.r -= t4, this.g -= e3, this.b -= r2, this.a -= i2;
                }, t3;
              }(), s = function() {
                function t3(t4, e3) {
                  void 0 === e3 && (e3 = 256), this._distance = t4, this._pointArray = [], this._sampleFactor = 1, this._networkSize = e3, this._distance.setWhitePoint(255 << a, 255 << a, 255 << a, 255 << a);
                }
                return t3.prototype.sample = function(t4) {
                  this._pointArray = this._pointArray.concat(t4.getPointArray());
                }, t3.prototype.quantize = function() {
                  return this._init(), this._learn(), this._buildPalette();
                }, t3.prototype._init = function() {
                  this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                  for (var e3 = 0; e3 < this._networkSize; e3++)
                    this._network[e3] = new o((e3 << a + 8) / this._networkSize), this._freq[e3] = t3._initialBias / this._networkSize, this._bias[e3] = 0;
                }, t3.prototype._learn = function() {
                  var e3 = this._sampleFactor, r2 = this._pointArray.length;
                  r2 < t3._minpicturebytes && (e3 = 1);
                  var i2, n2 = 30 + (e3 - 1) / 3, o2 = r2 / e3, s2 = o2 / t3._nCycles | 0, h = t3._initAlpha, f = (this._networkSize >> 3) * t3._radiusBias, u = f >> t3._radiusBiasShift;
                  u <= 1 && (u = 0);
                  for (var l = 0; l < u; l++)
                    this._radPower[l] = h * ((u * u - l * l) * t3._radBias / (u * u));
                  i2 = r2 < t3._minpicturebytes ? 1 : r2 % t3._prime1 != 0 ? t3._prime1 : r2 % t3._prime2 != 0 ? t3._prime2 : r2 % t3._prime3 != 0 ? t3._prime3 : t3._prime4, l = 0;
                  for (var c = 0; l < o2; ) {
                    var d = this._pointArray[c], p = d.b << a, m = d.g << a, g = d.r << a, b = d.a << a, _ = this._contest(p, m, g, b);
                    if (this._alterSingle(h, _, p, m, g, b), 0 != u && this._alterNeighbour(u, _, p, m, g, b), (c += i2) >= r2 && (c -= r2), 0 == s2 && (s2 = 1), ++l % s2 == 0) {
                      h -= h / n2, (u = (f -= f / t3._radiusDecrease) >> t3._radiusBiasShift) <= 1 && (u = 0);
                      for (var y = 0; y < u; y++)
                        this._radPower[y] = h * ((u * u - y * y) * t3._radBias / (u * u));
                    }
                  }
                }, t3.prototype._buildPalette = function() {
                  var t4 = new i.Palette();
                  return this._network.forEach(function(e3) {
                    t4.add(e3.toPoint());
                  }), t4.sort(), t4;
                }, t3.prototype._alterNeighbour = function(e3, r2, i2, n2, a2, o2) {
                  var s2 = r2 - e3;
                  s2 < -1 && (s2 = -1);
                  var h = r2 + e3;
                  h > this._networkSize && (h = this._networkSize);
                  for (var f = r2 + 1, u = r2 - 1, l = 1; f < h || u > s2; ) {
                    var c, d = this._radPower[l++] / t3._alphaRadBias;
                    f < h && (c = this._network[f++]).subtract(d * (c.r - a2), d * (c.g - n2), d * (c.b - i2), d * (c.a - o2)), u > s2 && (c = this._network[u--]).subtract(d * (c.r - a2), d * (c.g - n2), d * (c.b - i2), d * (c.a - o2));
                  }
                }, t3.prototype._alterSingle = function(e3, r2, i2, n2, a2, o2) {
                  e3 /= t3._initAlpha;
                  var s2 = this._network[r2];
                  s2.subtract(e3 * (s2.r - a2), e3 * (s2.g - n2), e3 * (s2.b - i2), e3 * (s2.a - o2));
                }, t3.prototype._contest = function(e3, r2, i2, n2) {
                  for (var o2 = 1020 << a, s2 = ~(1 << 31), h = s2, f = -1, u = f, l = 0; l < this._networkSize; l++) {
                    var c = this._network[l], d = this._distance.calculateNormalized(c, { r: i2, g: r2, b: e3, a: n2 }) * o2;
                    d < s2 && (s2 = d, f = l);
                    var p = d - (this._bias[l] >> t3._initialBiasShift - a);
                    p < h && (h = p, u = l);
                    var m = this._freq[l] >> t3._betaShift;
                    this._freq[l] -= m, this._bias[l] += m << t3._gammaShift;
                  }
                  return this._freq[f] += t3._beta, this._bias[f] -= t3._betaGamma, u;
                }, t3._prime1 = 499, t3._prime2 = 491, t3._prime3 = 487, t3._prime4 = 503, t3._minpicturebytes = t3._prime4, t3._nCycles = 100, t3._initialBiasShift = 16, t3._initialBias = 1 << t3._initialBiasShift, t3._gammaShift = 10, t3._betaShift = 10, t3._beta = t3._initialBias >> t3._betaShift, t3._betaGamma = t3._initialBias << t3._gammaShift - t3._betaShift, t3._radiusBiasShift = 6, t3._radiusBias = 1 << t3._radiusBiasShift, t3._radiusDecrease = 30, t3._alphaBiasShift = 10, t3._initAlpha = 1 << t3._alphaBiasShift, t3._radBiasShift = 8, t3._radBias = 1 << t3._radBiasShift, t3._alphaRadBiasShift = t3._alphaBiasShift + t3._radBiasShift, t3._alphaRadBias = 1 << t3._alphaRadBiasShift, t3;
              }();
              e2.NeuQuantFloat = s;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(22), n = r(24), a = r(27), o = r(6), s = function(t3, e3, r2) {
                this.index = t3, this.color = e3, this.distance = r2;
              }, h = function() {
                function t3(t4, e3, r2) {
                  void 0 === e3 && (e3 = 256), void 0 === r2 && (r2 = 2), this._distance = t4, this._colors = e3, this._histogram = new a.ColorHistogram(r2, e3), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
                }
                return t3.prototype.sample = function(t4) {
                  this._histogram.sample(t4);
                }, t3.prototype.quantize = function() {
                  var t4 = this._histogram.getImportanceSortedColorsIDXI32();
                  if (0 === t4.length)
                    throw new Error("No colors in image");
                  var e3 = this._buildPalette(t4);
                  return e3.sort(), e3;
                }, t3.prototype._buildPalette = function(t4) {
                  for (var e3 = new i.Palette(), r2 = e3.getPointContainer().getPointArray(), a2 = new Array(t4.length), h2 = 0; h2 < t4.length; h2++)
                    r2.push(n.Point.createByUint32(t4[h2])), a2[h2] = 1;
                  for (var f = r2.length, u = [], l = f, c = this._initialDistance; l > this._colors; ) {
                    for (u.length = 0, h2 = 0; h2 < f; h2++)
                      if (0 !== a2[h2]) {
                        for (var d = r2[h2], p = h2 + 1; p < f; p++)
                          if (0 !== a2[p]) {
                            var m = r2[p], g = this._distance.calculateNormalized(d, m);
                            g < c && (u.push(new s(p, m, g)), a2[p] = 0, l--);
                          }
                      }
                    c += l > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
                  }
                  if (l < this._colors) {
                    o.stableSort(u, function(t5, e4) {
                      return e4.distance - t5.distance;
                    });
                    for (var b = 0; l < this._colors && b < u.length; )
                      a2[u[b].index] = 1, l++, b++;
                  }
                  for (var _ = r2.length, y = _ - 1; y >= 0; y--)
                    0 === a2[y] && (y !== _ - 1 && (r2[y] = r2[_ - 1]), --_);
                  return r2.length = _, e3;
                }, t3;
              }();
              e2.RGBQuant = h;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(28), n = r(6), a = function() {
                function t3(e3, r2) {
                  this._method = e3, this._minHueCols = r2 << 2, this._initColors = r2 << 2, this._hueStats = new i.HueStatistics(t3._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
                }
                return t3.prototype.sample = function(t4) {
                  switch (this._method) {
                    case 1:
                      this._colorStats1D(t4);
                      break;
                    case 2:
                      this._colorStats2D(t4);
                  }
                }, t3.prototype.getImportanceSortedColorsIDXI32 = function() {
                  var t4, e3 = this, r2 = n.stableSort(Object.keys(this._histogram), function(t5, r3) {
                    return e3._histogram[r3] - e3._histogram[t5];
                  });
                  if (0 === r2.length)
                    return [];
                  switch (this._method) {
                    case 1:
                      var i2 = Math.min(r2.length, this._initColors), a2 = r2[i2 - 1], o = this._histogram[a2];
                      t4 = r2.slice(0, i2);
                      for (var s = i2, h = r2.length; s < h && this._histogram[r2[s]] == o; )
                        t4.push(r2[s++]);
                      this._hueStats.injectIntoArray(t4);
                      break;
                    case 2:
                      t4 = r2;
                      break;
                    default:
                      throw new Error("Incorrect method");
                  }
                  return t4.map(function(t5) {
                    return +t5;
                  });
                }, t3.prototype._colorStats1D = function(t4) {
                  for (var e3 = this._histogram, r2 = t4.getPointArray(), i2 = r2.length, n2 = 0; n2 < i2; n2++) {
                    var a2 = r2[n2].uint32;
                    this._hueStats.check(a2), a2 in e3 ? e3[a2]++ : e3[a2] = 1;
                  }
                }, t3.prototype._colorStats2D = function(e3) {
                  var r2 = this, i2 = e3.getWidth(), n2 = e3.getHeight(), a2 = e3.getPointArray(), o = t3._boxSize[0], s = t3._boxSize[1], h = o * s, f = this._makeBoxes(i2, n2, o, s), u = this._histogram;
                  f.forEach(function(e4) {
                    var n3 = Math.round(e4.w * e4.h / h) * t3._boxPixels;
                    n3 < 2 && (n3 = 2);
                    var o2 = {};
                    r2._iterateBox(e4, i2, function(t4) {
                      var e5 = a2[t4].uint32;
                      r2._hueStats.check(e5), e5 in u ? u[e5]++ : e5 in o2 ? ++o2[e5] >= n3 && (u[e5] = o2[e5]) : o2[e5] = 1;
                    });
                  }), this._hueStats.injectIntoDictionary(u);
                }, t3.prototype._iterateBox = function(t4, e3, r2) {
                  var i2 = t4, n2 = i2.y * e3 + i2.x, a2 = (i2.y + i2.h - 1) * e3 + (i2.x + i2.w - 1), o = e3 - i2.w + 1, s = 0, h = n2;
                  do {
                    r2.call(this, h), h += ++s % i2.w == 0 ? o : 1;
                  } while (h <= a2);
                }, t3.prototype._makeBoxes = function(t4, e3, r2, i2) {
                  for (var n2 = t4 % r2, a2 = e3 % i2, o = t4 - n2, s = e3 - a2, h = [], f = 0; f < e3; f += i2)
                    for (var u = 0; u < t4; u += r2)
                      h.push({ x: u, y: f, w: u == o ? n2 : r2, h: f == s ? a2 : i2 });
                  return h;
                }, t3._boxSize = [64, 64], t3._boxPixels = 2, t3._hueGroups = 10, t3;
              }();
              e2.ColorHistogram = a;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(5), n = r(22), a = function() {
                this.num = 0, this.cols = [];
              }, o = function() {
                function t3(t4, e3) {
                  this._numGroups = t4, this._minCols = e3, this._stats = [];
                  for (var r2 = 0; r2 <= t4; r2++)
                    this._stats[r2] = new a();
                  this._groupsFull = 0;
                }
                return t3.prototype.check = function(t4) {
                  this._groupsFull == this._numGroups + 1 && (this.check = function() {
                  });
                  var e3 = 255 & t4, r2 = t4 >>> 8 & 255, a2 = t4 >>> 16 & 255, o2 = e3 == r2 && r2 == a2 ? 0 : 1 + n.hueGroup(i.rgb2hsl(e3, r2, a2).h, this._numGroups), s = this._stats[o2], h = this._minCols;
                  s.num++, s.num > h || (s.num == h && this._groupsFull++, s.num <= h && this._stats[o2].cols.push(t4));
                }, t3.prototype.injectIntoDictionary = function(t4) {
                  for (var e3 = 0; e3 <= this._numGroups; e3++)
                    this._stats[e3].num <= this._minCols && this._stats[e3].cols.forEach(function(e4) {
                      t4[e4] ? t4[e4]++ : t4[e4] = 1;
                    });
                }, t3.prototype.injectIntoArray = function(t4) {
                  for (var e3 = 0; e3 <= this._numGroups; e3++)
                    this._stats[e3].num <= this._minCols && this._stats[e3].cols.forEach(function(e4) {
                      -1 == t4.indexOf(e4) && t4.push(e4);
                    });
                }, t3;
              }();
              e2.HueStatistics = o;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(22), n = r(24);
              function a(t3) {
                for (var e3 = [], r2 = 0; r2 < t3; r2++)
                  e3[r2] = 0;
                return e3;
              }
              function o(t3, e3, r2, i2) {
                for (var n2 = new Array(t3), a2 = 0; a2 < t3; a2++) {
                  n2[a2] = new Array(e3);
                  for (var o2 = 0; o2 < e3; o2++) {
                    n2[a2][o2] = new Array(r2);
                    for (var s2 = 0; s2 < r2; s2++) {
                      n2[a2][o2][s2] = new Array(i2);
                      for (var h2 = 0; h2 < i2; h2++)
                        n2[a2][o2][s2][h2] = 0;
                    }
                  }
                }
                return n2;
              }
              function s(t3, e3, r2) {
                for (var i2 = new Array(t3), n2 = 0; n2 < t3; n2++) {
                  i2[n2] = new Array(e3);
                  for (var a2 = 0; a2 < e3; a2++) {
                    i2[n2][a2] = new Array(r2);
                    for (var o2 = 0; o2 < r2; o2++)
                      i2[n2][a2][o2] = 0;
                  }
                }
                return i2;
              }
              function h(t3, e3, r2, i2, n2) {
                for (var a2 = 0; a2 < e3; a2++) {
                  t3[a2] = [];
                  for (var o2 = 0; o2 < r2; o2++) {
                    t3[a2][o2] = [];
                    for (var s2 = 0; s2 < i2; s2++)
                      t3[a2][o2][s2] = n2;
                  }
                }
              }
              function f(t3, e3, r2) {
                for (var i2 = 0; i2 < e3; i2++)
                  t3[i2] = r2;
              }
              var u = function() {
              };
              e2.WuColorCube = u;
              var l = function() {
                function t3(t4, e3, r2) {
                  void 0 === e3 && (e3 = 256), void 0 === r2 && (r2 = 5), this._distance = t4, this._setQuality(r2), this._initialize(e3);
                }
                return t3.prototype.sample = function(t4) {
                  for (var e3 = t4.getPointArray(), r2 = 0, i2 = e3.length; r2 < i2; r2++)
                    this._addColor(e3[r2]);
                  this._pixels = this._pixels.concat(e3);
                }, t3.prototype.quantize = function() {
                  this._preparePalette();
                  for (var t4 = new i.Palette(), e3 = 0; e3 < this._colors; e3++)
                    if (this._sums[e3] > 0) {
                      var r2 = this._sums[e3], a2 = this._reds[e3] / r2, o2 = this._greens[e3] / r2, s2 = this._blues[e3] / r2, h2 = this._alphas[e3] / r2, f2 = n.Point.createByRGBA(0 | a2, 0 | o2, 0 | s2, 0 | h2);
                      t4.add(f2);
                    }
                  return t4.sort(), t4;
                }, t3.prototype._preparePalette = function() {
                  this._calculateMoments();
                  for (var e3 = 0, r2 = a(this._colors), i2 = 1; i2 < this._colors; ++i2) {
                    this._cut(this._cubes[e3], this._cubes[i2]) ? (r2[e3] = this._cubes[e3].volume > 1 ? this._calculateVariance(this._cubes[e3]) : 0, r2[i2] = this._cubes[i2].volume > 1 ? this._calculateVariance(this._cubes[i2]) : 0) : (r2[e3] = 0, i2--), e3 = 0;
                    for (var n2 = r2[0], o2 = 1; o2 <= i2; ++o2)
                      r2[o2] > n2 && (n2 = r2[o2], e3 = o2);
                    if (n2 <= 0) {
                      this._colors = i2 + 1;
                      break;
                    }
                  }
                  for (var s2 = [], h2 = [], f2 = [], u2 = [], l2 = 0; l2 < this._colors; ++l2) {
                    var c = t3._volume(this._cubes[l2], this._weights);
                    c > 0 ? (s2[l2] = t3._volume(this._cubes[l2], this._momentsRed) / c | 0, h2[l2] = t3._volume(this._cubes[l2], this._momentsGreen) / c | 0, f2[l2] = t3._volume(this._cubes[l2], this._momentsBlue) / c | 0, u2[l2] = t3._volume(this._cubes[l2], this._momentsAlpha) / c | 0) : (s2[l2] = 0, h2[l2] = 0, f2[l2] = 0, u2[l2] = 0);
                  }
                  this._reds = a(this._colors + 1), this._greens = a(this._colors + 1), this._blues = a(this._colors + 1), this._alphas = a(this._colors + 1), this._sums = a(this._colors + 1), o2 = 0;
                  for (var d = this._pixels.length; o2 < d; o2++) {
                    for (var p = this._pixels[o2], m = -1, g = Number.MAX_VALUE, b = 0; b < this._colors; b++) {
                      var _ = s2[b], y = h2[b], w = f2[b], v = u2[b], x = this._distance.calculateRaw(_, y, w, v, p.r, p.g, p.b, p.a);
                      x < g && (g = x, m = b);
                    }
                    this._reds[m] += p.r, this._greens[m] += p.g, this._blues[m] += p.b, this._alphas[m] += p.a, this._sums[m]++;
                  }
                }, t3.prototype._addColor = function(t4) {
                  var e3 = 8 - this._significantBitsPerChannel, r2 = 1 + (t4.r >> e3), i2 = 1 + (t4.g >> e3), n2 = 1 + (t4.b >> e3), a2 = 1 + (t4.a >> e3);
                  this._weights[a2][r2][i2][n2]++, this._momentsRed[a2][r2][i2][n2] += t4.r, this._momentsGreen[a2][r2][i2][n2] += t4.g, this._momentsBlue[a2][r2][i2][n2] += t4.b, this._momentsAlpha[a2][r2][i2][n2] += t4.a, this._moments[a2][r2][i2][n2] += this._table[t4.r] + this._table[t4.g] + this._table[t4.b] + this._table[t4.a];
                }, t3.prototype._calculateMoments = function() {
                  for (var t4 = [], e3 = [], r2 = [], i2 = [], n2 = [], a2 = [], o2 = s(this._sideSize, this._sideSize, this._sideSize), u2 = s(this._sideSize, this._sideSize, this._sideSize), l2 = s(this._sideSize, this._sideSize, this._sideSize), c = s(this._sideSize, this._sideSize, this._sideSize), d = s(this._sideSize, this._sideSize, this._sideSize), p = s(this._sideSize, this._sideSize, this._sideSize), m = 1; m <= this._alphaMaxSideIndex; ++m) {
                    h(o2, this._sideSize, this._sideSize, this._sideSize, 0), h(u2, this._sideSize, this._sideSize, this._sideSize, 0), h(l2, this._sideSize, this._sideSize, this._sideSize, 0), h(c, this._sideSize, this._sideSize, this._sideSize, 0), h(d, this._sideSize, this._sideSize, this._sideSize, 0), h(p, this._sideSize, this._sideSize, this._sideSize, 0);
                    for (var g = 1; g <= this._maxSideIndex; ++g) {
                      f(t4, this._sideSize, 0), f(e3, this._sideSize, 0), f(r2, this._sideSize, 0), f(i2, this._sideSize, 0), f(n2, this._sideSize, 0), f(a2, this._sideSize, 0);
                      for (var b = 1; b <= this._maxSideIndex; ++b)
                        for (var _ = 0, y = 0, w = 0, v = 0, x = 0, E = 0, k = 1; k <= this._maxSideIndex; ++k)
                          _ += this._weights[m][g][b][k], y += this._momentsRed[m][g][b][k], w += this._momentsGreen[m][g][b][k], v += this._momentsBlue[m][g][b][k], x += this._momentsAlpha[m][g][b][k], E += this._moments[m][g][b][k], t4[k] += _, e3[k] += y, r2[k] += w, i2[k] += v, n2[k] += x, a2[k] += E, o2[g][b][k] = o2[g - 1][b][k] + t4[k], u2[g][b][k] = u2[g - 1][b][k] + e3[k], l2[g][b][k] = l2[g - 1][b][k] + r2[k], c[g][b][k] = c[g - 1][b][k] + i2[k], d[g][b][k] = d[g - 1][b][k] + n2[k], p[g][b][k] = p[g - 1][b][k] + a2[k], this._weights[m][g][b][k] = this._weights[m - 1][g][b][k] + o2[g][b][k], this._momentsRed[m][g][b][k] = this._momentsRed[m - 1][g][b][k] + u2[g][b][k], this._momentsGreen[m][g][b][k] = this._momentsGreen[m - 1][g][b][k] + l2[g][b][k], this._momentsBlue[m][g][b][k] = this._momentsBlue[m - 1][g][b][k] + c[g][b][k], this._momentsAlpha[m][g][b][k] = this._momentsAlpha[m - 1][g][b][k] + d[g][b][k], this._moments[m][g][b][k] = this._moments[m - 1][g][b][k] + p[g][b][k];
                    }
                  }
                }, t3._volumeFloat = function(t4, e3) {
                  return e3[t4.alphaMaximum][t4.redMaximum][t4.greenMaximum][t4.blueMaximum] - e3[t4.alphaMaximum][t4.redMaximum][t4.greenMinimum][t4.blueMaximum] - e3[t4.alphaMaximum][t4.redMinimum][t4.greenMaximum][t4.blueMaximum] + e3[t4.alphaMaximum][t4.redMinimum][t4.greenMinimum][t4.blueMaximum] - e3[t4.alphaMinimum][t4.redMaximum][t4.greenMaximum][t4.blueMaximum] + e3[t4.alphaMinimum][t4.redMaximum][t4.greenMinimum][t4.blueMaximum] + e3[t4.alphaMinimum][t4.redMinimum][t4.greenMaximum][t4.blueMaximum] - e3[t4.alphaMinimum][t4.redMinimum][t4.greenMinimum][t4.blueMaximum] - (e3[t4.alphaMaximum][t4.redMaximum][t4.greenMaximum][t4.blueMinimum] - e3[t4.alphaMinimum][t4.redMaximum][t4.greenMaximum][t4.blueMinimum] - e3[t4.alphaMaximum][t4.redMaximum][t4.greenMinimum][t4.blueMinimum] + e3[t4.alphaMinimum][t4.redMaximum][t4.greenMinimum][t4.blueMinimum] - e3[t4.alphaMaximum][t4.redMinimum][t4.greenMaximum][t4.blueMinimum] + e3[t4.alphaMinimum][t4.redMinimum][t4.greenMaximum][t4.blueMinimum] + e3[t4.alphaMaximum][t4.redMinimum][t4.greenMinimum][t4.blueMinimum] - e3[t4.alphaMinimum][t4.redMinimum][t4.greenMinimum][t4.blueMinimum]);
                }, t3._volume = function(e3, r2) {
                  return 0 | t3._volumeFloat(e3, r2);
                }, t3._top = function(e3, r2, i2, n2) {
                  var a2;
                  switch (r2) {
                    case t3.alpha:
                      a2 = n2[i2][e3.redMaximum][e3.greenMaximum][e3.blueMaximum] - n2[i2][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] - n2[i2][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] + n2[i2][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (n2[i2][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] - n2[i2][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] - n2[i2][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] + n2[i2][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
                      break;
                    case t3.red:
                      a2 = n2[e3.alphaMaximum][i2][e3.greenMaximum][e3.blueMaximum] - n2[e3.alphaMaximum][i2][e3.greenMinimum][e3.blueMaximum] - n2[e3.alphaMinimum][i2][e3.greenMaximum][e3.blueMaximum] + n2[e3.alphaMinimum][i2][e3.greenMinimum][e3.blueMaximum] - (n2[e3.alphaMaximum][i2][e3.greenMaximum][e3.blueMinimum] - n2[e3.alphaMaximum][i2][e3.greenMinimum][e3.blueMinimum] - n2[e3.alphaMinimum][i2][e3.greenMaximum][e3.blueMinimum] + n2[e3.alphaMinimum][i2][e3.greenMinimum][e3.blueMinimum]);
                      break;
                    case t3.green:
                      a2 = n2[e3.alphaMaximum][e3.redMaximum][i2][e3.blueMaximum] - n2[e3.alphaMaximum][e3.redMinimum][i2][e3.blueMaximum] - n2[e3.alphaMinimum][e3.redMaximum][i2][e3.blueMaximum] + n2[e3.alphaMinimum][e3.redMinimum][i2][e3.blueMaximum] - (n2[e3.alphaMaximum][e3.redMaximum][i2][e3.blueMinimum] - n2[e3.alphaMaximum][e3.redMinimum][i2][e3.blueMinimum] - n2[e3.alphaMinimum][e3.redMaximum][i2][e3.blueMinimum] + n2[e3.alphaMinimum][e3.redMinimum][i2][e3.blueMinimum]);
                      break;
                    case t3.blue:
                      a2 = n2[e3.alphaMaximum][e3.redMaximum][e3.greenMaximum][i2] - n2[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][i2] - n2[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][i2] + n2[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][i2] - (n2[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][i2] - n2[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][i2] - n2[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][i2] + n2[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][i2]);
                      break;
                    default:
                      throw new Error("impossible");
                  }
                  return 0 | a2;
                }, t3._bottom = function(e3, r2, i2) {
                  switch (r2) {
                    case t3.alpha:
                      return -i2[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][e3.blueMaximum] + i2[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] + i2[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] - i2[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (-i2[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] + i2[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + i2[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] - i2[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
                    case t3.red:
                      return -i2[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] + i2[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] + i2[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMaximum] - i2[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (-i2[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] + i2[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum] + i2[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] - i2[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
                    case t3.green:
                      return -i2[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] + i2[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] + i2[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMaximum] - i2[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMaximum] - (-i2[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + i2[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum] + i2[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] - i2[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
                    case t3.blue:
                      return -i2[e3.alphaMaximum][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] + i2[e3.alphaMaximum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + i2[e3.alphaMaximum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] - i2[e3.alphaMaximum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum] - (-i2[e3.alphaMinimum][e3.redMaximum][e3.greenMaximum][e3.blueMinimum] + i2[e3.alphaMinimum][e3.redMaximum][e3.greenMinimum][e3.blueMinimum] + i2[e3.alphaMinimum][e3.redMinimum][e3.greenMaximum][e3.blueMinimum] - i2[e3.alphaMinimum][e3.redMinimum][e3.greenMinimum][e3.blueMinimum]);
                    default:
                      return 0;
                  }
                }, t3.prototype._calculateVariance = function(e3) {
                  var r2 = t3._volume(e3, this._momentsRed), i2 = t3._volume(e3, this._momentsGreen), n2 = t3._volume(e3, this._momentsBlue), a2 = t3._volume(e3, this._momentsAlpha);
                  return t3._volumeFloat(e3, this._moments) - (r2 * r2 + i2 * i2 + n2 * n2 + a2 * a2) / t3._volume(e3, this._weights);
                }, t3.prototype._maximize = function(e3, r2, i2, n2, a2, o2, s2, h2, f2) {
                  for (var u2 = 0 | t3._bottom(e3, r2, this._momentsRed), l2 = 0 | t3._bottom(e3, r2, this._momentsGreen), c = 0 | t3._bottom(e3, r2, this._momentsBlue), d = 0 | t3._bottom(e3, r2, this._momentsAlpha), p = 0 | t3._bottom(e3, r2, this._weights), m = 0, g = -1, b = i2; b < n2; ++b) {
                    var _ = u2 + t3._top(e3, r2, b, this._momentsRed), y = l2 + t3._top(e3, r2, b, this._momentsGreen), w = c + t3._top(e3, r2, b, this._momentsBlue), v = d + t3._top(e3, r2, b, this._momentsAlpha), x = p + t3._top(e3, r2, b, this._weights);
                    if (0 != x) {
                      var E = _ * _ + y * y + w * w + v * v, k = E / x;
                      _ = a2 - _, y = o2 - y, w = s2 - w, v = h2 - v, 0 != (x = f2 - x) && (k += (E = _ * _ + y * y + w * w + v * v) / x) > m && (m = k, g = b);
                    }
                  }
                  return { max: m, position: g };
                }, t3.prototype._cut = function(e3, r2) {
                  var i2, n2 = t3._volume(e3, this._momentsRed), a2 = t3._volume(e3, this._momentsGreen), o2 = t3._volume(e3, this._momentsBlue), s2 = t3._volume(e3, this._momentsAlpha), h2 = t3._volume(e3, this._weights), f2 = this._maximize(e3, t3.red, e3.redMinimum + 1, e3.redMaximum, n2, a2, o2, s2, h2), u2 = this._maximize(e3, t3.green, e3.greenMinimum + 1, e3.greenMaximum, n2, a2, o2, s2, h2), l2 = this._maximize(e3, t3.blue, e3.blueMinimum + 1, e3.blueMaximum, n2, a2, o2, s2, h2), c = this._maximize(e3, t3.alpha, e3.alphaMinimum + 1, e3.alphaMaximum, n2, a2, o2, s2, h2);
                  if (c.max >= f2.max && c.max >= u2.max && c.max >= l2.max) {
                    if (i2 = t3.alpha, c.position < 0)
                      return false;
                  } else
                    i2 = f2.max >= c.max && f2.max >= u2.max && f2.max >= l2.max ? t3.red : u2.max >= c.max && u2.max >= f2.max && u2.max >= l2.max ? t3.green : t3.blue;
                  switch (r2.redMaximum = e3.redMaximum, r2.greenMaximum = e3.greenMaximum, r2.blueMaximum = e3.blueMaximum, r2.alphaMaximum = e3.alphaMaximum, i2) {
                    case t3.red:
                      r2.redMinimum = e3.redMaximum = f2.position, r2.greenMinimum = e3.greenMinimum, r2.blueMinimum = e3.blueMinimum, r2.alphaMinimum = e3.alphaMinimum;
                      break;
                    case t3.green:
                      r2.greenMinimum = e3.greenMaximum = u2.position, r2.redMinimum = e3.redMinimum, r2.blueMinimum = e3.blueMinimum, r2.alphaMinimum = e3.alphaMinimum;
                      break;
                    case t3.blue:
                      r2.blueMinimum = e3.blueMaximum = l2.position, r2.redMinimum = e3.redMinimum, r2.greenMinimum = e3.greenMinimum, r2.alphaMinimum = e3.alphaMinimum;
                      break;
                    case t3.alpha:
                      r2.alphaMinimum = e3.alphaMaximum = c.position, r2.blueMinimum = e3.blueMinimum, r2.redMinimum = e3.redMinimum, r2.greenMinimum = e3.greenMinimum;
                  }
                  return e3.volume = (e3.redMaximum - e3.redMinimum) * (e3.greenMaximum - e3.greenMinimum) * (e3.blueMaximum - e3.blueMinimum) * (e3.alphaMaximum - e3.alphaMinimum), r2.volume = (r2.redMaximum - r2.redMinimum) * (r2.greenMaximum - r2.greenMinimum) * (r2.blueMaximum - r2.blueMinimum) * (r2.alphaMaximum - r2.alphaMinimum), true;
                }, t3.prototype._initialize = function(t4) {
                  this._colors = t4, this._cubes = [];
                  for (var e3 = 0; e3 < t4; e3++)
                    this._cubes[e3] = new u();
                  this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = o(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = o(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = o(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = o(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = o(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = o(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
                  for (var r2 = 0; r2 < 256; ++r2)
                    this._table[r2] = r2 * r2;
                  this._pixels = [];
                }, t3.prototype._setQuality = function(t4) {
                  void 0 === t4 && (t4 = 5), this._significantBitsPerChannel = t4, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
                }, t3.alpha = 3, t3.red = 2, t3.green = 1, t3.blue = 0, t3;
              }();
              e2.WuQuant = l;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(31);
              e2.NearestColor = i.NearestColor;
              var n = r(32);
              e2.ErrorDiffusionArray = n.ErrorDiffusionArray, e2.ErrorDiffusionArrayKernel = n.ErrorDiffusionArrayKernel;
              var a = r(33);
              e2.ErrorDiffusionRiemersma = a.ErrorDiffusionRiemersma;
            }, function(t2, e2) {
              "use strict";
              var r = function() {
                function t3(t4) {
                  this._distance = t4;
                }
                return t3.prototype.quantize = function(t4, e3) {
                  for (var r2 = t4.getPointArray(), i = t4.getWidth(), n = t4.getHeight(), a = 0; a < n; a++)
                    for (var o = 0, s = a * i; o < i; o++, s++) {
                      var h = r2[s];
                      h.from(e3.getNearestColor(this._distance, h));
                    }
                  return t4;
                }, t3;
              }();
              e2.NearestColor = r;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(24), n = r(6);
              !function(t3) {
                t3[t3.FloydSteinberg = 0] = "FloydSteinberg", t3[t3.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", t3[t3.Stucki = 2] = "Stucki", t3[t3.Atkinson = 3] = "Atkinson", t3[t3.Jarvis = 4] = "Jarvis", t3[t3.Burkes = 5] = "Burkes", t3[t3.Sierra = 6] = "Sierra", t3[t3.TwoSierra = 7] = "TwoSierra", t3[t3.SierraLite = 8] = "SierraLite";
              }(e2.ErrorDiffusionArrayKernel || (e2.ErrorDiffusionArrayKernel = {}));
              var a = e2.ErrorDiffusionArrayKernel, o = function() {
                function t3(t4, e3, r2, i2, n2) {
                  void 0 === r2 && (r2 = true), void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = false), this._setKernel(e3), this._distance = t4, this._minColorDistance = i2, this._serpentine = r2, this._calculateErrorLikeGIMP = n2;
                }
                return t3.prototype.quantize = function(t4, e3) {
                  for (var r2 = t4.getPointArray(), a2 = new i.Point(), o2 = t4.getWidth(), s = t4.getHeight(), h = [], f = 1, u = 1, l = 0; l < this._kernel.length; l++) {
                    var c = this._kernel[l][2] + 1;
                    u < c && (u = c);
                  }
                  for (l = 0; l < u; l++)
                    this._fillErrorLine(h[l] = [], o2);
                  for (var d = 0; d < s; d++) {
                    this._serpentine && (f *= -1);
                    var p = d * o2, m = 1 == f ? 0 : o2 - 1, g = 1 == f ? o2 : -1;
                    this._fillErrorLine(h[0], o2), h.push(h.shift());
                    for (var b = h[0], _ = m, y = p + m; _ !== g; _ += f, y += f) {
                      var w = r2[y], v = b[_];
                      a2.from(w);
                      var x = i.Point.createByRGBA(n.inRange0to255Rounded(w.r + v[0]), n.inRange0to255Rounded(w.g + v[1]), n.inRange0to255Rounded(w.b + v[2]), n.inRange0to255Rounded(w.a + v[3])), E = e3.getNearestColor(this._distance, x);
                      if (w.from(E), !(this._minColorDistance && this._distance.calculateNormalized(w, E) < this._minColorDistance)) {
                        var k = void 0, S = void 0, M = void 0, A = void 0;
                        this._calculateErrorLikeGIMP ? (k = x.r - E.r, S = x.g - E.g, M = x.b - E.b, A = x.a - E.a) : (k = a2.r - E.r, S = a2.g - E.g, M = a2.b - E.b, A = a2.a - E.a);
                        var I = 1 == f ? 0 : this._kernel.length - 1, T = 1 == f ? this._kernel.length : -1;
                        for (l = I; l !== T; l += f) {
                          var B = this._kernel[l][1] * f, R = this._kernel[l][2];
                          if (B + _ >= 0 && B + _ < o2 && R + d >= 0 && R + d < s) {
                            var P = this._kernel[l][0], O = h[R][B + _];
                            O[0] = O[0] + k * P, O[1] = O[1] + S * P, O[2] = O[2] + M * P, O[3] = O[3] + A * P;
                          }
                        }
                      }
                    }
                  }
                  return t4;
                }, t3.prototype._fillErrorLine = function(t4, e3) {
                  t4.length > e3 && (t4.length = e3);
                  for (var r2 = t4.length, i2 = 0; i2 < r2; i2++) {
                    var n2 = t4[i2];
                    n2[0] = n2[1] = n2[2] = n2[3] = 0;
                  }
                  for (i2 = r2; i2 < e3; i2++)
                    t4[i2] = [0, 0, 0, 0];
                }, t3.prototype._setKernel = function(t4) {
                  switch (t4) {
                    case a.FloydSteinberg:
                      this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
                      break;
                    case a.FalseFloydSteinberg:
                      this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
                      break;
                    case a.Stucki:
                      this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
                      break;
                    case a.Atkinson:
                      this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
                      break;
                    case a.Jarvis:
                      this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
                      break;
                    case a.Burkes:
                      this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
                      break;
                    case a.Sierra:
                      this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
                      break;
                    case a.TwoSierra:
                      this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
                      break;
                    case a.SierraLite:
                      this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
                      break;
                    default:
                      throw new Error("ErrorDiffusionArray: unknown kernel = " + t4);
                  }
                }, t3;
              }();
              e2.ErrorDiffusionArray = o;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(34), n = r(24), a = r(6), o = function() {
                function t3(t4, e3, r2) {
                  void 0 === e3 && (e3 = 16), void 0 === r2 && (r2 = 1), this._distance = t4, this._errorPropagation = r2, this._errorQueueSize = e3, this._max = this._errorQueueSize, this._createWeights();
                }
                return t3.prototype.quantize = function(t4, e3) {
                  for (var r2 = this, o2 = new i.HilbertCurveBase(), s = t4.getPointArray(), h = t4.getWidth(), f = t4.getHeight(), u = [], l = 0, c = 0; c < this._errorQueueSize; c++)
                    u[c] = { r: 0, g: 0, b: 0, a: 0 };
                  return o2.walk(h, f, function(t5, i2) {
                    for (var o3 = s[t5 + i2 * h], f2 = o3.r, c2 = o3.g, d = o3.b, p = o3.a, m = 0; m < r2._errorQueueSize; m++) {
                      var g = r2._weights[m], b = u[(m + l) % r2._errorQueueSize];
                      f2 += b.r * g, c2 += b.g * g, d += b.b * g, p += b.a * g;
                    }
                    var _ = n.Point.createByRGBA(a.inRange0to255Rounded(f2), a.inRange0to255Rounded(c2), a.inRange0to255Rounded(d), a.inRange0to255Rounded(p)), y = e3.getNearestColor(r2._distance, _), w = ((l = (l + 1) % r2._errorQueueSize) + r2._errorQueueSize - 1) % r2._errorQueueSize;
                    u[w].r = o3.r - y.r, u[w].g = o3.g - y.g, u[w].b = o3.b - y.b, u[w].a = o3.a - y.a, o3.from(y);
                  }), t4;
                }, t3.prototype._createWeights = function() {
                  this._weights = [];
                  for (var t4 = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1)), e3 = 0, r2 = 1; e3 < this._errorQueueSize; e3++)
                    this._weights[e3] = (r2 + 0.5 | 0) / this._max * this._errorPropagation, r2 *= t4;
                }, t3;
              }();
              e2.ErrorDiffusionRiemersma = o;
            }, function(t2, e2) {
              "use strict";
              var r;
              !function(t3) {
                t3[t3.NONE = 0] = "NONE", t3[t3.UP = 1] = "UP", t3[t3.LEFT = 2] = "LEFT", t3[t3.RIGHT = 3] = "RIGHT", t3[t3.DOWN = 4] = "DOWN";
              }(r || (r = {}));
              var i = function() {
                function t3() {
                }
                return t3.prototype.walk = function(t4, e3, i2) {
                  this._x = 0, this._y = 0, this._d = 0, this._width = t4, this._height = e3, this._callback = i2;
                  var n = Math.max(t4, e3);
                  this._level = Math.log(n) / Math.log(2) + 1 | 0, this._walkHilbert(r.UP), this._visit(r.NONE);
                }, t3.prototype._walkHilbert = function(t4) {
                  if (!(this._level < 1)) {
                    switch (this._level--, t4) {
                      case r.LEFT:
                        this._walkHilbert(r.UP), this._visit(r.RIGHT), this._walkHilbert(r.LEFT), this._visit(r.DOWN), this._walkHilbert(r.LEFT), this._visit(r.LEFT), this._walkHilbert(r.DOWN);
                        break;
                      case r.RIGHT:
                        this._walkHilbert(r.DOWN), this._visit(r.LEFT), this._walkHilbert(r.RIGHT), this._visit(r.UP), this._walkHilbert(r.RIGHT), this._visit(r.RIGHT), this._walkHilbert(r.UP);
                        break;
                      case r.UP:
                        this._walkHilbert(r.LEFT), this._visit(r.DOWN), this._walkHilbert(r.UP), this._visit(r.RIGHT), this._walkHilbert(r.UP), this._visit(r.UP), this._walkHilbert(r.RIGHT);
                        break;
                      case r.DOWN:
                        this._walkHilbert(r.RIGHT), this._visit(r.UP), this._walkHilbert(r.DOWN), this._visit(r.LEFT), this._walkHilbert(r.DOWN), this._visit(r.DOWN), this._walkHilbert(r.LEFT);
                    }
                    this._level++;
                  }
                }, t3.prototype._visit = function(t4) {
                  switch (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height && (this._callback(this._x, this._y, this._d), this._d++), t4) {
                    case r.LEFT:
                      this._x--;
                      break;
                    case r.RIGHT:
                      this._x++;
                      break;
                    case r.UP:
                      this._y--;
                      break;
                    case r.DOWN:
                      this._y++;
                  }
                }, t3;
              }();
              e2.HilbertCurveBase = i;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(36);
              e2.SSIM = i.SSIM;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(2), n = function() {
                function t3() {
                }
                return t3.prototype.compare = function(t4, e3) {
                  if (t4.getHeight() !== e3.getHeight() || t4.getWidth() !== e3.getWidth())
                    throw new Error("Images have different sizes!");
                  var r2 = Math.pow(0.01 * 255, 2), i2 = Math.pow(0.03 * 255, 2), n2 = 0, a = 0;
                  return this._iterate(t4, e3, function(t5, e4, o, s) {
                    for (var h = 0, f = 0, u = 0, l = 0; l < t5.length; l++)
                      f += Math.pow(t5[l] - o, 2), u += Math.pow(e4[l] - s, 2), h += (t5[l] - o) * (e4[l] - s);
                    var c = t5.length - 1;
                    f /= c, u /= c;
                    var d = (2 * o * s + r2) * (2 * (h /= c) + i2), p = (Math.pow(o, 2) + Math.pow(s, 2) + r2) * (f + u + i2);
                    a += d / p, n2++;
                  }), a / n2;
                }, t3.prototype._iterate = function(t4, e3, r2) {
                  for (var i2 = t4.getWidth(), n2 = t4.getHeight(), a = 0; a < n2; a += 8)
                    for (var o = 0; o < i2; o += 8) {
                      var s = Math.min(8, i2 - o), h = Math.min(8, n2 - a), f = this._calculateLumaValuesForWindow(t4, o, a, s, h), u = this._calculateLumaValuesForWindow(e3, o, a, s, h);
                      r2(f, u, this._calculateAverageLuma(f), this._calculateAverageLuma(u));
                    }
                }, t3.prototype._calculateLumaValuesForWindow = function(t4, e3, r2, n2, a) {
                  for (var o = t4.getPointArray(), s = [], h = 0, f = r2; f < r2 + a; f++)
                    for (var u = f * t4.getWidth(), l = e3; l < e3 + n2; l++) {
                      var c = o[u + l];
                      s[h] = c.r * i.Y.RED + c.g * i.Y.GREEN + c.b * i.Y.BLUE, h++;
                    }
                  return s;
                }, t3.prototype._calculateAverageLuma = function(t4) {
                  for (var e3 = 0, r2 = 0; r2 < t4.length; r2++)
                    e3 += t4[r2];
                  return e3 / t4.length;
                }, t3;
              }();
              e2.SSIM = n;
            }, function(t2, e2, r) {
              "use strict";
              var i = r(6);
              e2.arithmetic = i;
              var n = r(28);
              e2.HueStatistics = n.HueStatistics;
              var a = r(22);
              e2.Palette = a.Palette;
              var o = r(24);
              e2.Point = o.Point;
              var s = r(23);
              e2.PointContainer = s.PointContainer;
            }]);
          }, t.exports = e();
        }, 9680: (t) => {
          "use strict";
          var e = Function.prototype.toString, r = /^\s*class\b/, i = function(t2) {
            try {
              var i2 = e.call(t2);
              return r.test(i2);
            } catch (t3) {
              return false;
            }
          }, n = Object.prototype.toString, a = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
          t.exports = function(t2) {
            if (!t2)
              return false;
            if ("function" != typeof t2 && "object" != typeof t2)
              return false;
            if ("function" == typeof t2 && !t2.prototype)
              return true;
            if (a)
              return function(t3) {
                try {
                  return !i(t3) && (e.call(t3), true);
                } catch (t4) {
                  return false;
                }
              }(t2);
            if (i(t2))
              return false;
            var r2 = n.call(t2);
            return "[object Function]" === r2 || "[object GeneratorFunction]" === r2;
          };
        }, 9748: (t) => {
          t.exports = function(t2) {
            var r = e.call(t2);
            return "[object Function]" === r || "function" == typeof t2 && "[object RegExp]" !== r || "undefined" != typeof window && (t2 === window.setTimeout || t2 === window.alert || t2 === window.confirm || t2 === window.prompt);
          };
          var e = Object.prototype.toString;
        }, 9307: (t, e, r) => {
          r(6168), t.exports = self.fetch.bind(self);
        }, 2691: (t, e, r) => {
          var i = r(706), n = r(770);
          t.exports = { encode: i, decode: n };
        }, 770: (t, e, r) => {
          var i = r(8834).lW, n = function() {
            "use strict";
            var t2 = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), e2 = 4017, r2 = 799, i2 = 3406, n2 = 2276, a = 1567, o = 3784, s = 5793, h = 2896;
            function f() {
            }
            function u(t3, e3) {
              for (var r3, i3, n3 = 0, a2 = [], o2 = 16; o2 > 0 && !t3[o2 - 1]; )
                o2--;
              a2.push({ children: [], index: 0 });
              var s2, h2 = a2[0];
              for (r3 = 0; r3 < o2; r3++) {
                for (i3 = 0; i3 < t3[r3]; i3++) {
                  for ((h2 = a2.pop()).children[h2.index] = e3[n3]; h2.index > 0; ) {
                    if (0 === a2.length)
                      throw new Error("Could not recreate Huffman Table");
                    h2 = a2.pop();
                  }
                  for (h2.index++, a2.push(h2); a2.length <= r3; )
                    a2.push(s2 = { children: [], index: 0 }), h2.children[h2.index] = s2.children, h2 = s2;
                  n3++;
                }
                r3 + 1 < o2 && (a2.push(s2 = { children: [], index: 0 }), h2.children[h2.index] = s2.children, h2 = s2);
              }
              return a2[0].children;
            }
            function l(e3, r3, i3, n3, a2, o2, s2, h2, f2, u2) {
              i3.precision, i3.samplesPerLine, i3.scanLines;
              var l2 = i3.mcusPerLine, c2 = i3.progressive, d2 = (i3.maxH, i3.maxV, r3), p2 = 0, m2 = 0;
              function g2() {
                if (m2 > 0)
                  return m2--, p2 >> m2 & 1;
                if (255 == (p2 = e3[r3++])) {
                  var t3 = e3[r3++];
                  if (t3)
                    throw new Error("unexpected marker: " + (p2 << 8 | t3).toString(16));
                }
                return m2 = 7, p2 >>> 7;
              }
              function b(t3) {
                for (var e4, r4 = t3; null !== (e4 = g2()); ) {
                  if ("number" == typeof (r4 = r4[e4]))
                    return r4;
                  if ("object" != typeof r4)
                    throw new Error("invalid huffman sequence");
                }
                return null;
              }
              function _(t3) {
                for (var e4 = 0; t3 > 0; ) {
                  var r4 = g2();
                  if (null === r4)
                    return;
                  e4 = e4 << 1 | r4, t3--;
                }
                return e4;
              }
              function y(t3) {
                var e4 = _(t3);
                return e4 >= 1 << t3 - 1 ? e4 : e4 + (-1 << t3) + 1;
              }
              var w, v = 0, x = 0;
              function E(t3, e4, r4, i4, n4) {
                var a3 = r4 % l2, o3 = (r4 / l2 | 0) * t3.v + i4, s3 = a3 * t3.h + n4;
                void 0 === t3.blocks[o3] && u2.tolerantDecoding || e4(t3, t3.blocks[o3][s3]);
              }
              function k(t3, e4, r4) {
                var i4 = r4 / t3.blocksPerLine | 0, n4 = r4 % t3.blocksPerLine;
                void 0 === t3.blocks[i4] && u2.tolerantDecoding || e4(t3, t3.blocks[i4][n4]);
              }
              var S, M, A, I, T, B, R = n3.length;
              B = c2 ? 0 === o2 ? 0 === h2 ? function(t3, e4) {
                var r4 = b(t3.huffmanTableDC), i4 = 0 === r4 ? 0 : y(r4) << f2;
                e4[0] = t3.pred += i4;
              } : function(t3, e4) {
                e4[0] |= g2() << f2;
              } : 0 === h2 ? function(e4, r4) {
                if (v > 0)
                  v--;
                else
                  for (var i4 = o2, n4 = s2; i4 <= n4; ) {
                    var a3 = b(e4.huffmanTableAC), h3 = 15 & a3, u3 = a3 >> 4;
                    if (0 !== h3)
                      r4[t2[i4 += u3]] = y(h3) * (1 << f2), i4++;
                    else {
                      if (u3 < 15) {
                        v = _(u3) + (1 << u3) - 1;
                        break;
                      }
                      i4 += 16;
                    }
                  }
              } : function(e4, r4) {
                for (var i4 = o2, n4 = s2, a3 = 0; i4 <= n4; ) {
                  var h3 = t2[i4], u3 = r4[h3] < 0 ? -1 : 1;
                  switch (x) {
                    case 0:
                      var l3 = b(e4.huffmanTableAC), c3 = 15 & l3;
                      if (a3 = l3 >> 4, 0 === c3)
                        a3 < 15 ? (v = _(a3) + (1 << a3), x = 4) : (a3 = 16, x = 1);
                      else {
                        if (1 !== c3)
                          throw new Error("invalid ACn encoding");
                        w = y(c3), x = a3 ? 2 : 3;
                      }
                      continue;
                    case 1:
                    case 2:
                      r4[h3] ? r4[h3] += (g2() << f2) * u3 : 0 == --a3 && (x = 2 == x ? 3 : 0);
                      break;
                    case 3:
                      r4[h3] ? r4[h3] += (g2() << f2) * u3 : (r4[h3] = w << f2, x = 0);
                      break;
                    case 4:
                      r4[h3] && (r4[h3] += (g2() << f2) * u3);
                  }
                  i4++;
                }
                4 === x && 0 == --v && (x = 0);
              } : function(e4, r4) {
                var i4 = b(e4.huffmanTableDC), n4 = 0 === i4 ? 0 : y(i4);
                r4[0] = e4.pred += n4;
                for (var a3 = 1; a3 < 64; ) {
                  var o3 = b(e4.huffmanTableAC), s3 = 15 & o3, h3 = o3 >> 4;
                  if (0 !== s3)
                    r4[t2[a3 += h3]] = y(s3), a3++;
                  else {
                    if (h3 < 15)
                      break;
                    a3 += 16;
                  }
                }
              };
              var P, O, L, C, U = 0;
              for (O = 1 == R ? n3[0].blocksPerLine * n3[0].blocksPerColumn : l2 * i3.mcusPerColumn, a2 || (a2 = O); U < O; ) {
                for (M = 0; M < R; M++)
                  n3[M].pred = 0;
                if (v = 0, 1 == R)
                  for (S = n3[0], T = 0; T < a2; T++)
                    k(S, B, U), U++;
                else
                  for (T = 0; T < a2; T++) {
                    for (M = 0; M < R; M++)
                      for (L = (S = n3[M]).h, C = S.v, A = 0; A < C; A++)
                        for (I = 0; I < L; I++)
                          E(S, B, U, A, I);
                    if (++U === O)
                      break;
                  }
                if (U === O)
                  do {
                    if (255 === e3[r3] && 0 !== e3[r3 + 1])
                      break;
                    r3 += 1;
                  } while (r3 < e3.length - 2);
                if (m2 = 0, (P = e3[r3] << 8 | e3[r3 + 1]) < 65280)
                  throw new Error("marker was not found");
                if (!(P >= 65488 && P <= 65495))
                  break;
                r3 += 2;
              }
              return r3 - d2;
            }
            function c(t3, f2) {
              var u2, l2, c2 = [], d2 = f2.blocksPerLine, p2 = f2.blocksPerColumn, m2 = d2 << 3, b = new Int32Array(64), _ = new Uint8Array(64);
              function y(t4, u3, l3) {
                var c3, d3, p3, m3, g2, b2, _2, y2, w2, v2, x2 = f2.quantizationTable, E2 = l3;
                for (v2 = 0; v2 < 64; v2++)
                  E2[v2] = t4[v2] * x2[v2];
                for (v2 = 0; v2 < 8; ++v2) {
                  var k2 = 8 * v2;
                  0 != E2[1 + k2] || 0 != E2[2 + k2] || 0 != E2[3 + k2] || 0 != E2[4 + k2] || 0 != E2[5 + k2] || 0 != E2[6 + k2] || 0 != E2[7 + k2] ? (c3 = s * E2[0 + k2] + 128 >> 8, d3 = s * E2[4 + k2] + 128 >> 8, p3 = E2[2 + k2], m3 = E2[6 + k2], g2 = h * (E2[1 + k2] - E2[7 + k2]) + 128 >> 8, y2 = h * (E2[1 + k2] + E2[7 + k2]) + 128 >> 8, b2 = E2[3 + k2] << 4, _2 = E2[5 + k2] << 4, w2 = c3 - d3 + 1 >> 1, c3 = c3 + d3 + 1 >> 1, d3 = w2, w2 = p3 * o + m3 * a + 128 >> 8, p3 = p3 * a - m3 * o + 128 >> 8, m3 = w2, w2 = g2 - _2 + 1 >> 1, g2 = g2 + _2 + 1 >> 1, _2 = w2, w2 = y2 + b2 + 1 >> 1, b2 = y2 - b2 + 1 >> 1, y2 = w2, w2 = c3 - m3 + 1 >> 1, c3 = c3 + m3 + 1 >> 1, m3 = w2, w2 = d3 - p3 + 1 >> 1, d3 = d3 + p3 + 1 >> 1, p3 = w2, w2 = g2 * n2 + y2 * i2 + 2048 >> 12, g2 = g2 * i2 - y2 * n2 + 2048 >> 12, y2 = w2, w2 = b2 * r2 + _2 * e2 + 2048 >> 12, b2 = b2 * e2 - _2 * r2 + 2048 >> 12, _2 = w2, E2[0 + k2] = c3 + y2, E2[7 + k2] = c3 - y2, E2[1 + k2] = d3 + _2, E2[6 + k2] = d3 - _2, E2[2 + k2] = p3 + b2, E2[5 + k2] = p3 - b2, E2[3 + k2] = m3 + g2, E2[4 + k2] = m3 - g2) : (w2 = s * E2[0 + k2] + 512 >> 10, E2[0 + k2] = w2, E2[1 + k2] = w2, E2[2 + k2] = w2, E2[3 + k2] = w2, E2[4 + k2] = w2, E2[5 + k2] = w2, E2[6 + k2] = w2, E2[7 + k2] = w2);
                }
                for (v2 = 0; v2 < 8; ++v2) {
                  var S2 = v2;
                  0 != E2[8 + S2] || 0 != E2[16 + S2] || 0 != E2[24 + S2] || 0 != E2[32 + S2] || 0 != E2[40 + S2] || 0 != E2[48 + S2] || 0 != E2[56 + S2] ? (c3 = s * E2[0 + S2] + 2048 >> 12, d3 = s * E2[32 + S2] + 2048 >> 12, p3 = E2[16 + S2], m3 = E2[48 + S2], g2 = h * (E2[8 + S2] - E2[56 + S2]) + 2048 >> 12, y2 = h * (E2[8 + S2] + E2[56 + S2]) + 2048 >> 12, b2 = E2[24 + S2], _2 = E2[40 + S2], w2 = c3 - d3 + 1 >> 1, c3 = c3 + d3 + 1 >> 1, d3 = w2, w2 = p3 * o + m3 * a + 2048 >> 12, p3 = p3 * a - m3 * o + 2048 >> 12, m3 = w2, w2 = g2 - _2 + 1 >> 1, g2 = g2 + _2 + 1 >> 1, _2 = w2, w2 = y2 + b2 + 1 >> 1, b2 = y2 - b2 + 1 >> 1, y2 = w2, w2 = c3 - m3 + 1 >> 1, c3 = c3 + m3 + 1 >> 1, m3 = w2, w2 = d3 - p3 + 1 >> 1, d3 = d3 + p3 + 1 >> 1, p3 = w2, w2 = g2 * n2 + y2 * i2 + 2048 >> 12, g2 = g2 * i2 - y2 * n2 + 2048 >> 12, y2 = w2, w2 = b2 * r2 + _2 * e2 + 2048 >> 12, b2 = b2 * e2 - _2 * r2 + 2048 >> 12, _2 = w2, E2[0 + S2] = c3 + y2, E2[56 + S2] = c3 - y2, E2[8 + S2] = d3 + _2, E2[48 + S2] = d3 - _2, E2[16 + S2] = p3 + b2, E2[40 + S2] = p3 - b2, E2[24 + S2] = m3 + g2, E2[32 + S2] = m3 - g2) : (w2 = s * l3[v2 + 0] + 8192 >> 14, E2[0 + S2] = w2, E2[8 + S2] = w2, E2[16 + S2] = w2, E2[24 + S2] = w2, E2[32 + S2] = w2, E2[40 + S2] = w2, E2[48 + S2] = w2, E2[56 + S2] = w2);
                }
                for (v2 = 0; v2 < 64; ++v2) {
                  var M = 128 + (E2[v2] + 8 >> 4);
                  u3[v2] = M < 0 ? 0 : M > 255 ? 255 : M;
                }
              }
              g(m2 * p2 * 8);
              for (var w = 0; w < p2; w++) {
                var v = w << 3;
                for (u2 = 0; u2 < 8; u2++)
                  c2.push(new Uint8Array(m2));
                for (var x = 0; x < d2; x++) {
                  y(f2.blocks[w][x], _, b);
                  var E = 0, k = x << 3;
                  for (l2 = 0; l2 < 8; l2++) {
                    var S = c2[v + l2];
                    for (u2 = 0; u2 < 8; u2++)
                      S[k + u2] = _[E++];
                  }
                }
              }
              return c2;
            }
            function d(t3) {
              return t3 < 0 ? 0 : t3 > 255 ? 255 : t3;
            }
            f.prototype = { load: function(t3) {
              var e3 = new XMLHttpRequest();
              e3.open("GET", t3, true), e3.responseType = "arraybuffer", e3.onload = function() {
                var t4 = new Uint8Array(e3.response || e3.mozResponseArrayBuffer);
                this.parse(t4), this.onload && this.onload();
              }.bind(this), e3.send(null);
            }, parse: function(e3) {
              var r3 = 1e3 * this.opts.maxResolutionInMP * 1e3, i3 = 0;
              function n3() {
                var t3 = e3[i3] << 8 | e3[i3 + 1];
                return i3 += 2, t3;
              }
              function a2(t3) {
                var e4, r4, i4 = 1, n4 = 1;
                for (r4 in t3.components)
                  t3.components.hasOwnProperty(r4) && (i4 < (e4 = t3.components[r4]).h && (i4 = e4.h), n4 < e4.v && (n4 = e4.v));
                var a3 = Math.ceil(t3.samplesPerLine / 8 / i4), o3 = Math.ceil(t3.scanLines / 8 / n4);
                for (r4 in t3.components)
                  if (t3.components.hasOwnProperty(r4)) {
                    e4 = t3.components[r4];
                    var s3 = Math.ceil(Math.ceil(t3.samplesPerLine / 8) * e4.h / i4), h3 = Math.ceil(Math.ceil(t3.scanLines / 8) * e4.v / n4), f3 = a3 * e4.h, u2 = o3 * e4.v, l2 = [];
                    g(u2 * f3 * 256);
                    for (var c2 = 0; c2 < u2; c2++) {
                      for (var d3 = [], p3 = 0; p3 < f3; p3++)
                        d3.push(new Int32Array(64));
                      l2.push(d3);
                    }
                    e4.blocksPerLine = s3, e4.blocksPerColumn = h3, e4.blocks = l2;
                  }
                t3.maxH = i4, t3.maxV = n4, t3.mcusPerLine = a3, t3.mcusPerColumn = o3;
              }
              e3.length;
              var o2, s2, h2, f2, d2 = null, p2 = null, m2 = [], b = [], _ = [], y = [], w = n3(), v = -1;
              if (this.comments = [], 65496 != w)
                throw new Error("SOI not found");
              for (w = n3(); 65497 != w; ) {
                switch (w) {
                  case 65280:
                    break;
                  case 65504:
                  case 65505:
                  case 65506:
                  case 65507:
                  case 65508:
                  case 65509:
                  case 65510:
                  case 65511:
                  case 65512:
                  case 65513:
                  case 65514:
                  case 65515:
                  case 65516:
                  case 65517:
                  case 65518:
                  case 65519:
                  case 65534:
                    var x = (h2 = void 0, f2 = void 0, h2 = n3(), f2 = e3.subarray(i3, i3 + h2 - 2), i3 += f2.length, f2);
                    if (65534 === w) {
                      var E = String.fromCharCode.apply(null, x);
                      this.comments.push(E);
                    }
                    65504 === w && 74 === x[0] && 70 === x[1] && 73 === x[2] && 70 === x[3] && 0 === x[4] && (d2 = { version: { major: x[5], minor: x[6] }, densityUnits: x[7], xDensity: x[8] << 8 | x[9], yDensity: x[10] << 8 | x[11], thumbWidth: x[12], thumbHeight: x[13], thumbData: x.subarray(14, 14 + 3 * x[12] * x[13]) }), 65505 === w && 69 === x[0] && 120 === x[1] && 105 === x[2] && 102 === x[3] && 0 === x[4] && (this.exifBuffer = x.subarray(5, x.length)), 65518 === w && 65 === x[0] && 100 === x[1] && 111 === x[2] && 98 === x[3] && 101 === x[4] && 0 === x[5] && (p2 = { version: x[6], flags0: x[7] << 8 | x[8], flags1: x[9] << 8 | x[10], transformCode: x[11] });
                    break;
                  case 65499:
                    for (var k = n3() + i3 - 2; i3 < k; ) {
                      var S = e3[i3++];
                      g(256);
                      var M = new Int32Array(64);
                      if (S >> 4 == 0)
                        for (V = 0; V < 64; V++)
                          M[t2[V]] = e3[i3++];
                      else {
                        if (S >> 4 != 1)
                          throw new Error("DQT: invalid table spec");
                        for (V = 0; V < 64; V++)
                          M[t2[V]] = n3();
                      }
                      m2[15 & S] = M;
                    }
                    break;
                  case 65472:
                  case 65473:
                  case 65474:
                    n3(), (o2 = {}).extended = 65473 === w, o2.progressive = 65474 === w, o2.precision = e3[i3++], o2.scanLines = n3(), o2.samplesPerLine = n3(), o2.components = {}, o2.componentsOrder = [];
                    var A = o2.scanLines * o2.samplesPerLine;
                    if (A > r3) {
                      var I = Math.ceil((A - r3) / 1e6);
                      throw new Error(`maxResolutionInMP limit exceeded by ${I}MP`);
                    }
                    var T, B = e3[i3++];
                    for (Z = 0; Z < B; Z++) {
                      T = e3[i3];
                      var R = e3[i3 + 1] >> 4, P = 15 & e3[i3 + 1], O = e3[i3 + 2];
                      if (R <= 0 || P <= 0)
                        throw new Error("Invalid sampling factor, expected values above 0");
                      o2.componentsOrder.push(T), o2.components[T] = { h: R, v: P, quantizationIdx: O }, i3 += 3;
                    }
                    a2(o2), b.push(o2);
                    break;
                  case 65476:
                    var L = n3();
                    for (Z = 2; Z < L; ) {
                      var C = e3[i3++], U = new Uint8Array(16), D = 0;
                      for (V = 0; V < 16; V++, i3++)
                        D += U[V] = e3[i3];
                      g(16 + D);
                      var z = new Uint8Array(D);
                      for (V = 0; V < D; V++, i3++)
                        z[V] = e3[i3];
                      Z += 17 + D, (C >> 4 == 0 ? y : _)[15 & C] = u(U, z);
                    }
                    break;
                  case 65501:
                    n3(), s2 = n3();
                    break;
                  case 65500:
                    n3(), n3();
                    break;
                  case 65498:
                    n3();
                    var N = e3[i3++], F = [];
                    for (Z = 0; Z < N; Z++) {
                      X = o2.components[e3[i3++]];
                      var j = e3[i3++];
                      X.huffmanTableDC = y[j >> 4], X.huffmanTableAC = _[15 & j], F.push(X);
                    }
                    var G = e3[i3++], H = e3[i3++], W = e3[i3++], q = l(e3, i3, o2, F, s2, G, H, W >> 4, 15 & W, this.opts);
                    i3 += q;
                    break;
                  case 65535:
                    255 !== e3[i3] && i3--;
                    break;
                  default:
                    if (255 == e3[i3 - 3] && e3[i3 - 2] >= 192 && e3[i3 - 2] <= 254) {
                      i3 -= 3;
                      break;
                    }
                    if (224 === w || 225 == w) {
                      if (-1 !== v)
                        throw new Error(`first unknown JPEG marker at offset ${v.toString(16)}, second unknown JPEG marker ${w.toString(16)} at offset ${(i3 - 1).toString(16)}`);
                      v = i3 - 1;
                      const t3 = n3();
                      if (255 === e3[i3 + t3 - 2]) {
                        i3 += t3 - 2;
                        break;
                      }
                    }
                    throw new Error("unknown JPEG marker " + w.toString(16));
                }
                w = n3();
              }
              if (1 != b.length)
                throw new Error("only single frame JPEGs supported");
              for (var Z = 0; Z < b.length; Z++) {
                var Y = b[Z].components;
                for (var V in Y)
                  Y[V].quantizationTable = m2[Y[V].quantizationIdx], delete Y[V].quantizationIdx;
              }
              for (this.width = o2.samplesPerLine, this.height = o2.scanLines, this.jfif = d2, this.adobe = p2, this.components = [], Z = 0; Z < o2.componentsOrder.length; Z++) {
                var X = o2.components[o2.componentsOrder[Z]];
                this.components.push({ lines: c(0, X), scaleX: X.h / o2.maxH, scaleY: X.v / o2.maxV });
              }
            }, getData: function(t3, e3) {
              var r3, i3, n3, a2, o2, s2, h2, f2, u2, l2, c2, p2, m2, b, _, y, w, v, x, E, k, S = this.width / t3, M = this.height / e3, A = 0, I = t3 * e3 * this.components.length;
              g(I);
              var T = new Uint8Array(I);
              switch (this.components.length) {
                case 1:
                  for (r3 = this.components[0], l2 = 0; l2 < e3; l2++)
                    for (o2 = r3.lines[0 | l2 * r3.scaleY * M], u2 = 0; u2 < t3; u2++)
                      c2 = o2[0 | u2 * r3.scaleX * S], T[A++] = c2;
                  break;
                case 2:
                  for (r3 = this.components[0], i3 = this.components[1], l2 = 0; l2 < e3; l2++)
                    for (o2 = r3.lines[0 | l2 * r3.scaleY * M], s2 = i3.lines[0 | l2 * i3.scaleY * M], u2 = 0; u2 < t3; u2++)
                      c2 = o2[0 | u2 * r3.scaleX * S], T[A++] = c2, c2 = s2[0 | u2 * i3.scaleX * S], T[A++] = c2;
                  break;
                case 3:
                  for (k = true, this.adobe && this.adobe.transformCode ? k = true : void 0 !== this.opts.colorTransform && (k = !!this.opts.colorTransform), r3 = this.components[0], i3 = this.components[1], n3 = this.components[2], l2 = 0; l2 < e3; l2++)
                    for (o2 = r3.lines[0 | l2 * r3.scaleY * M], s2 = i3.lines[0 | l2 * i3.scaleY * M], h2 = n3.lines[0 | l2 * n3.scaleY * M], u2 = 0; u2 < t3; u2++)
                      k ? (c2 = o2[0 | u2 * r3.scaleX * S], p2 = s2[0 | u2 * i3.scaleX * S], v = d(c2 + 1.402 * ((m2 = h2[0 | u2 * n3.scaleX * S]) - 128)), x = d(c2 - 0.3441363 * (p2 - 128) - 0.71413636 * (m2 - 128)), E = d(c2 + 1.772 * (p2 - 128))) : (v = o2[0 | u2 * r3.scaleX * S], x = s2[0 | u2 * i3.scaleX * S], E = h2[0 | u2 * n3.scaleX * S]), T[A++] = v, T[A++] = x, T[A++] = E;
                  break;
                case 4:
                  if (!this.adobe)
                    throw new Error("Unsupported color mode (4 components)");
                  for (k = false, this.adobe && this.adobe.transformCode ? k = true : void 0 !== this.opts.colorTransform && (k = !!this.opts.colorTransform), r3 = this.components[0], i3 = this.components[1], n3 = this.components[2], a2 = this.components[3], l2 = 0; l2 < e3; l2++)
                    for (o2 = r3.lines[0 | l2 * r3.scaleY * M], s2 = i3.lines[0 | l2 * i3.scaleY * M], h2 = n3.lines[0 | l2 * n3.scaleY * M], f2 = a2.lines[0 | l2 * a2.scaleY * M], u2 = 0; u2 < t3; u2++)
                      k ? (c2 = o2[0 | u2 * r3.scaleX * S], p2 = s2[0 | u2 * i3.scaleX * S], m2 = h2[0 | u2 * n3.scaleX * S], b = f2[0 | u2 * a2.scaleX * S], _ = 255 - d(c2 + 1.402 * (m2 - 128)), y = 255 - d(c2 - 0.3441363 * (p2 - 128) - 0.71413636 * (m2 - 128)), w = 255 - d(c2 + 1.772 * (p2 - 128))) : (_ = o2[0 | u2 * r3.scaleX * S], y = s2[0 | u2 * i3.scaleX * S], w = h2[0 | u2 * n3.scaleX * S], b = f2[0 | u2 * a2.scaleX * S]), T[A++] = 255 - _, T[A++] = 255 - y, T[A++] = 255 - w, T[A++] = 255 - b;
                  break;
                default:
                  throw new Error("Unsupported color mode");
              }
              return T;
            }, copyToImageData: function(t3, e3) {
              var r3, i3, n3, a2, o2, s2, h2, f2, u2, l2 = t3.width, c2 = t3.height, p2 = t3.data, m2 = this.getData(l2, c2), g2 = 0, b = 0;
              switch (this.components.length) {
                case 1:
                  for (i3 = 0; i3 < c2; i3++)
                    for (r3 = 0; r3 < l2; r3++)
                      n3 = m2[g2++], p2[b++] = n3, p2[b++] = n3, p2[b++] = n3, e3 && (p2[b++] = 255);
                  break;
                case 3:
                  for (i3 = 0; i3 < c2; i3++)
                    for (r3 = 0; r3 < l2; r3++)
                      h2 = m2[g2++], f2 = m2[g2++], u2 = m2[g2++], p2[b++] = h2, p2[b++] = f2, p2[b++] = u2, e3 && (p2[b++] = 255);
                  break;
                case 4:
                  for (i3 = 0; i3 < c2; i3++)
                    for (r3 = 0; r3 < l2; r3++)
                      o2 = m2[g2++], s2 = m2[g2++], n3 = m2[g2++], h2 = 255 - d(o2 * (1 - (a2 = m2[g2++]) / 255) + a2), f2 = 255 - d(s2 * (1 - a2 / 255) + a2), u2 = 255 - d(n3 * (1 - a2 / 255) + a2), p2[b++] = h2, p2[b++] = f2, p2[b++] = u2, e3 && (p2[b++] = 255);
                  break;
                default:
                  throw new Error("Unsupported color mode");
              }
            } };
            var p = 0, m = 0;
            function g(t3 = 0) {
              var e3 = p + t3;
              if (e3 > m) {
                var r3 = Math.ceil((e3 - m) / 1024 / 1024);
                throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${r3}MB`);
              }
              p = e3;
            }
            return f.resetMaxMemoryUsage = function(t3) {
              p = 0, m = t3;
            }, f.getBytesAllocated = function() {
              return p;
            }, f.requestMemoryAllocation = g, f;
          }();
          t.exports = function(t2, e2 = {}) {
            var r2 = { colorTransform: void 0, useTArray: false, formatAsRGBA: true, tolerantDecoding: true, maxResolutionInMP: 100, maxMemoryUsageInMB: 512, ...e2 }, a = new Uint8Array(t2), o = new n();
            o.opts = r2, n.resetMaxMemoryUsage(1024 * r2.maxMemoryUsageInMB * 1024), o.parse(a);
            var s = r2.formatAsRGBA ? 4 : 3, h = o.width * o.height * s;
            try {
              n.requestMemoryAllocation(h);
              var f = { width: o.width, height: o.height, exifBuffer: o.exifBuffer, data: r2.useTArray ? new Uint8Array(h) : i.alloc(h) };
              o.comments.length > 0 && (f.comments = o.comments);
            } catch (t3) {
              if (t3 instanceof RangeError)
                throw new Error("Could not allocate enough memory for the image. Required: " + h);
              if (t3 instanceof ReferenceError && "Buffer is not defined" === t3.message)
                throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
              throw t3;
            }
            return o.copyToImageData(f, r2.formatAsRGBA), f;
          };
        }, 706: (t, e, r) => {
          var i = r(8834).lW;
          function n(t2) {
            Math.round;
            var e2, r2, n2, a, o, s = Math.floor, h = new Array(64), f = new Array(64), u = new Array(64), l = new Array(64), c = new Array(65535), d = new Array(65535), p = new Array(64), m = new Array(64), g = [], b = 0, _ = 7, y = new Array(64), w = new Array(64), v = new Array(64), x = new Array(256), E = new Array(2048), k = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], S = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], M = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], A = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], I = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], T = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], B = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], R = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], P = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
            function O(t3, e3) {
              for (var r3 = 0, i2 = 0, n3 = new Array(), a2 = 1; a2 <= 16; a2++) {
                for (var o2 = 1; o2 <= t3[a2]; o2++)
                  n3[e3[i2]] = [], n3[e3[i2]][0] = r3, n3[e3[i2]][1] = a2, i2++, r3++;
                r3 *= 2;
              }
              return n3;
            }
            function L(t3) {
              for (var e3 = t3[0], r3 = t3[1] - 1; r3 >= 0; )
                e3 & 1 << r3 && (b |= 1 << _), r3--, --_ < 0 && (255 == b ? (C(255), C(0)) : C(b), _ = 7, b = 0);
            }
            function C(t3) {
              g.push(t3);
            }
            function U(t3) {
              C(t3 >> 8 & 255), C(255 & t3);
            }
            function D(t3, e3, r3, i2, n3) {
              for (var a2, o2 = n3[0], s2 = n3[240], h2 = function(t4, e4) {
                var r4, i3, n4, a3, o3, s3, h3, f3, u3, l3, c2 = 0;
                for (u3 = 0; u3 < 8; ++u3) {
                  r4 = t4[c2], i3 = t4[c2 + 1], n4 = t4[c2 + 2], a3 = t4[c2 + 3], o3 = t4[c2 + 4], s3 = t4[c2 + 5], h3 = t4[c2 + 6];
                  var d2 = r4 + (f3 = t4[c2 + 7]), m2 = r4 - f3, g3 = i3 + h3, b3 = i3 - h3, _3 = n4 + s3, y3 = n4 - s3, w3 = a3 + o3, v2 = a3 - o3, x2 = d2 + w3, E2 = d2 - w3, k2 = g3 + _3, S2 = g3 - _3;
                  t4[c2] = x2 + k2, t4[c2 + 4] = x2 - k2;
                  var M2 = 0.707106781 * (S2 + E2);
                  t4[c2 + 2] = E2 + M2, t4[c2 + 6] = E2 - M2;
                  var A2 = 0.382683433 * ((x2 = v2 + y3) - (S2 = b3 + m2)), I2 = 0.5411961 * x2 + A2, T2 = 1.306562965 * S2 + A2, B2 = 0.707106781 * (k2 = y3 + b3), R2 = m2 + B2, P2 = m2 - B2;
                  t4[c2 + 5] = P2 + I2, t4[c2 + 3] = P2 - I2, t4[c2 + 1] = R2 + T2, t4[c2 + 7] = R2 - T2, c2 += 8;
                }
                for (c2 = 0, u3 = 0; u3 < 8; ++u3) {
                  r4 = t4[c2], i3 = t4[c2 + 8], n4 = t4[c2 + 16], a3 = t4[c2 + 24], o3 = t4[c2 + 32], s3 = t4[c2 + 40], h3 = t4[c2 + 48];
                  var O2 = r4 + (f3 = t4[c2 + 56]), L2 = r4 - f3, C2 = i3 + h3, U2 = i3 - h3, D2 = n4 + s3, z2 = n4 - s3, N = a3 + o3, F = a3 - o3, j = O2 + N, G = O2 - N, H = C2 + D2, W = C2 - D2;
                  t4[c2] = j + H, t4[c2 + 32] = j - H;
                  var q = 0.707106781 * (W + G);
                  t4[c2 + 16] = G + q, t4[c2 + 48] = G - q;
                  var Z = 0.382683433 * ((j = F + z2) - (W = U2 + L2)), Y = 0.5411961 * j + Z, V = 1.306562965 * W + Z, X = 0.707106781 * (H = z2 + U2), Q = L2 + X, J = L2 - X;
                  t4[c2 + 40] = J + Y, t4[c2 + 24] = J - Y, t4[c2 + 8] = Q + V, t4[c2 + 56] = Q - V, c2++;
                }
                for (u3 = 0; u3 < 64; ++u3)
                  l3 = t4[u3] * e4[u3], p[u3] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
                return p;
              }(t3, e3), f2 = 0; f2 < 64; ++f2)
                m[k[f2]] = h2[f2];
              var u2 = m[0] - r3;
              r3 = m[0], 0 == u2 ? L(i2[0]) : (L(i2[d[a2 = 32767 + u2]]), L(c[a2]));
              for (var l2 = 63; l2 > 0 && 0 == m[l2]; l2--)
                ;
              if (0 == l2)
                return L(o2), r3;
              for (var g2, b2 = 1; b2 <= l2; ) {
                for (var _2 = b2; 0 == m[b2] && b2 <= l2; ++b2)
                  ;
                var y2 = b2 - _2;
                if (y2 >= 16) {
                  g2 = y2 >> 4;
                  for (var w2 = 1; w2 <= g2; ++w2)
                    L(s2);
                  y2 &= 15;
                }
                a2 = 32767 + m[b2], L(n3[(y2 << 4) + d[a2]]), L(c[a2]), b2++;
              }
              return 63 != l2 && L(o2), r3;
            }
            function z(t3) {
              t3 <= 0 && (t3 = 1), t3 > 100 && (t3 = 100), o != t3 && (function(t4) {
                for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0; r3 < 64; r3++) {
                  var i2 = s((e3[r3] * t4 + 50) / 100);
                  i2 < 1 ? i2 = 1 : i2 > 255 && (i2 = 255), h[k[r3]] = i2;
                }
                for (var n3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a2 = 0; a2 < 64; a2++) {
                  var o2 = s((n3[a2] * t4 + 50) / 100);
                  o2 < 1 ? o2 = 1 : o2 > 255 && (o2 = 255), f[k[a2]] = o2;
                }
                for (var c2 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d2 = 0, p2 = 0; p2 < 8; p2++)
                  for (var m2 = 0; m2 < 8; m2++)
                    u[d2] = 1 / (h[k[d2]] * c2[p2] * c2[m2] * 8), l[d2] = 1 / (f[k[d2]] * c2[p2] * c2[m2] * 8), d2++;
              }(t3 < 50 ? Math.floor(5e3 / t3) : Math.floor(200 - 2 * t3)), o = t3);
            }
            this.encode = function(t3, o2) {
              var s2;
              (/* @__PURE__ */ new Date()).getTime(), o2 && z(o2), g = new Array(), b = 0, _ = 7, U(65496), U(65504), U(16), C(74), C(70), C(73), C(70), C(0), C(1), C(1), C(0), U(1), U(1), C(0), C(0), void 0 !== (s2 = t3.comments) && s2.constructor === Array && s2.forEach((t4) => {
                if ("string" == typeof t4) {
                  U(65534);
                  var e3, r3 = t4.length;
                  for (U(r3 + 2), e3 = 0; e3 < r3; e3++)
                    C(t4.charCodeAt(e3));
                }
              }), function(t4) {
                if (t4) {
                  U(65505), 69 === t4[0] && 120 === t4[1] && 105 === t4[2] && 102 === t4[3] ? U(t4.length + 2) : (U(t4.length + 5 + 2), C(69), C(120), C(105), C(102), C(0));
                  for (var e3 = 0; e3 < t4.length; e3++)
                    C(t4[e3]);
                }
              }(t3.exifBuffer), function() {
                U(65499), U(132), C(0);
                for (var t4 = 0; t4 < 64; t4++)
                  C(h[t4]);
                C(1);
                for (var e3 = 0; e3 < 64; e3++)
                  C(f[e3]);
              }(), function(t4, e3) {
                U(65472), U(17), C(8), U(e3), U(t4), C(3), C(1), C(17), C(0), C(2), C(17), C(1), C(3), C(17), C(1);
              }(t3.width, t3.height), function() {
                U(65476), U(418), C(0);
                for (var t4 = 0; t4 < 16; t4++)
                  C(S[t4 + 1]);
                for (var e3 = 0; e3 <= 11; e3++)
                  C(M[e3]);
                C(16);
                for (var r3 = 0; r3 < 16; r3++)
                  C(A[r3 + 1]);
                for (var i2 = 0; i2 <= 161; i2++)
                  C(I[i2]);
                C(1);
                for (var n3 = 0; n3 < 16; n3++)
                  C(T[n3 + 1]);
                for (var a2 = 0; a2 <= 11; a2++)
                  C(B[a2]);
                C(17);
                for (var o3 = 0; o3 < 16; o3++)
                  C(R[o3 + 1]);
                for (var s3 = 0; s3 <= 161; s3++)
                  C(P[s3]);
              }(), U(65498), U(12), C(3), C(1), C(0), C(2), C(17), C(3), C(17), C(0), C(63), C(0);
              var c2 = 0, d2 = 0, p2 = 0;
              b = 0, _ = 7, this.encode.displayName = "_encode_";
              for (var m2, x2, k2, O2, N, F, j, G, H, W = t3.data, q = t3.width, Z = t3.height, Y = 4 * q, V = 0; V < Z; ) {
                for (m2 = 0; m2 < Y; ) {
                  for (F = N = Y * V + m2, j = -1, G = 0, H = 0; H < 64; H++)
                    F = N + (G = H >> 3) * Y + (j = 4 * (7 & H)), V + G >= Z && (F -= Y * (V + 1 + G - Z)), m2 + j >= Y && (F -= m2 + j - Y + 4), x2 = W[F++], k2 = W[F++], O2 = W[F++], y[H] = (E[x2] + E[k2 + 256 >> 0] + E[O2 + 512 >> 0] >> 16) - 128, w[H] = (E[x2 + 768 >> 0] + E[k2 + 1024 >> 0] + E[O2 + 1280 >> 0] >> 16) - 128, v[H] = (E[x2 + 1280 >> 0] + E[k2 + 1536 >> 0] + E[O2 + 1792 >> 0] >> 16) - 128;
                  c2 = D(y, u, c2, e2, n2), d2 = D(w, l, d2, r2, a), p2 = D(v, l, p2, r2, a), m2 += 32;
                }
                V += 8;
              }
              if (_ >= 0) {
                var X = [];
                X[1] = _ + 1, X[0] = (1 << _ + 1) - 1, L(X);
              }
              return U(65497), i.from(g);
            }, (/* @__PURE__ */ new Date()).getTime(), t2 || (t2 = 50), function() {
              for (var t3 = String.fromCharCode, e3 = 0; e3 < 256; e3++)
                x[e3] = t3(e3);
            }(), e2 = O(S, M), r2 = O(T, B), n2 = O(A, I), a = O(R, P), function() {
              for (var t3 = 1, e3 = 2, r3 = 1; r3 <= 15; r3++) {
                for (var i2 = t3; i2 < e3; i2++)
                  d[32767 + i2] = r3, c[32767 + i2] = [], c[32767 + i2][1] = r3, c[32767 + i2][0] = i2;
                for (var n3 = -(e3 - 1); n3 <= -t3; n3++)
                  d[32767 + n3] = r3, c[32767 + n3] = [], c[32767 + n3][1] = r3, c[32767 + n3][0] = e3 - 1 + n3;
                t3 <<= 1, e3 <<= 1;
              }
            }(), function() {
              for (var t3 = 0; t3 < 256; t3++)
                E[t3] = 19595 * t3, E[t3 + 256 >> 0] = 38470 * t3, E[t3 + 512 >> 0] = 7471 * t3 + 32768, E[t3 + 768 >> 0] = -11059 * t3, E[t3 + 1024 >> 0] = -21709 * t3, E[t3 + 1280 >> 0] = 32768 * t3 + 8421375, E[t3 + 1536 >> 0] = -27439 * t3, E[t3 + 1792 >> 0] = -5329 * t3;
            }(), z(t2), (/* @__PURE__ */ new Date()).getTime();
          }
          t.exports = function(t2, e2) {
            return void 0 === e2 && (e2 = 50), { data: new n(e2).encode(t2, e2), width: t2.width, height: t2.height };
          };
        }, 8058: (t, e, r) => {
          var i = r(8834).lW, n = r(6290), a = function() {
          }, o = r(4398), s = r(5947), h = r(8438), f = r(5565), u = r(1960), l = self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
          t.exports = function(t2, e2) {
            e2 = "function" == typeof e2 ? e2 : a, "string" == typeof t2 ? t2 = { uri: t2 } : t2 || (t2 = {}), t2.binary && (t2 = function(t3) {
              if (l)
                return u(t3, { responseType: "arraybuffer" });
              if (void 0 === self.XMLHttpRequest)
                throw new Error("your browser does not support XHR loading");
              var e3 = new self.XMLHttpRequest();
              return e3.overrideMimeType("text/plain; charset=x-user-defined"), u({ xhr: e3 }, t3);
            }(t2)), n(t2, function(r2, n2, u2) {
              if (r2)
                return e2(r2);
              if (!/^2/.test(n2.statusCode))
                return e2(new Error("http status code: " + n2.statusCode));
              if (!u2)
                return e2(new Error("no body result"));
              var l2, c, d = false;
              if (l2 = u2, "[object ArrayBuffer]" === Object.prototype.toString.call(l2)) {
                var p = new Uint8Array(u2);
                u2 = i.from(p, "binary");
              }
              f(u2) && (d = true, "string" == typeof u2 && (u2 = i.from(u2, "binary"))), d || (i.isBuffer(u2) && (u2 = u2.toString(t2.encoding)), u2 = u2.trim());
              try {
                var m = n2.headers["content-type"];
                c = d ? h(u2) : /json/.test(m) || "{" === u2.charAt(0) ? JSON.parse(u2) : /xml/.test(m) || "<" === u2.charAt(0) ? s(u2) : o(u2);
              } catch (t3) {
                e2(new Error("error parsing font " + t3.message)), e2 = a;
              }
              e2(null, c);
            });
          };
        }, 5565: (t, e, r) => {
          var i = r(8834).lW, n = r(5137), a = i.from([66, 77, 70, 3]);
          t.exports = function(t2) {
            return "string" == typeof t2 ? "BMF" === t2.substring(0, 3) : t2.length > 4 && n(t2.slice(0, 4), a);
          };
        }, 63: (t, e) => {
          "use strict";
          function r(t2, e2, r2, i) {
            for (var n = t2[e2++], a = 1 << n, o = a + 1, s = o + 1, h = n + 1, f = (1 << h) - 1, u = 0, l = 0, c = 0, d = t2[e2++], p = new Int32Array(4096), m = null; ; ) {
              for (; u < 16 && 0 !== d; )
                l |= t2[e2++] << u, u += 8, 1 === d ? d = t2[e2++] : --d;
              if (u < h)
                break;
              var g = l & f;
              if (l >>= h, u -= h, g !== a) {
                if (g === o)
                  break;
                for (var b = g < s ? g : m, _ = 0, y = b; y > a; )
                  y = p[y] >> 8, ++_;
                var w = y;
                if (c + _ + (b !== g ? 1 : 0) > i)
                  return void console.log("Warning, gif stream longer than expected.");
                r2[c++] = w;
                var v = c += _;
                for (b !== g && (r2[c++] = w), y = b; _--; )
                  y = p[y], r2[--v] = 255 & y, y >>= 8;
                null !== m && s < 4096 && (p[s++] = m << 8 | w, s >= f + 1 && h < 12 && (++h, f = f << 1 | 1)), m = g;
              } else
                s = o + 1, f = (1 << (h = n + 1)) - 1, m = null;
            }
            return c !== i && console.log("Warning, gif stream shorter than expected."), r2;
          }
          try {
            e.N = function(t2) {
              var e2 = 0;
              if (71 !== t2[e2++] || 73 !== t2[e2++] || 70 !== t2[e2++] || 56 !== t2[e2++] || 56 != (t2[e2++] + 1 & 253) || 97 !== t2[e2++])
                throw new Error("Invalid GIF 87a/89a header.");
              var i = t2[e2++] | t2[e2++] << 8, n = t2[e2++] | t2[e2++] << 8, a = t2[e2++], o = a >> 7, s = 1 << 1 + (7 & a);
              t2[e2++], t2[e2++];
              var h = null, f = null;
              o && (h = e2, f = s, e2 += 3 * s);
              var u = true, l = [], c = 0, d = null, p = 0, m = null;
              for (this.width = i, this.height = n; u && e2 < t2.length; )
                switch (t2[e2++]) {
                  case 33:
                    switch (t2[e2++]) {
                      case 255:
                        if (11 !== t2[e2] || 78 == t2[e2 + 1] && 69 == t2[e2 + 2] && 84 == t2[e2 + 3] && 83 == t2[e2 + 4] && 67 == t2[e2 + 5] && 65 == t2[e2 + 6] && 80 == t2[e2 + 7] && 69 == t2[e2 + 8] && 50 == t2[e2 + 9] && 46 == t2[e2 + 10] && 48 == t2[e2 + 11] && 3 == t2[e2 + 12] && 1 == t2[e2 + 13] && 0 == t2[e2 + 16])
                          e2 += 14, m = t2[e2++] | t2[e2++] << 8, e2++;
                        else
                          for (e2 += 12; ; ) {
                            if (!((I = t2[e2++]) >= 0))
                              throw Error("Invalid block size");
                            if (0 === I)
                              break;
                            e2 += I;
                          }
                        break;
                      case 249:
                        if (4 !== t2[e2++] || 0 !== t2[e2 + 4])
                          throw new Error("Invalid graphics extension block.");
                        var g = t2[e2++];
                        c = t2[e2++] | t2[e2++] << 8, d = t2[e2++], 0 == (1 & g) && (d = null), p = g >> 2 & 7, e2++;
                        break;
                      case 254:
                        for (; ; ) {
                          if (!((I = t2[e2++]) >= 0))
                            throw Error("Invalid block size");
                          if (0 === I)
                            break;
                          e2 += I;
                        }
                        break;
                      default:
                        throw new Error("Unknown graphic control label: 0x" + t2[e2 - 1].toString(16));
                    }
                    break;
                  case 44:
                    var b = t2[e2++] | t2[e2++] << 8, _ = t2[e2++] | t2[e2++] << 8, y = t2[e2++] | t2[e2++] << 8, w = t2[e2++] | t2[e2++] << 8, v = t2[e2++], x = v >> 6 & 1, E = 1 << 1 + (7 & v), k = h, S = f, M = false;
                    v >> 7 && (M = true, k = e2, S = E, e2 += 3 * E);
                    var A = e2;
                    for (e2++; ; ) {
                      var I;
                      if (!((I = t2[e2++]) >= 0))
                        throw Error("Invalid block size");
                      if (0 === I)
                        break;
                      e2 += I;
                    }
                    l.push({ x: b, y: _, width: y, height: w, has_local_palette: M, palette_offset: k, palette_size: S, data_offset: A, data_length: e2 - A, transparent_index: d, interlaced: !!x, delay: c, disposal: p });
                    break;
                  case 59:
                    u = false;
                    break;
                  default:
                    throw new Error("Unknown gif block: 0x" + t2[e2 - 1].toString(16));
                }
              this.numFrames = function() {
                return l.length;
              }, this.loopCount = function() {
                return m;
              }, this.frameInfo = function(t3) {
                if (t3 < 0 || t3 >= l.length)
                  throw new Error("Frame index out of range.");
                return l[t3];
              }, this.decodeAndBlitFrameBGRA = function(e3, n2) {
                var a2 = this.frameInfo(e3), o2 = a2.width * a2.height, s2 = new Uint8Array(o2);
                r(t2, a2.data_offset, s2, o2);
                var h2 = a2.palette_offset, f2 = a2.transparent_index;
                null === f2 && (f2 = 256);
                var u2 = a2.width, l2 = i - u2, c2 = u2, d2 = 4 * (a2.y * i + a2.x), p2 = 4 * ((a2.y + a2.height) * i + a2.x), m2 = d2, g2 = 4 * l2;
                true === a2.interlaced && (g2 += 4 * i * 7);
                for (var b2 = 8, _2 = 0, y2 = s2.length; _2 < y2; ++_2) {
                  var w2 = s2[_2];
                  if (0 === c2 && (c2 = u2, (m2 += g2) >= p2 && (g2 = 4 * l2 + 4 * i * (b2 - 1), m2 = d2 + (u2 + l2) * (b2 << 1), b2 >>= 1)), w2 === f2)
                    m2 += 4;
                  else {
                    var v2 = t2[h2 + 3 * w2], x2 = t2[h2 + 3 * w2 + 1], E2 = t2[h2 + 3 * w2 + 2];
                    n2[m2++] = E2, n2[m2++] = x2, n2[m2++] = v2, n2[m2++] = 255;
                  }
                  --c2;
                }
              }, this.decodeAndBlitFrameRGBA = function(e3, n2) {
                var a2 = this.frameInfo(e3), o2 = a2.width * a2.height, s2 = new Uint8Array(o2);
                r(t2, a2.data_offset, s2, o2);
                var h2 = a2.palette_offset, f2 = a2.transparent_index;
                null === f2 && (f2 = 256);
                var u2 = a2.width, l2 = i - u2, c2 = u2, d2 = 4 * (a2.y * i + a2.x), p2 = 4 * ((a2.y + a2.height) * i + a2.x), m2 = d2, g2 = 4 * l2;
                true === a2.interlaced && (g2 += 4 * i * 7);
                for (var b2 = 8, _2 = 0, y2 = s2.length; _2 < y2; ++_2) {
                  var w2 = s2[_2];
                  if (0 === c2 && (c2 = u2, (m2 += g2) >= p2 && (g2 = 4 * l2 + 4 * i * (b2 - 1), m2 = d2 + (u2 + l2) * (b2 << 1), b2 >>= 1)), w2 === f2)
                    m2 += 4;
                  else {
                    var v2 = t2[h2 + 3 * w2], x2 = t2[h2 + 3 * w2 + 1], E2 = t2[h2 + 3 * w2 + 2];
                    n2[m2++] = v2, n2[m2++] = x2, n2[m2++] = E2, n2[m2++] = 255;
                  }
                  --c2;
                }
              };
            };
          } catch (t2) {
          }
        }, 2845: (t, e, r) => {
          "use strict";
          var i = {};
          (0, r(9761).assign)(i, r(9880), r(1380), r(1271)), t.exports = i;
        }, 9880: (t, e, r) => {
          "use strict";
          var i = r(5789), n = r(9761), a = r(7944), o = r(2950), s = r(744), h = Object.prototype.toString, f = 0, u = -1, l = 0, c = 8;
          function d(t2) {
            if (!(this instanceof d))
              return new d(t2);
            this.options = n.assign({ level: u, method: c, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: l, to: "" }, t2 || {});
            var e2 = this.options;
            e2.raw && e2.windowBits > 0 ? e2.windowBits = -e2.windowBits : e2.gzip && e2.windowBits > 0 && e2.windowBits < 16 && (e2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
            var r2 = i.deflateInit2(this.strm, e2.level, e2.method, e2.windowBits, e2.memLevel, e2.strategy);
            if (r2 !== f)
              throw new Error(o[r2]);
            if (e2.header && i.deflateSetHeader(this.strm, e2.header), e2.dictionary) {
              var p2;
              if (p2 = "string" == typeof e2.dictionary ? a.string2buf(e2.dictionary) : "[object ArrayBuffer]" === h.call(e2.dictionary) ? new Uint8Array(e2.dictionary) : e2.dictionary, (r2 = i.deflateSetDictionary(this.strm, p2)) !== f)
                throw new Error(o[r2]);
              this._dict_set = true;
            }
          }
          function p(t2, e2) {
            var r2 = new d(e2);
            if (r2.push(t2, true), r2.err)
              throw r2.msg || o[r2.err];
            return r2.result;
          }
          d.prototype.push = function(t2, e2) {
            var r2, o2, s2 = this.strm, u2 = this.options.chunkSize;
            if (this.ended)
              return false;
            o2 = e2 === ~~e2 ? e2 : true === e2 ? 4 : 0, "string" == typeof t2 ? s2.input = a.string2buf(t2) : "[object ArrayBuffer]" === h.call(t2) ? s2.input = new Uint8Array(t2) : s2.input = t2, s2.next_in = 0, s2.avail_in = s2.input.length;
            do {
              if (0 === s2.avail_out && (s2.output = new n.Buf8(u2), s2.next_out = 0, s2.avail_out = u2), 1 !== (r2 = i.deflate(s2, o2)) && r2 !== f)
                return this.onEnd(r2), this.ended = true, false;
              0 !== s2.avail_out && (0 !== s2.avail_in || 4 !== o2 && 2 !== o2) || ("string" === this.options.to ? this.onData(a.buf2binstring(n.shrinkBuf(s2.output, s2.next_out))) : this.onData(n.shrinkBuf(s2.output, s2.next_out)));
            } while ((s2.avail_in > 0 || 0 === s2.avail_out) && 1 !== r2);
            return 4 === o2 ? (r2 = i.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === f) : 2 !== o2 || (this.onEnd(f), s2.avail_out = 0, true);
          }, d.prototype.onData = function(t2) {
            this.chunks.push(t2);
          }, d.prototype.onEnd = function(t2) {
            t2 === f && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = n.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
          }, e.Deflate = d, e.deflate = p, e.deflateRaw = function(t2, e2) {
            return (e2 = e2 || {}).raw = true, p(t2, e2);
          }, e.gzip = function(t2, e2) {
            return (e2 = e2 || {}).gzip = true, p(t2, e2);
          };
        }, 1380: (t, e, r) => {
          "use strict";
          var i = r(5020), n = r(9761), a = r(7944), o = r(1271), s = r(2950), h = r(744), f = r(7357), u = Object.prototype.toString;
          function l(t2) {
            if (!(this instanceof l))
              return new l(t2);
            this.options = n.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t2 || {});
            var e2 = this.options;
            e2.raw && e2.windowBits >= 0 && e2.windowBits < 16 && (e2.windowBits = -e2.windowBits, 0 === e2.windowBits && (e2.windowBits = -15)), !(e2.windowBits >= 0 && e2.windowBits < 16) || t2 && t2.windowBits || (e2.windowBits += 32), e2.windowBits > 15 && e2.windowBits < 48 && 0 == (15 & e2.windowBits) && (e2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
            var r2 = i.inflateInit2(this.strm, e2.windowBits);
            if (r2 !== o.Z_OK)
              throw new Error(s[r2]);
            if (this.header = new f(), i.inflateGetHeader(this.strm, this.header), e2.dictionary && ("string" == typeof e2.dictionary ? e2.dictionary = a.string2buf(e2.dictionary) : "[object ArrayBuffer]" === u.call(e2.dictionary) && (e2.dictionary = new Uint8Array(e2.dictionary)), e2.raw && (r2 = i.inflateSetDictionary(this.strm, e2.dictionary)) !== o.Z_OK))
              throw new Error(s[r2]);
          }
          function c(t2, e2) {
            var r2 = new l(e2);
            if (r2.push(t2, true), r2.err)
              throw r2.msg || s[r2.err];
            return r2.result;
          }
          l.prototype.push = function(t2, e2) {
            var r2, s2, h2, f2, l2, c2 = this.strm, d = this.options.chunkSize, p = this.options.dictionary, m = false;
            if (this.ended)
              return false;
            s2 = e2 === ~~e2 ? e2 : true === e2 ? o.Z_FINISH : o.Z_NO_FLUSH, "string" == typeof t2 ? c2.input = a.binstring2buf(t2) : "[object ArrayBuffer]" === u.call(t2) ? c2.input = new Uint8Array(t2) : c2.input = t2, c2.next_in = 0, c2.avail_in = c2.input.length;
            do {
              if (0 === c2.avail_out && (c2.output = new n.Buf8(d), c2.next_out = 0, c2.avail_out = d), (r2 = i.inflate(c2, o.Z_NO_FLUSH)) === o.Z_NEED_DICT && p && (r2 = i.inflateSetDictionary(this.strm, p)), r2 === o.Z_BUF_ERROR && true === m && (r2 = o.Z_OK, m = false), r2 !== o.Z_STREAM_END && r2 !== o.Z_OK)
                return this.onEnd(r2), this.ended = true, false;
              c2.next_out && (0 !== c2.avail_out && r2 !== o.Z_STREAM_END && (0 !== c2.avail_in || s2 !== o.Z_FINISH && s2 !== o.Z_SYNC_FLUSH) || ("string" === this.options.to ? (h2 = a.utf8border(c2.output, c2.next_out), f2 = c2.next_out - h2, l2 = a.buf2string(c2.output, h2), c2.next_out = f2, c2.avail_out = d - f2, f2 && n.arraySet(c2.output, c2.output, h2, f2, 0), this.onData(l2)) : this.onData(n.shrinkBuf(c2.output, c2.next_out)))), 0 === c2.avail_in && 0 === c2.avail_out && (m = true);
            } while ((c2.avail_in > 0 || 0 === c2.avail_out) && r2 !== o.Z_STREAM_END);
            return r2 === o.Z_STREAM_END && (s2 = o.Z_FINISH), s2 === o.Z_FINISH ? (r2 = i.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === o.Z_OK) : s2 !== o.Z_SYNC_FLUSH || (this.onEnd(o.Z_OK), c2.avail_out = 0, true);
          }, l.prototype.onData = function(t2) {
            this.chunks.push(t2);
          }, l.prototype.onEnd = function(t2) {
            t2 === o.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = n.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
          }, e.Inflate = l, e.inflate = c, e.inflateRaw = function(t2, e2) {
            return (e2 = e2 || {}).raw = true, c(t2, e2);
          }, e.ungzip = c;
        }, 9761: (t, e) => {
          "use strict";
          var r = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
          function i(t2, e2) {
            return Object.prototype.hasOwnProperty.call(t2, e2);
          }
          e.assign = function(t2) {
            for (var e2 = Array.prototype.slice.call(arguments, 1); e2.length; ) {
              var r2 = e2.shift();
              if (r2) {
                if ("object" != typeof r2)
                  throw new TypeError(r2 + "must be non-object");
                for (var n2 in r2)
                  i(r2, n2) && (t2[n2] = r2[n2]);
              }
            }
            return t2;
          }, e.shrinkBuf = function(t2, e2) {
            return t2.length === e2 ? t2 : t2.subarray ? t2.subarray(0, e2) : (t2.length = e2, t2);
          };
          var n = { arraySet: function(t2, e2, r2, i2, n2) {
            if (e2.subarray && t2.subarray)
              t2.set(e2.subarray(r2, r2 + i2), n2);
            else
              for (var a2 = 0; a2 < i2; a2++)
                t2[n2 + a2] = e2[r2 + a2];
          }, flattenChunks: function(t2) {
            var e2, r2, i2, n2, a2, o;
            for (i2 = 0, e2 = 0, r2 = t2.length; e2 < r2; e2++)
              i2 += t2[e2].length;
            for (o = new Uint8Array(i2), n2 = 0, e2 = 0, r2 = t2.length; e2 < r2; e2++)
              a2 = t2[e2], o.set(a2, n2), n2 += a2.length;
            return o;
          } }, a = { arraySet: function(t2, e2, r2, i2, n2) {
            for (var a2 = 0; a2 < i2; a2++)
              t2[n2 + a2] = e2[r2 + a2];
          }, flattenChunks: function(t2) {
            return [].concat.apply([], t2);
          } };
          e.setTyped = function(t2) {
            t2 ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, n)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, a));
          }, e.setTyped(r);
        }, 7944: (t, e, r) => {
          "use strict";
          var i = r(9761), n = true, a = true;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (t2) {
            n = false;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (t2) {
            a = false;
          }
          for (var o = new i.Buf8(256), s = 0; s < 256; s++)
            o[s] = s >= 252 ? 6 : s >= 248 ? 5 : s >= 240 ? 4 : s >= 224 ? 3 : s >= 192 ? 2 : 1;
          function h(t2, e2) {
            if (e2 < 65534 && (t2.subarray && a || !t2.subarray && n))
              return String.fromCharCode.apply(null, i.shrinkBuf(t2, e2));
            for (var r2 = "", o2 = 0; o2 < e2; o2++)
              r2 += String.fromCharCode(t2[o2]);
            return r2;
          }
          o[254] = o[254] = 1, e.string2buf = function(t2) {
            var e2, r2, n2, a2, o2, s2 = t2.length, h2 = 0;
            for (a2 = 0; a2 < s2; a2++)
              55296 == (64512 & (r2 = t2.charCodeAt(a2))) && a2 + 1 < s2 && 56320 == (64512 & (n2 = t2.charCodeAt(a2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), a2++), h2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (e2 = new i.Buf8(h2), o2 = 0, a2 = 0; o2 < h2; a2++)
              55296 == (64512 & (r2 = t2.charCodeAt(a2))) && a2 + 1 < s2 && 56320 == (64512 & (n2 = t2.charCodeAt(a2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), a2++), r2 < 128 ? e2[o2++] = r2 : r2 < 2048 ? (e2[o2++] = 192 | r2 >>> 6, e2[o2++] = 128 | 63 & r2) : r2 < 65536 ? (e2[o2++] = 224 | r2 >>> 12, e2[o2++] = 128 | r2 >>> 6 & 63, e2[o2++] = 128 | 63 & r2) : (e2[o2++] = 240 | r2 >>> 18, e2[o2++] = 128 | r2 >>> 12 & 63, e2[o2++] = 128 | r2 >>> 6 & 63, e2[o2++] = 128 | 63 & r2);
            return e2;
          }, e.buf2binstring = function(t2) {
            return h(t2, t2.length);
          }, e.binstring2buf = function(t2) {
            for (var e2 = new i.Buf8(t2.length), r2 = 0, n2 = e2.length; r2 < n2; r2++)
              e2[r2] = t2.charCodeAt(r2);
            return e2;
          }, e.buf2string = function(t2, e2) {
            var r2, i2, n2, a2, s2 = e2 || t2.length, f = new Array(2 * s2);
            for (i2 = 0, r2 = 0; r2 < s2; )
              if ((n2 = t2[r2++]) < 128)
                f[i2++] = n2;
              else if ((a2 = o[n2]) > 4)
                f[i2++] = 65533, r2 += a2 - 1;
              else {
                for (n2 &= 2 === a2 ? 31 : 3 === a2 ? 15 : 7; a2 > 1 && r2 < s2; )
                  n2 = n2 << 6 | 63 & t2[r2++], a2--;
                a2 > 1 ? f[i2++] = 65533 : n2 < 65536 ? f[i2++] = n2 : (n2 -= 65536, f[i2++] = 55296 | n2 >> 10 & 1023, f[i2++] = 56320 | 1023 & n2);
              }
            return h(f, i2);
          }, e.utf8border = function(t2, e2) {
            var r2;
            for ((e2 = e2 || t2.length) > t2.length && (e2 = t2.length), r2 = e2 - 1; r2 >= 0 && 128 == (192 & t2[r2]); )
              r2--;
            return r2 < 0 || 0 === r2 ? e2 : r2 + o[t2[r2]] > e2 ? r2 : e2;
          };
        }, 5562: (t) => {
          "use strict";
          t.exports = function(t2, e, r, i) {
            for (var n = 65535 & t2 | 0, a = t2 >>> 16 & 65535 | 0, o = 0; 0 !== r; ) {
              r -= o = r > 2e3 ? 2e3 : r;
              do {
                a = a + (n = n + e[i++] | 0) | 0;
              } while (--o);
              n %= 65521, a %= 65521;
            }
            return n | a << 16 | 0;
          };
        }, 1271: (t) => {
          "use strict";
          t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
        }, 4299: (t) => {
          "use strict";
          var e = function() {
            for (var t2, e2 = [], r = 0; r < 256; r++) {
              t2 = r;
              for (var i = 0; i < 8; i++)
                t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
              e2[r] = t2;
            }
            return e2;
          }();
          t.exports = function(t2, r, i, n) {
            var a = e, o = n + i;
            t2 ^= -1;
            for (var s = n; s < o; s++)
              t2 = t2 >>> 8 ^ a[255 & (t2 ^ r[s])];
            return -1 ^ t2;
          };
        }, 5789: (t, e, r) => {
          "use strict";
          var i, n = r(9761), a = r(9564), o = r(5562), s = r(4299), h = r(2950), f = 0, u = 4, l = 0, c = -2, d = -1, p = 1, m = 4, g = 2, b = 8, _ = 9, y = 286, w = 30, v = 19, x = 2 * y + 1, E = 15, k = 3, S = 258, M = S + k + 1, A = 42, I = 103, T = 113, B = 666, R = 1, P = 2, O = 3, L = 4;
          function C(t2, e2) {
            return t2.msg = h[e2], e2;
          }
          function U(t2) {
            return (t2 << 1) - (t2 > 4 ? 9 : 0);
          }
          function D(t2) {
            for (var e2 = t2.length; --e2 >= 0; )
              t2[e2] = 0;
          }
          function z(t2) {
            var e2 = t2.state, r2 = e2.pending;
            r2 > t2.avail_out && (r2 = t2.avail_out), 0 !== r2 && (n.arraySet(t2.output, e2.pending_buf, e2.pending_out, r2, t2.next_out), t2.next_out += r2, e2.pending_out += r2, t2.total_out += r2, t2.avail_out -= r2, e2.pending -= r2, 0 === e2.pending && (e2.pending_out = 0));
          }
          function N(t2, e2) {
            a._tr_flush_block(t2, t2.block_start >= 0 ? t2.block_start : -1, t2.strstart - t2.block_start, e2), t2.block_start = t2.strstart, z(t2.strm);
          }
          function F(t2, e2) {
            t2.pending_buf[t2.pending++] = e2;
          }
          function j(t2, e2) {
            t2.pending_buf[t2.pending++] = e2 >>> 8 & 255, t2.pending_buf[t2.pending++] = 255 & e2;
          }
          function G(t2, e2) {
            var r2, i2, n2 = t2.max_chain_length, a2 = t2.strstart, o2 = t2.prev_length, s2 = t2.nice_match, h2 = t2.strstart > t2.w_size - M ? t2.strstart - (t2.w_size - M) : 0, f2 = t2.window, u2 = t2.w_mask, l2 = t2.prev, c2 = t2.strstart + S, d2 = f2[a2 + o2 - 1], p2 = f2[a2 + o2];
            t2.prev_length >= t2.good_match && (n2 >>= 2), s2 > t2.lookahead && (s2 = t2.lookahead);
            do {
              if (f2[(r2 = e2) + o2] === p2 && f2[r2 + o2 - 1] === d2 && f2[r2] === f2[a2] && f2[++r2] === f2[a2 + 1]) {
                a2 += 2, r2++;
                do {
                } while (f2[++a2] === f2[++r2] && f2[++a2] === f2[++r2] && f2[++a2] === f2[++r2] && f2[++a2] === f2[++r2] && f2[++a2] === f2[++r2] && f2[++a2] === f2[++r2] && f2[++a2] === f2[++r2] && f2[++a2] === f2[++r2] && a2 < c2);
                if (i2 = S - (c2 - a2), a2 = c2 - S, i2 > o2) {
                  if (t2.match_start = e2, o2 = i2, i2 >= s2)
                    break;
                  d2 = f2[a2 + o2 - 1], p2 = f2[a2 + o2];
                }
              }
            } while ((e2 = l2[e2 & u2]) > h2 && 0 != --n2);
            return o2 <= t2.lookahead ? o2 : t2.lookahead;
          }
          function H(t2) {
            var e2, r2, i2, a2, h2, f2, u2, l2, c2, d2, p2 = t2.w_size;
            do {
              if (a2 = t2.window_size - t2.lookahead - t2.strstart, t2.strstart >= p2 + (p2 - M)) {
                n.arraySet(t2.window, t2.window, p2, p2, 0), t2.match_start -= p2, t2.strstart -= p2, t2.block_start -= p2, e2 = r2 = t2.hash_size;
                do {
                  i2 = t2.head[--e2], t2.head[e2] = i2 >= p2 ? i2 - p2 : 0;
                } while (--r2);
                e2 = r2 = p2;
                do {
                  i2 = t2.prev[--e2], t2.prev[e2] = i2 >= p2 ? i2 - p2 : 0;
                } while (--r2);
                a2 += p2;
              }
              if (0 === t2.strm.avail_in)
                break;
              if (f2 = t2.strm, u2 = t2.window, l2 = t2.strstart + t2.lookahead, c2 = a2, d2 = void 0, (d2 = f2.avail_in) > c2 && (d2 = c2), r2 = 0 === d2 ? 0 : (f2.avail_in -= d2, n.arraySet(u2, f2.input, f2.next_in, d2, l2), 1 === f2.state.wrap ? f2.adler = o(f2.adler, u2, d2, l2) : 2 === f2.state.wrap && (f2.adler = s(f2.adler, u2, d2, l2)), f2.next_in += d2, f2.total_in += d2, d2), t2.lookahead += r2, t2.lookahead + t2.insert >= k)
                for (h2 = t2.strstart - t2.insert, t2.ins_h = t2.window[h2], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[h2 + 1]) & t2.hash_mask; t2.insert && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[h2 + k - 1]) & t2.hash_mask, t2.prev[h2 & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = h2, h2++, t2.insert--, !(t2.lookahead + t2.insert < k)); )
                  ;
            } while (t2.lookahead < M && 0 !== t2.strm.avail_in);
          }
          function W(t2, e2) {
            for (var r2, i2; ; ) {
              if (t2.lookahead < M) {
                if (H(t2), t2.lookahead < M && e2 === f)
                  return R;
                if (0 === t2.lookahead)
                  break;
              }
              if (r2 = 0, t2.lookahead >= k && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + k - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), 0 !== r2 && t2.strstart - r2 <= t2.w_size - M && (t2.match_length = G(t2, r2)), t2.match_length >= k)
                if (i2 = a._tr_tally(t2, t2.strstart - t2.match_start, t2.match_length - k), t2.lookahead -= t2.match_length, t2.match_length <= t2.max_lazy_match && t2.lookahead >= k) {
                  t2.match_length--;
                  do {
                    t2.strstart++, t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + k - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart;
                  } while (0 != --t2.match_length);
                  t2.strstart++;
                } else
                  t2.strstart += t2.match_length, t2.match_length = 0, t2.ins_h = t2.window[t2.strstart], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 1]) & t2.hash_mask;
              else
                i2 = a._tr_tally(t2, 0, t2.window[t2.strstart]), t2.lookahead--, t2.strstart++;
              if (i2 && (N(t2, false), 0 === t2.strm.avail_out))
                return R;
            }
            return t2.insert = t2.strstart < k - 1 ? t2.strstart : k - 1, e2 === u ? (N(t2, true), 0 === t2.strm.avail_out ? O : L) : t2.last_lit && (N(t2, false), 0 === t2.strm.avail_out) ? R : P;
          }
          function q(t2, e2) {
            for (var r2, i2, n2; ; ) {
              if (t2.lookahead < M) {
                if (H(t2), t2.lookahead < M && e2 === f)
                  return R;
                if (0 === t2.lookahead)
                  break;
              }
              if (r2 = 0, t2.lookahead >= k && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + k - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), t2.prev_length = t2.match_length, t2.prev_match = t2.match_start, t2.match_length = k - 1, 0 !== r2 && t2.prev_length < t2.max_lazy_match && t2.strstart - r2 <= t2.w_size - M && (t2.match_length = G(t2, r2), t2.match_length <= 5 && (t2.strategy === p || t2.match_length === k && t2.strstart - t2.match_start > 4096) && (t2.match_length = k - 1)), t2.prev_length >= k && t2.match_length <= t2.prev_length) {
                n2 = t2.strstart + t2.lookahead - k, i2 = a._tr_tally(t2, t2.strstart - 1 - t2.prev_match, t2.prev_length - k), t2.lookahead -= t2.prev_length - 1, t2.prev_length -= 2;
                do {
                  ++t2.strstart <= n2 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + k - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart);
                } while (0 != --t2.prev_length);
                if (t2.match_available = 0, t2.match_length = k - 1, t2.strstart++, i2 && (N(t2, false), 0 === t2.strm.avail_out))
                  return R;
              } else if (t2.match_available) {
                if ((i2 = a._tr_tally(t2, 0, t2.window[t2.strstart - 1])) && N(t2, false), t2.strstart++, t2.lookahead--, 0 === t2.strm.avail_out)
                  return R;
              } else
                t2.match_available = 1, t2.strstart++, t2.lookahead--;
            }
            return t2.match_available && (i2 = a._tr_tally(t2, 0, t2.window[t2.strstart - 1]), t2.match_available = 0), t2.insert = t2.strstart < k - 1 ? t2.strstart : k - 1, e2 === u ? (N(t2, true), 0 === t2.strm.avail_out ? O : L) : t2.last_lit && (N(t2, false), 0 === t2.strm.avail_out) ? R : P;
          }
          function Z(t2, e2, r2, i2, n2) {
            this.good_length = t2, this.max_lazy = e2, this.nice_length = r2, this.max_chain = i2, this.func = n2;
          }
          function Y() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = b, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new n.Buf16(2 * x), this.dyn_dtree = new n.Buf16(2 * (2 * w + 1)), this.bl_tree = new n.Buf16(2 * (2 * v + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new n.Buf16(E + 1), this.heap = new n.Buf16(2 * y + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new n.Buf16(2 * y + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
          }
          function V(t2) {
            var e2;
            return t2 && t2.state ? (t2.total_in = t2.total_out = 0, t2.data_type = g, (e2 = t2.state).pending = 0, e2.pending_out = 0, e2.wrap < 0 && (e2.wrap = -e2.wrap), e2.status = e2.wrap ? A : T, t2.adler = 2 === e2.wrap ? 0 : 1, e2.last_flush = f, a._tr_init(e2), l) : C(t2, c);
          }
          function X(t2) {
            var e2, r2 = V(t2);
            return r2 === l && ((e2 = t2.state).window_size = 2 * e2.w_size, D(e2.head), e2.max_lazy_match = i[e2.level].max_lazy, e2.good_match = i[e2.level].good_length, e2.nice_match = i[e2.level].nice_length, e2.max_chain_length = i[e2.level].max_chain, e2.strstart = 0, e2.block_start = 0, e2.lookahead = 0, e2.insert = 0, e2.match_length = e2.prev_length = k - 1, e2.match_available = 0, e2.ins_h = 0), r2;
          }
          function Q(t2, e2, r2, i2, a2, o2) {
            if (!t2)
              return c;
            var s2 = 1;
            if (e2 === d && (e2 = 6), i2 < 0 ? (s2 = 0, i2 = -i2) : i2 > 15 && (s2 = 2, i2 -= 16), a2 < 1 || a2 > _ || r2 !== b || i2 < 8 || i2 > 15 || e2 < 0 || e2 > 9 || o2 < 0 || o2 > m)
              return C(t2, c);
            8 === i2 && (i2 = 9);
            var h2 = new Y();
            return t2.state = h2, h2.strm = t2, h2.wrap = s2, h2.gzhead = null, h2.w_bits = i2, h2.w_size = 1 << h2.w_bits, h2.w_mask = h2.w_size - 1, h2.hash_bits = a2 + 7, h2.hash_size = 1 << h2.hash_bits, h2.hash_mask = h2.hash_size - 1, h2.hash_shift = ~~((h2.hash_bits + k - 1) / k), h2.window = new n.Buf8(2 * h2.w_size), h2.head = new n.Buf16(h2.hash_size), h2.prev = new n.Buf16(h2.w_size), h2.lit_bufsize = 1 << a2 + 6, h2.pending_buf_size = 4 * h2.lit_bufsize, h2.pending_buf = new n.Buf8(h2.pending_buf_size), h2.d_buf = 1 * h2.lit_bufsize, h2.l_buf = 3 * h2.lit_bufsize, h2.level = e2, h2.strategy = o2, h2.method = r2, X(t2);
          }
          i = [new Z(0, 0, 0, 0, function(t2, e2) {
            var r2 = 65535;
            for (r2 > t2.pending_buf_size - 5 && (r2 = t2.pending_buf_size - 5); ; ) {
              if (t2.lookahead <= 1) {
                if (H(t2), 0 === t2.lookahead && e2 === f)
                  return R;
                if (0 === t2.lookahead)
                  break;
              }
              t2.strstart += t2.lookahead, t2.lookahead = 0;
              var i2 = t2.block_start + r2;
              if ((0 === t2.strstart || t2.strstart >= i2) && (t2.lookahead = t2.strstart - i2, t2.strstart = i2, N(t2, false), 0 === t2.strm.avail_out))
                return R;
              if (t2.strstart - t2.block_start >= t2.w_size - M && (N(t2, false), 0 === t2.strm.avail_out))
                return R;
            }
            return t2.insert = 0, e2 === u ? (N(t2, true), 0 === t2.strm.avail_out ? O : L) : (t2.strstart > t2.block_start && (N(t2, false), t2.strm.avail_out), R);
          }), new Z(4, 4, 8, 4, W), new Z(4, 5, 16, 8, W), new Z(4, 6, 32, 32, W), new Z(4, 4, 16, 16, q), new Z(8, 16, 32, 32, q), new Z(8, 16, 128, 128, q), new Z(8, 32, 128, 256, q), new Z(32, 128, 258, 1024, q), new Z(32, 258, 258, 4096, q)], e.deflateInit = function(t2, e2) {
            return Q(t2, e2, b, 15, 8, 0);
          }, e.deflateInit2 = Q, e.deflateReset = X, e.deflateResetKeep = V, e.deflateSetHeader = function(t2, e2) {
            return t2 && t2.state ? 2 !== t2.state.wrap ? c : (t2.state.gzhead = e2, l) : c;
          }, e.deflate = function(t2, e2) {
            var r2, n2, o2, h2;
            if (!t2 || !t2.state || e2 > 5 || e2 < 0)
              return t2 ? C(t2, c) : c;
            if (n2 = t2.state, !t2.output || !t2.input && 0 !== t2.avail_in || n2.status === B && e2 !== u)
              return C(t2, 0 === t2.avail_out ? -5 : c);
            if (n2.strm = t2, r2 = n2.last_flush, n2.last_flush = e2, n2.status === A)
              if (2 === n2.wrap)
                t2.adler = 0, F(n2, 31), F(n2, 139), F(n2, 8), n2.gzhead ? (F(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), F(n2, 255 & n2.gzhead.time), F(n2, n2.gzhead.time >> 8 & 255), F(n2, n2.gzhead.time >> 16 & 255), F(n2, n2.gzhead.time >> 24 & 255), F(n2, 9 === n2.level ? 2 : n2.strategy >= 2 || n2.level < 2 ? 4 : 0), F(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (F(n2, 255 & n2.gzhead.extra.length), F(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (t2.adler = s(t2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (F(n2, 0), F(n2, 0), F(n2, 0), F(n2, 0), F(n2, 0), F(n2, 9 === n2.level ? 2 : n2.strategy >= 2 || n2.level < 2 ? 4 : 0), F(n2, 3), n2.status = T);
              else {
                var d2 = b + (n2.w_bits - 8 << 4) << 8;
                d2 |= (n2.strategy >= 2 || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (d2 |= 32), d2 += 31 - d2 % 31, n2.status = T, j(n2, d2), 0 !== n2.strstart && (j(n2, t2.adler >>> 16), j(n2, 65535 & t2.adler)), t2.adler = 1;
              }
            if (69 === n2.status)
              if (n2.gzhead.extra) {
                for (o2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > o2 && (t2.adler = s(t2.adler, n2.pending_buf, n2.pending - o2, o2)), z(t2), o2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                  F(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
                n2.gzhead.hcrc && n2.pending > o2 && (t2.adler = s(t2.adler, n2.pending_buf, n2.pending - o2, o2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
              } else
                n2.status = 73;
            if (73 === n2.status)
              if (n2.gzhead.name) {
                o2 = n2.pending;
                do {
                  if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > o2 && (t2.adler = s(t2.adler, n2.pending_buf, n2.pending - o2, o2)), z(t2), o2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                    h2 = 1;
                    break;
                  }
                  h2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, F(n2, h2);
                } while (0 !== h2);
                n2.gzhead.hcrc && n2.pending > o2 && (t2.adler = s(t2.adler, n2.pending_buf, n2.pending - o2, o2)), 0 === h2 && (n2.gzindex = 0, n2.status = 91);
              } else
                n2.status = 91;
            if (91 === n2.status)
              if (n2.gzhead.comment) {
                o2 = n2.pending;
                do {
                  if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > o2 && (t2.adler = s(t2.adler, n2.pending_buf, n2.pending - o2, o2)), z(t2), o2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                    h2 = 1;
                    break;
                  }
                  h2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, F(n2, h2);
                } while (0 !== h2);
                n2.gzhead.hcrc && n2.pending > o2 && (t2.adler = s(t2.adler, n2.pending_buf, n2.pending - o2, o2)), 0 === h2 && (n2.status = I);
              } else
                n2.status = I;
            if (n2.status === I && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && z(t2), n2.pending + 2 <= n2.pending_buf_size && (F(n2, 255 & t2.adler), F(n2, t2.adler >> 8 & 255), t2.adler = 0, n2.status = T)) : n2.status = T), 0 !== n2.pending) {
              if (z(t2), 0 === t2.avail_out)
                return n2.last_flush = -1, l;
            } else if (0 === t2.avail_in && U(e2) <= U(r2) && e2 !== u)
              return C(t2, -5);
            if (n2.status === B && 0 !== t2.avail_in)
              return C(t2, -5);
            if (0 !== t2.avail_in || 0 !== n2.lookahead || e2 !== f && n2.status !== B) {
              var p2 = 2 === n2.strategy ? function(t3, e3) {
                for (var r3; ; ) {
                  if (0 === t3.lookahead && (H(t3), 0 === t3.lookahead)) {
                    if (e3 === f)
                      return R;
                    break;
                  }
                  if (t3.match_length = 0, r3 = a._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++, r3 && (N(t3, false), 0 === t3.strm.avail_out))
                    return R;
                }
                return t3.insert = 0, e3 === u ? (N(t3, true), 0 === t3.strm.avail_out ? O : L) : t3.last_lit && (N(t3, false), 0 === t3.strm.avail_out) ? R : P;
              }(n2, e2) : 3 === n2.strategy ? function(t3, e3) {
                for (var r3, i2, n3, o3, s2 = t3.window; ; ) {
                  if (t3.lookahead <= S) {
                    if (H(t3), t3.lookahead <= S && e3 === f)
                      return R;
                    if (0 === t3.lookahead)
                      break;
                  }
                  if (t3.match_length = 0, t3.lookahead >= k && t3.strstart > 0 && (i2 = s2[n3 = t3.strstart - 1]) === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3]) {
                    o3 = t3.strstart + S;
                    do {
                    } while (i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && n3 < o3);
                    t3.match_length = S - (o3 - n3), t3.match_length > t3.lookahead && (t3.match_length = t3.lookahead);
                  }
                  if (t3.match_length >= k ? (r3 = a._tr_tally(t3, 1, t3.match_length - k), t3.lookahead -= t3.match_length, t3.strstart += t3.match_length, t3.match_length = 0) : (r3 = a._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++), r3 && (N(t3, false), 0 === t3.strm.avail_out))
                    return R;
                }
                return t3.insert = 0, e3 === u ? (N(t3, true), 0 === t3.strm.avail_out ? O : L) : t3.last_lit && (N(t3, false), 0 === t3.strm.avail_out) ? R : P;
              }(n2, e2) : i[n2.level].func(n2, e2);
              if (p2 !== O && p2 !== L || (n2.status = B), p2 === R || p2 === O)
                return 0 === t2.avail_out && (n2.last_flush = -1), l;
              if (p2 === P && (1 === e2 ? a._tr_align(n2) : 5 !== e2 && (a._tr_stored_block(n2, 0, 0, false), 3 === e2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), z(t2), 0 === t2.avail_out))
                return n2.last_flush = -1, l;
            }
            return e2 !== u ? l : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (F(n2, 255 & t2.adler), F(n2, t2.adler >> 8 & 255), F(n2, t2.adler >> 16 & 255), F(n2, t2.adler >> 24 & 255), F(n2, 255 & t2.total_in), F(n2, t2.total_in >> 8 & 255), F(n2, t2.total_in >> 16 & 255), F(n2, t2.total_in >> 24 & 255)) : (j(n2, t2.adler >>> 16), j(n2, 65535 & t2.adler)), z(t2), n2.wrap > 0 && (n2.wrap = -n2.wrap), 0 !== n2.pending ? l : 1);
          }, e.deflateEnd = function(t2) {
            var e2;
            return t2 && t2.state ? (e2 = t2.state.status) !== A && 69 !== e2 && 73 !== e2 && 91 !== e2 && e2 !== I && e2 !== T && e2 !== B ? C(t2, c) : (t2.state = null, e2 === T ? C(t2, -3) : l) : c;
          }, e.deflateSetDictionary = function(t2, e2) {
            var r2, i2, a2, s2, h2, f2, u2, d2, p2 = e2.length;
            if (!t2 || !t2.state)
              return c;
            if (2 === (s2 = (r2 = t2.state).wrap) || 1 === s2 && r2.status !== A || r2.lookahead)
              return c;
            for (1 === s2 && (t2.adler = o(t2.adler, e2, p2, 0)), r2.wrap = 0, p2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), d2 = new n.Buf8(r2.w_size), n.arraySet(d2, e2, p2 - r2.w_size, r2.w_size, 0), e2 = d2, p2 = r2.w_size), h2 = t2.avail_in, f2 = t2.next_in, u2 = t2.input, t2.avail_in = p2, t2.next_in = 0, t2.input = e2, H(r2); r2.lookahead >= k; ) {
              i2 = r2.strstart, a2 = r2.lookahead - (k - 1);
              do {
                r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[i2 + k - 1]) & r2.hash_mask, r2.prev[i2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = i2, i2++;
              } while (--a2);
              r2.strstart = i2, r2.lookahead = k - 1, H(r2);
            }
            return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = k - 1, r2.match_available = 0, t2.next_in = f2, t2.input = u2, t2.avail_in = h2, r2.wrap = s2, l;
          }, e.deflateInfo = "pako deflate (from Nodeca project)";
        }, 7357: (t) => {
          "use strict";
          t.exports = function() {
            this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
          };
        }, 4980: (t) => {
          "use strict";
          t.exports = function(t2, e) {
            var r, i, n, a, o, s, h, f, u, l, c, d, p, m, g, b, _, y, w, v, x, E, k, S, M;
            r = t2.state, i = t2.next_in, S = t2.input, n = i + (t2.avail_in - 5), a = t2.next_out, M = t2.output, o = a - (e - t2.avail_out), s = a + (t2.avail_out - 257), h = r.dmax, f = r.wsize, u = r.whave, l = r.wnext, c = r.window, d = r.hold, p = r.bits, m = r.lencode, g = r.distcode, b = (1 << r.lenbits) - 1, _ = (1 << r.distbits) - 1;
            t:
              do {
                p < 15 && (d += S[i++] << p, p += 8, d += S[i++] << p, p += 8), y = m[d & b];
                e:
                  for (; ; ) {
                    if (d >>>= w = y >>> 24, p -= w, 0 == (w = y >>> 16 & 255))
                      M[a++] = 65535 & y;
                    else {
                      if (!(16 & w)) {
                        if (0 == (64 & w)) {
                          y = m[(65535 & y) + (d & (1 << w) - 1)];
                          continue e;
                        }
                        if (32 & w) {
                          r.mode = 12;
                          break t;
                        }
                        t2.msg = "invalid literal/length code", r.mode = 30;
                        break t;
                      }
                      v = 65535 & y, (w &= 15) && (p < w && (d += S[i++] << p, p += 8), v += d & (1 << w) - 1, d >>>= w, p -= w), p < 15 && (d += S[i++] << p, p += 8, d += S[i++] << p, p += 8), y = g[d & _];
                      r:
                        for (; ; ) {
                          if (d >>>= w = y >>> 24, p -= w, !(16 & (w = y >>> 16 & 255))) {
                            if (0 == (64 & w)) {
                              y = g[(65535 & y) + (d & (1 << w) - 1)];
                              continue r;
                            }
                            t2.msg = "invalid distance code", r.mode = 30;
                            break t;
                          }
                          if (x = 65535 & y, p < (w &= 15) && (d += S[i++] << p, (p += 8) < w && (d += S[i++] << p, p += 8)), (x += d & (1 << w) - 1) > h) {
                            t2.msg = "invalid distance too far back", r.mode = 30;
                            break t;
                          }
                          if (d >>>= w, p -= w, x > (w = a - o)) {
                            if ((w = x - w) > u && r.sane) {
                              t2.msg = "invalid distance too far back", r.mode = 30;
                              break t;
                            }
                            if (E = 0, k = c, 0 === l) {
                              if (E += f - w, w < v) {
                                v -= w;
                                do {
                                  M[a++] = c[E++];
                                } while (--w);
                                E = a - x, k = M;
                              }
                            } else if (l < w) {
                              if (E += f + l - w, (w -= l) < v) {
                                v -= w;
                                do {
                                  M[a++] = c[E++];
                                } while (--w);
                                if (E = 0, l < v) {
                                  v -= w = l;
                                  do {
                                    M[a++] = c[E++];
                                  } while (--w);
                                  E = a - x, k = M;
                                }
                              }
                            } else if (E += l - w, w < v) {
                              v -= w;
                              do {
                                M[a++] = c[E++];
                              } while (--w);
                              E = a - x, k = M;
                            }
                            for (; v > 2; )
                              M[a++] = k[E++], M[a++] = k[E++], M[a++] = k[E++], v -= 3;
                            v && (M[a++] = k[E++], v > 1 && (M[a++] = k[E++]));
                          } else {
                            E = a - x;
                            do {
                              M[a++] = M[E++], M[a++] = M[E++], M[a++] = M[E++], v -= 3;
                            } while (v > 2);
                            v && (M[a++] = M[E++], v > 1 && (M[a++] = M[E++]));
                          }
                          break;
                        }
                    }
                    break;
                  }
              } while (i < n && a < s);
            i -= v = p >> 3, d &= (1 << (p -= v << 3)) - 1, t2.next_in = i, t2.next_out = a, t2.avail_in = i < n ? n - i + 5 : 5 - (i - n), t2.avail_out = a < s ? s - a + 257 : 257 - (a - s), r.hold = d, r.bits = p;
          };
        }, 5020: (t, e, r) => {
          "use strict";
          var i = r(9761), n = r(5562), a = r(4299), o = r(4980), s = r(881), h = 1, f = 2, u = 0, l = -2, c = 1, d = 12, p = 30, m = 852, g = 592;
          function b(t2) {
            return (t2 >>> 24 & 255) + (t2 >>> 8 & 65280) + ((65280 & t2) << 8) + ((255 & t2) << 24);
          }
          function _() {
            this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i.Buf16(320), this.work = new i.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
          }
          function y(t2) {
            var e2;
            return t2 && t2.state ? (e2 = t2.state, t2.total_in = t2.total_out = e2.total = 0, t2.msg = "", e2.wrap && (t2.adler = 1 & e2.wrap), e2.mode = c, e2.last = 0, e2.havedict = 0, e2.dmax = 32768, e2.head = null, e2.hold = 0, e2.bits = 0, e2.lencode = e2.lendyn = new i.Buf32(m), e2.distcode = e2.distdyn = new i.Buf32(g), e2.sane = 1, e2.back = -1, u) : l;
          }
          function w(t2) {
            var e2;
            return t2 && t2.state ? ((e2 = t2.state).wsize = 0, e2.whave = 0, e2.wnext = 0, y(t2)) : l;
          }
          function v(t2, e2) {
            var r2, i2;
            return t2 && t2.state ? (i2 = t2.state, e2 < 0 ? (r2 = 0, e2 = -e2) : (r2 = 1 + (e2 >> 4), e2 < 48 && (e2 &= 15)), e2 && (e2 < 8 || e2 > 15) ? l : (null !== i2.window && i2.wbits !== e2 && (i2.window = null), i2.wrap = r2, i2.wbits = e2, w(t2))) : l;
          }
          function x(t2, e2) {
            var r2, i2;
            return t2 ? (i2 = new _(), t2.state = i2, i2.window = null, (r2 = v(t2, e2)) !== u && (t2.state = null), r2) : l;
          }
          var E, k, S = true;
          function M(t2) {
            if (S) {
              var e2;
              for (E = new i.Buf32(512), k = new i.Buf32(32), e2 = 0; e2 < 144; )
                t2.lens[e2++] = 8;
              for (; e2 < 256; )
                t2.lens[e2++] = 9;
              for (; e2 < 280; )
                t2.lens[e2++] = 7;
              for (; e2 < 288; )
                t2.lens[e2++] = 8;
              for (s(h, t2.lens, 0, 288, E, 0, t2.work, { bits: 9 }), e2 = 0; e2 < 32; )
                t2.lens[e2++] = 5;
              s(f, t2.lens, 0, 32, k, 0, t2.work, { bits: 5 }), S = false;
            }
            t2.lencode = E, t2.lenbits = 9, t2.distcode = k, t2.distbits = 5;
          }
          function A(t2, e2, r2, n2) {
            var a2, o2 = t2.state;
            return null === o2.window && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new i.Buf8(o2.wsize)), n2 >= o2.wsize ? (i.arraySet(o2.window, e2, r2 - o2.wsize, o2.wsize, 0), o2.wnext = 0, o2.whave = o2.wsize) : ((a2 = o2.wsize - o2.wnext) > n2 && (a2 = n2), i.arraySet(o2.window, e2, r2 - n2, a2, o2.wnext), (n2 -= a2) ? (i.arraySet(o2.window, e2, r2 - n2, n2, 0), o2.wnext = n2, o2.whave = o2.wsize) : (o2.wnext += a2, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += a2))), 0;
          }
          e.inflateReset = w, e.inflateReset2 = v, e.inflateResetKeep = y, e.inflateInit = function(t2) {
            return x(t2, 15);
          }, e.inflateInit2 = x, e.inflate = function(t2, e2) {
            var r2, m2, g2, _2, y2, w2, v2, x2, E2, k2, S2, I, T, B, R, P, O, L, C, U, D, z, N, F, j = 0, G = new i.Buf8(4), H = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            if (!t2 || !t2.state || !t2.output || !t2.input && 0 !== t2.avail_in)
              return l;
            (r2 = t2.state).mode === d && (r2.mode = 13), y2 = t2.next_out, g2 = t2.output, v2 = t2.avail_out, _2 = t2.next_in, m2 = t2.input, w2 = t2.avail_in, x2 = r2.hold, E2 = r2.bits, k2 = w2, S2 = v2, z = u;
            t:
              for (; ; )
                switch (r2.mode) {
                  case c:
                    if (0 === r2.wrap) {
                      r2.mode = 13;
                      break;
                    }
                    for (; E2 < 16; ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    if (2 & r2.wrap && 35615 === x2) {
                      r2.check = 0, G[0] = 255 & x2, G[1] = x2 >>> 8 & 255, r2.check = a(r2.check, G, 2, 0), x2 = 0, E2 = 0, r2.mode = 2;
                      break;
                    }
                    if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & x2) << 8) + (x2 >> 8)) % 31) {
                      t2.msg = "incorrect header check", r2.mode = p;
                      break;
                    }
                    if (8 != (15 & x2)) {
                      t2.msg = "unknown compression method", r2.mode = p;
                      break;
                    }
                    if (E2 -= 4, D = 8 + (15 & (x2 >>>= 4)), 0 === r2.wbits)
                      r2.wbits = D;
                    else if (D > r2.wbits) {
                      t2.msg = "invalid window size", r2.mode = p;
                      break;
                    }
                    r2.dmax = 1 << D, t2.adler = r2.check = 1, r2.mode = 512 & x2 ? 10 : d, x2 = 0, E2 = 0;
                    break;
                  case 2:
                    for (; E2 < 16; ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    if (r2.flags = x2, 8 != (255 & r2.flags)) {
                      t2.msg = "unknown compression method", r2.mode = p;
                      break;
                    }
                    if (57344 & r2.flags) {
                      t2.msg = "unknown header flags set", r2.mode = p;
                      break;
                    }
                    r2.head && (r2.head.text = x2 >> 8 & 1), 512 & r2.flags && (G[0] = 255 & x2, G[1] = x2 >>> 8 & 255, r2.check = a(r2.check, G, 2, 0)), x2 = 0, E2 = 0, r2.mode = 3;
                  case 3:
                    for (; E2 < 32; ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    r2.head && (r2.head.time = x2), 512 & r2.flags && (G[0] = 255 & x2, G[1] = x2 >>> 8 & 255, G[2] = x2 >>> 16 & 255, G[3] = x2 >>> 24 & 255, r2.check = a(r2.check, G, 4, 0)), x2 = 0, E2 = 0, r2.mode = 4;
                  case 4:
                    for (; E2 < 16; ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    r2.head && (r2.head.xflags = 255 & x2, r2.head.os = x2 >> 8), 512 & r2.flags && (G[0] = 255 & x2, G[1] = x2 >>> 8 & 255, r2.check = a(r2.check, G, 2, 0)), x2 = 0, E2 = 0, r2.mode = 5;
                  case 5:
                    if (1024 & r2.flags) {
                      for (; E2 < 16; ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      r2.length = x2, r2.head && (r2.head.extra_len = x2), 512 & r2.flags && (G[0] = 255 & x2, G[1] = x2 >>> 8 & 255, r2.check = a(r2.check, G, 2, 0)), x2 = 0, E2 = 0;
                    } else
                      r2.head && (r2.head.extra = null);
                    r2.mode = 6;
                  case 6:
                    if (1024 & r2.flags && ((I = r2.length) > w2 && (I = w2), I && (r2.head && (D = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), i.arraySet(r2.head.extra, m2, _2, I, D)), 512 & r2.flags && (r2.check = a(r2.check, m2, I, _2)), w2 -= I, _2 += I, r2.length -= I), r2.length))
                      break t;
                    r2.length = 0, r2.mode = 7;
                  case 7:
                    if (2048 & r2.flags) {
                      if (0 === w2)
                        break t;
                      I = 0;
                      do {
                        D = m2[_2 + I++], r2.head && D && r2.length < 65536 && (r2.head.name += String.fromCharCode(D));
                      } while (D && I < w2);
                      if (512 & r2.flags && (r2.check = a(r2.check, m2, I, _2)), w2 -= I, _2 += I, D)
                        break t;
                    } else
                      r2.head && (r2.head.name = null);
                    r2.length = 0, r2.mode = 8;
                  case 8:
                    if (4096 & r2.flags) {
                      if (0 === w2)
                        break t;
                      I = 0;
                      do {
                        D = m2[_2 + I++], r2.head && D && r2.length < 65536 && (r2.head.comment += String.fromCharCode(D));
                      } while (D && I < w2);
                      if (512 & r2.flags && (r2.check = a(r2.check, m2, I, _2)), w2 -= I, _2 += I, D)
                        break t;
                    } else
                      r2.head && (r2.head.comment = null);
                    r2.mode = 9;
                  case 9:
                    if (512 & r2.flags) {
                      for (; E2 < 16; ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      if (x2 !== (65535 & r2.check)) {
                        t2.msg = "header crc mismatch", r2.mode = p;
                        break;
                      }
                      x2 = 0, E2 = 0;
                    }
                    r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), t2.adler = r2.check = 0, r2.mode = d;
                    break;
                  case 10:
                    for (; E2 < 32; ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    t2.adler = r2.check = b(x2), x2 = 0, E2 = 0, r2.mode = 11;
                  case 11:
                    if (0 === r2.havedict)
                      return t2.next_out = y2, t2.avail_out = v2, t2.next_in = _2, t2.avail_in = w2, r2.hold = x2, r2.bits = E2, 2;
                    t2.adler = r2.check = 1, r2.mode = d;
                  case d:
                    if (5 === e2 || 6 === e2)
                      break t;
                  case 13:
                    if (r2.last) {
                      x2 >>>= 7 & E2, E2 -= 7 & E2, r2.mode = 27;
                      break;
                    }
                    for (; E2 < 3; ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    switch (r2.last = 1 & x2, E2 -= 1, 3 & (x2 >>>= 1)) {
                      case 0:
                        r2.mode = 14;
                        break;
                      case 1:
                        if (M(r2), r2.mode = 20, 6 === e2) {
                          x2 >>>= 2, E2 -= 2;
                          break t;
                        }
                        break;
                      case 2:
                        r2.mode = 17;
                        break;
                      case 3:
                        t2.msg = "invalid block type", r2.mode = p;
                    }
                    x2 >>>= 2, E2 -= 2;
                    break;
                  case 14:
                    for (x2 >>>= 7 & E2, E2 -= 7 & E2; E2 < 32; ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    if ((65535 & x2) != (x2 >>> 16 ^ 65535)) {
                      t2.msg = "invalid stored block lengths", r2.mode = p;
                      break;
                    }
                    if (r2.length = 65535 & x2, x2 = 0, E2 = 0, r2.mode = 15, 6 === e2)
                      break t;
                  case 15:
                    r2.mode = 16;
                  case 16:
                    if (I = r2.length) {
                      if (I > w2 && (I = w2), I > v2 && (I = v2), 0 === I)
                        break t;
                      i.arraySet(g2, m2, _2, I, y2), w2 -= I, _2 += I, v2 -= I, y2 += I, r2.length -= I;
                      break;
                    }
                    r2.mode = d;
                    break;
                  case 17:
                    for (; E2 < 14; ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    if (r2.nlen = 257 + (31 & x2), x2 >>>= 5, E2 -= 5, r2.ndist = 1 + (31 & x2), x2 >>>= 5, E2 -= 5, r2.ncode = 4 + (15 & x2), x2 >>>= 4, E2 -= 4, r2.nlen > 286 || r2.ndist > 30) {
                      t2.msg = "too many length or distance symbols", r2.mode = p;
                      break;
                    }
                    r2.have = 0, r2.mode = 18;
                  case 18:
                    for (; r2.have < r2.ncode; ) {
                      for (; E2 < 3; ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      r2.lens[H[r2.have++]] = 7 & x2, x2 >>>= 3, E2 -= 3;
                    }
                    for (; r2.have < 19; )
                      r2.lens[H[r2.have++]] = 0;
                    if (r2.lencode = r2.lendyn, r2.lenbits = 7, N = { bits: r2.lenbits }, z = s(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, N), r2.lenbits = N.bits, z) {
                      t2.msg = "invalid code lengths set", r2.mode = p;
                      break;
                    }
                    r2.have = 0, r2.mode = 19;
                  case 19:
                    for (; r2.have < r2.nlen + r2.ndist; ) {
                      for (; P = (j = r2.lencode[x2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, O = 65535 & j, !((R = j >>> 24) <= E2); ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      if (O < 16)
                        x2 >>>= R, E2 -= R, r2.lens[r2.have++] = O;
                      else {
                        if (16 === O) {
                          for (F = R + 2; E2 < F; ) {
                            if (0 === w2)
                              break t;
                            w2--, x2 += m2[_2++] << E2, E2 += 8;
                          }
                          if (x2 >>>= R, E2 -= R, 0 === r2.have) {
                            t2.msg = "invalid bit length repeat", r2.mode = p;
                            break;
                          }
                          D = r2.lens[r2.have - 1], I = 3 + (3 & x2), x2 >>>= 2, E2 -= 2;
                        } else if (17 === O) {
                          for (F = R + 3; E2 < F; ) {
                            if (0 === w2)
                              break t;
                            w2--, x2 += m2[_2++] << E2, E2 += 8;
                          }
                          E2 -= R, D = 0, I = 3 + (7 & (x2 >>>= R)), x2 >>>= 3, E2 -= 3;
                        } else {
                          for (F = R + 7; E2 < F; ) {
                            if (0 === w2)
                              break t;
                            w2--, x2 += m2[_2++] << E2, E2 += 8;
                          }
                          E2 -= R, D = 0, I = 11 + (127 & (x2 >>>= R)), x2 >>>= 7, E2 -= 7;
                        }
                        if (r2.have + I > r2.nlen + r2.ndist) {
                          t2.msg = "invalid bit length repeat", r2.mode = p;
                          break;
                        }
                        for (; I--; )
                          r2.lens[r2.have++] = D;
                      }
                    }
                    if (r2.mode === p)
                      break;
                    if (0 === r2.lens[256]) {
                      t2.msg = "invalid code -- missing end-of-block", r2.mode = p;
                      break;
                    }
                    if (r2.lenbits = 9, N = { bits: r2.lenbits }, z = s(h, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, N), r2.lenbits = N.bits, z) {
                      t2.msg = "invalid literal/lengths set", r2.mode = p;
                      break;
                    }
                    if (r2.distbits = 6, r2.distcode = r2.distdyn, N = { bits: r2.distbits }, z = s(f, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, N), r2.distbits = N.bits, z) {
                      t2.msg = "invalid distances set", r2.mode = p;
                      break;
                    }
                    if (r2.mode = 20, 6 === e2)
                      break t;
                  case 20:
                    r2.mode = 21;
                  case 21:
                    if (w2 >= 6 && v2 >= 258) {
                      t2.next_out = y2, t2.avail_out = v2, t2.next_in = _2, t2.avail_in = w2, r2.hold = x2, r2.bits = E2, o(t2, S2), y2 = t2.next_out, g2 = t2.output, v2 = t2.avail_out, _2 = t2.next_in, m2 = t2.input, w2 = t2.avail_in, x2 = r2.hold, E2 = r2.bits, r2.mode === d && (r2.back = -1);
                      break;
                    }
                    for (r2.back = 0; P = (j = r2.lencode[x2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, O = 65535 & j, !((R = j >>> 24) <= E2); ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    if (P && 0 == (240 & P)) {
                      for (L = R, C = P, U = O; P = (j = r2.lencode[U + ((x2 & (1 << L + C) - 1) >> L)]) >>> 16 & 255, O = 65535 & j, !(L + (R = j >>> 24) <= E2); ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      x2 >>>= L, E2 -= L, r2.back += L;
                    }
                    if (x2 >>>= R, E2 -= R, r2.back += R, r2.length = O, 0 === P) {
                      r2.mode = 26;
                      break;
                    }
                    if (32 & P) {
                      r2.back = -1, r2.mode = d;
                      break;
                    }
                    if (64 & P) {
                      t2.msg = "invalid literal/length code", r2.mode = p;
                      break;
                    }
                    r2.extra = 15 & P, r2.mode = 22;
                  case 22:
                    if (r2.extra) {
                      for (F = r2.extra; E2 < F; ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      r2.length += x2 & (1 << r2.extra) - 1, x2 >>>= r2.extra, E2 -= r2.extra, r2.back += r2.extra;
                    }
                    r2.was = r2.length, r2.mode = 23;
                  case 23:
                    for (; P = (j = r2.distcode[x2 & (1 << r2.distbits) - 1]) >>> 16 & 255, O = 65535 & j, !((R = j >>> 24) <= E2); ) {
                      if (0 === w2)
                        break t;
                      w2--, x2 += m2[_2++] << E2, E2 += 8;
                    }
                    if (0 == (240 & P)) {
                      for (L = R, C = P, U = O; P = (j = r2.distcode[U + ((x2 & (1 << L + C) - 1) >> L)]) >>> 16 & 255, O = 65535 & j, !(L + (R = j >>> 24) <= E2); ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      x2 >>>= L, E2 -= L, r2.back += L;
                    }
                    if (x2 >>>= R, E2 -= R, r2.back += R, 64 & P) {
                      t2.msg = "invalid distance code", r2.mode = p;
                      break;
                    }
                    r2.offset = O, r2.extra = 15 & P, r2.mode = 24;
                  case 24:
                    if (r2.extra) {
                      for (F = r2.extra; E2 < F; ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      r2.offset += x2 & (1 << r2.extra) - 1, x2 >>>= r2.extra, E2 -= r2.extra, r2.back += r2.extra;
                    }
                    if (r2.offset > r2.dmax) {
                      t2.msg = "invalid distance too far back", r2.mode = p;
                      break;
                    }
                    r2.mode = 25;
                  case 25:
                    if (0 === v2)
                      break t;
                    if (I = S2 - v2, r2.offset > I) {
                      if ((I = r2.offset - I) > r2.whave && r2.sane) {
                        t2.msg = "invalid distance too far back", r2.mode = p;
                        break;
                      }
                      I > r2.wnext ? (I -= r2.wnext, T = r2.wsize - I) : T = r2.wnext - I, I > r2.length && (I = r2.length), B = r2.window;
                    } else
                      B = g2, T = y2 - r2.offset, I = r2.length;
                    I > v2 && (I = v2), v2 -= I, r2.length -= I;
                    do {
                      g2[y2++] = B[T++];
                    } while (--I);
                    0 === r2.length && (r2.mode = 21);
                    break;
                  case 26:
                    if (0 === v2)
                      break t;
                    g2[y2++] = r2.length, v2--, r2.mode = 21;
                    break;
                  case 27:
                    if (r2.wrap) {
                      for (; E2 < 32; ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 |= m2[_2++] << E2, E2 += 8;
                      }
                      if (S2 -= v2, t2.total_out += S2, r2.total += S2, S2 && (t2.adler = r2.check = r2.flags ? a(r2.check, g2, S2, y2 - S2) : n(r2.check, g2, S2, y2 - S2)), S2 = v2, (r2.flags ? x2 : b(x2)) !== r2.check) {
                        t2.msg = "incorrect data check", r2.mode = p;
                        break;
                      }
                      x2 = 0, E2 = 0;
                    }
                    r2.mode = 28;
                  case 28:
                    if (r2.wrap && r2.flags) {
                      for (; E2 < 32; ) {
                        if (0 === w2)
                          break t;
                        w2--, x2 += m2[_2++] << E2, E2 += 8;
                      }
                      if (x2 !== (4294967295 & r2.total)) {
                        t2.msg = "incorrect length check", r2.mode = p;
                        break;
                      }
                      x2 = 0, E2 = 0;
                    }
                    r2.mode = 29;
                  case 29:
                    z = 1;
                    break t;
                  case p:
                    z = -3;
                    break t;
                  case 31:
                    return -4;
                  default:
                    return l;
                }
            return t2.next_out = y2, t2.avail_out = v2, t2.next_in = _2, t2.avail_in = w2, r2.hold = x2, r2.bits = E2, (r2.wsize || S2 !== t2.avail_out && r2.mode < p && (r2.mode < 27 || 4 !== e2)) && A(t2, t2.output, t2.next_out, S2 - t2.avail_out) ? (r2.mode = 31, -4) : (k2 -= t2.avail_in, S2 -= t2.avail_out, t2.total_in += k2, t2.total_out += S2, r2.total += S2, r2.wrap && S2 && (t2.adler = r2.check = r2.flags ? a(r2.check, g2, S2, t2.next_out - S2) : n(r2.check, g2, S2, t2.next_out - S2)), t2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === d ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 === k2 && 0 === S2 || 4 === e2) && z === u && (z = -5), z);
          }, e.inflateEnd = function(t2) {
            if (!t2 || !t2.state)
              return l;
            var e2 = t2.state;
            return e2.window && (e2.window = null), t2.state = null, u;
          }, e.inflateGetHeader = function(t2, e2) {
            var r2;
            return t2 && t2.state ? 0 == (2 & (r2 = t2.state).wrap) ? l : (r2.head = e2, e2.done = false, u) : l;
          }, e.inflateSetDictionary = function(t2, e2) {
            var r2, i2 = e2.length;
            return t2 && t2.state ? 0 !== (r2 = t2.state).wrap && 11 !== r2.mode ? l : 11 === r2.mode && n(1, e2, i2, 0) !== r2.check ? -3 : A(t2, e2, i2, i2) ? (r2.mode = 31, -4) : (r2.havedict = 1, u) : l;
          }, e.inflateInfo = "pako inflate (from Nodeca project)";
        }, 881: (t, e, r) => {
          "use strict";
          var i = r(9761), n = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], o = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], s = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
          t.exports = function(t2, e2, r2, h, f, u, l, c) {
            var d, p, m, g, b, _, y, w, v, x = c.bits, E = 0, k = 0, S = 0, M = 0, A = 0, I = 0, T = 0, B = 0, R = 0, P = 0, O = null, L = 0, C = new i.Buf16(16), U = new i.Buf16(16), D = null, z = 0;
            for (E = 0; E <= 15; E++)
              C[E] = 0;
            for (k = 0; k < h; k++)
              C[e2[r2 + k]]++;
            for (A = x, M = 15; M >= 1 && 0 === C[M]; M--)
              ;
            if (A > M && (A = M), 0 === M)
              return f[u++] = 20971520, f[u++] = 20971520, c.bits = 1, 0;
            for (S = 1; S < M && 0 === C[S]; S++)
              ;
            for (A < S && (A = S), B = 1, E = 1; E <= 15; E++)
              if (B <<= 1, (B -= C[E]) < 0)
                return -1;
            if (B > 0 && (0 === t2 || 1 !== M))
              return -1;
            for (U[1] = 0, E = 1; E < 15; E++)
              U[E + 1] = U[E] + C[E];
            for (k = 0; k < h; k++)
              0 !== e2[r2 + k] && (l[U[e2[r2 + k]]++] = k);
            if (0 === t2 ? (O = D = l, _ = 19) : 1 === t2 ? (O = n, L -= 257, D = a, z -= 257, _ = 256) : (O = o, D = s, _ = -1), P = 0, k = 0, E = S, b = u, I = A, T = 0, m = -1, g = (R = 1 << A) - 1, 1 === t2 && R > 852 || 2 === t2 && R > 592)
              return 1;
            for (; ; ) {
              y = E - T, l[k] < _ ? (w = 0, v = l[k]) : l[k] > _ ? (w = D[z + l[k]], v = O[L + l[k]]) : (w = 96, v = 0), d = 1 << E - T, S = p = 1 << I;
              do {
                f[b + (P >> T) + (p -= d)] = y << 24 | w << 16 | v | 0;
              } while (0 !== p);
              for (d = 1 << E - 1; P & d; )
                d >>= 1;
              if (0 !== d ? (P &= d - 1, P += d) : P = 0, k++, 0 == --C[E]) {
                if (E === M)
                  break;
                E = e2[r2 + l[k]];
              }
              if (E > A && (P & g) !== m) {
                for (0 === T && (T = A), b += S, B = 1 << (I = E - T); I + T < M && !((B -= C[I + T]) <= 0); )
                  I++, B <<= 1;
                if (R += 1 << I, 1 === t2 && R > 852 || 2 === t2 && R > 592)
                  return 1;
                f[m = P & g] = A << 24 | I << 16 | b - u | 0;
              }
            }
            return 0 !== P && (f[b + P] = E - T << 24 | 64 << 16 | 0), c.bits = A, 0;
          };
        }, 2950: (t) => {
          "use strict";
          t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
        }, 9564: (t, e, r) => {
          "use strict";
          var i = r(9761);
          function n(t2) {
            for (var e2 = t2.length; --e2 >= 0; )
              t2[e2] = 0;
          }
          var a = 0, o = 256, s = o + 1 + 29, h = 30, f = 19, u = 2 * s + 1, l = 15, c = 16, d = 256, p = 16, m = 17, g = 18, b = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], _ = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], w = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], v = new Array(2 * (s + 2));
          n(v);
          var x = new Array(2 * h);
          n(x);
          var E = new Array(512);
          n(E);
          var k = new Array(256);
          n(k);
          var S = new Array(29);
          n(S);
          var M, A, I, T = new Array(h);
          function B(t2, e2, r2, i2, n2) {
            this.static_tree = t2, this.extra_bits = e2, this.extra_base = r2, this.elems = i2, this.max_length = n2, this.has_stree = t2 && t2.length;
          }
          function R(t2, e2) {
            this.dyn_tree = t2, this.max_code = 0, this.stat_desc = e2;
          }
          function P(t2) {
            return t2 < 256 ? E[t2] : E[256 + (t2 >>> 7)];
          }
          function O(t2, e2) {
            t2.pending_buf[t2.pending++] = 255 & e2, t2.pending_buf[t2.pending++] = e2 >>> 8 & 255;
          }
          function L(t2, e2, r2) {
            t2.bi_valid > c - r2 ? (t2.bi_buf |= e2 << t2.bi_valid & 65535, O(t2, t2.bi_buf), t2.bi_buf = e2 >> c - t2.bi_valid, t2.bi_valid += r2 - c) : (t2.bi_buf |= e2 << t2.bi_valid & 65535, t2.bi_valid += r2);
          }
          function C(t2, e2, r2) {
            L(t2, r2[2 * e2], r2[2 * e2 + 1]);
          }
          function U(t2, e2) {
            var r2 = 0;
            do {
              r2 |= 1 & t2, t2 >>>= 1, r2 <<= 1;
            } while (--e2 > 0);
            return r2 >>> 1;
          }
          function D(t2, e2, r2) {
            var i2, n2, a2 = new Array(l + 1), o2 = 0;
            for (i2 = 1; i2 <= l; i2++)
              a2[i2] = o2 = o2 + r2[i2 - 1] << 1;
            for (n2 = 0; n2 <= e2; n2++) {
              var s2 = t2[2 * n2 + 1];
              0 !== s2 && (t2[2 * n2] = U(a2[s2]++, s2));
            }
          }
          function z(t2) {
            var e2;
            for (e2 = 0; e2 < s; e2++)
              t2.dyn_ltree[2 * e2] = 0;
            for (e2 = 0; e2 < h; e2++)
              t2.dyn_dtree[2 * e2] = 0;
            for (e2 = 0; e2 < f; e2++)
              t2.bl_tree[2 * e2] = 0;
            t2.dyn_ltree[2 * d] = 1, t2.opt_len = t2.static_len = 0, t2.last_lit = t2.matches = 0;
          }
          function N(t2) {
            t2.bi_valid > 8 ? O(t2, t2.bi_buf) : t2.bi_valid > 0 && (t2.pending_buf[t2.pending++] = t2.bi_buf), t2.bi_buf = 0, t2.bi_valid = 0;
          }
          function F(t2, e2, r2, i2) {
            var n2 = 2 * e2, a2 = 2 * r2;
            return t2[n2] < t2[a2] || t2[n2] === t2[a2] && i2[e2] <= i2[r2];
          }
          function j(t2, e2, r2) {
            for (var i2 = t2.heap[r2], n2 = r2 << 1; n2 <= t2.heap_len && (n2 < t2.heap_len && F(e2, t2.heap[n2 + 1], t2.heap[n2], t2.depth) && n2++, !F(e2, i2, t2.heap[n2], t2.depth)); )
              t2.heap[r2] = t2.heap[n2], r2 = n2, n2 <<= 1;
            t2.heap[r2] = i2;
          }
          function G(t2, e2, r2) {
            var i2, n2, a2, s2, h2 = 0;
            if (0 !== t2.last_lit)
              do {
                i2 = t2.pending_buf[t2.d_buf + 2 * h2] << 8 | t2.pending_buf[t2.d_buf + 2 * h2 + 1], n2 = t2.pending_buf[t2.l_buf + h2], h2++, 0 === i2 ? C(t2, n2, e2) : (C(t2, (a2 = k[n2]) + o + 1, e2), 0 !== (s2 = b[a2]) && L(t2, n2 -= S[a2], s2), C(t2, a2 = P(--i2), r2), 0 !== (s2 = _[a2]) && L(t2, i2 -= T[a2], s2));
              } while (h2 < t2.last_lit);
            C(t2, d, e2);
          }
          function H(t2, e2) {
            var r2, i2, n2, a2 = e2.dyn_tree, o2 = e2.stat_desc.static_tree, s2 = e2.stat_desc.has_stree, h2 = e2.stat_desc.elems, f2 = -1;
            for (t2.heap_len = 0, t2.heap_max = u, r2 = 0; r2 < h2; r2++)
              0 !== a2[2 * r2] ? (t2.heap[++t2.heap_len] = f2 = r2, t2.depth[r2] = 0) : a2[2 * r2 + 1] = 0;
            for (; t2.heap_len < 2; )
              a2[2 * (n2 = t2.heap[++t2.heap_len] = f2 < 2 ? ++f2 : 0)] = 1, t2.depth[n2] = 0, t2.opt_len--, s2 && (t2.static_len -= o2[2 * n2 + 1]);
            for (e2.max_code = f2, r2 = t2.heap_len >> 1; r2 >= 1; r2--)
              j(t2, a2, r2);
            n2 = h2;
            do {
              r2 = t2.heap[1], t2.heap[1] = t2.heap[t2.heap_len--], j(t2, a2, 1), i2 = t2.heap[1], t2.heap[--t2.heap_max] = r2, t2.heap[--t2.heap_max] = i2, a2[2 * n2] = a2[2 * r2] + a2[2 * i2], t2.depth[n2] = (t2.depth[r2] >= t2.depth[i2] ? t2.depth[r2] : t2.depth[i2]) + 1, a2[2 * r2 + 1] = a2[2 * i2 + 1] = n2, t2.heap[1] = n2++, j(t2, a2, 1);
            } while (t2.heap_len >= 2);
            t2.heap[--t2.heap_max] = t2.heap[1], function(t3, e3) {
              var r3, i3, n3, a3, o3, s3, h3 = e3.dyn_tree, f3 = e3.max_code, c2 = e3.stat_desc.static_tree, d2 = e3.stat_desc.has_stree, p2 = e3.stat_desc.extra_bits, m2 = e3.stat_desc.extra_base, g2 = e3.stat_desc.max_length, b2 = 0;
              for (a3 = 0; a3 <= l; a3++)
                t3.bl_count[a3] = 0;
              for (h3[2 * t3.heap[t3.heap_max] + 1] = 0, r3 = t3.heap_max + 1; r3 < u; r3++)
                (a3 = h3[2 * h3[2 * (i3 = t3.heap[r3]) + 1] + 1] + 1) > g2 && (a3 = g2, b2++), h3[2 * i3 + 1] = a3, i3 > f3 || (t3.bl_count[a3]++, o3 = 0, i3 >= m2 && (o3 = p2[i3 - m2]), s3 = h3[2 * i3], t3.opt_len += s3 * (a3 + o3), d2 && (t3.static_len += s3 * (c2[2 * i3 + 1] + o3)));
              if (0 !== b2) {
                do {
                  for (a3 = g2 - 1; 0 === t3.bl_count[a3]; )
                    a3--;
                  t3.bl_count[a3]--, t3.bl_count[a3 + 1] += 2, t3.bl_count[g2]--, b2 -= 2;
                } while (b2 > 0);
                for (a3 = g2; 0 !== a3; a3--)
                  for (i3 = t3.bl_count[a3]; 0 !== i3; )
                    (n3 = t3.heap[--r3]) > f3 || (h3[2 * n3 + 1] !== a3 && (t3.opt_len += (a3 - h3[2 * n3 + 1]) * h3[2 * n3], h3[2 * n3 + 1] = a3), i3--);
              }
            }(t2, e2), D(a2, f2, t2.bl_count);
          }
          function W(t2, e2, r2) {
            var i2, n2, a2 = -1, o2 = e2[1], s2 = 0, h2 = 7, f2 = 4;
            for (0 === o2 && (h2 = 138, f2 = 3), e2[2 * (r2 + 1) + 1] = 65535, i2 = 0; i2 <= r2; i2++)
              n2 = o2, o2 = e2[2 * (i2 + 1) + 1], ++s2 < h2 && n2 === o2 || (s2 < f2 ? t2.bl_tree[2 * n2] += s2 : 0 !== n2 ? (n2 !== a2 && t2.bl_tree[2 * n2]++, t2.bl_tree[2 * p]++) : s2 <= 10 ? t2.bl_tree[2 * m]++ : t2.bl_tree[2 * g]++, s2 = 0, a2 = n2, 0 === o2 ? (h2 = 138, f2 = 3) : n2 === o2 ? (h2 = 6, f2 = 3) : (h2 = 7, f2 = 4));
          }
          function q(t2, e2, r2) {
            var i2, n2, a2 = -1, o2 = e2[1], s2 = 0, h2 = 7, f2 = 4;
            for (0 === o2 && (h2 = 138, f2 = 3), i2 = 0; i2 <= r2; i2++)
              if (n2 = o2, o2 = e2[2 * (i2 + 1) + 1], !(++s2 < h2 && n2 === o2)) {
                if (s2 < f2)
                  do {
                    C(t2, n2, t2.bl_tree);
                  } while (0 != --s2);
                else
                  0 !== n2 ? (n2 !== a2 && (C(t2, n2, t2.bl_tree), s2--), C(t2, p, t2.bl_tree), L(t2, s2 - 3, 2)) : s2 <= 10 ? (C(t2, m, t2.bl_tree), L(t2, s2 - 3, 3)) : (C(t2, g, t2.bl_tree), L(t2, s2 - 11, 7));
                s2 = 0, a2 = n2, 0 === o2 ? (h2 = 138, f2 = 3) : n2 === o2 ? (h2 = 6, f2 = 3) : (h2 = 7, f2 = 4);
              }
          }
          n(T);
          var Z = false;
          function Y(t2, e2, r2, n2) {
            L(t2, (a << 1) + (n2 ? 1 : 0), 3), function(t3, e3, r3, n3) {
              N(t3), O(t3, r3), O(t3, ~r3), i.arraySet(t3.pending_buf, t3.window, e3, r3, t3.pending), t3.pending += r3;
            }(t2, e2, r2);
          }
          e._tr_init = function(t2) {
            Z || (function() {
              var t3, e2, r2, i2, n2, a2 = new Array(l + 1);
              for (r2 = 0, i2 = 0; i2 < 28; i2++)
                for (S[i2] = r2, t3 = 0; t3 < 1 << b[i2]; t3++)
                  k[r2++] = i2;
              for (k[r2 - 1] = i2, n2 = 0, i2 = 0; i2 < 16; i2++)
                for (T[i2] = n2, t3 = 0; t3 < 1 << _[i2]; t3++)
                  E[n2++] = i2;
              for (n2 >>= 7; i2 < h; i2++)
                for (T[i2] = n2 << 7, t3 = 0; t3 < 1 << _[i2] - 7; t3++)
                  E[256 + n2++] = i2;
              for (e2 = 0; e2 <= l; e2++)
                a2[e2] = 0;
              for (t3 = 0; t3 <= 143; )
                v[2 * t3 + 1] = 8, t3++, a2[8]++;
              for (; t3 <= 255; )
                v[2 * t3 + 1] = 9, t3++, a2[9]++;
              for (; t3 <= 279; )
                v[2 * t3 + 1] = 7, t3++, a2[7]++;
              for (; t3 <= 287; )
                v[2 * t3 + 1] = 8, t3++, a2[8]++;
              for (D(v, s + 1, a2), t3 = 0; t3 < h; t3++)
                x[2 * t3 + 1] = 5, x[2 * t3] = U(t3, 5);
              M = new B(v, b, o + 1, s, l), A = new B(x, _, 0, h, l), I = new B(new Array(0), y, 0, f, 7);
            }(), Z = true), t2.l_desc = new R(t2.dyn_ltree, M), t2.d_desc = new R(t2.dyn_dtree, A), t2.bl_desc = new R(t2.bl_tree, I), t2.bi_buf = 0, t2.bi_valid = 0, z(t2);
          }, e._tr_stored_block = Y, e._tr_flush_block = function(t2, e2, r2, i2) {
            var n2, a2, s2 = 0;
            t2.level > 0 ? (2 === t2.strm.data_type && (t2.strm.data_type = function(t3) {
              var e3, r3 = 4093624447;
              for (e3 = 0; e3 <= 31; e3++, r3 >>>= 1)
                if (1 & r3 && 0 !== t3.dyn_ltree[2 * e3])
                  return 0;
              if (0 !== t3.dyn_ltree[18] || 0 !== t3.dyn_ltree[20] || 0 !== t3.dyn_ltree[26])
                return 1;
              for (e3 = 32; e3 < o; e3++)
                if (0 !== t3.dyn_ltree[2 * e3])
                  return 1;
              return 0;
            }(t2)), H(t2, t2.l_desc), H(t2, t2.d_desc), s2 = function(t3) {
              var e3;
              for (W(t3, t3.dyn_ltree, t3.l_desc.max_code), W(t3, t3.dyn_dtree, t3.d_desc.max_code), H(t3, t3.bl_desc), e3 = f - 1; e3 >= 3 && 0 === t3.bl_tree[2 * w[e3] + 1]; e3--)
                ;
              return t3.opt_len += 3 * (e3 + 1) + 5 + 5 + 4, e3;
            }(t2), n2 = t2.opt_len + 3 + 7 >>> 3, (a2 = t2.static_len + 3 + 7 >>> 3) <= n2 && (n2 = a2)) : n2 = a2 = r2 + 5, r2 + 4 <= n2 && -1 !== e2 ? Y(t2, e2, r2, i2) : 4 === t2.strategy || a2 === n2 ? (L(t2, 2 + (i2 ? 1 : 0), 3), G(t2, v, x)) : (L(t2, 4 + (i2 ? 1 : 0), 3), function(t3, e3, r3, i3) {
              var n3;
              for (L(t3, e3 - 257, 5), L(t3, r3 - 1, 5), L(t3, i3 - 4, 4), n3 = 0; n3 < i3; n3++)
                L(t3, t3.bl_tree[2 * w[n3] + 1], 3);
              q(t3, t3.dyn_ltree, e3 - 1), q(t3, t3.dyn_dtree, r3 - 1);
            }(t2, t2.l_desc.max_code + 1, t2.d_desc.max_code + 1, s2 + 1), G(t2, t2.dyn_ltree, t2.dyn_dtree)), z(t2), i2 && N(t2);
          }, e._tr_tally = function(t2, e2, r2) {
            return t2.pending_buf[t2.d_buf + 2 * t2.last_lit] = e2 >>> 8 & 255, t2.pending_buf[t2.d_buf + 2 * t2.last_lit + 1] = 255 & e2, t2.pending_buf[t2.l_buf + t2.last_lit] = 255 & r2, t2.last_lit++, 0 === e2 ? t2.dyn_ltree[2 * r2]++ : (t2.matches++, e2--, t2.dyn_ltree[2 * (k[r2] + o + 1)]++, t2.dyn_dtree[2 * P(e2)]++), t2.last_lit === t2.lit_bufsize - 1;
          }, e._tr_align = function(t2) {
            L(t2, 2, 3), C(t2, d, v), function(t3) {
              16 === t3.bi_valid ? (O(t3, t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0) : t3.bi_valid >= 8 && (t3.pending_buf[t3.pending++] = 255 & t3.bi_buf, t3.bi_buf >>= 8, t3.bi_valid -= 8);
            }(t2);
          };
        }, 744: (t) => {
          "use strict";
          t.exports = function() {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
          };
        }, 4398: (t) => {
          function e(t2, e2) {
            if (!(t2 = t2.replace(/\t+/g, " ").trim()))
              return null;
            var i = t2.indexOf(" ");
            if (-1 === i)
              throw new Error("no named row at line " + e2);
            var n = t2.substring(0, i);
            t2 = (t2 = (t2 = (t2 = t2.substring(i + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map(function(t3) {
              return t3.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
            });
            for (var a = [], o = 0; o < t2.length; o++) {
              var s = t2[o];
              0 === o ? a.push({ key: s[0], data: "" }) : o === t2.length - 1 ? a[a.length - 1].data = r(s[0]) : (a[a.length - 1].data = r(s[0]), a.push({ key: s[1], data: "" }));
            }
            var h = { key: n, data: {} };
            return a.forEach(function(t3) {
              h.data[t3.key] = t3.data;
            }), h;
          }
          function r(t2) {
            return t2 && 0 !== t2.length ? 0 === t2.indexOf('"') || 0 === t2.indexOf("'") ? t2.substring(1, t2.length - 1) : -1 !== t2.indexOf(",") ? function(t3) {
              return t3.split(",").map(function(t4) {
                return parseInt(t4, 10);
              });
            }(t2) : parseInt(t2, 10) : "";
          }
          t.exports = function(t2) {
            if (!t2)
              throw new Error("no data provided");
            var r2 = { pages: [], chars: [], kernings: [] }, i = (t2 = t2.toString().trim()).split(/\r\n?|\n/g);
            if (0 === i.length)
              throw new Error("no data in BMFont file");
            for (var n = 0; n < i.length; n++) {
              var a = e(i[n], n);
              if (a)
                if ("page" === a.key) {
                  if ("number" != typeof a.data.id)
                    throw new Error("malformed file at line " + n + " -- needs page id=N");
                  if ("string" != typeof a.data.file)
                    throw new Error("malformed file at line " + n + ' -- needs page file="path"');
                  r2.pages[a.data.id] = a.data.file;
                } else
                  "chars" === a.key || "kernings" === a.key || ("char" === a.key ? r2.chars.push(a.data) : "kerning" === a.key ? r2.kernings.push(a.data) : r2[a.key] = a.data);
            }
            return r2;
          };
        }, 8438: (t) => {
          var e = [66, 77, 70];
          function r(t2, e2, r2) {
            if (r2 > e2.length - 1)
              return 0;
            var n = e2.readUInt8(r2++), a = e2.readInt32LE(r2);
            switch (r2 += 4, n) {
              case 1:
                t2.info = function(t3, e3) {
                  var r3 = {};
                  r3.size = t3.readInt16LE(e3);
                  var n2 = t3.readUInt8(e3 + 2);
                  return r3.smooth = n2 >> 7 & 1, r3.unicode = n2 >> 6 & 1, r3.italic = n2 >> 5 & 1, r3.bold = n2 >> 4 & 1, n2 >> 3 & 1 && (r3.fixedHeight = 1), r3.charset = t3.readUInt8(e3 + 3) || "", r3.stretchH = t3.readUInt16LE(e3 + 4), r3.aa = t3.readUInt8(e3 + 6), r3.padding = [t3.readInt8(e3 + 7), t3.readInt8(e3 + 8), t3.readInt8(e3 + 9), t3.readInt8(e3 + 10)], r3.spacing = [t3.readInt8(e3 + 11), t3.readInt8(e3 + 12)], r3.outline = t3.readUInt8(e3 + 13), r3.face = function(t4, e4) {
                    return i(t4, e4).toString("utf8");
                  }(t3, e3 + 14), r3;
                }(e2, r2);
                break;
              case 2:
                t2.common = function(t3, e3) {
                  var r3 = {};
                  return r3.lineHeight = t3.readUInt16LE(e3), r3.base = t3.readUInt16LE(e3 + 2), r3.scaleW = t3.readUInt16LE(e3 + 4), r3.scaleH = t3.readUInt16LE(e3 + 6), r3.pages = t3.readUInt16LE(e3 + 8), t3.readUInt8(e3 + 10), r3.packed = 0, r3.alphaChnl = t3.readUInt8(e3 + 11), r3.redChnl = t3.readUInt8(e3 + 12), r3.greenChnl = t3.readUInt8(e3 + 13), r3.blueChnl = t3.readUInt8(e3 + 14), r3;
                }(e2, r2);
                break;
              case 3:
                t2.pages = function(t3, e3, r3) {
                  for (var n2 = [], a2 = i(t3, e3), o = a2.length + 1, s = r3 / o, h = 0; h < s; h++)
                    n2[h] = t3.slice(e3, e3 + a2.length).toString("utf8"), e3 += o;
                  return n2;
                }(e2, r2, a);
                break;
              case 4:
                t2.chars = function(t3, e3, r3) {
                  for (var i2 = [], n2 = r3 / 20, a2 = 0; a2 < n2; a2++) {
                    var o = {}, s = 20 * a2;
                    o.id = t3.readUInt32LE(e3 + 0 + s), o.x = t3.readUInt16LE(e3 + 4 + s), o.y = t3.readUInt16LE(e3 + 6 + s), o.width = t3.readUInt16LE(e3 + 8 + s), o.height = t3.readUInt16LE(e3 + 10 + s), o.xoffset = t3.readInt16LE(e3 + 12 + s), o.yoffset = t3.readInt16LE(e3 + 14 + s), o.xadvance = t3.readInt16LE(e3 + 16 + s), o.page = t3.readUInt8(e3 + 18 + s), o.chnl = t3.readUInt8(e3 + 19 + s), i2[a2] = o;
                  }
                  return i2;
                }(e2, r2, a);
                break;
              case 5:
                t2.kernings = function(t3, e3, r3) {
                  for (var i2 = [], n2 = r3 / 10, a2 = 0; a2 < n2; a2++) {
                    var o = {}, s = 10 * a2;
                    o.first = t3.readUInt32LE(e3 + 0 + s), o.second = t3.readUInt32LE(e3 + 4 + s), o.amount = t3.readInt16LE(e3 + 8 + s), i2[a2] = o;
                  }
                  return i2;
                }(e2, r2, a);
            }
            return 5 + a;
          }
          function i(t2, e2) {
            for (var r2 = e2; r2 < t2.length && 0 !== t2[r2]; r2++)
              ;
            return t2.slice(e2, r2);
          }
          t.exports = function(t2) {
            if (t2.length < 6)
              throw new Error("invalid buffer length for BMFont");
            var i2 = e.every(function(e2, r2) {
              return t2.readUInt8(r2) === e2;
            });
            if (!i2)
              throw new Error("BMFont missing BMF byte header");
            var n = 3;
            if (t2.readUInt8(n++) > 3)
              throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
            for (var a = { kernings: [], chars: [] }, o = 0; o < 5; o++)
              n += r(a, t2, n);
            return a;
          };
        }, 5947: (t, e, r) => {
          var i = r(403), n = r(1596), a = { scaleh: "scaleH", scalew: "scaleW", stretchh: "stretchH", lineheight: "lineHeight", alphachnl: "alphaChnl", redchnl: "redChnl", greenchnl: "greenChnl", bluechnl: "blueChnl" };
          function o(t2) {
            var e2 = function(t3) {
              for (var e3 = [], r2 = 0; r2 < t3.attributes.length; r2++)
                e3.push(t3.attributes[r2]);
              return e3;
            }(t2);
            return e2.reduce(function(t3, e3) {
              var r2;
              return t3[r2 = e3.nodeName, a[r2.toLowerCase()] || r2] = e3.nodeValue, t3;
            }, {});
          }
          t.exports = function(t2) {
            t2 = t2.toString();
            var e2 = n(t2), r2 = { pages: [], chars: [], kernings: [] };
            ["info", "common"].forEach(function(t3) {
              var n2 = e2.getElementsByTagName(t3)[0];
              n2 && (r2[t3] = i(o(n2)));
            });
            var a2 = e2.getElementsByTagName("pages")[0];
            if (!a2)
              throw new Error("malformed file -- no <pages> element");
            for (var s = a2.getElementsByTagName("page"), h = 0; h < s.length; h++) {
              var f = s[h], u = parseInt(f.getAttribute("id"), 10), l = f.getAttribute("file");
              if (isNaN(u))
                throw new Error('malformed file -- page "id" attribute is NaN');
              if (!l)
                throw new Error('malformed file -- needs page "file" attribute');
              r2.pages[parseInt(u, 10)] = l;
            }
            return ["chars", "kernings"].forEach(function(t3) {
              var n2 = e2.getElementsByTagName(t3)[0];
              if (n2)
                for (var a3 = t3.substring(0, t3.length - 1), s2 = n2.getElementsByTagName(a3), h2 = 0; h2 < s2.length; h2++) {
                  var f2 = s2[h2];
                  r2[t3].push(i(o(f2)));
                }
            }), r2;
          };
        }, 403: (t) => {
          var e = "chasrset";
          t.exports = function(t2) {
            for (var r in e in t2 && (t2.charset = t2[e], delete t2[e]), t2)
              "face" !== r && "charset" !== r && (t2[r] = "padding" === r || "spacing" === r ? t2[r].split(",").map(function(t3) {
                return parseInt(t3, 10);
              }) : parseInt(t2[r], 10));
            return t2;
          };
        }, 4655: (t, e, r) => {
          var i = r(311), n = r(3243);
          t.exports = function(t2) {
            if (!t2)
              return {};
            var e2 = {};
            return n(i(t2).split("\n"), function(t3) {
              var r2, n2 = t3.indexOf(":"), a = i(t3.slice(0, n2)).toLowerCase(), o = i(t3.slice(n2 + 1));
              void 0 === e2[a] ? e2[a] = o : (r2 = e2[a], "[object Array]" === Object.prototype.toString.call(r2) ? e2[a].push(o) : e2[a] = [e2[a], o]);
            }), e2;
          };
        }, 1023: (t, e, r) => {
          "use strict";
          var i = r(4406);
          function n(t2) {
            if ("string" != typeof t2)
              throw new TypeError("Path must be a string. Received " + JSON.stringify(t2));
          }
          function a(t2, e2) {
            for (var r2, i2 = "", n2 = 0, a2 = -1, o2 = 0, s = 0; s <= t2.length; ++s) {
              if (s < t2.length)
                r2 = t2.charCodeAt(s);
              else {
                if (47 === r2)
                  break;
                r2 = 47;
              }
              if (47 === r2) {
                if (a2 === s - 1 || 1 === o2)
                  ;
                else if (a2 !== s - 1 && 2 === o2) {
                  if (i2.length < 2 || 2 !== n2 || 46 !== i2.charCodeAt(i2.length - 1) || 46 !== i2.charCodeAt(i2.length - 2)) {
                    if (i2.length > 2) {
                      var h = i2.lastIndexOf("/");
                      if (h !== i2.length - 1) {
                        -1 === h ? (i2 = "", n2 = 0) : n2 = (i2 = i2.slice(0, h)).length - 1 - i2.lastIndexOf("/"), a2 = s, o2 = 0;
                        continue;
                      }
                    } else if (2 === i2.length || 1 === i2.length) {
                      i2 = "", n2 = 0, a2 = s, o2 = 0;
                      continue;
                    }
                  }
                  e2 && (i2.length > 0 ? i2 += "/.." : i2 = "..", n2 = 2);
                } else
                  i2.length > 0 ? i2 += "/" + t2.slice(a2 + 1, s) : i2 = t2.slice(a2 + 1, s), n2 = s - a2 - 1;
                a2 = s, o2 = 0;
              } else
                46 === r2 && -1 !== o2 ? ++o2 : o2 = -1;
            }
            return i2;
          }
          var o = { resolve: function() {
            for (var t2, e2 = "", r2 = false, o2 = arguments.length - 1; o2 >= -1 && !r2; o2--) {
              var s;
              o2 >= 0 ? s = arguments[o2] : (void 0 === t2 && (t2 = i.cwd()), s = t2), n(s), 0 !== s.length && (e2 = s + "/" + e2, r2 = 47 === s.charCodeAt(0));
            }
            return e2 = a(e2, !r2), r2 ? e2.length > 0 ? "/" + e2 : "/" : e2.length > 0 ? e2 : ".";
          }, normalize: function(t2) {
            if (n(t2), 0 === t2.length)
              return ".";
            var e2 = 47 === t2.charCodeAt(0), r2 = 47 === t2.charCodeAt(t2.length - 1);
            return 0 !== (t2 = a(t2, !e2)).length || e2 || (t2 = "."), t2.length > 0 && r2 && (t2 += "/"), e2 ? "/" + t2 : t2;
          }, isAbsolute: function(t2) {
            return n(t2), t2.length > 0 && 47 === t2.charCodeAt(0);
          }, join: function() {
            if (0 === arguments.length)
              return ".";
            for (var t2, e2 = 0; e2 < arguments.length; ++e2) {
              var r2 = arguments[e2];
              n(r2), r2.length > 0 && (void 0 === t2 ? t2 = r2 : t2 += "/" + r2);
            }
            return void 0 === t2 ? "." : o.normalize(t2);
          }, relative: function(t2, e2) {
            if (n(t2), n(e2), t2 === e2)
              return "";
            if ((t2 = o.resolve(t2)) === (e2 = o.resolve(e2)))
              return "";
            for (var r2 = 1; r2 < t2.length && 47 === t2.charCodeAt(r2); ++r2)
              ;
            for (var i2 = t2.length, a2 = i2 - r2, s = 1; s < e2.length && 47 === e2.charCodeAt(s); ++s)
              ;
            for (var h = e2.length - s, f = a2 < h ? a2 : h, u = -1, l = 0; l <= f; ++l) {
              if (l === f) {
                if (h > f) {
                  if (47 === e2.charCodeAt(s + l))
                    return e2.slice(s + l + 1);
                  if (0 === l)
                    return e2.slice(s + l);
                } else
                  a2 > f && (47 === t2.charCodeAt(r2 + l) ? u = l : 0 === l && (u = 0));
                break;
              }
              var c = t2.charCodeAt(r2 + l);
              if (c !== e2.charCodeAt(s + l))
                break;
              47 === c && (u = l);
            }
            var d = "";
            for (l = r2 + u + 1; l <= i2; ++l)
              l !== i2 && 47 !== t2.charCodeAt(l) || (0 === d.length ? d += ".." : d += "/..");
            return d.length > 0 ? d + e2.slice(s + u) : (s += u, 47 === e2.charCodeAt(s) && ++s, e2.slice(s));
          }, _makeLong: function(t2) {
            return t2;
          }, dirname: function(t2) {
            if (n(t2), 0 === t2.length)
              return ".";
            for (var e2 = t2.charCodeAt(0), r2 = 47 === e2, i2 = -1, a2 = true, o2 = t2.length - 1; o2 >= 1; --o2)
              if (47 === (e2 = t2.charCodeAt(o2))) {
                if (!a2) {
                  i2 = o2;
                  break;
                }
              } else
                a2 = false;
            return -1 === i2 ? r2 ? "/" : "." : r2 && 1 === i2 ? "//" : t2.slice(0, i2);
          }, basename: function(t2, e2) {
            if (void 0 !== e2 && "string" != typeof e2)
              throw new TypeError('"ext" argument must be a string');
            n(t2);
            var r2, i2 = 0, a2 = -1, o2 = true;
            if (void 0 !== e2 && e2.length > 0 && e2.length <= t2.length) {
              if (e2.length === t2.length && e2 === t2)
                return "";
              var s = e2.length - 1, h = -1;
              for (r2 = t2.length - 1; r2 >= 0; --r2) {
                var f = t2.charCodeAt(r2);
                if (47 === f) {
                  if (!o2) {
                    i2 = r2 + 1;
                    break;
                  }
                } else
                  -1 === h && (o2 = false, h = r2 + 1), s >= 0 && (f === e2.charCodeAt(s) ? -1 == --s && (a2 = r2) : (s = -1, a2 = h));
              }
              return i2 === a2 ? a2 = h : -1 === a2 && (a2 = t2.length), t2.slice(i2, a2);
            }
            for (r2 = t2.length - 1; r2 >= 0; --r2)
              if (47 === t2.charCodeAt(r2)) {
                if (!o2) {
                  i2 = r2 + 1;
                  break;
                }
              } else
                -1 === a2 && (o2 = false, a2 = r2 + 1);
            return -1 === a2 ? "" : t2.slice(i2, a2);
          }, extname: function(t2) {
            n(t2);
            for (var e2 = -1, r2 = 0, i2 = -1, a2 = true, o2 = 0, s = t2.length - 1; s >= 0; --s) {
              var h = t2.charCodeAt(s);
              if (47 !== h)
                -1 === i2 && (a2 = false, i2 = s + 1), 46 === h ? -1 === e2 ? e2 = s : 1 !== o2 && (o2 = 1) : -1 !== e2 && (o2 = -1);
              else if (!a2) {
                r2 = s + 1;
                break;
              }
            }
            return -1 === e2 || -1 === i2 || 0 === o2 || 1 === o2 && e2 === i2 - 1 && e2 === r2 + 1 ? "" : t2.slice(e2, i2);
          }, format: function(t2) {
            if (null === t2 || "object" != typeof t2)
              throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t2);
            return function(t3, e2) {
              var r2 = e2.dir || e2.root, i2 = e2.base || (e2.name || "") + (e2.ext || "");
              return r2 ? r2 === e2.root ? r2 + i2 : r2 + "/" + i2 : i2;
            }(0, t2);
          }, parse: function(t2) {
            n(t2);
            var e2 = { root: "", dir: "", base: "", ext: "", name: "" };
            if (0 === t2.length)
              return e2;
            var r2, i2 = t2.charCodeAt(0), a2 = 47 === i2;
            a2 ? (e2.root = "/", r2 = 1) : r2 = 0;
            for (var o2 = -1, s = 0, h = -1, f = true, u = t2.length - 1, l = 0; u >= r2; --u)
              if (47 !== (i2 = t2.charCodeAt(u)))
                -1 === h && (f = false, h = u + 1), 46 === i2 ? -1 === o2 ? o2 = u : 1 !== l && (l = 1) : -1 !== o2 && (l = -1);
              else if (!f) {
                s = u + 1;
                break;
              }
            return -1 === o2 || -1 === h || 0 === l || 1 === l && o2 === h - 1 && o2 === s + 1 ? -1 !== h && (e2.base = e2.name = 0 === s && a2 ? t2.slice(1, h) : t2.slice(s, h)) : (0 === s && a2 ? (e2.name = t2.slice(1, o2), e2.base = t2.slice(1, h)) : (e2.name = t2.slice(s, o2), e2.base = t2.slice(s, h)), e2.ext = t2.slice(o2, h)), s > 0 ? e2.dir = t2.slice(0, s - 1) : a2 && (e2.dir = "/"), e2;
          }, sep: "/", delimiter: ":", win32: null, posix: null };
          o.posix = o, t.exports = o;
        }, 482: (t, e) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.Deferred = void 0, e.Deferred = class {
            constructor() {
              this.resolve = () => null, this.reject = () => null, this.promise = new Promise((t2, e2) => {
                this.reject = e2, this.resolve = t2;
              });
            }
          };
        }, 5567: (t, e) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.EndOfStreamError = e.defaultMessages = void 0, e.defaultMessages = "End-Of-Stream";
          class r extends Error {
            constructor() {
              super(e.defaultMessages);
            }
          }
          e.EndOfStreamError = r;
        }, 4514: (t, e, r) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.StreamReader = e.EndOfStreamError = void 0;
          const i = r(5567), n = r(482);
          var a = r(5567);
          Object.defineProperty(e, "EndOfStreamError", { enumerable: true, get: function() {
            return a.EndOfStreamError;
          } }), e.StreamReader = class {
            constructor(t2) {
              if (this.s = t2, this.deferred = null, this.endOfStream = false, this.peekQueue = [], !t2.read || !t2.once)
                throw new Error("Expected an instance of stream.Readable");
              this.s.once("end", () => this.reject(new i.EndOfStreamError())), this.s.once("error", (t3) => this.reject(t3)), this.s.once("close", () => this.reject(new Error("Stream closed")));
            }
            async peek(t2, e2, r2) {
              const i2 = await this.read(t2, e2, r2);
              return this.peekQueue.push(t2.subarray(e2, e2 + i2)), i2;
            }
            async read(t2, e2, r2) {
              if (0 === r2)
                return 0;
              if (0 === this.peekQueue.length && this.endOfStream)
                throw new i.EndOfStreamError();
              let n2 = r2, a2 = 0;
              for (; this.peekQueue.length > 0 && n2 > 0; ) {
                const r3 = this.peekQueue.pop();
                if (!r3)
                  throw new Error("peekData should be defined");
                const i2 = Math.min(r3.length, n2);
                t2.set(r3.subarray(0, i2), e2 + a2), a2 += i2, n2 -= i2, i2 < r3.length && this.peekQueue.push(r3.subarray(i2));
              }
              for (; n2 > 0 && !this.endOfStream; ) {
                const r3 = Math.min(n2, 1048576), i2 = await this.readFromStream(t2, e2 + a2, r3);
                if (a2 += i2, i2 < r3)
                  break;
                n2 -= i2;
              }
              return a2;
            }
            async readFromStream(t2, e2, r2) {
              const i2 = this.s.read(r2);
              if (i2)
                return t2.set(i2, e2), i2.length;
              {
                const i3 = { buffer: t2, offset: e2, length: r2, deferred: new n.Deferred() };
                return this.deferred = i3.deferred, this.s.once("readable", () => {
                  this.readDeferred(i3);
                }), i3.deferred.promise;
              }
            }
            readDeferred(t2) {
              const e2 = this.s.read(t2.length);
              e2 ? (t2.buffer.set(e2, t2.offset), t2.deferred.resolve(e2.length), this.deferred = null) : this.s.once("readable", () => {
                this.readDeferred(t2);
              });
            }
            reject(t2) {
              this.endOfStream = true, this.deferred && (this.deferred.reject(t2), this.deferred = null);
            }
          };
        }, 4644: (t, e, r) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.StreamReader = e.EndOfStreamError = void 0;
          var i = r(5567);
          Object.defineProperty(e, "EndOfStreamError", { enumerable: true, get: function() {
            return i.EndOfStreamError;
          } });
          var n = r(4514);
          Object.defineProperty(e, "StreamReader", { enumerable: true, get: function() {
            return n.StreamReader;
          } });
        }, 1294: (t) => {
          "use strict";
          function e(t2, i2, n2, a2, o2, s2) {
            for (var h, f, u, l, c = Math.max(i2 - 1, 0), d = Math.max(n2 - 1, 0), p = Math.min(i2 + 1, a2 - 1), m = Math.min(n2 + 1, o2 - 1), g = 4 * (n2 * a2 + i2), b = 0, _ = 0, y = 0, w = 0, v = 0, x = c; x <= p; x++)
              for (var E = d; E <= m; E++)
                if (x !== i2 || E !== n2) {
                  var k = r(t2, t2, g, 4 * (E * a2 + x), true);
                  if (0 === k ? b++ : k < 0 ? y++ : k > 0 && _++, b > 2)
                    return false;
                  s2 && (k < w && (w = k, h = x, f = E), k > v && (v = k, u = x, l = E));
                }
            return !s2 || 0 !== y && 0 !== _ && (!e(t2, h, f, a2, o2) && !e(s2, h, f, a2, o2) || !e(t2, u, l, a2, o2) && !e(s2, u, l, a2, o2));
          }
          function r(t2, e2, r2, s2, h) {
            var f = t2[r2 + 3] / 255, u = e2[s2 + 3] / 255, l = o(t2[r2 + 0], f), c = o(t2[r2 + 1], f), d = o(t2[r2 + 2], f), p = o(e2[s2 + 0], u), m = o(e2[s2 + 1], u), g = o(e2[s2 + 2], u), b = i(l, c, d) - i(p, m, g);
            if (h)
              return b;
            var _ = n(l, c, d) - n(p, m, g), y = a(l, c, d) - a(p, m, g);
            return 0.5053 * b * b + 0.299 * _ * _ + 0.1957 * y * y;
          }
          function i(t2, e2, r2) {
            return 0.29889531 * t2 + 0.58662247 * e2 + 0.11448223 * r2;
          }
          function n(t2, e2, r2) {
            return 0.59597799 * t2 - 0.2741761 * e2 - 0.32180189 * r2;
          }
          function a(t2, e2, r2) {
            return 0.21147017 * t2 - 0.52261711 * e2 + 0.31114694 * r2;
          }
          function o(t2, e2) {
            return 255 + (t2 - 255) * e2;
          }
          function s(t2, e2, r2, i2, n2) {
            t2[e2 + 0] = r2, t2[e2 + 1] = i2, t2[e2 + 2] = n2, t2[e2 + 3] = 255;
          }
          t.exports = function(t2, n2, a2, h, f, u) {
            u || (u = {});
            for (var l = void 0 === u.threshold ? 0.1 : u.threshold, c = 35215 * l * l, d = 0, p = 0; p < f; p++)
              for (var m = 0; m < h; m++) {
                var g = 4 * (p * h + m);
                if (r(t2, n2, g, g) > c)
                  u.includeAA || !e(t2, m, p, h, f, n2) && !e(n2, m, p, h, f, t2) ? (a2 && s(a2, g, 255, 0, 0), d++) : a2 && s(a2, g, 255, 255, 0);
                else if (a2) {
                  var b = o((void 0, void 0, void 0, void 0, w = (_ = t2)[(y = g) + 3] / 255, i(o(_[y + 0], w), o(_[y + 1], w), o(_[y + 2], w))), 0.1);
                  s(a2, g, b, b, b);
                }
              }
            var _, y, w;
            return d;
          };
        }, 9902: (t, e, r) => {
          t.exports = function t2(e2, r2, i) {
            function n(o2, s) {
              if (!r2[o2]) {
                if (!e2[o2]) {
                  if (a)
                    return a(o2, true);
                  var h = new Error("Cannot find module '" + o2 + "'");
                  throw h.code = "MODULE_NOT_FOUND", h;
                }
                var f = r2[o2] = { exports: {} };
                e2[o2][0].call(f.exports, function(t3) {
                  return n(e2[o2][1][t3] || t3);
                }, f, f.exports, t2, e2, r2, i);
              }
              return r2[o2].exports;
            }
            for (var a = void 0, o = 0; o < i.length; o++)
              n(i[o]);
            return n;
          }({ 1: [function(t2, e2, r2) {
            (function(e3) {
              (function() {
                "use strict";
                let i = t2("./interlace"), n = [function() {
                }, function(t3, e4, r3, i2) {
                  if (i2 === e4.length)
                    throw new Error("Ran out of data");
                  let n2 = e4[i2];
                  t3[r3] = n2, t3[r3 + 1] = n2, t3[r3 + 2] = n2, t3[r3 + 3] = 255;
                }, function(t3, e4, r3, i2) {
                  if (i2 + 1 >= e4.length)
                    throw new Error("Ran out of data");
                  let n2 = e4[i2];
                  t3[r3] = n2, t3[r3 + 1] = n2, t3[r3 + 2] = n2, t3[r3 + 3] = e4[i2 + 1];
                }, function(t3, e4, r3, i2) {
                  if (i2 + 2 >= e4.length)
                    throw new Error("Ran out of data");
                  t3[r3] = e4[i2], t3[r3 + 1] = e4[i2 + 1], t3[r3 + 2] = e4[i2 + 2], t3[r3 + 3] = 255;
                }, function(t3, e4, r3, i2) {
                  if (i2 + 3 >= e4.length)
                    throw new Error("Ran out of data");
                  t3[r3] = e4[i2], t3[r3 + 1] = e4[i2 + 1], t3[r3 + 2] = e4[i2 + 2], t3[r3 + 3] = e4[i2 + 3];
                }], a = [function() {
                }, function(t3, e4, r3, i2) {
                  let n2 = e4[0];
                  t3[r3] = n2, t3[r3 + 1] = n2, t3[r3 + 2] = n2, t3[r3 + 3] = i2;
                }, function(t3, e4, r3) {
                  let i2 = e4[0];
                  t3[r3] = i2, t3[r3 + 1] = i2, t3[r3 + 2] = i2, t3[r3 + 3] = e4[1];
                }, function(t3, e4, r3, i2) {
                  t3[r3] = e4[0], t3[r3 + 1] = e4[1], t3[r3 + 2] = e4[2], t3[r3 + 3] = i2;
                }, function(t3, e4, r3) {
                  t3[r3] = e4[0], t3[r3 + 1] = e4[1], t3[r3 + 2] = e4[2], t3[r3 + 3] = e4[3];
                }];
                function o(t3, e4, r3, i2, a2, o2) {
                  let s2 = t3.width, h = t3.height, f = t3.index;
                  for (let t4 = 0; t4 < h; t4++)
                    for (let h2 = 0; h2 < s2; h2++) {
                      let s3 = r3(h2, t4, f);
                      n[i2](e4, a2, s3, o2), o2 += i2;
                    }
                  return o2;
                }
                function s(t3, e4, r3, i2, n2, o2) {
                  let s2 = t3.width, h = t3.height, f = t3.index;
                  for (let t4 = 0; t4 < h; t4++) {
                    for (let h2 = 0; h2 < s2; h2++) {
                      let s3 = n2.get(i2), u = r3(h2, t4, f);
                      a[i2](e4, s3, u, o2);
                    }
                    n2.resetAfterLine();
                  }
                }
                r2.dataToBitMap = function(t3, r3) {
                  let n2, a2, h = r3.width, f = r3.height, u = r3.depth, l = r3.bpp, c = r3.interlace;
                  8 !== u && (n2 = function(t4, e4) {
                    let r4 = [], i2 = 0;
                    function n3() {
                      if (i2 === t4.length)
                        throw new Error("Ran out of data");
                      let n4, a3, o2, s2, h2, f2, u2, l2, c2 = t4[i2];
                      switch (i2++, e4) {
                        default:
                          throw new Error("unrecognised depth");
                        case 16:
                          u2 = t4[i2], i2++, r4.push((c2 << 8) + u2);
                          break;
                        case 4:
                          u2 = 15 & c2, l2 = c2 >> 4, r4.push(l2, u2);
                          break;
                        case 2:
                          h2 = 3 & c2, f2 = c2 >> 2 & 3, u2 = c2 >> 4 & 3, l2 = c2 >> 6 & 3, r4.push(l2, u2, f2, h2);
                          break;
                        case 1:
                          n4 = 1 & c2, a3 = c2 >> 1 & 1, o2 = c2 >> 2 & 1, s2 = c2 >> 3 & 1, h2 = c2 >> 4 & 1, f2 = c2 >> 5 & 1, u2 = c2 >> 6 & 1, l2 = c2 >> 7 & 1, r4.push(l2, u2, f2, h2, s2, o2, a3, n4);
                      }
                    }
                    return { get: function(t5) {
                      for (; r4.length < t5; )
                        n3();
                      let e5 = r4.slice(0, t5);
                      return r4 = r4.slice(t5), e5;
                    }, resetAfterLine: function() {
                      r4.length = 0;
                    }, end: function() {
                      if (i2 !== t4.length)
                        throw new Error("extra data found");
                    } };
                  }(t3, u)), a2 = u <= 8 ? e3.alloc(h * f * 4) : new Uint16Array(h * f * 4);
                  let d, p, m = Math.pow(2, u) - 1, g = 0;
                  if (c)
                    d = i.getImagePasses(h, f), p = i.getInterlaceIterator(h, f);
                  else {
                    let t4 = 0;
                    p = function() {
                      let e4 = t4;
                      return t4 += 4, e4;
                    }, d = [{ width: h, height: f }];
                  }
                  for (let e4 = 0; e4 < d.length; e4++)
                    8 === u ? g = o(d[e4], a2, p, l, t3, g) : s(d[e4], a2, p, l, n2, m);
                  if (8 === u) {
                    if (g !== t3.length)
                      throw new Error("extra data found");
                  } else
                    n2.end();
                  return a2;
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./interlace": 11, buffer: 33 }], 2: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = t2("./constants");
                e2.exports = function(t3, e3, n, a) {
                  let o = -1 !== [i.COLORTYPE_COLOR_ALPHA, i.COLORTYPE_ALPHA].indexOf(a.colorType);
                  if (a.colorType === a.inputColorType) {
                    let e4 = function() {
                      let t4 = new ArrayBuffer(2);
                      return new DataView(t4).setInt16(0, 256, true), 256 !== new Int16Array(t4)[0];
                    }();
                    if (8 === a.bitDepth || 16 === a.bitDepth && e4)
                      return t3;
                  }
                  let s = 16 !== a.bitDepth ? t3 : new Uint16Array(t3.buffer), h = 255, f = i.COLORTYPE_TO_BPP_MAP[a.inputColorType];
                  4 !== f || a.inputHasAlpha || (f = 3);
                  let u = i.COLORTYPE_TO_BPP_MAP[a.colorType];
                  16 === a.bitDepth && (h = 65535, u *= 2);
                  let l = r3.alloc(e3 * n * u), c = 0, d = 0, p = a.bgColor || {};
                  function m() {
                    let t4, e4, r4, n2 = h;
                    switch (a.inputColorType) {
                      case i.COLORTYPE_COLOR_ALPHA:
                        n2 = s[c + 3], t4 = s[c], e4 = s[c + 1], r4 = s[c + 2];
                        break;
                      case i.COLORTYPE_COLOR:
                        t4 = s[c], e4 = s[c + 1], r4 = s[c + 2];
                        break;
                      case i.COLORTYPE_ALPHA:
                        n2 = s[c + 1], t4 = s[c], e4 = t4, r4 = t4;
                        break;
                      case i.COLORTYPE_GRAYSCALE:
                        t4 = s[c], e4 = t4, r4 = t4;
                        break;
                      default:
                        throw new Error("input color type:" + a.inputColorType + " is not supported at present");
                    }
                    return a.inputHasAlpha && (o || (n2 /= h, t4 = Math.min(Math.max(Math.round((1 - n2) * p.red + n2 * t4), 0), h), e4 = Math.min(Math.max(Math.round((1 - n2) * p.green + n2 * e4), 0), h), r4 = Math.min(Math.max(Math.round((1 - n2) * p.blue + n2 * r4), 0), h))), { red: t4, green: e4, blue: r4, alpha: n2 };
                  }
                  void 0 === p.red && (p.red = h), void 0 === p.green && (p.green = h), void 0 === p.blue && (p.blue = h);
                  for (let t4 = 0; t4 < n; t4++)
                    for (let t5 = 0; t5 < e3; t5++) {
                      let t6 = m();
                      switch (a.colorType) {
                        case i.COLORTYPE_COLOR_ALPHA:
                        case i.COLORTYPE_COLOR:
                          8 === a.bitDepth ? (l[d] = t6.red, l[d + 1] = t6.green, l[d + 2] = t6.blue, o && (l[d + 3] = t6.alpha)) : (l.writeUInt16BE(t6.red, d), l.writeUInt16BE(t6.green, d + 2), l.writeUInt16BE(t6.blue, d + 4), o && l.writeUInt16BE(t6.alpha, d + 6));
                          break;
                        case i.COLORTYPE_ALPHA:
                        case i.COLORTYPE_GRAYSCALE: {
                          let e4 = (t6.red + t6.green + t6.blue) / 3;
                          8 === a.bitDepth ? (l[d] = e4, o && (l[d + 1] = t6.alpha)) : (l.writeUInt16BE(e4, d), o && l.writeUInt16BE(t6.alpha, d + 2));
                          break;
                        }
                        default:
                          throw new Error("unrecognised color Type " + a.colorType);
                      }
                      c += f, d += u;
                    }
                  return l;
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./constants": 4, buffer: 33 }], 3: [function(t2, e2, r2) {
            (function(r3, i) {
              (function() {
                "use strict";
                let n = t2("util"), a = t2("stream"), o = e2.exports = function() {
                  a.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = false, this._encoding = "utf8", this.writable = true;
                };
                n.inherits(o, a), o.prototype.read = function(t3, e3) {
                  this._reads.push({ length: Math.abs(t3), allowLess: t3 < 0, func: e3 }), r3.nextTick(function() {
                    this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = false, this.emit("drain"));
                  }.bind(this));
                }, o.prototype.write = function(t3, e3) {
                  if (!this.writable)
                    return this.emit("error", new Error("Stream not writable")), false;
                  let r4;
                  return r4 = i.isBuffer(t3) ? t3 : i.from(t3, e3 || this._encoding), this._buffers.push(r4), this._buffered += r4.length, this._process(), this._reads && 0 === this._reads.length && (this._paused = true), this.writable && !this._paused;
                }, o.prototype.end = function(t3, e3) {
                  t3 && this.write(t3, e3), this.writable = false, this._buffers && (0 === this._buffers.length ? this._end() : (this._buffers.push(null), this._process()));
                }, o.prototype.destroySoon = o.prototype.end, o.prototype._end = function() {
                  this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
                }, o.prototype.destroy = function() {
                  this._buffers && (this.writable = false, this._reads = null, this._buffers = null, this.emit("close"));
                }, o.prototype._processReadAllowingLess = function(t3) {
                  this._reads.shift();
                  let e3 = this._buffers[0];
                  e3.length > t3.length ? (this._buffered -= t3.length, this._buffers[0] = e3.slice(t3.length), t3.func.call(this, e3.slice(0, t3.length))) : (this._buffered -= e3.length, this._buffers.shift(), t3.func.call(this, e3));
                }, o.prototype._processRead = function(t3) {
                  this._reads.shift();
                  let e3 = 0, r4 = 0, n2 = i.alloc(t3.length);
                  for (; e3 < t3.length; ) {
                    let i2 = this._buffers[r4++], a2 = Math.min(i2.length, t3.length - e3);
                    i2.copy(n2, e3, 0, a2), e3 += a2, a2 !== i2.length && (this._buffers[--r4] = i2.slice(a2));
                  }
                  r4 > 0 && this._buffers.splice(0, r4), this._buffered -= t3.length, t3.func.call(this, n2);
                }, o.prototype._process = function() {
                  try {
                    for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                      let t3 = this._reads[0];
                      if (t3.allowLess)
                        this._processReadAllowingLess(t3);
                      else {
                        if (!(this._buffered >= t3.length))
                          break;
                        this._processRead(t3);
                      }
                    }
                    this._buffers && !this.writable && this._end();
                  } catch (t3) {
                    this.emit("error", t3);
                  }
                };
              }).call(this);
            }).call(this, t2("_process"), t2("buffer").Buffer);
          }, { _process: 60, buffer: 33, stream: 61, util: 81 }], 4: [function(t2, e2, r2) {
            "use strict";
            e2.exports = { PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10], TYPE_IHDR: 1229472850, TYPE_IEND: 1229278788, TYPE_IDAT: 1229209940, TYPE_PLTE: 1347179589, TYPE_tRNS: 1951551059, TYPE_gAMA: 1732332865, COLORTYPE_GRAYSCALE: 0, COLORTYPE_PALETTE: 1, COLORTYPE_COLOR: 2, COLORTYPE_ALPHA: 4, COLORTYPE_PALETTE_COLOR: 3, COLORTYPE_COLOR_ALPHA: 6, COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 }, GAMMA_DIVISION: 1e5 };
          }, {}], 5: [function(t2, e2, r2) {
            "use strict";
            let i = [];
            !function() {
              for (let t3 = 0; t3 < 256; t3++) {
                let e3 = t3;
                for (let t4 = 0; t4 < 8; t4++)
                  1 & e3 ? e3 = 3988292384 ^ e3 >>> 1 : e3 >>>= 1;
                i[t3] = e3;
              }
            }();
            let n = e2.exports = function() {
              this._crc = -1;
            };
            n.prototype.write = function(t3) {
              for (let e3 = 0; e3 < t3.length; e3++)
                this._crc = i[255 & (this._crc ^ t3[e3])] ^ this._crc >>> 8;
              return true;
            }, n.prototype.crc32 = function() {
              return -1 ^ this._crc;
            }, n.crc32 = function(t3) {
              let e3 = -1;
              for (let r3 = 0; r3 < t3.length; r3++)
                e3 = i[255 & (e3 ^ t3[r3])] ^ e3 >>> 8;
              return -1 ^ e3;
            };
          }, {}], 6: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = t2("./paeth-predictor");
                let n = { 0: function(t3, e3, r4, i2, n2) {
                  for (let a2 = 0; a2 < r4; a2++)
                    i2[n2 + a2] = t3[e3 + a2];
                }, 1: function(t3, e3, r4, i2, n2, a2) {
                  for (let o = 0; o < r4; o++) {
                    let r5 = o >= a2 ? t3[e3 + o - a2] : 0, s = t3[e3 + o] - r5;
                    i2[n2 + o] = s;
                  }
                }, 2: function(t3, e3, r4, i2, n2) {
                  for (let a2 = 0; a2 < r4; a2++) {
                    let o = e3 > 0 ? t3[e3 + a2 - r4] : 0, s = t3[e3 + a2] - o;
                    i2[n2 + a2] = s;
                  }
                }, 3: function(t3, e3, r4, i2, n2, a2) {
                  for (let o = 0; o < r4; o++) {
                    let s = o >= a2 ? t3[e3 + o - a2] : 0, h = e3 > 0 ? t3[e3 + o - r4] : 0, f = t3[e3 + o] - (s + h >> 1);
                    i2[n2 + o] = f;
                  }
                }, 4: function(t3, e3, r4, n2, a2, o) {
                  for (let s = 0; s < r4; s++) {
                    let h = s >= o ? t3[e3 + s - o] : 0, f = e3 > 0 ? t3[e3 + s - r4] : 0, u = e3 > 0 && s >= o ? t3[e3 + s - (r4 + o)] : 0, l = t3[e3 + s] - i(h, f, u);
                    n2[a2 + s] = l;
                  }
                } }, a = { 0: function(t3, e3, r4) {
                  let i2 = 0, n2 = e3 + r4;
                  for (let r5 = e3; r5 < n2; r5++)
                    i2 += Math.abs(t3[r5]);
                  return i2;
                }, 1: function(t3, e3, r4, i2) {
                  let n2 = 0;
                  for (let a2 = 0; a2 < r4; a2++) {
                    let r5 = a2 >= i2 ? t3[e3 + a2 - i2] : 0, o = t3[e3 + a2] - r5;
                    n2 += Math.abs(o);
                  }
                  return n2;
                }, 2: function(t3, e3, r4) {
                  let i2 = 0, n2 = e3 + r4;
                  for (let a2 = e3; a2 < n2; a2++) {
                    let n3 = e3 > 0 ? t3[a2 - r4] : 0, o = t3[a2] - n3;
                    i2 += Math.abs(o);
                  }
                  return i2;
                }, 3: function(t3, e3, r4, i2) {
                  let n2 = 0;
                  for (let a2 = 0; a2 < r4; a2++) {
                    let o = a2 >= i2 ? t3[e3 + a2 - i2] : 0, s = e3 > 0 ? t3[e3 + a2 - r4] : 0, h = t3[e3 + a2] - (o + s >> 1);
                    n2 += Math.abs(h);
                  }
                  return n2;
                }, 4: function(t3, e3, r4, n2) {
                  let a2 = 0;
                  for (let o = 0; o < r4; o++) {
                    let s = o >= n2 ? t3[e3 + o - n2] : 0, h = e3 > 0 ? t3[e3 + o - r4] : 0, f = e3 > 0 && o >= n2 ? t3[e3 + o - (r4 + n2)] : 0, u = t3[e3 + o] - i(s, h, f);
                    a2 += Math.abs(u);
                  }
                  return a2;
                } };
                e2.exports = function(t3, e3, i2, o, s) {
                  let h;
                  if ("filterType" in o && -1 !== o.filterType) {
                    if ("number" != typeof o.filterType)
                      throw new Error("unrecognised filter types");
                    h = [o.filterType];
                  } else
                    h = [0, 1, 2, 3, 4];
                  16 === o.bitDepth && (s *= 2);
                  let f = e3 * s, u = 0, l = 0, c = r3.alloc((f + 1) * i2), d = h[0];
                  for (let e4 = 0; e4 < i2; e4++) {
                    if (h.length > 1) {
                      let e5 = 1 / 0;
                      for (let r4 = 0; r4 < h.length; r4++) {
                        let i3 = a[h[r4]](t3, l, f, s);
                        i3 < e5 && (d = h[r4], e5 = i3);
                      }
                    }
                    c[u] = d, u++, n[d](t3, l, f, c, u, s), u += f, l += f;
                  }
                  return c;
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./paeth-predictor": 15, buffer: 33 }], 7: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = t2("util"), n = t2("./chunkstream"), a = t2("./filter-parse"), o = e2.exports = function(t3) {
                  n.call(this);
                  let e3 = [], i2 = this;
                  this._filter = new a(t3, { read: this.read.bind(this), write: function(t4) {
                    e3.push(t4);
                  }, complete: function() {
                    i2.emit("complete", r3.concat(e3));
                  } }), this._filter.start();
                };
                i.inherits(o, n);
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./chunkstream": 3, "./filter-parse": 9, buffer: 33, util: 81 }], 8: [function(t2, e2, r2) {
            (function(e3) {
              (function() {
                "use strict";
                let i = t2("./sync-reader"), n = t2("./filter-parse");
                r2.process = function(t3, r3) {
                  let a = [], o = new i(t3);
                  return new n(r3, { read: o.read.bind(o), write: function(t4) {
                    a.push(t4);
                  }, complete: function() {
                  } }).start(), o.process(), e3.concat(a);
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./filter-parse": 9, "./sync-reader": 22, buffer: 33 }], 9: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = t2("./interlace"), n = t2("./paeth-predictor");
                function a(t3, e3, r4) {
                  let i2 = t3 * e3;
                  return 8 !== r4 && (i2 = Math.ceil(i2 / (8 / r4))), i2;
                }
                let o = e2.exports = function(t3, e3) {
                  let r4 = t3.width, n2 = t3.height, o2 = t3.interlace, s = t3.bpp, h = t3.depth;
                  if (this.read = e3.read, this.write = e3.write, this.complete = e3.complete, this._imageIndex = 0, this._images = [], o2) {
                    let t4 = i.getImagePasses(r4, n2);
                    for (let e4 = 0; e4 < t4.length; e4++)
                      this._images.push({ byteWidth: a(t4[e4].width, s, h), height: t4[e4].height, lineIndex: 0 });
                  } else
                    this._images.push({ byteWidth: a(r4, s, h), height: n2, lineIndex: 0 });
                  this._xComparison = 8 === h ? s : 16 === h ? 2 * s : 1;
                };
                o.prototype.start = function() {
                  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
                }, o.prototype._unFilterType1 = function(t3, e3, r4) {
                  let i2 = this._xComparison, n2 = i2 - 1;
                  for (let a2 = 0; a2 < r4; a2++) {
                    let r5 = t3[1 + a2], o2 = a2 > n2 ? e3[a2 - i2] : 0;
                    e3[a2] = r5 + o2;
                  }
                }, o.prototype._unFilterType2 = function(t3, e3, r4) {
                  let i2 = this._lastLine;
                  for (let n2 = 0; n2 < r4; n2++) {
                    let r5 = t3[1 + n2], a2 = i2 ? i2[n2] : 0;
                    e3[n2] = r5 + a2;
                  }
                }, o.prototype._unFilterType3 = function(t3, e3, r4) {
                  let i2 = this._xComparison, n2 = i2 - 1, a2 = this._lastLine;
                  for (let o2 = 0; o2 < r4; o2++) {
                    let r5 = t3[1 + o2], s = a2 ? a2[o2] : 0, h = o2 > n2 ? e3[o2 - i2] : 0, f = Math.floor((h + s) / 2);
                    e3[o2] = r5 + f;
                  }
                }, o.prototype._unFilterType4 = function(t3, e3, r4) {
                  let i2 = this._xComparison, a2 = i2 - 1, o2 = this._lastLine;
                  for (let s = 0; s < r4; s++) {
                    let r5 = t3[1 + s], h = o2 ? o2[s] : 0, f = s > a2 ? e3[s - i2] : 0, u = s > a2 && o2 ? o2[s - i2] : 0, l = n(f, h, u);
                    e3[s] = r5 + l;
                  }
                }, o.prototype._reverseFilterLine = function(t3) {
                  let e3, i2 = t3[0], n2 = this._images[this._imageIndex], a2 = n2.byteWidth;
                  if (0 === i2)
                    e3 = t3.slice(1, a2 + 1);
                  else
                    switch (e3 = r3.alloc(a2), i2) {
                      case 1:
                        this._unFilterType1(t3, e3, a2);
                        break;
                      case 2:
                        this._unFilterType2(t3, e3, a2);
                        break;
                      case 3:
                        this._unFilterType3(t3, e3, a2);
                        break;
                      case 4:
                        this._unFilterType4(t3, e3, a2);
                        break;
                      default:
                        throw new Error("Unrecognised filter type - " + i2);
                    }
                  this.write(e3), n2.lineIndex++, n2.lineIndex >= n2.height ? (this._lastLine = null, this._imageIndex++, n2 = this._images[this._imageIndex]) : this._lastLine = e3, n2 ? this.read(n2.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./interlace": 11, "./paeth-predictor": 15, buffer: 33 }], 10: [function(t2, e2, r2) {
            (function(t3) {
              (function() {
                "use strict";
                e2.exports = function(e3, r3, i = false) {
                  let n = r3.depth, a = r3.width, o = r3.height, s = r3.colorType, h = r3.transColor, f = r3.palette, u = e3;
                  return 3 === s ? function(t4, e4, r4, i2, n2) {
                    let a2 = 0;
                    for (let o2 = 0; o2 < i2; o2++)
                      for (let i3 = 0; i3 < r4; i3++) {
                        let r5 = n2[t4[a2]];
                        if (!r5)
                          throw new Error("index " + t4[a2] + " not in palette");
                        for (let t5 = 0; t5 < 4; t5++)
                          e4[a2 + t5] = r5[t5];
                        a2 += 4;
                      }
                  }(e3, u, a, o, f) : (h && function(t4, e4, r4, i2, n2) {
                    let a2 = 0;
                    for (let o2 = 0; o2 < i2; o2++)
                      for (let i3 = 0; i3 < r4; i3++) {
                        let r5 = false;
                        if (1 === n2.length ? n2[0] === t4[a2] && (r5 = true) : n2[0] === t4[a2] && n2[1] === t4[a2 + 1] && n2[2] === t4[a2 + 2] && (r5 = true), r5)
                          for (let t5 = 0; t5 < 4; t5++)
                            e4[a2 + t5] = 0;
                        a2 += 4;
                      }
                  }(e3, u, a, o, h), 8 === n || i || (16 === n && (u = t3.alloc(a * o * 4)), function(t4, e4, r4, i2, n2) {
                    let a2 = Math.pow(2, n2) - 1, o2 = 0;
                    for (let n3 = 0; n3 < i2; n3++)
                      for (let i3 = 0; i3 < r4; i3++) {
                        for (let r5 = 0; r5 < 4; r5++)
                          e4[o2 + r5] = Math.floor(255 * t4[o2 + r5] / a2 + 0.5);
                        o2 += 4;
                      }
                  }(e3, u, a, o, n))), u;
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { buffer: 33 }], 11: [function(t2, e2, r2) {
            "use strict";
            let i = [{ x: [0], y: [0] }, { x: [4], y: [0] }, { x: [0, 4], y: [4] }, { x: [2, 6], y: [0, 4] }, { x: [0, 2, 4, 6], y: [2, 6] }, { x: [1, 3, 5, 7], y: [0, 2, 4, 6] }, { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] }];
            r2.getImagePasses = function(t3, e3) {
              let r3 = [], n = t3 % 8, a = e3 % 8, o = (t3 - n) / 8, s = (e3 - a) / 8;
              for (let t4 = 0; t4 < i.length; t4++) {
                let e4 = i[t4], h = o * e4.x.length, f = s * e4.y.length;
                for (let t5 = 0; t5 < e4.x.length && e4.x[t5] < n; t5++)
                  h++;
                for (let t5 = 0; t5 < e4.y.length && e4.y[t5] < a; t5++)
                  f++;
                h > 0 && f > 0 && r3.push({ width: h, height: f, index: t4 });
              }
              return r3;
            }, r2.getInterlaceIterator = function(t3) {
              return function(e3, r3, n) {
                let a = e3 % i[n].x.length, o = (e3 - a) / i[n].x.length * 8 + i[n].x[a], s = r3 % i[n].y.length;
                return 4 * o + ((r3 - s) / i[n].y.length * 8 + i[n].y[s]) * t3 * 4;
              };
            };
          }, {}], 12: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = t2("util"), n = t2("stream"), a = t2("./constants"), o = t2("./packer"), s = e2.exports = function(t3) {
                  n.call(this);
                  let e3 = t3 || {};
                  this._packer = new o(e3), this._deflate = this._packer.createDeflate(), this.readable = true;
                };
                i.inherits(s, n), s.prototype.pack = function(t3, e3, i2, n2) {
                  this.emit("data", r3.from(a.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(e3, i2)), n2 && this.emit("data", this._packer.packGAMA(n2));
                  let o2 = this._packer.filterData(t3, e3, i2);
                  this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", function(t4) {
                    this.emit("data", this._packer.packIDAT(t4));
                  }.bind(this)), this._deflate.on("end", function() {
                    this.emit("data", this._packer.packIEND()), this.emit("end");
                  }.bind(this)), this._deflate.end(o2);
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./constants": 4, "./packer": 14, buffer: 33, stream: 61, util: 81 }], 13: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = true, n = t2("zlib");
                n.deflateSync || (i = false);
                let a = t2("./constants"), o = t2("./packer");
                e2.exports = function(t3, e3) {
                  if (!i)
                    throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
                  let s = new o(e3 || {}), h = [];
                  h.push(r3.from(a.PNG_SIGNATURE)), h.push(s.packIHDR(t3.width, t3.height)), t3.gamma && h.push(s.packGAMA(t3.gamma));
                  let f = s.filterData(t3.data, t3.width, t3.height), u = n.deflateSync(f, s.getDeflateOptions());
                  if (f = null, !u || !u.length)
                    throw new Error("bad png - invalid compressed data response");
                  return h.push(s.packIDAT(u)), h.push(s.packIEND()), r3.concat(h);
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./constants": 4, "./packer": 14, buffer: 33, zlib: 32 }], 14: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = t2("./constants"), n = t2("./crc"), a = t2("./bitpacker"), o = t2("./filter-pack"), s = t2("zlib"), h = e2.exports = function(t3) {
                  if (this._options = t3, t3.deflateChunkSize = t3.deflateChunkSize || 32768, t3.deflateLevel = null != t3.deflateLevel ? t3.deflateLevel : 9, t3.deflateStrategy = null != t3.deflateStrategy ? t3.deflateStrategy : 3, t3.inputHasAlpha = null == t3.inputHasAlpha || t3.inputHasAlpha, t3.deflateFactory = t3.deflateFactory || s.createDeflate, t3.bitDepth = t3.bitDepth || 8, t3.colorType = "number" == typeof t3.colorType ? t3.colorType : i.COLORTYPE_COLOR_ALPHA, t3.inputColorType = "number" == typeof t3.inputColorType ? t3.inputColorType : i.COLORTYPE_COLOR_ALPHA, -1 === [i.COLORTYPE_GRAYSCALE, i.COLORTYPE_COLOR, i.COLORTYPE_COLOR_ALPHA, i.COLORTYPE_ALPHA].indexOf(t3.colorType))
                    throw new Error("option color type:" + t3.colorType + " is not supported at present");
                  if (-1 === [i.COLORTYPE_GRAYSCALE, i.COLORTYPE_COLOR, i.COLORTYPE_COLOR_ALPHA, i.COLORTYPE_ALPHA].indexOf(t3.inputColorType))
                    throw new Error("option input color type:" + t3.inputColorType + " is not supported at present");
                  if (8 !== t3.bitDepth && 16 !== t3.bitDepth)
                    throw new Error("option bit depth:" + t3.bitDepth + " is not supported at present");
                };
                h.prototype.getDeflateOptions = function() {
                  return { chunkSize: this._options.deflateChunkSize, level: this._options.deflateLevel, strategy: this._options.deflateStrategy };
                }, h.prototype.createDeflate = function() {
                  return this._options.deflateFactory(this.getDeflateOptions());
                }, h.prototype.filterData = function(t3, e3, r4) {
                  let n2 = a(t3, e3, r4, this._options), s2 = i.COLORTYPE_TO_BPP_MAP[this._options.colorType];
                  return o(n2, e3, r4, this._options, s2);
                }, h.prototype._packChunk = function(t3, e3) {
                  let i2 = e3 ? e3.length : 0, a2 = r3.alloc(i2 + 12);
                  return a2.writeUInt32BE(i2, 0), a2.writeUInt32BE(t3, 4), e3 && e3.copy(a2, 8), a2.writeInt32BE(n.crc32(a2.slice(4, a2.length - 4)), a2.length - 4), a2;
                }, h.prototype.packGAMA = function(t3) {
                  let e3 = r3.alloc(4);
                  return e3.writeUInt32BE(Math.floor(t3 * i.GAMMA_DIVISION), 0), this._packChunk(i.TYPE_gAMA, e3);
                }, h.prototype.packIHDR = function(t3, e3) {
                  let n2 = r3.alloc(13);
                  return n2.writeUInt32BE(t3, 0), n2.writeUInt32BE(e3, 4), n2[8] = this._options.bitDepth, n2[9] = this._options.colorType, n2[10] = 0, n2[11] = 0, n2[12] = 0, this._packChunk(i.TYPE_IHDR, n2);
                }, h.prototype.packIDAT = function(t3) {
                  return this._packChunk(i.TYPE_IDAT, t3);
                }, h.prototype.packIEND = function() {
                  return this._packChunk(i.TYPE_IEND, null);
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 33, zlib: 32 }], 15: [function(t2, e2, r2) {
            "use strict";
            e2.exports = function(t3, e3, r3) {
              let i = t3 + e3 - r3, n = Math.abs(i - t3), a = Math.abs(i - e3), o = Math.abs(i - r3);
              return n <= a && n <= o ? t3 : a <= o ? e3 : r3;
            };
          }, {}], 16: [function(t2, e2, r2) {
            "use strict";
            let i = t2("util"), n = t2("zlib"), a = t2("./chunkstream"), o = t2("./filter-parse-async"), s = t2("./parser"), h = t2("./bitmapper"), f = t2("./format-normaliser"), u = e2.exports = function(t3) {
              a.call(this), this._parser = new s(t3, { read: this.read.bind(this), error: this._handleError.bind(this), metadata: this._handleMetaData.bind(this), gamma: this.emit.bind(this, "gamma"), palette: this._handlePalette.bind(this), transColor: this._handleTransColor.bind(this), finished: this._finished.bind(this), inflateData: this._inflateData.bind(this), simpleTransparency: this._simpleTransparency.bind(this), headersFinished: this._headersFinished.bind(this) }), this._options = t3, this.writable = true, this._parser.start();
            };
            i.inherits(u, a), u.prototype._handleError = function(t3) {
              this.emit("error", t3), this.writable = false, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
              })), this.errord = true;
            }, u.prototype._inflateData = function(t3) {
              if (!this._inflate)
                if (this._bitmapInfo.interlace)
                  this._inflate = n.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
                else {
                  let t4 = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, e3 = Math.max(t4, n.Z_MIN_CHUNK);
                  this._inflate = n.createInflate({ chunkSize: e3 });
                  let r3 = t4, i2 = this.emit.bind(this, "error");
                  this._inflate.on("error", function(t5) {
                    r3 && i2(t5);
                  }), this._filter.on("complete", this._complete.bind(this));
                  let a2 = this._filter.write.bind(this._filter);
                  this._inflate.on("data", function(t5) {
                    r3 && (t5.length > r3 && (t5 = t5.slice(0, r3)), r3 -= t5.length, a2(t5));
                  }), this._inflate.on("end", this._filter.end.bind(this._filter));
                }
              this._inflate.write(t3);
            }, u.prototype._handleMetaData = function(t3) {
              this._metaData = t3, this._bitmapInfo = Object.create(t3), this._filter = new o(this._bitmapInfo);
            }, u.prototype._handleTransColor = function(t3) {
              this._bitmapInfo.transColor = t3;
            }, u.prototype._handlePalette = function(t3) {
              this._bitmapInfo.palette = t3;
            }, u.prototype._simpleTransparency = function() {
              this._metaData.alpha = true;
            }, u.prototype._headersFinished = function() {
              this.emit("metadata", this._metaData);
            }, u.prototype._finished = function() {
              this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
            }, u.prototype._complete = function(t3) {
              if (this.errord)
                return;
              let e3;
              try {
                let r3 = h.dataToBitMap(t3, this._bitmapInfo);
                e3 = f(r3, this._bitmapInfo, this._options.skipRescale), r3 = null;
              } catch (t4) {
                return void this._handleError(t4);
              }
              this.emit("parsed", e3);
            };
          }, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 81, zlib: 32 }], 17: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = true, n = t2("zlib"), a = t2("./sync-inflate");
                n.deflateSync || (i = false);
                let o = t2("./sync-reader"), s = t2("./filter-parse-sync"), h = t2("./parser"), f = t2("./bitmapper"), u = t2("./format-normaliser");
                e2.exports = function(t3, e3) {
                  if (!i)
                    throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
                  let l, c, d;
                  let p = [];
                  let m = new o(t3);
                  if (new h(e3, { read: m.read.bind(m), error: function(t4) {
                    l = t4;
                  }, metadata: function(t4) {
                    c = t4;
                  }, gamma: function(t4) {
                    d = t4;
                  }, palette: function(t4) {
                    c.palette = t4;
                  }, transColor: function(t4) {
                    c.transColor = t4;
                  }, inflateData: function(t4) {
                    p.push(t4);
                  }, simpleTransparency: function() {
                    c.alpha = true;
                  } }).start(), m.process(), l)
                    throw l;
                  let g, b = r3.concat(p);
                  if (p.length = 0, c.interlace)
                    g = n.inflateSync(b);
                  else {
                    let t4 = (1 + (c.width * c.bpp * c.depth + 7 >> 3)) * c.height;
                    g = a(b, { chunkSize: t4, maxLength: t4 });
                  }
                  if (b = null, !g || !g.length)
                    throw new Error("bad png - invalid inflate data response");
                  let _ = s.process(g, c);
                  b = null;
                  let y = f.dataToBitMap(_, c);
                  _ = null;
                  let w = u(y, c, e3.skipRescale);
                  return c.data = w, c.gamma = d || 0, c;
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 33, zlib: 32 }], 18: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                let i = t2("./constants"), n = t2("./crc"), a = e2.exports = function(t3, e3) {
                  this._options = t3, t3.checkCRC = false !== t3.checkCRC, this._hasIHDR = false, this._hasIEND = false, this._emittedHeadersFinished = false, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[i.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[i.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[i.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[i.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[i.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[i.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = e3.read, this.error = e3.error, this.metadata = e3.metadata, this.gamma = e3.gamma, this.transColor = e3.transColor, this.palette = e3.palette, this.parsed = e3.parsed, this.inflateData = e3.inflateData, this.finished = e3.finished, this.simpleTransparency = e3.simpleTransparency, this.headersFinished = e3.headersFinished || function() {
                  };
                };
                a.prototype.start = function() {
                  this.read(i.PNG_SIGNATURE.length, this._parseSignature.bind(this));
                }, a.prototype._parseSignature = function(t3) {
                  let e3 = i.PNG_SIGNATURE;
                  for (let r4 = 0; r4 < e3.length; r4++)
                    if (t3[r4] !== e3[r4])
                      return void this.error(new Error("Invalid file signature"));
                  this.read(8, this._parseChunkBegin.bind(this));
                }, a.prototype._parseChunkBegin = function(t3) {
                  let e3 = t3.readUInt32BE(0), a2 = t3.readUInt32BE(4), o = "";
                  for (let e4 = 4; e4 < 8; e4++)
                    o += String.fromCharCode(t3[e4]);
                  let s = Boolean(32 & t3[4]);
                  if (this._hasIHDR || a2 === i.TYPE_IHDR) {
                    if (this._crc = new n(), this._crc.write(r3.from(o)), this._chunks[a2])
                      return this._chunks[a2](e3);
                    s ? this.read(e3 + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + o));
                  } else
                    this.error(new Error("Expected IHDR on beggining"));
                }, a.prototype._skipChunk = function() {
                  this.read(8, this._parseChunkBegin.bind(this));
                }, a.prototype._handleChunkEnd = function() {
                  this.read(4, this._parseChunkEnd.bind(this));
                }, a.prototype._parseChunkEnd = function(t3) {
                  let e3 = t3.readInt32BE(0), r4 = this._crc.crc32();
                  this._options.checkCRC && r4 !== e3 ? this.error(new Error("Crc error - " + e3 + " - " + r4)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
                }, a.prototype._handleIHDR = function(t3) {
                  this.read(t3, this._parseIHDR.bind(this));
                }, a.prototype._parseIHDR = function(t3) {
                  this._crc.write(t3);
                  let e3 = t3.readUInt32BE(0), r4 = t3.readUInt32BE(4), n2 = t3[8], a2 = t3[9], o = t3[10], s = t3[11], h = t3[12];
                  if (8 !== n2 && 4 !== n2 && 2 !== n2 && 1 !== n2 && 16 !== n2)
                    return void this.error(new Error("Unsupported bit depth " + n2));
                  if (!(a2 in i.COLORTYPE_TO_BPP_MAP))
                    return void this.error(new Error("Unsupported color type"));
                  if (0 !== o)
                    return void this.error(new Error("Unsupported compression method"));
                  if (0 !== s)
                    return void this.error(new Error("Unsupported filter method"));
                  if (0 !== h && 1 !== h)
                    return void this.error(new Error("Unsupported interlace method"));
                  this._colorType = a2;
                  let f = i.COLORTYPE_TO_BPP_MAP[this._colorType];
                  this._hasIHDR = true, this.metadata({ width: e3, height: r4, depth: n2, interlace: Boolean(h), palette: Boolean(a2 & i.COLORTYPE_PALETTE), color: Boolean(a2 & i.COLORTYPE_COLOR), alpha: Boolean(a2 & i.COLORTYPE_ALPHA), bpp: f, colorType: a2 }), this._handleChunkEnd();
                }, a.prototype._handlePLTE = function(t3) {
                  this.read(t3, this._parsePLTE.bind(this));
                }, a.prototype._parsePLTE = function(t3) {
                  this._crc.write(t3);
                  let e3 = Math.floor(t3.length / 3);
                  for (let r4 = 0; r4 < e3; r4++)
                    this._palette.push([t3[3 * r4], t3[3 * r4 + 1], t3[3 * r4 + 2], 255]);
                  this.palette(this._palette), this._handleChunkEnd();
                }, a.prototype._handleTRNS = function(t3) {
                  this.simpleTransparency(), this.read(t3, this._parseTRNS.bind(this));
                }, a.prototype._parseTRNS = function(t3) {
                  if (this._crc.write(t3), this._colorType === i.COLORTYPE_PALETTE_COLOR) {
                    if (0 === this._palette.length)
                      return void this.error(new Error("Transparency chunk must be after palette"));
                    if (t3.length > this._palette.length)
                      return void this.error(new Error("More transparent colors than palette size"));
                    for (let e3 = 0; e3 < t3.length; e3++)
                      this._palette[e3][3] = t3[e3];
                    this.palette(this._palette);
                  }
                  this._colorType === i.COLORTYPE_GRAYSCALE && this.transColor([t3.readUInt16BE(0)]), this._colorType === i.COLORTYPE_COLOR && this.transColor([t3.readUInt16BE(0), t3.readUInt16BE(2), t3.readUInt16BE(4)]), this._handleChunkEnd();
                }, a.prototype._handleGAMA = function(t3) {
                  this.read(t3, this._parseGAMA.bind(this));
                }, a.prototype._parseGAMA = function(t3) {
                  this._crc.write(t3), this.gamma(t3.readUInt32BE(0) / i.GAMMA_DIVISION), this._handleChunkEnd();
                }, a.prototype._handleIDAT = function(t3) {
                  this._emittedHeadersFinished || (this._emittedHeadersFinished = true, this.headersFinished()), this.read(-t3, this._parseIDAT.bind(this, t3));
                }, a.prototype._parseIDAT = function(t3, e3) {
                  if (this._crc.write(e3), this._colorType === i.COLORTYPE_PALETTE_COLOR && 0 === this._palette.length)
                    throw new Error("Expected palette not found");
                  this.inflateData(e3);
                  let r4 = t3 - e3.length;
                  r4 > 0 ? this._handleIDAT(r4) : this._handleChunkEnd();
                }, a.prototype._handleIEND = function(t3) {
                  this.read(t3, this._parseIEND.bind(this));
                }, a.prototype._parseIEND = function(t3) {
                  this._crc.write(t3), this._hasIEND = true, this._handleChunkEnd(), this.finished && this.finished();
                };
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "./constants": 4, "./crc": 5, buffer: 33 }], 19: [function(t2, e2, r2) {
            "use strict";
            let i = t2("./parser-sync"), n = t2("./packer-sync");
            r2.read = function(t3, e3) {
              return i(t3, e3 || {});
            }, r2.write = function(t3, e3) {
              return n(t3, e3);
            };
          }, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function(t2, e2, r2) {
            (function(e3, i) {
              (function() {
                "use strict";
                let n = t2("util"), a = t2("stream"), o = t2("./parser-async"), s = t2("./packer-async"), h = t2("./png-sync"), f = r2.PNG = function(t3) {
                  a.call(this), t3 = t3 || {}, this.width = 0 | t3.width, this.height = 0 | t3.height, this.data = this.width > 0 && this.height > 0 ? i.alloc(4 * this.width * this.height) : null, t3.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = true, this._parser = new o(t3), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", function(t4) {
                    this.data = t4, this.emit("parsed", t4);
                  }.bind(this)), this._packer = new s(t3), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
                };
                n.inherits(f, a), f.sync = h, f.prototype.pack = function() {
                  return this.data && this.data.length ? (e3.nextTick(function() {
                    this._packer.pack(this.data, this.width, this.height, this.gamma);
                  }.bind(this)), this) : (this.emit("error", "No data provided"), this);
                }, f.prototype.parse = function(t3, e4) {
                  if (e4) {
                    let t4, r3;
                    t4 = function(t5) {
                      this.removeListener("error", r3), this.data = t5, e4(null, this);
                    }.bind(this), r3 = function(r4) {
                      this.removeListener("parsed", t4), e4(r4, null);
                    }.bind(this), this.once("parsed", t4), this.once("error", r3);
                  }
                  return this.end(t3), this;
                }, f.prototype.write = function(t3) {
                  return this._parser.write(t3), true;
                }, f.prototype.end = function(t3) {
                  this._parser.end(t3);
                }, f.prototype._metadata = function(t3) {
                  this.width = t3.width, this.height = t3.height, this.emit("metadata", t3);
                }, f.prototype._gamma = function(t3) {
                  this.gamma = t3;
                }, f.prototype._handleClose = function() {
                  this._parser.writable || this._packer.readable || this.emit("close");
                }, f.bitblt = function(t3, e4, r3, i2, n2, a2, o2, s2) {
                  if (i2 |= 0, n2 |= 0, a2 |= 0, o2 |= 0, s2 |= 0, (r3 |= 0) > t3.width || i2 > t3.height || r3 + n2 > t3.width || i2 + a2 > t3.height)
                    throw new Error("bitblt reading outside image");
                  if (o2 > e4.width || s2 > e4.height || o2 + n2 > e4.width || s2 + a2 > e4.height)
                    throw new Error("bitblt writing outside image");
                  for (let h2 = 0; h2 < a2; h2++)
                    t3.data.copy(e4.data, (s2 + h2) * e4.width + o2 << 2, (i2 + h2) * t3.width + r3 << 2, (i2 + h2) * t3.width + r3 + n2 << 2);
                }, f.prototype.bitblt = function(t3, e4, r3, i2, n2, a2, o2) {
                  return f.bitblt(this, t3, e4, r3, i2, n2, a2, o2), this;
                }, f.adjustGamma = function(t3) {
                  if (t3.gamma) {
                    for (let e4 = 0; e4 < t3.height; e4++)
                      for (let r3 = 0; r3 < t3.width; r3++) {
                        let i2 = t3.width * e4 + r3 << 2;
                        for (let e5 = 0; e5 < 3; e5++) {
                          let r4 = t3.data[i2 + e5] / 255;
                          r4 = Math.pow(r4, 1 / 2.2 / t3.gamma), t3.data[i2 + e5] = Math.round(255 * r4);
                        }
                      }
                    t3.gamma = 0;
                  }
                }, f.prototype.adjustGamma = function() {
                  f.adjustGamma(this);
                };
              }).call(this);
            }).call(this, t2("_process"), t2("buffer").Buffer);
          }, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 60, buffer: 33, stream: 61, util: 81 }], 21: [function(t2, e2, r2) {
            (function(i, n) {
              (function() {
                "use strict";
                let a = t2("assert").ok, o = t2("zlib"), s = t2("util"), h = t2("buffer").kMaxLength;
                function f(t3) {
                  if (!(this instanceof f))
                    return new f(t3);
                  t3 && t3.chunkSize < o.Z_MIN_CHUNK && (t3.chunkSize = o.Z_MIN_CHUNK), o.Inflate.call(this, t3), this._offset = void 0 === this._offset ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, t3 && null != t3.maxLength && (this._maxLength = t3.maxLength);
                }
                function u(t3, e3) {
                  e3 && i.nextTick(e3), t3._handle && (t3._handle.close(), t3._handle = null);
                }
                function l(t3, e3) {
                  return function(t4, e4) {
                    if ("string" == typeof e4 && (e4 = n.from(e4)), !(e4 instanceof n))
                      throw new TypeError("Not a string or buffer");
                    let r3 = t4._finishFlushFlag;
                    return null == r3 && (r3 = o.Z_FINISH), t4._processChunk(e4, r3);
                  }(new f(e3), t3);
                }
                f.prototype._processChunk = function(t3, e3, r3) {
                  if ("function" == typeof r3)
                    return o.Inflate._processChunk.call(this, t3, e3, r3);
                  let i2, s2, f2 = this, l2 = t3 && t3.length, c = this._chunkSize - this._offset, d = this._maxLength, p = 0, m = [], g = 0;
                  function b(t4, e4) {
                    if (f2._hadError)
                      return;
                    let r4 = c - e4;
                    if (a(r4 >= 0, "have should not go down"), r4 > 0) {
                      let t5 = f2._buffer.slice(f2._offset, f2._offset + r4);
                      if (f2._offset += r4, t5.length > d && (t5 = t5.slice(0, d)), m.push(t5), g += t5.length, d -= t5.length, 0 === d)
                        return false;
                    }
                    return (0 === e4 || f2._offset >= f2._chunkSize) && (c = f2._chunkSize, f2._offset = 0, f2._buffer = n.allocUnsafe(f2._chunkSize)), 0 === e4 && (p += l2 - t4, l2 = t4, true);
                  }
                  this.on("error", function(t4) {
                    i2 = t4;
                  }), a(this._handle, "zlib binding closed");
                  do {
                    s2 = this._handle.writeSync(e3, t3, p, l2, this._buffer, this._offset, c), s2 = s2 || this._writeState;
                  } while (!this._hadError && b(s2[0], s2[1]));
                  if (this._hadError)
                    throw i2;
                  if (g >= h)
                    throw u(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + h.toString(16) + " bytes");
                  let _ = n.concat(m, g);
                  return u(this), _;
                }, s.inherits(f, o.Inflate), e2.exports = r2 = l, r2.Inflate = f, r2.createInflate = function(t3) {
                  return new f(t3);
                }, r2.inflateSync = l;
              }).call(this);
            }).call(this, t2("_process"), t2("buffer").Buffer);
          }, { _process: 60, assert: 23, buffer: 33, util: 81, zlib: 32 }], 22: [function(t2, e2, r2) {
            "use strict";
            let i = e2.exports = function(t3) {
              this._buffer = t3, this._reads = [];
            };
            i.prototype.read = function(t3, e3) {
              this._reads.push({ length: Math.abs(t3), allowLess: t3 < 0, func: e3 });
            }, i.prototype.process = function() {
              for (; this._reads.length > 0 && this._buffer.length; ) {
                let t3 = this._reads[0];
                if (!this._buffer.length || !(this._buffer.length >= t3.length || t3.allowLess))
                  break;
                {
                  this._reads.shift();
                  let e3 = this._buffer;
                  this._buffer = e3.slice(t3.length), t3.func.call(this, e3.slice(0, t3.length));
                }
              }
              if (this._reads.length > 0)
                throw new Error("There are some read requests waitng on finished stream");
              if (this._buffer.length > 0)
                throw new Error("unrecognised content at end of stream");
            };
          }, {}], 23: [function(t2, e2, i) {
            (function(r2) {
              (function() {
                "use strict";
                function i2(t3, e3) {
                  if (t3 === e3)
                    return 0;
                  for (var r3 = t3.length, i3 = e3.length, n2 = 0, a2 = Math.min(r3, i3); n2 < a2; ++n2)
                    if (t3[n2] !== e3[n2]) {
                      r3 = t3[n2], i3 = e3[n2];
                      break;
                    }
                  return r3 < i3 ? -1 : i3 < r3 ? 1 : 0;
                }
                function n(t3) {
                  return r2.Buffer && "function" == typeof r2.Buffer.isBuffer ? r2.Buffer.isBuffer(t3) : !(null == t3 || !t3._isBuffer);
                }
                var a = t2("util/"), o = Object.prototype.hasOwnProperty, s = Array.prototype.slice, h = "foo" === function() {
                }.name;
                function f(t3) {
                  return Object.prototype.toString.call(t3);
                }
                function u(t3) {
                  return !n(t3) && "function" == typeof r2.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t3) : !!t3 && (t3 instanceof DataView || !!(t3.buffer && t3.buffer instanceof ArrayBuffer)));
                }
                var l = e2.exports = b, c = /\s*function\s+([^\(\s]*)\s*/;
                function d(t3) {
                  if (a.isFunction(t3)) {
                    if (h)
                      return t3.name;
                    var e3 = t3.toString().match(c);
                    return e3 && e3[1];
                  }
                }
                function p(t3, e3) {
                  return "string" == typeof t3 ? t3.length < e3 ? t3 : t3.slice(0, e3) : t3;
                }
                function m(t3) {
                  if (h || !a.isFunction(t3))
                    return a.inspect(t3);
                  var e3 = d(t3);
                  return "[Function" + (e3 ? ": " + e3 : "") + "]";
                }
                function g(t3, e3, r3, i3, n2) {
                  throw new l.AssertionError({ message: r3, actual: t3, expected: e3, operator: i3, stackStartFunction: n2 });
                }
                function b(t3, e3) {
                  t3 || g(t3, true, e3, "==", l.ok);
                }
                function _(t3, e3, r3, o2) {
                  if (t3 === e3)
                    return true;
                  if (n(t3) && n(e3))
                    return 0 === i2(t3, e3);
                  if (a.isDate(t3) && a.isDate(e3))
                    return t3.getTime() === e3.getTime();
                  if (a.isRegExp(t3) && a.isRegExp(e3))
                    return t3.source === e3.source && t3.global === e3.global && t3.multiline === e3.multiline && t3.lastIndex === e3.lastIndex && t3.ignoreCase === e3.ignoreCase;
                  if (null !== t3 && "object" == typeof t3 || null !== e3 && "object" == typeof e3) {
                    if (u(t3) && u(e3) && f(t3) === f(e3) && !(t3 instanceof Float32Array || t3 instanceof Float64Array))
                      return 0 === i2(new Uint8Array(t3.buffer), new Uint8Array(e3.buffer));
                    if (n(t3) !== n(e3))
                      return false;
                    var h2 = (o2 = o2 || { actual: [], expected: [] }).actual.indexOf(t3);
                    return -1 !== h2 && h2 === o2.expected.indexOf(e3) || (o2.actual.push(t3), o2.expected.push(e3), function(t4, e4, r4, i3) {
                      if (null == t4 || null == e4)
                        return false;
                      if (a.isPrimitive(t4) || a.isPrimitive(e4))
                        return t4 === e4;
                      if (r4 && Object.getPrototypeOf(t4) !== Object.getPrototypeOf(e4))
                        return false;
                      var n2 = y(t4), o3 = y(e4);
                      if (n2 && !o3 || !n2 && o3)
                        return false;
                      if (n2)
                        return _(t4 = s.call(t4), e4 = s.call(e4), r4);
                      var h3, f2, u2 = x(t4), l2 = x(e4);
                      if (u2.length !== l2.length)
                        return false;
                      for (u2.sort(), l2.sort(), f2 = u2.length - 1; f2 >= 0; f2--)
                        if (u2[f2] !== l2[f2])
                          return false;
                      for (f2 = u2.length - 1; f2 >= 0; f2--)
                        if (!_(t4[h3 = u2[f2]], e4[h3], r4, i3))
                          return false;
                      return true;
                    }(t3, e3, r3, o2));
                  }
                  return r3 ? t3 === e3 : t3 == e3;
                }
                function y(t3) {
                  return "[object Arguments]" == Object.prototype.toString.call(t3);
                }
                function w(t3, e3) {
                  if (!t3 || !e3)
                    return false;
                  if ("[object RegExp]" == Object.prototype.toString.call(e3))
                    return e3.test(t3);
                  try {
                    if (t3 instanceof e3)
                      return true;
                  } catch (t4) {
                  }
                  return !Error.isPrototypeOf(e3) && true === e3.call({}, t3);
                }
                function v(t3, e3, r3, i3) {
                  var n2;
                  if ("function" != typeof e3)
                    throw new TypeError('"block" argument must be a function');
                  "string" == typeof r3 && (i3 = r3, r3 = null), n2 = function(t4) {
                    var e4;
                    try {
                      t4();
                    } catch (t5) {
                      e4 = t5;
                    }
                    return e4;
                  }(e3), i3 = (r3 && r3.name ? " (" + r3.name + ")." : ".") + (i3 ? " " + i3 : "."), t3 && !n2 && g(n2, r3, "Missing expected exception" + i3);
                  var o2 = "string" == typeof i3, s2 = !t3 && n2 && !r3;
                  if ((!t3 && a.isError(n2) && o2 && w(n2, r3) || s2) && g(n2, r3, "Got unwanted exception" + i3), t3 && n2 && r3 && !w(n2, r3) || !t3 && n2)
                    throw n2;
                }
                l.AssertionError = function(t3) {
                  this.name = "AssertionError", this.actual = t3.actual, this.expected = t3.expected, this.operator = t3.operator, t3.message ? (this.message = t3.message, this.generatedMessage = false) : (this.message = function(t4) {
                    return p(m(t4.actual), 128) + " " + t4.operator + " " + p(m(t4.expected), 128);
                  }(this), this.generatedMessage = true);
                  var e3 = t3.stackStartFunction || g;
                  if (Error.captureStackTrace)
                    Error.captureStackTrace(this, e3);
                  else {
                    var r3 = new Error();
                    if (r3.stack) {
                      var i3 = r3.stack, n2 = d(e3), a2 = i3.indexOf("\n" + n2);
                      if (a2 >= 0) {
                        var o2 = i3.indexOf("\n", a2 + 1);
                        i3 = i3.substring(o2 + 1);
                      }
                      this.stack = i3;
                    }
                  }
                }, a.inherits(l.AssertionError, Error), l.fail = g, l.ok = b, l.equal = function(t3, e3, r3) {
                  t3 != e3 && g(t3, e3, r3, "==", l.equal);
                }, l.notEqual = function(t3, e3, r3) {
                  t3 == e3 && g(t3, e3, r3, "!=", l.notEqual);
                }, l.deepEqual = function(t3, e3, r3) {
                  _(t3, e3, false) || g(t3, e3, r3, "deepEqual", l.deepEqual);
                }, l.deepStrictEqual = function(t3, e3, r3) {
                  _(t3, e3, true) || g(t3, e3, r3, "deepStrictEqual", l.deepStrictEqual);
                }, l.notDeepEqual = function(t3, e3, r3) {
                  _(t3, e3, false) && g(t3, e3, r3, "notDeepEqual", l.notDeepEqual);
                }, l.notDeepStrictEqual = function t3(e3, r3, i3) {
                  _(e3, r3, true) && g(e3, r3, i3, "notDeepStrictEqual", t3);
                }, l.strictEqual = function(t3, e3, r3) {
                  t3 !== e3 && g(t3, e3, r3, "===", l.strictEqual);
                }, l.notStrictEqual = function(t3, e3, r3) {
                  t3 === e3 && g(t3, e3, r3, "!==", l.notStrictEqual);
                }, l.throws = function(t3, e3, r3) {
                  v(true, t3, e3, r3);
                }, l.doesNotThrow = function(t3, e3, r3) {
                  v(false, t3, e3, r3);
                }, l.ifError = function(t3) {
                  if (t3)
                    throw t3;
                };
                var x = Object.keys || function(t3) {
                  var e3 = [];
                  for (var r3 in t3)
                    o.call(t3, r3) && e3.push(r3);
                  return e3;
                };
              }).call(this);
            }).call(this, void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, { "util/": 26 }], 24: [function(t2, e2, r2) {
            "function" == typeof Object.create ? e2.exports = function(t3, e3) {
              t3.super_ = e3, t3.prototype = Object.create(e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } });
            } : e2.exports = function(t3, e3) {
              t3.super_ = e3;
              var r3 = function() {
              };
              r3.prototype = e3.prototype, t3.prototype = new r3(), t3.prototype.constructor = t3;
            };
          }, {}], 25: [function(t2, e2, r2) {
            e2.exports = function(t3) {
              return t3 && "object" == typeof t3 && "function" == typeof t3.copy && "function" == typeof t3.fill && "function" == typeof t3.readUInt8;
            };
          }, {}], 26: [function(t2, e2, i) {
            (function(e3, r2) {
              (function() {
                var n = /%[sdj%]/g;
                i.format = function(t3) {
                  if (!b(t3)) {
                    for (var e4 = [], r3 = 0; r3 < arguments.length; r3++)
                      e4.push(s(arguments[r3]));
                    return e4.join(" ");
                  }
                  r3 = 1;
                  for (var i2 = arguments, a2 = i2.length, o2 = String(t3).replace(n, function(t4) {
                    if ("%%" === t4)
                      return "%";
                    if (r3 >= a2)
                      return t4;
                    switch (t4) {
                      case "%s":
                        return String(i2[r3++]);
                      case "%d":
                        return Number(i2[r3++]);
                      case "%j":
                        try {
                          return JSON.stringify(i2[r3++]);
                        } catch (t5) {
                          return "[Circular]";
                        }
                      default:
                        return t4;
                    }
                  }), h2 = i2[r3]; r3 < a2; h2 = i2[++r3])
                    m(h2) || !w(h2) ? o2 += " " + h2 : o2 += " " + s(h2);
                  return o2;
                }, i.deprecate = function(t3, n2) {
                  if (_(r2.process))
                    return function() {
                      return i.deprecate(t3, n2).apply(this, arguments);
                    };
                  if (true === e3.noDeprecation)
                    return t3;
                  var a2 = false;
                  return function() {
                    if (!a2) {
                      if (e3.throwDeprecation)
                        throw new Error(n2);
                      e3.traceDeprecation ? console.trace(n2) : console.error(n2), a2 = true;
                    }
                    return t3.apply(this, arguments);
                  };
                };
                var a, o = {};
                function s(t3, e4) {
                  var r3 = { seen: [], stylize: f };
                  return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), p(e4) ? r3.showHidden = e4 : e4 && i._extend(r3, e4), _(r3.showHidden) && (r3.showHidden = false), _(r3.depth) && (r3.depth = 2), _(r3.colors) && (r3.colors = false), _(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = h), u(r3, t3, r3.depth);
                }
                function h(t3, e4) {
                  var r3 = s.styles[e4];
                  return r3 ? "\x1B[" + s.colors[r3][0] + "m" + t3 + "\x1B[" + s.colors[r3][1] + "m" : t3;
                }
                function f(t3, e4) {
                  return t3;
                }
                function u(t3, e4, r3) {
                  if (t3.customInspect && e4 && E(e4.inspect) && e4.inspect !== i.inspect && (!e4.constructor || e4.constructor.prototype !== e4)) {
                    var n2 = e4.inspect(r3, t3);
                    return b(n2) || (n2 = u(t3, n2, r3)), n2;
                  }
                  var a2 = function(t4, e5) {
                    if (_(e5))
                      return t4.stylize("undefined", "undefined");
                    if (b(e5)) {
                      var r4 = "'" + JSON.stringify(e5).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                      return t4.stylize(r4, "string");
                    }
                    return g(e5) ? t4.stylize("" + e5, "number") : p(e5) ? t4.stylize("" + e5, "boolean") : m(e5) ? t4.stylize("null", "null") : void 0;
                  }(t3, e4);
                  if (a2)
                    return a2;
                  var o2 = Object.keys(e4), s2 = function(t4) {
                    var e5 = {};
                    return t4.forEach(function(t5, r4) {
                      e5[t5] = true;
                    }), e5;
                  }(o2);
                  if (t3.showHidden && (o2 = Object.getOwnPropertyNames(e4)), x(e4) && (o2.indexOf("message") >= 0 || o2.indexOf("description") >= 0))
                    return l(e4);
                  if (0 === o2.length) {
                    if (E(e4)) {
                      var h2 = e4.name ? ": " + e4.name : "";
                      return t3.stylize("[Function" + h2 + "]", "special");
                    }
                    if (y(e4))
                      return t3.stylize(RegExp.prototype.toString.call(e4), "regexp");
                    if (v(e4))
                      return t3.stylize(Date.prototype.toString.call(e4), "date");
                    if (x(e4))
                      return l(e4);
                  }
                  var f2, w2 = "", k2 = false, S2 = ["{", "}"];
                  return d(e4) && (k2 = true, S2 = ["[", "]"]), E(e4) && (w2 = " [Function" + (e4.name ? ": " + e4.name : "") + "]"), y(e4) && (w2 = " " + RegExp.prototype.toString.call(e4)), v(e4) && (w2 = " " + Date.prototype.toUTCString.call(e4)), x(e4) && (w2 = " " + l(e4)), 0 !== o2.length || k2 && 0 != e4.length ? r3 < 0 ? y(e4) ? t3.stylize(RegExp.prototype.toString.call(e4), "regexp") : t3.stylize("[Object]", "special") : (t3.seen.push(e4), f2 = k2 ? function(t4, e5, r4, i2, n3) {
                    for (var a3 = [], o3 = 0, s3 = e5.length; o3 < s3; ++o3)
                      A(e5, String(o3)) ? a3.push(c(t4, e5, r4, i2, String(o3), true)) : a3.push("");
                    return n3.forEach(function(n4) {
                      n4.match(/^\d+$/) || a3.push(c(t4, e5, r4, i2, n4, true));
                    }), a3;
                  }(t3, e4, r3, s2, o2) : o2.map(function(i2) {
                    return c(t3, e4, r3, s2, i2, k2);
                  }), t3.seen.pop(), function(t4, e5, r4) {
                    return t4.reduce(function(t5, e6) {
                      return e6.indexOf("\n"), t5 + e6.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0) > 60 ? r4[0] + ("" === e5 ? "" : e5 + "\n ") + " " + t4.join(",\n  ") + " " + r4[1] : r4[0] + e5 + " " + t4.join(", ") + " " + r4[1];
                  }(f2, w2, S2)) : S2[0] + w2 + S2[1];
                }
                function l(t3) {
                  return "[" + Error.prototype.toString.call(t3) + "]";
                }
                function c(t3, e4, r3, i2, n2, a2) {
                  var o2, s2, h2;
                  if ((h2 = Object.getOwnPropertyDescriptor(e4, n2) || { value: e4[n2] }).get ? s2 = h2.set ? t3.stylize("[Getter/Setter]", "special") : t3.stylize("[Getter]", "special") : h2.set && (s2 = t3.stylize("[Setter]", "special")), A(i2, n2) || (o2 = "[" + n2 + "]"), s2 || (t3.seen.indexOf(h2.value) < 0 ? (s2 = m(r3) ? u(t3, h2.value, null) : u(t3, h2.value, r3 - 1)).indexOf("\n") > -1 && (s2 = a2 ? s2.split("\n").map(function(t4) {
                    return "  " + t4;
                  }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(t4) {
                    return "   " + t4;
                  }).join("\n")) : s2 = t3.stylize("[Circular]", "special")), _(o2)) {
                    if (a2 && n2.match(/^\d+$/))
                      return s2;
                    (o2 = JSON.stringify("" + n2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = t3.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = t3.stylize(o2, "string"));
                  }
                  return o2 + ": " + s2;
                }
                function d(t3) {
                  return Array.isArray(t3);
                }
                function p(t3) {
                  return "boolean" == typeof t3;
                }
                function m(t3) {
                  return null === t3;
                }
                function g(t3) {
                  return "number" == typeof t3;
                }
                function b(t3) {
                  return "string" == typeof t3;
                }
                function _(t3) {
                  return void 0 === t3;
                }
                function y(t3) {
                  return w(t3) && "[object RegExp]" === k(t3);
                }
                function w(t3) {
                  return "object" == typeof t3 && null !== t3;
                }
                function v(t3) {
                  return w(t3) && "[object Date]" === k(t3);
                }
                function x(t3) {
                  return w(t3) && ("[object Error]" === k(t3) || t3 instanceof Error);
                }
                function E(t3) {
                  return "function" == typeof t3;
                }
                function k(t3) {
                  return Object.prototype.toString.call(t3);
                }
                function S(t3) {
                  return t3 < 10 ? "0" + t3.toString(10) : t3.toString(10);
                }
                i.debuglog = function(t3) {
                  if (_(a) && (a = e3.env.NODE_DEBUG || ""), t3 = t3.toUpperCase(), !o[t3])
                    if (new RegExp("\\b" + t3 + "\\b", "i").test(a)) {
                      var r3 = e3.pid;
                      o[t3] = function() {
                        var e4 = i.format.apply(i, arguments);
                        console.error("%s %d: %s", t3, r3, e4);
                      };
                    } else
                      o[t3] = function() {
                      };
                  return o[t3];
                }, i.inspect = s, s.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, s.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i.isArray = d, i.isBoolean = p, i.isNull = m, i.isNullOrUndefined = function(t3) {
                  return null == t3;
                }, i.isNumber = g, i.isString = b, i.isSymbol = function(t3) {
                  return "symbol" == typeof t3;
                }, i.isUndefined = _, i.isRegExp = y, i.isObject = w, i.isDate = v, i.isError = x, i.isFunction = E, i.isPrimitive = function(t3) {
                  return null === t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || "symbol" == typeof t3 || void 0 === t3;
                }, i.isBuffer = t2("./support/isBuffer");
                var M = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                function A(t3, e4) {
                  return Object.prototype.hasOwnProperty.call(t3, e4);
                }
                i.log = function() {
                  var t3, e4;
                  console.log("%s - %s", (t3 = /* @__PURE__ */ new Date(), e4 = [S(t3.getHours()), S(t3.getMinutes()), S(t3.getSeconds())].join(":"), [t3.getDate(), M[t3.getMonth()], e4].join(" ")), i.format.apply(i, arguments));
                }, i.inherits = t2("inherits"), i._extend = function(t3, e4) {
                  if (!e4 || !w(e4))
                    return t3;
                  for (var r3 = Object.keys(e4), i2 = r3.length; i2--; )
                    t3[r3[i2]] = e4[r3[i2]];
                  return t3;
                };
              }).call(this);
            }).call(this, t2("_process"), void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, { "./support/isBuffer": 25, _process: 60, inherits: 24 }], 27: [function(t2, e2, i) {
            (function(r2) {
              (function() {
                "use strict";
                var i2 = t2("array-filter");
                e2.exports = function() {
                  return i2(["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], function(t3) {
                    return "function" == typeof r2[t3];
                  });
                };
              }).call(this);
            }).call(this, void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, { "array-filter": 28 }], 28: [function(t2, e2, r2) {
            e2.exports = function(t3, e3, r3) {
              if (t3.filter)
                return t3.filter(e3, r3);
              if (null == t3)
                throw new TypeError();
              if ("function" != typeof e3)
                throw new TypeError();
              for (var n = [], a = 0; a < t3.length; a++)
                if (i.call(t3, a)) {
                  var o = t3[a];
                  e3.call(r3, o, a, t3) && n.push(o);
                }
              return n;
            };
            var i = Object.prototype.hasOwnProperty;
          }, {}], 29: [function(t2, e2, r2) {
            "use strict";
            r2.byteLength = function(t3) {
              var e3 = f(t3), r3 = e3[0], i2 = e3[1];
              return 3 * (r3 + i2) / 4 - i2;
            }, r2.toByteArray = function(t3) {
              var e3, r3, i2 = f(t3), o2 = i2[0], s2 = i2[1], h2 = new a(function(t4, e4, r4) {
                return 3 * (e4 + r4) / 4 - r4;
              }(0, o2, s2)), u2 = 0, l = s2 > 0 ? o2 - 4 : o2;
              for (r3 = 0; r3 < l; r3 += 4)
                e3 = n[t3.charCodeAt(r3)] << 18 | n[t3.charCodeAt(r3 + 1)] << 12 | n[t3.charCodeAt(r3 + 2)] << 6 | n[t3.charCodeAt(r3 + 3)], h2[u2++] = e3 >> 16 & 255, h2[u2++] = e3 >> 8 & 255, h2[u2++] = 255 & e3;
              return 2 === s2 && (e3 = n[t3.charCodeAt(r3)] << 2 | n[t3.charCodeAt(r3 + 1)] >> 4, h2[u2++] = 255 & e3), 1 === s2 && (e3 = n[t3.charCodeAt(r3)] << 10 | n[t3.charCodeAt(r3 + 1)] << 4 | n[t3.charCodeAt(r3 + 2)] >> 2, h2[u2++] = e3 >> 8 & 255, h2[u2++] = 255 & e3), h2;
            }, r2.fromByteArray = function(t3) {
              for (var e3, r3 = t3.length, n2 = r3 % 3, a2 = [], o2 = 16383, s2 = 0, h2 = r3 - n2; s2 < h2; s2 += o2)
                a2.push(u(t3, s2, s2 + o2 > h2 ? h2 : s2 + o2));
              return 1 === n2 ? (e3 = t3[r3 - 1], a2.push(i[e3 >> 2] + i[e3 << 4 & 63] + "==")) : 2 === n2 && (e3 = (t3[r3 - 2] << 8) + t3[r3 - 1], a2.push(i[e3 >> 10] + i[e3 >> 4 & 63] + i[e3 << 2 & 63] + "=")), a2.join("");
            };
            for (var i = [], n = [], a = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, h = o.length; s < h; ++s)
              i[s] = o[s], n[o.charCodeAt(s)] = s;
            function f(t3) {
              var e3 = t3.length;
              if (e3 % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4");
              var r3 = t3.indexOf("=");
              return -1 === r3 && (r3 = e3), [r3, r3 === e3 ? 0 : 4 - r3 % 4];
            }
            function u(t3, e3, r3) {
              for (var n2, a2 = [], o2 = e3; o2 < r3; o2 += 3)
                n2 = (t3[o2] << 16 & 16711680) + (t3[o2 + 1] << 8 & 65280) + (255 & t3[o2 + 2]), a2.push(i[(s2 = n2) >> 18 & 63] + i[s2 >> 12 & 63] + i[s2 >> 6 & 63] + i[63 & s2]);
              var s2;
              return a2.join("");
            }
            n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
          }, {}], 30: [function(t2, e2, r2) {
          }, {}], 31: [function(t2, e2, r2) {
            (function(e3, i) {
              (function() {
                "use strict";
                var n = t2("assert"), a = t2("pako/lib/zlib/zstream"), o = t2("pako/lib/zlib/deflate.js"), s = t2("pako/lib/zlib/inflate.js"), h = t2("pako/lib/zlib/constants");
                for (var f in h)
                  r2[f] = h[f];
                r2.NONE = 0, r2.DEFLATE = 1, r2.INFLATE = 2, r2.GZIP = 3, r2.GUNZIP = 4, r2.DEFLATERAW = 5, r2.INFLATERAW = 6, r2.UNZIP = 7;
                function u(t3) {
                  if ("number" != typeof t3 || t3 < r2.DEFLATE || t3 > r2.UNZIP)
                    throw new TypeError("Bad argument");
                  this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = false, this.level = 0, this.memLevel = 0, this.mode = t3, this.strategy = 0, this.windowBits = 0, this.write_in_progress = false, this.pending_close = false, this.gzip_id_bytes_read = 0;
                }
                u.prototype.close = function() {
                  this.write_in_progress ? this.pending_close = true : (this.pending_close = false, n(this.init_done, "close before init"), n(this.mode <= r2.UNZIP), this.mode === r2.DEFLATE || this.mode === r2.GZIP || this.mode === r2.DEFLATERAW ? o.deflateEnd(this.strm) : this.mode !== r2.INFLATE && this.mode !== r2.GUNZIP && this.mode !== r2.INFLATERAW && this.mode !== r2.UNZIP || s.inflateEnd(this.strm), this.mode = r2.NONE, this.dictionary = null);
                }, u.prototype.write = function(t3, e4, r3, i2, n2, a2, o2) {
                  return this._write(true, t3, e4, r3, i2, n2, a2, o2);
                }, u.prototype.writeSync = function(t3, e4, r3, i2, n2, a2, o2) {
                  return this._write(false, t3, e4, r3, i2, n2, a2, o2);
                }, u.prototype._write = function(t3, a2, o2, s2, h2, f2, u2, l) {
                  if (n.equal(arguments.length, 8), n(this.init_done, "write before init"), n(this.mode !== r2.NONE, "already finalized"), n.equal(false, this.write_in_progress, "write already in progress"), n.equal(false, this.pending_close, "close is pending"), this.write_in_progress = true, n.equal(false, void 0 === a2, "must provide flush value"), this.write_in_progress = true, a2 !== r2.Z_NO_FLUSH && a2 !== r2.Z_PARTIAL_FLUSH && a2 !== r2.Z_SYNC_FLUSH && a2 !== r2.Z_FULL_FLUSH && a2 !== r2.Z_FINISH && a2 !== r2.Z_BLOCK)
                    throw new Error("Invalid flush value");
                  if (null == o2 && (o2 = i.alloc(0), h2 = 0, s2 = 0), this.strm.avail_in = h2, this.strm.input = o2, this.strm.next_in = s2, this.strm.avail_out = l, this.strm.output = f2, this.strm.next_out = u2, this.flush = a2, !t3)
                    return this._process(), this._checkError() ? this._afterSync() : void 0;
                  var c = this;
                  return e3.nextTick(function() {
                    c._process(), c._after();
                  }), this;
                }, u.prototype._afterSync = function() {
                  var t3 = this.strm.avail_out, e4 = this.strm.avail_in;
                  return this.write_in_progress = false, [e4, t3];
                }, u.prototype._process = function() {
                  var t3 = null;
                  switch (this.mode) {
                    case r2.DEFLATE:
                    case r2.GZIP:
                    case r2.DEFLATERAW:
                      this.err = o.deflate(this.strm, this.flush);
                      break;
                    case r2.UNZIP:
                      switch (this.strm.avail_in > 0 && (t3 = this.strm.next_in), this.gzip_id_bytes_read) {
                        case 0:
                          if (null === t3)
                            break;
                          if (31 !== this.strm.input[t3]) {
                            this.mode = r2.INFLATE;
                            break;
                          }
                          if (this.gzip_id_bytes_read = 1, t3++, 1 === this.strm.avail_in)
                            break;
                        case 1:
                          if (null === t3)
                            break;
                          139 === this.strm.input[t3] ? (this.gzip_id_bytes_read = 2, this.mode = r2.GUNZIP) : this.mode = r2.INFLATE;
                          break;
                        default:
                          throw new Error("invalid number of gzip magic number bytes read");
                      }
                    case r2.INFLATE:
                    case r2.GUNZIP:
                    case r2.INFLATERAW:
                      for (this.err = s.inflate(this.strm, this.flush), this.err === r2.Z_NEED_DICT && this.dictionary && (this.err = s.inflateSetDictionary(this.strm, this.dictionary), this.err === r2.Z_OK ? this.err = s.inflate(this.strm, this.flush) : this.err === r2.Z_DATA_ERROR && (this.err = r2.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === r2.GUNZIP && this.err === r2.Z_STREAM_END && 0 !== this.strm.next_in[0]; )
                        this.reset(), this.err = s.inflate(this.strm, this.flush);
                      break;
                    default:
                      throw new Error("Unknown mode " + this.mode);
                  }
                }, u.prototype._checkError = function() {
                  switch (this.err) {
                    case r2.Z_OK:
                    case r2.Z_BUF_ERROR:
                      if (0 !== this.strm.avail_out && this.flush === r2.Z_FINISH)
                        return this._error("unexpected end of file"), false;
                      break;
                    case r2.Z_STREAM_END:
                      break;
                    case r2.Z_NEED_DICT:
                      return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), false;
                    default:
                      return this._error("Zlib error"), false;
                  }
                  return true;
                }, u.prototype._after = function() {
                  if (this._checkError()) {
                    var t3 = this.strm.avail_out, e4 = this.strm.avail_in;
                    this.write_in_progress = false, this.callback(e4, t3), this.pending_close && this.close();
                  }
                }, u.prototype._error = function(t3) {
                  this.strm.msg && (t3 = this.strm.msg), this.onerror(t3, this.err), this.write_in_progress = false, this.pending_close && this.close();
                }, u.prototype.init = function(t3, e4, i2, a2, o2) {
                  n(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), n(t3 >= 8 && t3 <= 15, "invalid windowBits"), n(e4 >= -1 && e4 <= 9, "invalid compression level"), n(i2 >= 1 && i2 <= 9, "invalid memlevel"), n(a2 === r2.Z_FILTERED || a2 === r2.Z_HUFFMAN_ONLY || a2 === r2.Z_RLE || a2 === r2.Z_FIXED || a2 === r2.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(e4, t3, i2, a2, o2), this._setDictionary();
                }, u.prototype.params = function() {
                  throw new Error("deflateParams Not supported");
                }, u.prototype.reset = function() {
                  this._reset(), this._setDictionary();
                }, u.prototype._init = function(t3, e4, i2, n2, h2) {
                  switch (this.level = t3, this.windowBits = e4, this.memLevel = i2, this.strategy = n2, this.flush = r2.Z_NO_FLUSH, this.err = r2.Z_OK, this.mode !== r2.GZIP && this.mode !== r2.GUNZIP || (this.windowBits += 16), this.mode === r2.UNZIP && (this.windowBits += 32), this.mode !== r2.DEFLATERAW && this.mode !== r2.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new a(), this.mode) {
                    case r2.DEFLATE:
                    case r2.GZIP:
                    case r2.DEFLATERAW:
                      this.err = o.deflateInit2(this.strm, this.level, r2.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                      break;
                    case r2.INFLATE:
                    case r2.GUNZIP:
                    case r2.INFLATERAW:
                    case r2.UNZIP:
                      this.err = s.inflateInit2(this.strm, this.windowBits);
                      break;
                    default:
                      throw new Error("Unknown mode " + this.mode);
                  }
                  this.err !== r2.Z_OK && this._error("Init error"), this.dictionary = h2, this.write_in_progress = false, this.init_done = true;
                }, u.prototype._setDictionary = function() {
                  if (null != this.dictionary) {
                    switch (this.err = r2.Z_OK, this.mode) {
                      case r2.DEFLATE:
                      case r2.DEFLATERAW:
                        this.err = o.deflateSetDictionary(this.strm, this.dictionary);
                    }
                    this.err !== r2.Z_OK && this._error("Failed to set dictionary");
                  }
                }, u.prototype._reset = function() {
                  switch (this.err = r2.Z_OK, this.mode) {
                    case r2.DEFLATE:
                    case r2.DEFLATERAW:
                    case r2.GZIP:
                      this.err = o.deflateReset(this.strm);
                      break;
                    case r2.INFLATE:
                    case r2.INFLATERAW:
                    case r2.GUNZIP:
                      this.err = s.inflateReset(this.strm);
                  }
                  this.err !== r2.Z_OK && this._error("Failed to reset stream");
                }, r2.Zlib = u;
              }).call(this);
            }).call(this, t2("_process"), t2("buffer").Buffer);
          }, { _process: 60, assert: 23, buffer: 33, "pako/lib/zlib/constants": 51, "pako/lib/zlib/deflate.js": 53, "pako/lib/zlib/inflate.js": 55, "pako/lib/zlib/zstream": 59 }], 32: [function(t2, e2, r2) {
            (function(e3) {
              (function() {
                "use strict";
                var i = t2("buffer").Buffer, n = t2("stream").Transform, a = t2("./binding"), o = t2("util"), s = t2("assert").ok, h = t2("buffer").kMaxLength, f = "Cannot create final Buffer. It would be larger than 0x" + h.toString(16) + " bytes";
                a.Z_MIN_WINDOWBITS = 8, a.Z_MAX_WINDOWBITS = 15, a.Z_DEFAULT_WINDOWBITS = 15, a.Z_MIN_CHUNK = 64, a.Z_MAX_CHUNK = 1 / 0, a.Z_DEFAULT_CHUNK = 16384, a.Z_MIN_MEMLEVEL = 1, a.Z_MAX_MEMLEVEL = 9, a.Z_DEFAULT_MEMLEVEL = 8, a.Z_MIN_LEVEL = -1, a.Z_MAX_LEVEL = 9, a.Z_DEFAULT_LEVEL = a.Z_DEFAULT_COMPRESSION;
                for (var u = Object.keys(a), l = 0; l < u.length; l++) {
                  var c = u[l];
                  c.match(/^Z/) && Object.defineProperty(r2, c, { enumerable: true, value: a[c], writable: false });
                }
                for (var d = { Z_OK: a.Z_OK, Z_STREAM_END: a.Z_STREAM_END, Z_NEED_DICT: a.Z_NEED_DICT, Z_ERRNO: a.Z_ERRNO, Z_STREAM_ERROR: a.Z_STREAM_ERROR, Z_DATA_ERROR: a.Z_DATA_ERROR, Z_MEM_ERROR: a.Z_MEM_ERROR, Z_BUF_ERROR: a.Z_BUF_ERROR, Z_VERSION_ERROR: a.Z_VERSION_ERROR }, p = Object.keys(d), m = 0; m < p.length; m++) {
                  var g = p[m];
                  d[d[g]] = g;
                }
                function b(t3, e4, r3) {
                  var n2 = [], a2 = 0;
                  function o2() {
                    for (var e5; null !== (e5 = t3.read()); )
                      n2.push(e5), a2 += e5.length;
                    t3.once("readable", o2);
                  }
                  function s2() {
                    var e5, o3 = null;
                    a2 >= h ? o3 = new RangeError(f) : e5 = i.concat(n2, a2), n2 = [], t3.close(), r3(o3, e5);
                  }
                  t3.on("error", function(e5) {
                    t3.removeListener("end", s2), t3.removeListener("readable", o2), r3(e5);
                  }), t3.on("end", s2), t3.end(e4), o2();
                }
                function _(t3, e4) {
                  if ("string" == typeof e4 && (e4 = i.from(e4)), !i.isBuffer(e4))
                    throw new TypeError("Not a string or buffer");
                  var r3 = t3._finishFlushFlag;
                  return t3._processChunk(e4, r3);
                }
                function y(t3) {
                  if (!(this instanceof y))
                    return new y(t3);
                  A.call(this, t3, a.DEFLATE);
                }
                function w(t3) {
                  if (!(this instanceof w))
                    return new w(t3);
                  A.call(this, t3, a.INFLATE);
                }
                function v(t3) {
                  if (!(this instanceof v))
                    return new v(t3);
                  A.call(this, t3, a.GZIP);
                }
                function x(t3) {
                  if (!(this instanceof x))
                    return new x(t3);
                  A.call(this, t3, a.GUNZIP);
                }
                function E(t3) {
                  if (!(this instanceof E))
                    return new E(t3);
                  A.call(this, t3, a.DEFLATERAW);
                }
                function k(t3) {
                  if (!(this instanceof k))
                    return new k(t3);
                  A.call(this, t3, a.INFLATERAW);
                }
                function S(t3) {
                  if (!(this instanceof S))
                    return new S(t3);
                  A.call(this, t3, a.UNZIP);
                }
                function M(t3) {
                  return t3 === a.Z_NO_FLUSH || t3 === a.Z_PARTIAL_FLUSH || t3 === a.Z_SYNC_FLUSH || t3 === a.Z_FULL_FLUSH || t3 === a.Z_FINISH || t3 === a.Z_BLOCK;
                }
                function A(t3, e4) {
                  var o2 = this;
                  if (this._opts = t3 = t3 || {}, this._chunkSize = t3.chunkSize || r2.Z_DEFAULT_CHUNK, n.call(this, t3), t3.flush && !M(t3.flush))
                    throw new Error("Invalid flush flag: " + t3.flush);
                  if (t3.finishFlush && !M(t3.finishFlush))
                    throw new Error("Invalid flush flag: " + t3.finishFlush);
                  if (this._flushFlag = t3.flush || a.Z_NO_FLUSH, this._finishFlushFlag = void 0 !== t3.finishFlush ? t3.finishFlush : a.Z_FINISH, t3.chunkSize && (t3.chunkSize < r2.Z_MIN_CHUNK || t3.chunkSize > r2.Z_MAX_CHUNK))
                    throw new Error("Invalid chunk size: " + t3.chunkSize);
                  if (t3.windowBits && (t3.windowBits < r2.Z_MIN_WINDOWBITS || t3.windowBits > r2.Z_MAX_WINDOWBITS))
                    throw new Error("Invalid windowBits: " + t3.windowBits);
                  if (t3.level && (t3.level < r2.Z_MIN_LEVEL || t3.level > r2.Z_MAX_LEVEL))
                    throw new Error("Invalid compression level: " + t3.level);
                  if (t3.memLevel && (t3.memLevel < r2.Z_MIN_MEMLEVEL || t3.memLevel > r2.Z_MAX_MEMLEVEL))
                    throw new Error("Invalid memLevel: " + t3.memLevel);
                  if (t3.strategy && t3.strategy != r2.Z_FILTERED && t3.strategy != r2.Z_HUFFMAN_ONLY && t3.strategy != r2.Z_RLE && t3.strategy != r2.Z_FIXED && t3.strategy != r2.Z_DEFAULT_STRATEGY)
                    throw new Error("Invalid strategy: " + t3.strategy);
                  if (t3.dictionary && !i.isBuffer(t3.dictionary))
                    throw new Error("Invalid dictionary: it should be a Buffer instance");
                  this._handle = new a.Zlib(e4);
                  var s2 = this;
                  this._hadError = false, this._handle.onerror = function(t4, e5) {
                    I(s2), s2._hadError = true;
                    var i2 = new Error(t4);
                    i2.errno = e5, i2.code = r2.codes[e5], s2.emit("error", i2);
                  };
                  var h2 = r2.Z_DEFAULT_COMPRESSION;
                  "number" == typeof t3.level && (h2 = t3.level);
                  var f2 = r2.Z_DEFAULT_STRATEGY;
                  "number" == typeof t3.strategy && (f2 = t3.strategy), this._handle.init(t3.windowBits || r2.Z_DEFAULT_WINDOWBITS, h2, t3.memLevel || r2.Z_DEFAULT_MEMLEVEL, f2, t3.dictionary), this._buffer = i.allocUnsafe(this._chunkSize), this._offset = 0, this._level = h2, this._strategy = f2, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
                    return !o2._handle;
                  }, configurable: true, enumerable: true });
                }
                function I(t3, r3) {
                  r3 && e3.nextTick(r3), t3._handle && (t3._handle.close(), t3._handle = null);
                }
                function T(t3) {
                  t3.emit("close");
                }
                Object.defineProperty(r2, "codes", { enumerable: true, value: Object.freeze(d), writable: false }), r2.Deflate = y, r2.Inflate = w, r2.Gzip = v, r2.Gunzip = x, r2.DeflateRaw = E, r2.InflateRaw = k, r2.Unzip = S, r2.createDeflate = function(t3) {
                  return new y(t3);
                }, r2.createInflate = function(t3) {
                  return new w(t3);
                }, r2.createDeflateRaw = function(t3) {
                  return new E(t3);
                }, r2.createInflateRaw = function(t3) {
                  return new k(t3);
                }, r2.createGzip = function(t3) {
                  return new v(t3);
                }, r2.createGunzip = function(t3) {
                  return new x(t3);
                }, r2.createUnzip = function(t3) {
                  return new S(t3);
                }, r2.deflate = function(t3, e4, r3) {
                  return "function" == typeof e4 && (r3 = e4, e4 = {}), b(new y(e4), t3, r3);
                }, r2.deflateSync = function(t3, e4) {
                  return _(new y(e4), t3);
                }, r2.gzip = function(t3, e4, r3) {
                  return "function" == typeof e4 && (r3 = e4, e4 = {}), b(new v(e4), t3, r3);
                }, r2.gzipSync = function(t3, e4) {
                  return _(new v(e4), t3);
                }, r2.deflateRaw = function(t3, e4, r3) {
                  return "function" == typeof e4 && (r3 = e4, e4 = {}), b(new E(e4), t3, r3);
                }, r2.deflateRawSync = function(t3, e4) {
                  return _(new E(e4), t3);
                }, r2.unzip = function(t3, e4, r3) {
                  return "function" == typeof e4 && (r3 = e4, e4 = {}), b(new S(e4), t3, r3);
                }, r2.unzipSync = function(t3, e4) {
                  return _(new S(e4), t3);
                }, r2.inflate = function(t3, e4, r3) {
                  return "function" == typeof e4 && (r3 = e4, e4 = {}), b(new w(e4), t3, r3);
                }, r2.inflateSync = function(t3, e4) {
                  return _(new w(e4), t3);
                }, r2.gunzip = function(t3, e4, r3) {
                  return "function" == typeof e4 && (r3 = e4, e4 = {}), b(new x(e4), t3, r3);
                }, r2.gunzipSync = function(t3, e4) {
                  return _(new x(e4), t3);
                }, r2.inflateRaw = function(t3, e4, r3) {
                  return "function" == typeof e4 && (r3 = e4, e4 = {}), b(new k(e4), t3, r3);
                }, r2.inflateRawSync = function(t3, e4) {
                  return _(new k(e4), t3);
                }, o.inherits(A, n), A.prototype.params = function(t3, i2, n2) {
                  if (t3 < r2.Z_MIN_LEVEL || t3 > r2.Z_MAX_LEVEL)
                    throw new RangeError("Invalid compression level: " + t3);
                  if (i2 != r2.Z_FILTERED && i2 != r2.Z_HUFFMAN_ONLY && i2 != r2.Z_RLE && i2 != r2.Z_FIXED && i2 != r2.Z_DEFAULT_STRATEGY)
                    throw new TypeError("Invalid strategy: " + i2);
                  if (this._level !== t3 || this._strategy !== i2) {
                    var o2 = this;
                    this.flush(a.Z_SYNC_FLUSH, function() {
                      s(o2._handle, "zlib binding closed"), o2._handle.params(t3, i2), o2._hadError || (o2._level = t3, o2._strategy = i2, n2 && n2());
                    });
                  } else
                    e3.nextTick(n2);
                }, A.prototype.reset = function() {
                  return s(this._handle, "zlib binding closed"), this._handle.reset();
                }, A.prototype._flush = function(t3) {
                  this._transform(i.alloc(0), "", t3);
                }, A.prototype.flush = function(t3, r3) {
                  var n2 = this, o2 = this._writableState;
                  ("function" == typeof t3 || void 0 === t3 && !r3) && (r3 = t3, t3 = a.Z_FULL_FLUSH), o2.ended ? r3 && e3.nextTick(r3) : o2.ending ? r3 && this.once("end", r3) : o2.needDrain ? r3 && this.once("drain", function() {
                    return n2.flush(t3, r3);
                  }) : (this._flushFlag = t3, this.write(i.alloc(0), "", r3));
                }, A.prototype.close = function(t3) {
                  I(this, t3), e3.nextTick(T, this);
                }, A.prototype._transform = function(t3, e4, r3) {
                  var n2, o2 = this._writableState, s2 = (o2.ending || o2.ended) && (!t3 || o2.length === t3.length);
                  return null === t3 || i.isBuffer(t3) ? this._handle ? (s2 ? n2 = this._finishFlushFlag : (n2 = this._flushFlag, t3.length >= o2.length && (this._flushFlag = this._opts.flush || a.Z_NO_FLUSH)), void this._processChunk(t3, n2, r3)) : r3(new Error("zlib binding closed")) : r3(new Error("invalid input"));
                }, A.prototype._processChunk = function(t3, e4, r3) {
                  var n2 = t3 && t3.length, a2 = this._chunkSize - this._offset, o2 = 0, u2 = this, l2 = "function" == typeof r3;
                  if (!l2) {
                    var c2, d2 = [], p2 = 0;
                    this.on("error", function(t4) {
                      c2 = t4;
                    }), s(this._handle, "zlib binding closed");
                    do {
                      var m2 = this._handle.writeSync(e4, t3, o2, n2, this._buffer, this._offset, a2);
                    } while (!this._hadError && _2(m2[0], m2[1]));
                    if (this._hadError)
                      throw c2;
                    if (p2 >= h)
                      throw I(this), new RangeError(f);
                    var g2 = i.concat(d2, p2);
                    return I(this), g2;
                  }
                  s(this._handle, "zlib binding closed");
                  var b2 = this._handle.write(e4, t3, o2, n2, this._buffer, this._offset, a2);
                  function _2(h2, f2) {
                    if (this && (this.buffer = null, this.callback = null), !u2._hadError) {
                      var c3 = a2 - f2;
                      if (s(c3 >= 0, "have should not go down"), c3 > 0) {
                        var m3 = u2._buffer.slice(u2._offset, u2._offset + c3);
                        u2._offset += c3, l2 ? u2.push(m3) : (d2.push(m3), p2 += m3.length);
                      }
                      if ((0 === f2 || u2._offset >= u2._chunkSize) && (a2 = u2._chunkSize, u2._offset = 0, u2._buffer = i.allocUnsafe(u2._chunkSize)), 0 === f2) {
                        if (o2 += n2 - h2, n2 = h2, !l2)
                          return true;
                        var g3 = u2._handle.write(e4, t3, o2, n2, u2._buffer, u2._offset, u2._chunkSize);
                        return g3.callback = _2, void (g3.buffer = t3);
                      }
                      if (!l2)
                        return false;
                      r3();
                    }
                  }
                  b2.buffer = t3, b2.callback = _2;
                }, o.inherits(y, A), o.inherits(w, A), o.inherits(v, A), o.inherits(x, A), o.inherits(E, A), o.inherits(k, A), o.inherits(S, A);
              }).call(this);
            }).call(this, t2("_process"));
          }, { "./binding": 31, _process: 60, assert: 23, buffer: 33, stream: 61, util: 81 }], 33: [function(t2, e2, r2) {
            (function(e3) {
              (function() {
                "use strict";
                var e4 = t2("base64-js"), i = t2("ieee754");
                r2.Buffer = o, r2.SlowBuffer = function(t3) {
                  return +t3 != t3 && (t3 = 0), o.alloc(+t3);
                }, r2.INSPECT_MAX_BYTES = 50;
                var n = 2147483647;
                function a(t3) {
                  if (t3 > n)
                    throw new RangeError('The value "' + t3 + '" is invalid for option "size"');
                  var e5 = new Uint8Array(t3);
                  return e5.__proto__ = o.prototype, e5;
                }
                function o(t3, e5, r3) {
                  if ("number" == typeof t3) {
                    if ("string" == typeof e5)
                      throw new TypeError('The "string" argument must be of type string. Received type number');
                    return f(t3);
                  }
                  return s(t3, e5, r3);
                }
                function s(t3, e5, r3) {
                  if ("string" == typeof t3)
                    return function(t4, e6) {
                      if ("string" == typeof e6 && "" !== e6 || (e6 = "utf8"), !o.isEncoding(e6))
                        throw new TypeError("Unknown encoding: " + e6);
                      var r4 = 0 | c(t4, e6), i3 = a(r4), n3 = i3.write(t4, e6);
                      return n3 !== r4 && (i3 = i3.slice(0, n3)), i3;
                    }(t3, e5);
                  if (ArrayBuffer.isView(t3))
                    return u(t3);
                  if (null == t3)
                    throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t3);
                  if (N(t3, ArrayBuffer) || t3 && N(t3.buffer, ArrayBuffer))
                    return function(t4, e6, r4) {
                      if (e6 < 0 || t4.byteLength < e6)
                        throw new RangeError('"offset" is outside of buffer bounds');
                      if (t4.byteLength < e6 + (r4 || 0))
                        throw new RangeError('"length" is outside of buffer bounds');
                      var i3;
                      return (i3 = void 0 === e6 && void 0 === r4 ? new Uint8Array(t4) : void 0 === r4 ? new Uint8Array(t4, e6) : new Uint8Array(t4, e6, r4)).__proto__ = o.prototype, i3;
                    }(t3, e5, r3);
                  if ("number" == typeof t3)
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                  var i2 = t3.valueOf && t3.valueOf();
                  if (null != i2 && i2 !== t3)
                    return o.from(i2, e5, r3);
                  var n2 = function(t4) {
                    if (o.isBuffer(t4)) {
                      var e6 = 0 | l(t4.length), r4 = a(e6);
                      return 0 === r4.length || t4.copy(r4, 0, 0, e6), r4;
                    }
                    return void 0 !== t4.length ? "number" != typeof t4.length || F(t4.length) ? a(0) : u(t4) : "Buffer" === t4.type && Array.isArray(t4.data) ? u(t4.data) : void 0;
                  }(t3);
                  if (n2)
                    return n2;
                  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t3[Symbol.toPrimitive])
                    return o.from(t3[Symbol.toPrimitive]("string"), e5, r3);
                  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t3);
                }
                function h(t3) {
                  if ("number" != typeof t3)
                    throw new TypeError('"size" argument must be of type number');
                  if (t3 < 0)
                    throw new RangeError('The value "' + t3 + '" is invalid for option "size"');
                }
                function f(t3) {
                  return h(t3), a(t3 < 0 ? 0 : 0 | l(t3));
                }
                function u(t3) {
                  for (var e5 = t3.length < 0 ? 0 : 0 | l(t3.length), r3 = a(e5), i2 = 0; i2 < e5; i2 += 1)
                    r3[i2] = 255 & t3[i2];
                  return r3;
                }
                function l(t3) {
                  if (t3 >= n)
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
                  return 0 | t3;
                }
                function c(t3, e5) {
                  if (o.isBuffer(t3))
                    return t3.length;
                  if (ArrayBuffer.isView(t3) || N(t3, ArrayBuffer))
                    return t3.byteLength;
                  if ("string" != typeof t3)
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t3);
                  var r3 = t3.length, i2 = arguments.length > 2 && true === arguments[2];
                  if (!i2 && 0 === r3)
                    return 0;
                  for (var n2 = false; ; )
                    switch (e5) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return r3;
                      case "utf8":
                      case "utf-8":
                        return U(t3).length;
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return 2 * r3;
                      case "hex":
                        return r3 >>> 1;
                      case "base64":
                        return D(t3).length;
                      default:
                        if (n2)
                          return i2 ? -1 : U(t3).length;
                        e5 = ("" + e5).toLowerCase(), n2 = true;
                    }
                }
                function d(t3, e5, r3) {
                  var i2 = false;
                  if ((void 0 === e5 || e5 < 0) && (e5 = 0), e5 > this.length)
                    return "";
                  if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0)
                    return "";
                  if ((r3 >>>= 0) <= (e5 >>>= 0))
                    return "";
                  for (t3 || (t3 = "utf8"); ; )
                    switch (t3) {
                      case "hex":
                        return I(this, e5, r3);
                      case "utf8":
                      case "utf-8":
                        return k(this, e5, r3);
                      case "ascii":
                        return M(this, e5, r3);
                      case "latin1":
                      case "binary":
                        return A(this, e5, r3);
                      case "base64":
                        return E(this, e5, r3);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return T(this, e5, r3);
                      default:
                        if (i2)
                          throw new TypeError("Unknown encoding: " + t3);
                        t3 = (t3 + "").toLowerCase(), i2 = true;
                    }
                }
                function p(t3, e5, r3) {
                  var i2 = t3[e5];
                  t3[e5] = t3[r3], t3[r3] = i2;
                }
                function m(t3, e5, r3, i2, n2) {
                  if (0 === t3.length)
                    return -1;
                  if ("string" == typeof r3 ? (i2 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), F(r3 = +r3) && (r3 = n2 ? 0 : t3.length - 1), r3 < 0 && (r3 = t3.length + r3), r3 >= t3.length) {
                    if (n2)
                      return -1;
                    r3 = t3.length - 1;
                  } else if (r3 < 0) {
                    if (!n2)
                      return -1;
                    r3 = 0;
                  }
                  if ("string" == typeof e5 && (e5 = o.from(e5, i2)), o.isBuffer(e5))
                    return 0 === e5.length ? -1 : g(t3, e5, r3, i2, n2);
                  if ("number" == typeof e5)
                    return e5 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? n2 ? Uint8Array.prototype.indexOf.call(t3, e5, r3) : Uint8Array.prototype.lastIndexOf.call(t3, e5, r3) : g(t3, [e5], r3, i2, n2);
                  throw new TypeError("val must be string, number or Buffer");
                }
                function g(t3, e5, r3, i2, n2) {
                  var a2, o2 = 1, s2 = t3.length, h2 = e5.length;
                  if (void 0 !== i2 && ("ucs2" === (i2 = String(i2).toLowerCase()) || "ucs-2" === i2 || "utf16le" === i2 || "utf-16le" === i2)) {
                    if (t3.length < 2 || e5.length < 2)
                      return -1;
                    o2 = 2, s2 /= 2, h2 /= 2, r3 /= 2;
                  }
                  function f2(t4, e6) {
                    return 1 === o2 ? t4[e6] : t4.readUInt16BE(e6 * o2);
                  }
                  if (n2) {
                    var u2 = -1;
                    for (a2 = r3; a2 < s2; a2++)
                      if (f2(t3, a2) === f2(e5, -1 === u2 ? 0 : a2 - u2)) {
                        if (-1 === u2 && (u2 = a2), a2 - u2 + 1 === h2)
                          return u2 * o2;
                      } else
                        -1 !== u2 && (a2 -= a2 - u2), u2 = -1;
                  } else
                    for (r3 + h2 > s2 && (r3 = s2 - h2), a2 = r3; a2 >= 0; a2--) {
                      for (var l2 = true, c2 = 0; c2 < h2; c2++)
                        if (f2(t3, a2 + c2) !== f2(e5, c2)) {
                          l2 = false;
                          break;
                        }
                      if (l2)
                        return a2;
                    }
                  return -1;
                }
                function b(t3, e5, r3, i2) {
                  r3 = Number(r3) || 0;
                  var n2 = t3.length - r3;
                  i2 ? (i2 = Number(i2)) > n2 && (i2 = n2) : i2 = n2;
                  var a2 = e5.length;
                  i2 > a2 / 2 && (i2 = a2 / 2);
                  for (var o2 = 0; o2 < i2; ++o2) {
                    var s2 = parseInt(e5.substr(2 * o2, 2), 16);
                    if (F(s2))
                      return o2;
                    t3[r3 + o2] = s2;
                  }
                  return o2;
                }
                function _(t3, e5, r3, i2) {
                  return z(U(e5, t3.length - r3), t3, r3, i2);
                }
                function y(t3, e5, r3, i2) {
                  return z(function(t4) {
                    for (var e6 = [], r4 = 0; r4 < t4.length; ++r4)
                      e6.push(255 & t4.charCodeAt(r4));
                    return e6;
                  }(e5), t3, r3, i2);
                }
                function w(t3, e5, r3, i2) {
                  return y(t3, e5, r3, i2);
                }
                function v(t3, e5, r3, i2) {
                  return z(D(e5), t3, r3, i2);
                }
                function x(t3, e5, r3, i2) {
                  return z(function(t4, e6) {
                    for (var r4, i3, n2, a2 = [], o2 = 0; o2 < t4.length && !((e6 -= 2) < 0); ++o2)
                      i3 = (r4 = t4.charCodeAt(o2)) >> 8, n2 = r4 % 256, a2.push(n2), a2.push(i3);
                    return a2;
                  }(e5, t3.length - r3), t3, r3, i2);
                }
                function E(t3, r3, i2) {
                  return 0 === r3 && i2 === t3.length ? e4.fromByteArray(t3) : e4.fromByteArray(t3.slice(r3, i2));
                }
                function k(t3, e5, r3) {
                  r3 = Math.min(t3.length, r3);
                  for (var i2 = [], n2 = e5; n2 < r3; ) {
                    var a2, o2, s2, h2, f2 = t3[n2], u2 = null, l2 = f2 > 239 ? 4 : f2 > 223 ? 3 : f2 > 191 ? 2 : 1;
                    if (n2 + l2 <= r3)
                      switch (l2) {
                        case 1:
                          f2 < 128 && (u2 = f2);
                          break;
                        case 2:
                          128 == (192 & (a2 = t3[n2 + 1])) && (h2 = (31 & f2) << 6 | 63 & a2) > 127 && (u2 = h2);
                          break;
                        case 3:
                          a2 = t3[n2 + 1], o2 = t3[n2 + 2], 128 == (192 & a2) && 128 == (192 & o2) && (h2 = (15 & f2) << 12 | (63 & a2) << 6 | 63 & o2) > 2047 && (h2 < 55296 || h2 > 57343) && (u2 = h2);
                          break;
                        case 4:
                          a2 = t3[n2 + 1], o2 = t3[n2 + 2], s2 = t3[n2 + 3], 128 == (192 & a2) && 128 == (192 & o2) && 128 == (192 & s2) && (h2 = (15 & f2) << 18 | (63 & a2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && h2 < 1114112 && (u2 = h2);
                      }
                    null === u2 ? (u2 = 65533, l2 = 1) : u2 > 65535 && (u2 -= 65536, i2.push(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), i2.push(u2), n2 += l2;
                  }
                  return function(t4) {
                    var e6 = t4.length;
                    if (e6 <= S)
                      return String.fromCharCode.apply(String, t4);
                    for (var r4 = "", i3 = 0; i3 < e6; )
                      r4 += String.fromCharCode.apply(String, t4.slice(i3, i3 += S));
                    return r4;
                  }(i2);
                }
                r2.kMaxLength = n, o.TYPED_ARRAY_SUPPORT = function() {
                  try {
                    var t3 = new Uint8Array(1);
                    return t3.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                      return 42;
                    } }, 42 === t3.foo();
                  } catch (t4) {
                    return false;
                  }
                }(), o.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(o.prototype, "parent", { enumerable: true, get: function() {
                  if (o.isBuffer(this))
                    return this.buffer;
                } }), Object.defineProperty(o.prototype, "offset", { enumerable: true, get: function() {
                  if (o.isBuffer(this))
                    return this.byteOffset;
                } }), "undefined" != typeof Symbol && null != Symbol.species && o[Symbol.species] === o && Object.defineProperty(o, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), o.poolSize = 8192, o.from = function(t3, e5, r3) {
                  return s(t3, e5, r3);
                }, o.prototype.__proto__ = Uint8Array.prototype, o.__proto__ = Uint8Array, o.alloc = function(t3, e5, r3) {
                  return function(t4, e6, r4) {
                    return h(t4), t4 <= 0 ? a(t4) : void 0 !== e6 ? "string" == typeof r4 ? a(t4).fill(e6, r4) : a(t4).fill(e6) : a(t4);
                  }(t3, e5, r3);
                }, o.allocUnsafe = function(t3) {
                  return f(t3);
                }, o.allocUnsafeSlow = function(t3) {
                  return f(t3);
                }, o.isBuffer = function(t3) {
                  return null != t3 && true === t3._isBuffer && t3 !== o.prototype;
                }, o.compare = function(t3, e5) {
                  if (N(t3, Uint8Array) && (t3 = o.from(t3, t3.offset, t3.byteLength)), N(e5, Uint8Array) && (e5 = o.from(e5, e5.offset, e5.byteLength)), !o.isBuffer(t3) || !o.isBuffer(e5))
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                  if (t3 === e5)
                    return 0;
                  for (var r3 = t3.length, i2 = e5.length, n2 = 0, a2 = Math.min(r3, i2); n2 < a2; ++n2)
                    if (t3[n2] !== e5[n2]) {
                      r3 = t3[n2], i2 = e5[n2];
                      break;
                    }
                  return r3 < i2 ? -1 : i2 < r3 ? 1 : 0;
                }, o.isEncoding = function(t3) {
                  switch (String(t3).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return true;
                    default:
                      return false;
                  }
                }, o.concat = function(t3, e5) {
                  if (!Array.isArray(t3))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  if (0 === t3.length)
                    return o.alloc(0);
                  var r3;
                  if (void 0 === e5)
                    for (e5 = 0, r3 = 0; r3 < t3.length; ++r3)
                      e5 += t3[r3].length;
                  var i2 = o.allocUnsafe(e5), n2 = 0;
                  for (r3 = 0; r3 < t3.length; ++r3) {
                    var a2 = t3[r3];
                    if (N(a2, Uint8Array) && (a2 = o.from(a2)), !o.isBuffer(a2))
                      throw new TypeError('"list" argument must be an Array of Buffers');
                    a2.copy(i2, n2), n2 += a2.length;
                  }
                  return i2;
                }, o.byteLength = c, o.prototype._isBuffer = true, o.prototype.swap16 = function() {
                  var t3 = this.length;
                  if (t3 % 2 != 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                  for (var e5 = 0; e5 < t3; e5 += 2)
                    p(this, e5, e5 + 1);
                  return this;
                }, o.prototype.swap32 = function() {
                  var t3 = this.length;
                  if (t3 % 4 != 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                  for (var e5 = 0; e5 < t3; e5 += 4)
                    p(this, e5, e5 + 3), p(this, e5 + 1, e5 + 2);
                  return this;
                }, o.prototype.swap64 = function() {
                  var t3 = this.length;
                  if (t3 % 8 != 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                  for (var e5 = 0; e5 < t3; e5 += 8)
                    p(this, e5, e5 + 7), p(this, e5 + 1, e5 + 6), p(this, e5 + 2, e5 + 5), p(this, e5 + 3, e5 + 4);
                  return this;
                }, o.prototype.toString = function() {
                  var t3 = this.length;
                  return 0 === t3 ? "" : 0 === arguments.length ? k(this, 0, t3) : d.apply(this, arguments);
                }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(t3) {
                  if (!o.isBuffer(t3))
                    throw new TypeError("Argument must be a Buffer");
                  return this === t3 || 0 === o.compare(this, t3);
                }, o.prototype.inspect = function() {
                  var t3 = "", e5 = r2.INSPECT_MAX_BYTES;
                  return t3 = this.toString("hex", 0, e5).replace(/(.{2})/g, "$1 ").trim(), this.length > e5 && (t3 += " ... "), "<Buffer " + t3 + ">";
                }, o.prototype.compare = function(t3, e5, r3, i2, n2) {
                  if (N(t3, Uint8Array) && (t3 = o.from(t3, t3.offset, t3.byteLength)), !o.isBuffer(t3))
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t3);
                  if (void 0 === e5 && (e5 = 0), void 0 === r3 && (r3 = t3 ? t3.length : 0), void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = this.length), e5 < 0 || r3 > t3.length || i2 < 0 || n2 > this.length)
                    throw new RangeError("out of range index");
                  if (i2 >= n2 && e5 >= r3)
                    return 0;
                  if (i2 >= n2)
                    return -1;
                  if (e5 >= r3)
                    return 1;
                  if (this === t3)
                    return 0;
                  for (var a2 = (n2 >>>= 0) - (i2 >>>= 0), s2 = (r3 >>>= 0) - (e5 >>>= 0), h2 = Math.min(a2, s2), f2 = this.slice(i2, n2), u2 = t3.slice(e5, r3), l2 = 0; l2 < h2; ++l2)
                    if (f2[l2] !== u2[l2]) {
                      a2 = f2[l2], s2 = u2[l2];
                      break;
                    }
                  return a2 < s2 ? -1 : s2 < a2 ? 1 : 0;
                }, o.prototype.includes = function(t3, e5, r3) {
                  return -1 !== this.indexOf(t3, e5, r3);
                }, o.prototype.indexOf = function(t3, e5, r3) {
                  return m(this, t3, e5, r3, true);
                }, o.prototype.lastIndexOf = function(t3, e5, r3) {
                  return m(this, t3, e5, r3, false);
                }, o.prototype.write = function(t3, e5, r3, i2) {
                  if (void 0 === e5)
                    i2 = "utf8", r3 = this.length, e5 = 0;
                  else if (void 0 === r3 && "string" == typeof e5)
                    i2 = e5, r3 = this.length, e5 = 0;
                  else {
                    if (!isFinite(e5))
                      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    e5 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === i2 && (i2 = "utf8")) : (i2 = r3, r3 = void 0);
                  }
                  var n2 = this.length - e5;
                  if ((void 0 === r3 || r3 > n2) && (r3 = n2), t3.length > 0 && (r3 < 0 || e5 < 0) || e5 > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds");
                  i2 || (i2 = "utf8");
                  for (var a2 = false; ; )
                    switch (i2) {
                      case "hex":
                        return b(this, t3, e5, r3);
                      case "utf8":
                      case "utf-8":
                        return _(this, t3, e5, r3);
                      case "ascii":
                        return y(this, t3, e5, r3);
                      case "latin1":
                      case "binary":
                        return w(this, t3, e5, r3);
                      case "base64":
                        return v(this, t3, e5, r3);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return x(this, t3, e5, r3);
                      default:
                        if (a2)
                          throw new TypeError("Unknown encoding: " + i2);
                        i2 = ("" + i2).toLowerCase(), a2 = true;
                    }
                }, o.prototype.toJSON = function() {
                  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
                };
                var S = 4096;
                function M(t3, e5, r3) {
                  var i2 = "";
                  r3 = Math.min(t3.length, r3);
                  for (var n2 = e5; n2 < r3; ++n2)
                    i2 += String.fromCharCode(127 & t3[n2]);
                  return i2;
                }
                function A(t3, e5, r3) {
                  var i2 = "";
                  r3 = Math.min(t3.length, r3);
                  for (var n2 = e5; n2 < r3; ++n2)
                    i2 += String.fromCharCode(t3[n2]);
                  return i2;
                }
                function I(t3, e5, r3) {
                  var i2, n2 = t3.length;
                  (!e5 || e5 < 0) && (e5 = 0), (!r3 || r3 < 0 || r3 > n2) && (r3 = n2);
                  for (var a2 = "", o2 = e5; o2 < r3; ++o2)
                    a2 += (i2 = t3[o2]) < 16 ? "0" + i2.toString(16) : i2.toString(16);
                  return a2;
                }
                function T(t3, e5, r3) {
                  for (var i2 = t3.slice(e5, r3), n2 = "", a2 = 0; a2 < i2.length; a2 += 2)
                    n2 += String.fromCharCode(i2[a2] + 256 * i2[a2 + 1]);
                  return n2;
                }
                function B(t3, e5, r3) {
                  if (t3 % 1 != 0 || t3 < 0)
                    throw new RangeError("offset is not uint");
                  if (t3 + e5 > r3)
                    throw new RangeError("Trying to access beyond buffer length");
                }
                function R(t3, e5, r3, i2, n2, a2) {
                  if (!o.isBuffer(t3))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                  if (e5 > n2 || e5 < a2)
                    throw new RangeError('"value" argument is out of bounds');
                  if (r3 + i2 > t3.length)
                    throw new RangeError("Index out of range");
                }
                function P(t3, e5, r3, i2, n2, a2) {
                  if (r3 + i2 > t3.length)
                    throw new RangeError("Index out of range");
                  if (r3 < 0)
                    throw new RangeError("Index out of range");
                }
                function O(t3, e5, r3, n2, a2) {
                  return e5 = +e5, r3 >>>= 0, a2 || P(t3, 0, r3, 4), i.write(t3, e5, r3, n2, 23, 4), r3 + 4;
                }
                function L(t3, e5, r3, n2, a2) {
                  return e5 = +e5, r3 >>>= 0, a2 || P(t3, 0, r3, 8), i.write(t3, e5, r3, n2, 52, 8), r3 + 8;
                }
                o.prototype.slice = function(t3, e5) {
                  var r3 = this.length;
                  (t3 = ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), (e5 = void 0 === e5 ? r3 : ~~e5) < 0 ? (e5 += r3) < 0 && (e5 = 0) : e5 > r3 && (e5 = r3), e5 < t3 && (e5 = t3);
                  var i2 = this.subarray(t3, e5);
                  return i2.__proto__ = o.prototype, i2;
                }, o.prototype.readUIntLE = function(t3, e5, r3) {
                  t3 >>>= 0, e5 >>>= 0, r3 || B(t3, e5, this.length);
                  for (var i2 = this[t3], n2 = 1, a2 = 0; ++a2 < e5 && (n2 *= 256); )
                    i2 += this[t3 + a2] * n2;
                  return i2;
                }, o.prototype.readUIntBE = function(t3, e5, r3) {
                  t3 >>>= 0, e5 >>>= 0, r3 || B(t3, e5, this.length);
                  for (var i2 = this[t3 + --e5], n2 = 1; e5 > 0 && (n2 *= 256); )
                    i2 += this[t3 + --e5] * n2;
                  return i2;
                }, o.prototype.readUInt8 = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 1, this.length), this[t3];
                }, o.prototype.readUInt16LE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 2, this.length), this[t3] | this[t3 + 1] << 8;
                }, o.prototype.readUInt16BE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 2, this.length), this[t3] << 8 | this[t3 + 1];
                }, o.prototype.readUInt32LE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 4, this.length), (this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16) + 16777216 * this[t3 + 3];
                }, o.prototype.readUInt32BE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 4, this.length), 16777216 * this[t3] + (this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3]);
                }, o.prototype.readIntLE = function(t3, e5, r3) {
                  t3 >>>= 0, e5 >>>= 0, r3 || B(t3, e5, this.length);
                  for (var i2 = this[t3], n2 = 1, a2 = 0; ++a2 < e5 && (n2 *= 256); )
                    i2 += this[t3 + a2] * n2;
                  return i2 >= (n2 *= 128) && (i2 -= Math.pow(2, 8 * e5)), i2;
                }, o.prototype.readIntBE = function(t3, e5, r3) {
                  t3 >>>= 0, e5 >>>= 0, r3 || B(t3, e5, this.length);
                  for (var i2 = e5, n2 = 1, a2 = this[t3 + --i2]; i2 > 0 && (n2 *= 256); )
                    a2 += this[t3 + --i2] * n2;
                  return a2 >= (n2 *= 128) && (a2 -= Math.pow(2, 8 * e5)), a2;
                }, o.prototype.readInt8 = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 1, this.length), 128 & this[t3] ? -1 * (255 - this[t3] + 1) : this[t3];
                }, o.prototype.readInt16LE = function(t3, e5) {
                  t3 >>>= 0, e5 || B(t3, 2, this.length);
                  var r3 = this[t3] | this[t3 + 1] << 8;
                  return 32768 & r3 ? 4294901760 | r3 : r3;
                }, o.prototype.readInt16BE = function(t3, e5) {
                  t3 >>>= 0, e5 || B(t3, 2, this.length);
                  var r3 = this[t3 + 1] | this[t3] << 8;
                  return 32768 & r3 ? 4294901760 | r3 : r3;
                }, o.prototype.readInt32LE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 4, this.length), this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16 | this[t3 + 3] << 24;
                }, o.prototype.readInt32BE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 4, this.length), this[t3] << 24 | this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3];
                }, o.prototype.readFloatLE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 4, this.length), i.read(this, t3, true, 23, 4);
                }, o.prototype.readFloatBE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 4, this.length), i.read(this, t3, false, 23, 4);
                }, o.prototype.readDoubleLE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 8, this.length), i.read(this, t3, true, 52, 8);
                }, o.prototype.readDoubleBE = function(t3, e5) {
                  return t3 >>>= 0, e5 || B(t3, 8, this.length), i.read(this, t3, false, 52, 8);
                }, o.prototype.writeUIntLE = function(t3, e5, r3, i2) {
                  t3 = +t3, e5 >>>= 0, r3 >>>= 0, i2 || R(this, t3, e5, r3, Math.pow(2, 8 * r3) - 1, 0);
                  var n2 = 1, a2 = 0;
                  for (this[e5] = 255 & t3; ++a2 < r3 && (n2 *= 256); )
                    this[e5 + a2] = t3 / n2 & 255;
                  return e5 + r3;
                }, o.prototype.writeUIntBE = function(t3, e5, r3, i2) {
                  t3 = +t3, e5 >>>= 0, r3 >>>= 0, i2 || R(this, t3, e5, r3, Math.pow(2, 8 * r3) - 1, 0);
                  var n2 = r3 - 1, a2 = 1;
                  for (this[e5 + n2] = 255 & t3; --n2 >= 0 && (a2 *= 256); )
                    this[e5 + n2] = t3 / a2 & 255;
                  return e5 + r3;
                }, o.prototype.writeUInt8 = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 1, 255, 0), this[e5] = 255 & t3, e5 + 1;
                }, o.prototype.writeUInt16LE = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 2, 65535, 0), this[e5] = 255 & t3, this[e5 + 1] = t3 >>> 8, e5 + 2;
                }, o.prototype.writeUInt16BE = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 2, 65535, 0), this[e5] = t3 >>> 8, this[e5 + 1] = 255 & t3, e5 + 2;
                }, o.prototype.writeUInt32LE = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 4, 4294967295, 0), this[e5 + 3] = t3 >>> 24, this[e5 + 2] = t3 >>> 16, this[e5 + 1] = t3 >>> 8, this[e5] = 255 & t3, e5 + 4;
                }, o.prototype.writeUInt32BE = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 4, 4294967295, 0), this[e5] = t3 >>> 24, this[e5 + 1] = t3 >>> 16, this[e5 + 2] = t3 >>> 8, this[e5 + 3] = 255 & t3, e5 + 4;
                }, o.prototype.writeIntLE = function(t3, e5, r3, i2) {
                  if (t3 = +t3, e5 >>>= 0, !i2) {
                    var n2 = Math.pow(2, 8 * r3 - 1);
                    R(this, t3, e5, r3, n2 - 1, -n2);
                  }
                  var a2 = 0, o2 = 1, s2 = 0;
                  for (this[e5] = 255 & t3; ++a2 < r3 && (o2 *= 256); )
                    t3 < 0 && 0 === s2 && 0 !== this[e5 + a2 - 1] && (s2 = 1), this[e5 + a2] = (t3 / o2 >> 0) - s2 & 255;
                  return e5 + r3;
                }, o.prototype.writeIntBE = function(t3, e5, r3, i2) {
                  if (t3 = +t3, e5 >>>= 0, !i2) {
                    var n2 = Math.pow(2, 8 * r3 - 1);
                    R(this, t3, e5, r3, n2 - 1, -n2);
                  }
                  var a2 = r3 - 1, o2 = 1, s2 = 0;
                  for (this[e5 + a2] = 255 & t3; --a2 >= 0 && (o2 *= 256); )
                    t3 < 0 && 0 === s2 && 0 !== this[e5 + a2 + 1] && (s2 = 1), this[e5 + a2] = (t3 / o2 >> 0) - s2 & 255;
                  return e5 + r3;
                }, o.prototype.writeInt8 = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 1, 127, -128), t3 < 0 && (t3 = 255 + t3 + 1), this[e5] = 255 & t3, e5 + 1;
                }, o.prototype.writeInt16LE = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 2, 32767, -32768), this[e5] = 255 & t3, this[e5 + 1] = t3 >>> 8, e5 + 2;
                }, o.prototype.writeInt16BE = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 2, 32767, -32768), this[e5] = t3 >>> 8, this[e5 + 1] = 255 & t3, e5 + 2;
                }, o.prototype.writeInt32LE = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 4, 2147483647, -2147483648), this[e5] = 255 & t3, this[e5 + 1] = t3 >>> 8, this[e5 + 2] = t3 >>> 16, this[e5 + 3] = t3 >>> 24, e5 + 4;
                }, o.prototype.writeInt32BE = function(t3, e5, r3) {
                  return t3 = +t3, e5 >>>= 0, r3 || R(this, t3, e5, 4, 2147483647, -2147483648), t3 < 0 && (t3 = 4294967295 + t3 + 1), this[e5] = t3 >>> 24, this[e5 + 1] = t3 >>> 16, this[e5 + 2] = t3 >>> 8, this[e5 + 3] = 255 & t3, e5 + 4;
                }, o.prototype.writeFloatLE = function(t3, e5, r3) {
                  return O(this, t3, e5, true, r3);
                }, o.prototype.writeFloatBE = function(t3, e5, r3) {
                  return O(this, t3, e5, false, r3);
                }, o.prototype.writeDoubleLE = function(t3, e5, r3) {
                  return L(this, t3, e5, true, r3);
                }, o.prototype.writeDoubleBE = function(t3, e5, r3) {
                  return L(this, t3, e5, false, r3);
                }, o.prototype.copy = function(t3, e5, r3, i2) {
                  if (!o.isBuffer(t3))
                    throw new TypeError("argument should be a Buffer");
                  if (r3 || (r3 = 0), i2 || 0 === i2 || (i2 = this.length), e5 >= t3.length && (e5 = t3.length), e5 || (e5 = 0), i2 > 0 && i2 < r3 && (i2 = r3), i2 === r3)
                    return 0;
                  if (0 === t3.length || 0 === this.length)
                    return 0;
                  if (e5 < 0)
                    throw new RangeError("targetStart out of bounds");
                  if (r3 < 0 || r3 >= this.length)
                    throw new RangeError("Index out of range");
                  if (i2 < 0)
                    throw new RangeError("sourceEnd out of bounds");
                  i2 > this.length && (i2 = this.length), t3.length - e5 < i2 - r3 && (i2 = t3.length - e5 + r3);
                  var n2 = i2 - r3;
                  if (this === t3 && "function" == typeof Uint8Array.prototype.copyWithin)
                    this.copyWithin(e5, r3, i2);
                  else if (this === t3 && r3 < e5 && e5 < i2)
                    for (var a2 = n2 - 1; a2 >= 0; --a2)
                      t3[a2 + e5] = this[a2 + r3];
                  else
                    Uint8Array.prototype.set.call(t3, this.subarray(r3, i2), e5);
                  return n2;
                }, o.prototype.fill = function(t3, e5, r3, i2) {
                  if ("string" == typeof t3) {
                    if ("string" == typeof e5 ? (i2 = e5, e5 = 0, r3 = this.length) : "string" == typeof r3 && (i2 = r3, r3 = this.length), void 0 !== i2 && "string" != typeof i2)
                      throw new TypeError("encoding must be a string");
                    if ("string" == typeof i2 && !o.isEncoding(i2))
                      throw new TypeError("Unknown encoding: " + i2);
                    if (1 === t3.length) {
                      var n2 = t3.charCodeAt(0);
                      ("utf8" === i2 && n2 < 128 || "latin1" === i2) && (t3 = n2);
                    }
                  } else
                    "number" == typeof t3 && (t3 &= 255);
                  if (e5 < 0 || this.length < e5 || this.length < r3)
                    throw new RangeError("Out of range index");
                  if (r3 <= e5)
                    return this;
                  var a2;
                  if (e5 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, t3 || (t3 = 0), "number" == typeof t3)
                    for (a2 = e5; a2 < r3; ++a2)
                      this[a2] = t3;
                  else {
                    var s2 = o.isBuffer(t3) ? t3 : o.from(t3, i2), h2 = s2.length;
                    if (0 === h2)
                      throw new TypeError('The value "' + t3 + '" is invalid for argument "value"');
                    for (a2 = 0; a2 < r3 - e5; ++a2)
                      this[a2 + e5] = s2[a2 % h2];
                  }
                  return this;
                };
                var C = /[^+/0-9A-Za-z-_]/g;
                function U(t3, e5) {
                  var r3;
                  e5 = e5 || 1 / 0;
                  for (var i2 = t3.length, n2 = null, a2 = [], o2 = 0; o2 < i2; ++o2) {
                    if ((r3 = t3.charCodeAt(o2)) > 55295 && r3 < 57344) {
                      if (!n2) {
                        if (r3 > 56319) {
                          (e5 -= 3) > -1 && a2.push(239, 191, 189);
                          continue;
                        }
                        if (o2 + 1 === i2) {
                          (e5 -= 3) > -1 && a2.push(239, 191, 189);
                          continue;
                        }
                        n2 = r3;
                        continue;
                      }
                      if (r3 < 56320) {
                        (e5 -= 3) > -1 && a2.push(239, 191, 189), n2 = r3;
                        continue;
                      }
                      r3 = 65536 + (n2 - 55296 << 10 | r3 - 56320);
                    } else
                      n2 && (e5 -= 3) > -1 && a2.push(239, 191, 189);
                    if (n2 = null, r3 < 128) {
                      if ((e5 -= 1) < 0)
                        break;
                      a2.push(r3);
                    } else if (r3 < 2048) {
                      if ((e5 -= 2) < 0)
                        break;
                      a2.push(r3 >> 6 | 192, 63 & r3 | 128);
                    } else if (r3 < 65536) {
                      if ((e5 -= 3) < 0)
                        break;
                      a2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
                    } else {
                      if (!(r3 < 1114112))
                        throw new Error("Invalid code point");
                      if ((e5 -= 4) < 0)
                        break;
                      a2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
                    }
                  }
                  return a2;
                }
                function D(t3) {
                  return e4.toByteArray(function(t4) {
                    if ((t4 = (t4 = t4.split("=")[0]).trim().replace(C, "")).length < 2)
                      return "";
                    for (; t4.length % 4 != 0; )
                      t4 += "=";
                    return t4;
                  }(t3));
                }
                function z(t3, e5, r3, i2) {
                  for (var n2 = 0; n2 < i2 && !(n2 + r3 >= e5.length || n2 >= t3.length); ++n2)
                    e5[n2 + r3] = t3[n2];
                  return n2;
                }
                function N(t3, e5) {
                  return t3 instanceof e5 || null != t3 && null != t3.constructor && null != t3.constructor.name && t3.constructor.name === e5.name;
                }
                function F(t3) {
                  return t3 != t3;
                }
              }).call(this);
            }).call(this, t2("buffer").Buffer);
          }, { "base64-js": 29, buffer: 33, ieee754: 44 }], 34: [function(t2, e2, r2) {
            "use strict";
            var i, n = TypeError, a = Object.getOwnPropertyDescriptor;
            if (a)
              try {
                a({}, "");
              } catch (t3) {
                a = null;
              }
            var o = function() {
              throw new n();
            }, s = a ? function() {
              try {
                return o;
              } catch (t3) {
                try {
                  return a(arguments, "callee").get;
                } catch (t4) {
                  return o;
                }
              }
            }() : o, h = t2("has-symbols")(), f = Object.getPrototypeOf || function(t3) {
              return t3.__proto__;
            }, u = i, l = i, c = i, d = i, p = "undefined" == typeof Uint8Array ? i : f(Uint8Array), m = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? i : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? i : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": h ? f([][Symbol.iterator]()) : i, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": i, "%AsyncFunction%": l, "%AsyncFunctionPrototype%": i, "%AsyncGenerator%": i, "%AsyncGeneratorFunction%": c, "%AsyncGeneratorPrototype%": i, "%AsyncIteratorPrototype%": d && h && Symbol.asyncIterator ? d[Symbol.asyncIterator]() : i, "%Atomics%": "undefined" == typeof Atomics ? i : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? i : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? i : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? i : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? i : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? i : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? i : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": i, "%GeneratorFunction%": u, "%GeneratorPrototype%": i, "%Int8Array%": "undefined" == typeof Int8Array ? i : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? i : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? i : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? i : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? i : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? i : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": h ? f(f([][Symbol.iterator]())) : i, "%JSON%": "object" == typeof JSON ? JSON : i, "%JSONParse%": "object" == typeof JSON ? JSON.parse : i, "%Map%": "undefined" == typeof Map ? i : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && h ? f((/* @__PURE__ */ new Map())[Symbol.iterator]()) : i, "%MapPrototype%": "undefined" == typeof Map ? i : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? i : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? i : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? i : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? i : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? i : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? i : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? i : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? i : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? i : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && h ? f((/* @__PURE__ */ new Set())[Symbol.iterator]()) : i, "%SetPrototype%": "undefined" == typeof Set ? i : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? i : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? i : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": h ? f(""[Symbol.iterator]()) : i, "%StringPrototype%": String.prototype, "%Symbol%": h ? Symbol : i, "%SymbolPrototype%": h ? Symbol.prototype : i, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": s, "%TypedArray%": p, "%TypedArrayPrototype%": p ? p.prototype : i, "%TypeError%": n, "%TypeErrorPrototype%": n.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? i : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? i : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? i : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? i : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? i : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? i : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? i : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? i : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? i : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? i : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? i : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? i : WeakSet.prototype }, g = t2("function-bind").call(Function.call, String.prototype.replace), b = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, _ = /\\(\\)?/g, y = function(t3) {
              var e3 = [];
              return g(t3, b, function(t4, r3, i2, n2) {
                e3[e3.length] = i2 ? g(n2, _, "$1") : r3 || t4;
              }), e3;
            }, w = function(t3, e3) {
              if (!(t3 in m))
                throw new SyntaxError("intrinsic " + t3 + " does not exist!");
              if (void 0 === m[t3] && !e3)
                throw new n("intrinsic " + t3 + " exists, but is not available. Please file an issue!");
              return m[t3];
            };
            e2.exports = function(t3, e3) {
              if ("string" != typeof t3 || 0 === t3.length)
                throw new TypeError("intrinsic name must be a non-empty string");
              if (arguments.length > 1 && "boolean" != typeof e3)
                throw new TypeError('"allowMissing" argument must be a boolean');
              for (var r3 = y(t3), i2 = w("%" + (r3.length > 0 ? r3[0] : "") + "%", e3), o2 = 1; o2 < r3.length; o2 += 1)
                if (null != i2)
                  if (a && o2 + 1 >= r3.length) {
                    var s2 = a(i2, r3[o2]);
                    if (!e3 && !(r3[o2] in i2))
                      throw new n("base intrinsic for " + t3 + " exists, but the property is not available.");
                    i2 = s2 ? s2.get || s2.value : i2[r3[o2]];
                  } else
                    i2 = i2[r3[o2]];
              return i2;
            };
          }, { "function-bind": 41, "has-symbols": 42 }], 35: [function(t2, e2, r2) {
            "use strict";
            var i = t2("function-bind"), n = t2("../GetIntrinsic")("%Function%"), a = n.apply, o = n.call;
            e2.exports = function() {
              return i.apply(o, arguments);
            }, e2.exports.apply = function() {
              return i.apply(a, arguments);
            };
          }, { "../GetIntrinsic": 34, "function-bind": 41 }], 36: [function(t2, e2, r2) {
            "use strict";
            var i = t2("../GetIntrinsic"), n = t2("./callBind"), a = n(i("String.prototype.indexOf"));
            e2.exports = function(t3, e3) {
              var r3 = i(t3, !!e3);
              return "function" == typeof r3 && a(t3, ".prototype.") ? n(r3) : r3;
            };
          }, { "../GetIntrinsic": 34, "./callBind": 35 }], 37: [function(t2, e2, r2) {
            "use strict";
            var i = t2("../GetIntrinsic")("%Object.getOwnPropertyDescriptor%");
            if (i)
              try {
                i([], "length");
              } catch (t3) {
                i = null;
              }
            e2.exports = i;
          }, { "../GetIntrinsic": 34 }], 38: [function(t2, e2, r2) {
            "use strict";
            var i, n = "object" == typeof Reflect ? Reflect : null, a = n && "function" == typeof n.apply ? n.apply : function(t3, e3, r3) {
              return Function.prototype.apply.call(t3, e3, r3);
            };
            i = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(t3) {
              return Object.getOwnPropertyNames(t3).concat(Object.getOwnPropertySymbols(t3));
            } : function(t3) {
              return Object.getOwnPropertyNames(t3);
            };
            var o = Number.isNaN || function(t3) {
              return t3 != t3;
            };
            function s() {
              s.init.call(this);
            }
            e2.exports = s, e2.exports.once = function(t3, e3) {
              return new Promise(function(r3, i2) {
                function n2() {
                  void 0 !== a2 && t3.removeListener("error", a2), r3([].slice.call(arguments));
                }
                var a2;
                "error" !== e3 && (a2 = function(r4) {
                  t3.removeListener(e3, n2), i2(r4);
                }, t3.once("error", a2)), t3.once(e3, n2);
              });
            }, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
            var h = 10;
            function f(t3) {
              if ("function" != typeof t3)
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t3);
            }
            function u(t3) {
              return void 0 === t3._maxListeners ? s.defaultMaxListeners : t3._maxListeners;
            }
            function l(t3, e3, r3, i2) {
              var n2, a2, o2, s2;
              if (f(r3), void 0 === (a2 = t3._events) ? (a2 = t3._events = /* @__PURE__ */ Object.create(null), t3._eventsCount = 0) : (void 0 !== a2.newListener && (t3.emit("newListener", e3, r3.listener ? r3.listener : r3), a2 = t3._events), o2 = a2[e3]), void 0 === o2)
                o2 = a2[e3] = r3, ++t3._eventsCount;
              else if ("function" == typeof o2 ? o2 = a2[e3] = i2 ? [r3, o2] : [o2, r3] : i2 ? o2.unshift(r3) : o2.push(r3), (n2 = u(t3)) > 0 && o2.length > n2 && !o2.warned) {
                o2.warned = true;
                var h2 = new Error("Possible EventEmitter memory leak detected. " + o2.length + " " + String(e3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                h2.name = "MaxListenersExceededWarning", h2.emitter = t3, h2.type = e3, h2.count = o2.length, s2 = h2, console && console.warn && console.warn(s2);
              }
              return t3;
            }
            function c() {
              if (!this.fired)
                return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
            }
            function d(t3, e3, r3) {
              var i2 = { fired: false, wrapFn: void 0, target: t3, type: e3, listener: r3 }, n2 = c.bind(i2);
              return n2.listener = r3, i2.wrapFn = n2, n2;
            }
            function p(t3, e3, r3) {
              var i2 = t3._events;
              if (void 0 === i2)
                return [];
              var n2 = i2[e3];
              return void 0 === n2 ? [] : "function" == typeof n2 ? r3 ? [n2.listener || n2] : [n2] : r3 ? function(t4) {
                for (var e4 = new Array(t4.length), r4 = 0; r4 < e4.length; ++r4)
                  e4[r4] = t4[r4].listener || t4[r4];
                return e4;
              }(n2) : g(n2, n2.length);
            }
            function m(t3) {
              var e3 = this._events;
              if (void 0 !== e3) {
                var r3 = e3[t3];
                if ("function" == typeof r3)
                  return 1;
                if (void 0 !== r3)
                  return r3.length;
              }
              return 0;
            }
            function g(t3, e3) {
              for (var r3 = new Array(e3), i2 = 0; i2 < e3; ++i2)
                r3[i2] = t3[i2];
              return r3;
            }
            Object.defineProperty(s, "defaultMaxListeners", { enumerable: true, get: function() {
              return h;
            }, set: function(t3) {
              if ("number" != typeof t3 || t3 < 0 || o(t3))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t3 + ".");
              h = t3;
            } }), s.init = function() {
              void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
            }, s.prototype.setMaxListeners = function(t3) {
              if ("number" != typeof t3 || t3 < 0 || o(t3))
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t3 + ".");
              return this._maxListeners = t3, this;
            }, s.prototype.getMaxListeners = function() {
              return u(this);
            }, s.prototype.emit = function(t3) {
              for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
                e3.push(arguments[r3]);
              var i2 = "error" === t3, n2 = this._events;
              if (void 0 !== n2)
                i2 = i2 && void 0 === n2.error;
              else if (!i2)
                return false;
              if (i2) {
                var o2;
                if (e3.length > 0 && (o2 = e3[0]), o2 instanceof Error)
                  throw o2;
                var s2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
                throw s2.context = o2, s2;
              }
              var h2 = n2[t3];
              if (void 0 === h2)
                return false;
              if ("function" == typeof h2)
                a(h2, this, e3);
              else {
                var f2 = h2.length, u2 = g(h2, f2);
                for (r3 = 0; r3 < f2; ++r3)
                  a(u2[r3], this, e3);
              }
              return true;
            }, s.prototype.addListener = function(t3, e3) {
              return l(this, t3, e3, false);
            }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(t3, e3) {
              return l(this, t3, e3, true);
            }, s.prototype.once = function(t3, e3) {
              return f(e3), this.on(t3, d(this, t3, e3)), this;
            }, s.prototype.prependOnceListener = function(t3, e3) {
              return f(e3), this.prependListener(t3, d(this, t3, e3)), this;
            }, s.prototype.removeListener = function(t3, e3) {
              var r3, i2, n2, a2, o2;
              if (f(e3), void 0 === (i2 = this._events))
                return this;
              if (void 0 === (r3 = i2[t3]))
                return this;
              if (r3 === e3 || r3.listener === e3)
                0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete i2[t3], i2.removeListener && this.emit("removeListener", t3, r3.listener || e3));
              else if ("function" != typeof r3) {
                for (n2 = -1, a2 = r3.length - 1; a2 >= 0; a2--)
                  if (r3[a2] === e3 || r3[a2].listener === e3) {
                    o2 = r3[a2].listener, n2 = a2;
                    break;
                  }
                if (n2 < 0)
                  return this;
                0 === n2 ? r3.shift() : function(t4, e4) {
                  for (; e4 + 1 < t4.length; e4++)
                    t4[e4] = t4[e4 + 1];
                  t4.pop();
                }(r3, n2), 1 === r3.length && (i2[t3] = r3[0]), void 0 !== i2.removeListener && this.emit("removeListener", t3, o2 || e3);
              }
              return this;
            }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(t3) {
              var e3, r3, i2;
              if (void 0 === (r3 = this._events))
                return this;
              if (void 0 === r3.removeListener)
                return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r3[t3] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r3[t3]), this;
              if (0 === arguments.length) {
                var n2, a2 = Object.keys(r3);
                for (i2 = 0; i2 < a2.length; ++i2)
                  "removeListener" !== (n2 = a2[i2]) && this.removeAllListeners(n2);
                return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
              }
              if ("function" == typeof (e3 = r3[t3]))
                this.removeListener(t3, e3);
              else if (void 0 !== e3)
                for (i2 = e3.length - 1; i2 >= 0; i2--)
                  this.removeListener(t3, e3[i2]);
              return this;
            }, s.prototype.listeners = function(t3) {
              return p(this, t3, true);
            }, s.prototype.rawListeners = function(t3) {
              return p(this, t3, false);
            }, s.listenerCount = function(t3, e3) {
              return "function" == typeof t3.listenerCount ? t3.listenerCount(e3) : m.call(t3, e3);
            }, s.prototype.listenerCount = m, s.prototype.eventNames = function() {
              return this._eventsCount > 0 ? i(this._events) : [];
            };
          }, {}], 39: [function(t2, e2, r2) {
            var i = Object.prototype.hasOwnProperty, n = Object.prototype.toString;
            e2.exports = function(t3, e3, r3) {
              if ("[object Function]" !== n.call(e3))
                throw new TypeError("iterator must be a function");
              var a = t3.length;
              if (a === +a)
                for (var o = 0; o < a; o++)
                  e3.call(r3, t3[o], o, t3);
              else
                for (var s in t3)
                  i.call(t3, s) && e3.call(r3, t3[s], s, t3);
            };
          }, {}], 40: [function(t2, e2, r2) {
            "use strict";
            var i = "Function.prototype.bind called on incompatible ", n = Array.prototype.slice, a = Object.prototype.toString, o = "[object Function]";
            e2.exports = function(t3) {
              var e3 = this;
              if ("function" != typeof e3 || a.call(e3) !== o)
                throw new TypeError(i + e3);
              for (var r3, s = n.call(arguments, 1), h = Math.max(0, e3.length - s.length), f = [], u = 0; u < h; u++)
                f.push("$" + u);
              if (r3 = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(function() {
                if (this instanceof r3) {
                  var i2 = e3.apply(this, s.concat(n.call(arguments)));
                  return Object(i2) === i2 ? i2 : this;
                }
                return e3.apply(t3, s.concat(n.call(arguments)));
              }), e3.prototype) {
                var l = function() {
                };
                l.prototype = e3.prototype, r3.prototype = new l(), l.prototype = null;
              }
              return r3;
            };
          }, {}], 41: [function(t2, e2, r2) {
            "use strict";
            var i = t2("./implementation");
            e2.exports = Function.prototype.bind || i;
          }, { "./implementation": 40 }], 42: [function(t2, e2, i) {
            (function(r2) {
              (function() {
                "use strict";
                var i2 = r2.Symbol, n = t2("./shams");
                e2.exports = function() {
                  return "function" == typeof i2 && "function" == typeof Symbol && "symbol" == typeof i2("foo") && "symbol" == typeof Symbol("bar") && n();
                };
              }).call(this);
            }).call(this, void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, { "./shams": 43 }], 43: [function(t2, e2, r2) {
            "use strict";
            e2.exports = function() {
              if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
                return false;
              if ("symbol" == typeof Symbol.iterator)
                return true;
              var t3 = {}, e3 = Symbol("test"), r3 = Object(e3);
              if ("string" == typeof e3)
                return false;
              if ("[object Symbol]" !== Object.prototype.toString.call(e3))
                return false;
              if ("[object Symbol]" !== Object.prototype.toString.call(r3))
                return false;
              for (e3 in t3[e3] = 42, t3)
                return false;
              if ("function" == typeof Object.keys && 0 !== Object.keys(t3).length)
                return false;
              if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t3).length)
                return false;
              var i = Object.getOwnPropertySymbols(t3);
              if (1 !== i.length || i[0] !== e3)
                return false;
              if (!Object.prototype.propertyIsEnumerable.call(t3, e3))
                return false;
              if ("function" == typeof Object.getOwnPropertyDescriptor) {
                var n = Object.getOwnPropertyDescriptor(t3, e3);
                if (42 !== n.value || true !== n.enumerable)
                  return false;
              }
              return true;
            };
          }, {}], 44: [function(t2, e2, r2) {
            r2.read = function(t3, e3, r3, i, n) {
              var a, o, s = 8 * n - i - 1, h = (1 << s) - 1, f = h >> 1, u = -7, l = r3 ? n - 1 : 0, c = r3 ? -1 : 1, d = t3[e3 + l];
              for (l += c, a = d & (1 << -u) - 1, d >>= -u, u += s; u > 0; a = 256 * a + t3[e3 + l], l += c, u -= 8)
                ;
              for (o = a & (1 << -u) - 1, a >>= -u, u += i; u > 0; o = 256 * o + t3[e3 + l], l += c, u -= 8)
                ;
              if (0 === a)
                a = 1 - f;
              else {
                if (a === h)
                  return o ? NaN : 1 / 0 * (d ? -1 : 1);
                o += Math.pow(2, i), a -= f;
              }
              return (d ? -1 : 1) * o * Math.pow(2, a - i);
            }, r2.write = function(t3, e3, r3, i, n, a) {
              var o, s, h, f = 8 * a - n - 1, u = (1 << f) - 1, l = u >> 1, c = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = i ? 0 : a - 1, p = i ? 1 : -1, m = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
              for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (s = isNaN(e3) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e3) / Math.LN2), e3 * (h = Math.pow(2, -o)) < 1 && (o--, h *= 2), (e3 += o + l >= 1 ? c / h : c * Math.pow(2, 1 - l)) * h >= 2 && (o++, h /= 2), o + l >= u ? (s = 0, o = u) : o + l >= 1 ? (s = (e3 * h - 1) * Math.pow(2, n), o += l) : (s = e3 * Math.pow(2, l - 1) * Math.pow(2, n), o = 0)); n >= 8; t3[r3 + d] = 255 & s, d += p, s /= 256, n -= 8)
                ;
              for (o = o << n | s, f += n; f > 0; t3[r3 + d] = 255 & o, d += p, o /= 256, f -= 8)
                ;
              t3[r3 + d - p] |= 128 * m;
            };
          }, {}], 45: [function(t2, e2, r2) {
            "function" == typeof Object.create ? e2.exports = function(t3, e3) {
              e3 && (t3.super_ = e3, t3.prototype = Object.create(e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }));
            } : e2.exports = function(t3, e3) {
              if (e3) {
                t3.super_ = e3;
                var r3 = function() {
                };
                r3.prototype = e3.prototype, t3.prototype = new r3(), t3.prototype.constructor = t3;
              }
            };
          }, {}], 46: [function(t2, e2, r2) {
            "use strict";
            var i = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, n = Object.prototype.toString, a = function(t3) {
              return !(i && t3 && "object" == typeof t3 && Symbol.toStringTag in t3) && "[object Arguments]" === n.call(t3);
            }, o = function(t3) {
              return !!a(t3) || null !== t3 && "object" == typeof t3 && "number" == typeof t3.length && t3.length >= 0 && "[object Array]" !== n.call(t3) && "[object Function]" === n.call(t3.callee);
            }, s = function() {
              return a(arguments);
            }();
            a.isLegacyArguments = o, e2.exports = s ? a : o;
          }, {}], 47: [function(t2, e2, r2) {
            "use strict";
            var i = Object.prototype.toString, n = Function.prototype.toString, a = /^\s*(?:function)?\*/, o = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, s = Object.getPrototypeOf, h = function() {
              if (!o)
                return false;
              try {
                return Function("return function*() {}")();
              } catch (t3) {
              }
            }(), f = h ? s(h) : {};
            e2.exports = function(t3) {
              return "function" == typeof t3 && (!!a.test(n.call(t3)) || (o ? s(t3) === f : "[object GeneratorFunction]" === i.call(t3)));
            };
          }, {}], 48: [function(t2, e2, i) {
            (function(r2) {
              (function() {
                "use strict";
                var i2 = t2("foreach"), n = t2("available-typed-arrays"), a = t2("es-abstract/helpers/callBound"), o = a("Object.prototype.toString"), s = t2("has-symbols")() && "symbol" == typeof Symbol.toStringTag, h = n(), f = a("Array.prototype.indexOf", true) || function(t3, e3) {
                  for (var r3 = 0; r3 < t3.length; r3 += 1)
                    if (t3[r3] === e3)
                      return r3;
                  return -1;
                }, u = a("String.prototype.slice"), l = {}, c = t2("es-abstract/helpers/getOwnPropertyDescriptor"), d = Object.getPrototypeOf;
                s && c && d && i2(h, function(t3) {
                  var e3 = new r2[t3]();
                  if (!(Symbol.toStringTag in e3))
                    throw new EvalError("this engine has support for Symbol.toStringTag, but " + t3 + " does not have the property! Please report this.");
                  var i3 = d(e3), n2 = c(i3, Symbol.toStringTag);
                  if (!n2) {
                    var a2 = d(i3);
                    n2 = c(a2, Symbol.toStringTag);
                  }
                  l[t3] = n2.get;
                });
                e2.exports = function(t3) {
                  if (!t3 || "object" != typeof t3)
                    return false;
                  if (!s) {
                    var e3 = u(o(t3), 8, -1);
                    return f(h, e3) > -1;
                  }
                  return !!c && function(t4) {
                    var e4 = false;
                    return i2(l, function(r3, i3) {
                      if (!e4)
                        try {
                          e4 = r3.call(t4) === i3;
                        } catch (t5) {
                        }
                    }), e4;
                  }(t3);
                };
              }).call(this);
            }).call(this, void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, { "available-typed-arrays": 27, "es-abstract/helpers/callBound": 36, "es-abstract/helpers/getOwnPropertyDescriptor": 37, foreach: 39, "has-symbols": 42 }], 49: [function(t2, e2, r2) {
            "use strict";
            var i = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
            function n(t3, e3) {
              return Object.prototype.hasOwnProperty.call(t3, e3);
            }
            r2.assign = function(t3) {
              for (var e3 = Array.prototype.slice.call(arguments, 1); e3.length; ) {
                var r3 = e3.shift();
                if (r3) {
                  if ("object" != typeof r3)
                    throw new TypeError(r3 + "must be non-object");
                  for (var i2 in r3)
                    n(r3, i2) && (t3[i2] = r3[i2]);
                }
              }
              return t3;
            }, r2.shrinkBuf = function(t3, e3) {
              return t3.length === e3 ? t3 : t3.subarray ? t3.subarray(0, e3) : (t3.length = e3, t3);
            };
            var a = { arraySet: function(t3, e3, r3, i2, n2) {
              if (e3.subarray && t3.subarray)
                t3.set(e3.subarray(r3, r3 + i2), n2);
              else
                for (var a2 = 0; a2 < i2; a2++)
                  t3[n2 + a2] = e3[r3 + a2];
            }, flattenChunks: function(t3) {
              var e3, r3, i2, n2, a2, o2;
              for (i2 = 0, e3 = 0, r3 = t3.length; e3 < r3; e3++)
                i2 += t3[e3].length;
              for (o2 = new Uint8Array(i2), n2 = 0, e3 = 0, r3 = t3.length; e3 < r3; e3++)
                a2 = t3[e3], o2.set(a2, n2), n2 += a2.length;
              return o2;
            } }, o = { arraySet: function(t3, e3, r3, i2, n2) {
              for (var a2 = 0; a2 < i2; a2++)
                t3[n2 + a2] = e3[r3 + a2];
            }, flattenChunks: function(t3) {
              return [].concat.apply([], t3);
            } };
            r2.setTyped = function(t3) {
              t3 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, a)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, o));
            }, r2.setTyped(i);
          }, {}], 50: [function(t2, e2, r2) {
            "use strict";
            e2.exports = function(t3, e3, r3, i) {
              for (var n = 65535 & t3 | 0, a = t3 >>> 16 & 65535 | 0, o = 0; 0 !== r3; ) {
                r3 -= o = r3 > 2e3 ? 2e3 : r3;
                do {
                  a = a + (n = n + e3[i++] | 0) | 0;
                } while (--o);
                n %= 65521, a %= 65521;
              }
              return n | a << 16 | 0;
            };
          }, {}], 51: [function(t2, e2, r2) {
            "use strict";
            e2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
          }, {}], 52: [function(t2, e2, r2) {
            "use strict";
            var i = function() {
              for (var t3, e3 = [], r3 = 0; r3 < 256; r3++) {
                t3 = r3;
                for (var i2 = 0; i2 < 8; i2++)
                  t3 = 1 & t3 ? 3988292384 ^ t3 >>> 1 : t3 >>> 1;
                e3[r3] = t3;
              }
              return e3;
            }();
            e2.exports = function(t3, e3, r3, n) {
              var a = i, o = n + r3;
              t3 ^= -1;
              for (var s = n; s < o; s++)
                t3 = t3 >>> 8 ^ a[255 & (t3 ^ e3[s])];
              return -1 ^ t3;
            };
          }, {}], 53: [function(t2, e2, r2) {
            "use strict";
            var i, n = t2("../utils/common"), a = t2("./trees"), o = t2("./adler32"), s = t2("./crc32"), h = t2("./messages"), f = 0, u = 1, l = 3, c = 4, d = 5, p = 0, m = 1, g = -2, b = -3, _ = -5, y = -1, w = 1, v = 2, x = 3, E = 4, k = 0, S = 2, M = 8, A = 9, I = 15, T = 8, B = 286, R = 30, P = 19, O = 2 * B + 1, L = 15, C = 3, U = 258, D = U + C + 1, z = 32, N = 42, F = 69, j = 73, G = 91, H = 103, W = 113, q = 666, Z = 1, Y = 2, V = 3, X = 4, Q = 3;
            function J(t3, e3) {
              return t3.msg = h[e3], e3;
            }
            function K(t3) {
              return (t3 << 1) - (t3 > 4 ? 9 : 0);
            }
            function $(t3) {
              for (var e3 = t3.length; --e3 >= 0; )
                t3[e3] = 0;
            }
            function tt(t3) {
              var e3 = t3.state, r3 = e3.pending;
              r3 > t3.avail_out && (r3 = t3.avail_out), 0 !== r3 && (n.arraySet(t3.output, e3.pending_buf, e3.pending_out, r3, t3.next_out), t3.next_out += r3, e3.pending_out += r3, t3.total_out += r3, t3.avail_out -= r3, e3.pending -= r3, 0 === e3.pending && (e3.pending_out = 0));
            }
            function et(t3, e3) {
              a._tr_flush_block(t3, t3.block_start >= 0 ? t3.block_start : -1, t3.strstart - t3.block_start, e3), t3.block_start = t3.strstart, tt(t3.strm);
            }
            function rt(t3, e3) {
              t3.pending_buf[t3.pending++] = e3;
            }
            function it(t3, e3) {
              t3.pending_buf[t3.pending++] = e3 >>> 8 & 255, t3.pending_buf[t3.pending++] = 255 & e3;
            }
            function nt(t3, e3) {
              var r3, i2, n2 = t3.max_chain_length, a2 = t3.strstart, o2 = t3.prev_length, s2 = t3.nice_match, h2 = t3.strstart > t3.w_size - D ? t3.strstart - (t3.w_size - D) : 0, f2 = t3.window, u2 = t3.w_mask, l2 = t3.prev, c2 = t3.strstart + U, d2 = f2[a2 + o2 - 1], p2 = f2[a2 + o2];
              t3.prev_length >= t3.good_match && (n2 >>= 2), s2 > t3.lookahead && (s2 = t3.lookahead);
              do {
                if (f2[(r3 = e3) + o2] === p2 && f2[r3 + o2 - 1] === d2 && f2[r3] === f2[a2] && f2[++r3] === f2[a2 + 1]) {
                  a2 += 2, r3++;
                  do {
                  } while (f2[++a2] === f2[++r3] && f2[++a2] === f2[++r3] && f2[++a2] === f2[++r3] && f2[++a2] === f2[++r3] && f2[++a2] === f2[++r3] && f2[++a2] === f2[++r3] && f2[++a2] === f2[++r3] && f2[++a2] === f2[++r3] && a2 < c2);
                  if (i2 = U - (c2 - a2), a2 = c2 - U, i2 > o2) {
                    if (t3.match_start = e3, o2 = i2, i2 >= s2)
                      break;
                    d2 = f2[a2 + o2 - 1], p2 = f2[a2 + o2];
                  }
                }
              } while ((e3 = l2[e3 & u2]) > h2 && 0 != --n2);
              return o2 <= t3.lookahead ? o2 : t3.lookahead;
            }
            function at(t3) {
              var e3, r3, i2, a2, h2, f2, u2, l2, c2, d2, p2 = t3.w_size;
              do {
                if (a2 = t3.window_size - t3.lookahead - t3.strstart, t3.strstart >= p2 + (p2 - D)) {
                  n.arraySet(t3.window, t3.window, p2, p2, 0), t3.match_start -= p2, t3.strstart -= p2, t3.block_start -= p2, e3 = r3 = t3.hash_size;
                  do {
                    i2 = t3.head[--e3], t3.head[e3] = i2 >= p2 ? i2 - p2 : 0;
                  } while (--r3);
                  e3 = r3 = p2;
                  do {
                    i2 = t3.prev[--e3], t3.prev[e3] = i2 >= p2 ? i2 - p2 : 0;
                  } while (--r3);
                  a2 += p2;
                }
                if (0 === t3.strm.avail_in)
                  break;
                if (f2 = t3.strm, u2 = t3.window, l2 = t3.strstart + t3.lookahead, c2 = a2, d2 = void 0, (d2 = f2.avail_in) > c2 && (d2 = c2), r3 = 0 === d2 ? 0 : (f2.avail_in -= d2, n.arraySet(u2, f2.input, f2.next_in, d2, l2), 1 === f2.state.wrap ? f2.adler = o(f2.adler, u2, d2, l2) : 2 === f2.state.wrap && (f2.adler = s(f2.adler, u2, d2, l2)), f2.next_in += d2, f2.total_in += d2, d2), t3.lookahead += r3, t3.lookahead + t3.insert >= C)
                  for (h2 = t3.strstart - t3.insert, t3.ins_h = t3.window[h2], t3.ins_h = (t3.ins_h << t3.hash_shift ^ t3.window[h2 + 1]) & t3.hash_mask; t3.insert && (t3.ins_h = (t3.ins_h << t3.hash_shift ^ t3.window[h2 + C - 1]) & t3.hash_mask, t3.prev[h2 & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = h2, h2++, t3.insert--, !(t3.lookahead + t3.insert < C)); )
                    ;
              } while (t3.lookahead < D && 0 !== t3.strm.avail_in);
            }
            function ot(t3, e3) {
              for (var r3, i2; ; ) {
                if (t3.lookahead < D) {
                  if (at(t3), t3.lookahead < D && e3 === f)
                    return Z;
                  if (0 === t3.lookahead)
                    break;
                }
                if (r3 = 0, t3.lookahead >= C && (t3.ins_h = (t3.ins_h << t3.hash_shift ^ t3.window[t3.strstart + C - 1]) & t3.hash_mask, r3 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart), 0 !== r3 && t3.strstart - r3 <= t3.w_size - D && (t3.match_length = nt(t3, r3)), t3.match_length >= C)
                  if (i2 = a._tr_tally(t3, t3.strstart - t3.match_start, t3.match_length - C), t3.lookahead -= t3.match_length, t3.match_length <= t3.max_lazy_match && t3.lookahead >= C) {
                    t3.match_length--;
                    do {
                      t3.strstart++, t3.ins_h = (t3.ins_h << t3.hash_shift ^ t3.window[t3.strstart + C - 1]) & t3.hash_mask, r3 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart;
                    } while (0 != --t3.match_length);
                    t3.strstart++;
                  } else
                    t3.strstart += t3.match_length, t3.match_length = 0, t3.ins_h = t3.window[t3.strstart], t3.ins_h = (t3.ins_h << t3.hash_shift ^ t3.window[t3.strstart + 1]) & t3.hash_mask;
                else
                  i2 = a._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++;
                if (i2 && (et(t3, false), 0 === t3.strm.avail_out))
                  return Z;
              }
              return t3.insert = t3.strstart < C - 1 ? t3.strstart : C - 1, e3 === c ? (et(t3, true), 0 === t3.strm.avail_out ? V : X) : t3.last_lit && (et(t3, false), 0 === t3.strm.avail_out) ? Z : Y;
            }
            function st(t3, e3) {
              for (var r3, i2, n2; ; ) {
                if (t3.lookahead < D) {
                  if (at(t3), t3.lookahead < D && e3 === f)
                    return Z;
                  if (0 === t3.lookahead)
                    break;
                }
                if (r3 = 0, t3.lookahead >= C && (t3.ins_h = (t3.ins_h << t3.hash_shift ^ t3.window[t3.strstart + C - 1]) & t3.hash_mask, r3 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart), t3.prev_length = t3.match_length, t3.prev_match = t3.match_start, t3.match_length = C - 1, 0 !== r3 && t3.prev_length < t3.max_lazy_match && t3.strstart - r3 <= t3.w_size - D && (t3.match_length = nt(t3, r3), t3.match_length <= 5 && (t3.strategy === w || t3.match_length === C && t3.strstart - t3.match_start > 4096) && (t3.match_length = C - 1)), t3.prev_length >= C && t3.match_length <= t3.prev_length) {
                  n2 = t3.strstart + t3.lookahead - C, i2 = a._tr_tally(t3, t3.strstart - 1 - t3.prev_match, t3.prev_length - C), t3.lookahead -= t3.prev_length - 1, t3.prev_length -= 2;
                  do {
                    ++t3.strstart <= n2 && (t3.ins_h = (t3.ins_h << t3.hash_shift ^ t3.window[t3.strstart + C - 1]) & t3.hash_mask, r3 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart);
                  } while (0 != --t3.prev_length);
                  if (t3.match_available = 0, t3.match_length = C - 1, t3.strstart++, i2 && (et(t3, false), 0 === t3.strm.avail_out))
                    return Z;
                } else if (t3.match_available) {
                  if ((i2 = a._tr_tally(t3, 0, t3.window[t3.strstart - 1])) && et(t3, false), t3.strstart++, t3.lookahead--, 0 === t3.strm.avail_out)
                    return Z;
                } else
                  t3.match_available = 1, t3.strstart++, t3.lookahead--;
              }
              return t3.match_available && (i2 = a._tr_tally(t3, 0, t3.window[t3.strstart - 1]), t3.match_available = 0), t3.insert = t3.strstart < C - 1 ? t3.strstart : C - 1, e3 === c ? (et(t3, true), 0 === t3.strm.avail_out ? V : X) : t3.last_lit && (et(t3, false), 0 === t3.strm.avail_out) ? Z : Y;
            }
            function ht(t3, e3, r3, i2, n2) {
              this.good_length = t3, this.max_lazy = e3, this.nice_length = r3, this.max_chain = i2, this.func = n2;
            }
            function ft() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = M, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new n.Buf16(2 * O), this.dyn_dtree = new n.Buf16(2 * (2 * R + 1)), this.bl_tree = new n.Buf16(2 * (2 * P + 1)), $(this.dyn_ltree), $(this.dyn_dtree), $(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new n.Buf16(L + 1), this.heap = new n.Buf16(2 * B + 1), $(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new n.Buf16(2 * B + 1), $(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function ut(t3) {
              var e3;
              return t3 && t3.state ? (t3.total_in = t3.total_out = 0, t3.data_type = S, (e3 = t3.state).pending = 0, e3.pending_out = 0, e3.wrap < 0 && (e3.wrap = -e3.wrap), e3.status = e3.wrap ? N : W, t3.adler = 2 === e3.wrap ? 0 : 1, e3.last_flush = f, a._tr_init(e3), p) : J(t3, g);
            }
            function lt(t3) {
              var e3, r3 = ut(t3);
              return r3 === p && ((e3 = t3.state).window_size = 2 * e3.w_size, $(e3.head), e3.max_lazy_match = i[e3.level].max_lazy, e3.good_match = i[e3.level].good_length, e3.nice_match = i[e3.level].nice_length, e3.max_chain_length = i[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = C - 1, e3.match_available = 0, e3.ins_h = 0), r3;
            }
            function ct(t3, e3, r3, i2, a2, o2) {
              if (!t3)
                return g;
              var s2 = 1;
              if (e3 === y && (e3 = 6), i2 < 0 ? (s2 = 0, i2 = -i2) : i2 > 15 && (s2 = 2, i2 -= 16), a2 < 1 || a2 > A || r3 !== M || i2 < 8 || i2 > 15 || e3 < 0 || e3 > 9 || o2 < 0 || o2 > E)
                return J(t3, g);
              8 === i2 && (i2 = 9);
              var h2 = new ft();
              return t3.state = h2, h2.strm = t3, h2.wrap = s2, h2.gzhead = null, h2.w_bits = i2, h2.w_size = 1 << h2.w_bits, h2.w_mask = h2.w_size - 1, h2.hash_bits = a2 + 7, h2.hash_size = 1 << h2.hash_bits, h2.hash_mask = h2.hash_size - 1, h2.hash_shift = ~~((h2.hash_bits + C - 1) / C), h2.window = new n.Buf8(2 * h2.w_size), h2.head = new n.Buf16(h2.hash_size), h2.prev = new n.Buf16(h2.w_size), h2.lit_bufsize = 1 << a2 + 6, h2.pending_buf_size = 4 * h2.lit_bufsize, h2.pending_buf = new n.Buf8(h2.pending_buf_size), h2.d_buf = 1 * h2.lit_bufsize, h2.l_buf = 3 * h2.lit_bufsize, h2.level = e3, h2.strategy = o2, h2.method = r3, lt(t3);
            }
            i = [new ht(0, 0, 0, 0, function(t3, e3) {
              var r3 = 65535;
              for (r3 > t3.pending_buf_size - 5 && (r3 = t3.pending_buf_size - 5); ; ) {
                if (t3.lookahead <= 1) {
                  if (at(t3), 0 === t3.lookahead && e3 === f)
                    return Z;
                  if (0 === t3.lookahead)
                    break;
                }
                t3.strstart += t3.lookahead, t3.lookahead = 0;
                var i2 = t3.block_start + r3;
                if ((0 === t3.strstart || t3.strstart >= i2) && (t3.lookahead = t3.strstart - i2, t3.strstart = i2, et(t3, false), 0 === t3.strm.avail_out))
                  return Z;
                if (t3.strstart - t3.block_start >= t3.w_size - D && (et(t3, false), 0 === t3.strm.avail_out))
                  return Z;
              }
              return t3.insert = 0, e3 === c ? (et(t3, true), 0 === t3.strm.avail_out ? V : X) : (t3.strstart > t3.block_start && (et(t3, false), t3.strm.avail_out), Z);
            }), new ht(4, 4, 8, 4, ot), new ht(4, 5, 16, 8, ot), new ht(4, 6, 32, 32, ot), new ht(4, 4, 16, 16, st), new ht(8, 16, 32, 32, st), new ht(8, 16, 128, 128, st), new ht(8, 32, 128, 256, st), new ht(32, 128, 258, 1024, st), new ht(32, 258, 258, 4096, st)], r2.deflateInit = function(t3, e3) {
              return ct(t3, e3, M, I, T, k);
            }, r2.deflateInit2 = ct, r2.deflateReset = lt, r2.deflateResetKeep = ut, r2.deflateSetHeader = function(t3, e3) {
              return t3 && t3.state ? 2 !== t3.state.wrap ? g : (t3.state.gzhead = e3, p) : g;
            }, r2.deflate = function(t3, e3) {
              var r3, n2, o2, h2;
              if (!t3 || !t3.state || e3 > d || e3 < 0)
                return t3 ? J(t3, g) : g;
              if (n2 = t3.state, !t3.output || !t3.input && 0 !== t3.avail_in || n2.status === q && e3 !== c)
                return J(t3, 0 === t3.avail_out ? _ : g);
              if (n2.strm = t3, r3 = n2.last_flush, n2.last_flush = e3, n2.status === N)
                if (2 === n2.wrap)
                  t3.adler = 0, rt(n2, 31), rt(n2, 139), rt(n2, 8), n2.gzhead ? (rt(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), rt(n2, 255 & n2.gzhead.time), rt(n2, n2.gzhead.time >> 8 & 255), rt(n2, n2.gzhead.time >> 16 & 255), rt(n2, n2.gzhead.time >> 24 & 255), rt(n2, 9 === n2.level ? 2 : n2.strategy >= v || n2.level < 2 ? 4 : 0), rt(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (rt(n2, 255 & n2.gzhead.extra.length), rt(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (t3.adler = s(t3.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = F) : (rt(n2, 0), rt(n2, 0), rt(n2, 0), rt(n2, 0), rt(n2, 0), rt(n2, 9 === n2.level ? 2 : n2.strategy >= v || n2.level < 2 ? 4 : 0), rt(n2, Q), n2.status = W);
                else {
                  var b2 = M + (n2.w_bits - 8 << 4) << 8;
                  b2 |= (n2.strategy >= v || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (b2 |= z), b2 += 31 - b2 % 31, n2.status = W, it(n2, b2), 0 !== n2.strstart && (it(n2, t3.adler >>> 16), it(n2, 65535 & t3.adler)), t3.adler = 1;
                }
              if (n2.status === F)
                if (n2.gzhead.extra) {
                  for (o2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > o2 && (t3.adler = s(t3.adler, n2.pending_buf, n2.pending - o2, o2)), tt(t3), o2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                    rt(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
                  n2.gzhead.hcrc && n2.pending > o2 && (t3.adler = s(t3.adler, n2.pending_buf, n2.pending - o2, o2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = j);
                } else
                  n2.status = j;
              if (n2.status === j)
                if (n2.gzhead.name) {
                  o2 = n2.pending;
                  do {
                    if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > o2 && (t3.adler = s(t3.adler, n2.pending_buf, n2.pending - o2, o2)), tt(t3), o2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                      h2 = 1;
                      break;
                    }
                    h2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, rt(n2, h2);
                  } while (0 !== h2);
                  n2.gzhead.hcrc && n2.pending > o2 && (t3.adler = s(t3.adler, n2.pending_buf, n2.pending - o2, o2)), 0 === h2 && (n2.gzindex = 0, n2.status = G);
                } else
                  n2.status = G;
              if (n2.status === G)
                if (n2.gzhead.comment) {
                  o2 = n2.pending;
                  do {
                    if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > o2 && (t3.adler = s(t3.adler, n2.pending_buf, n2.pending - o2, o2)), tt(t3), o2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                      h2 = 1;
                      break;
                    }
                    h2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, rt(n2, h2);
                  } while (0 !== h2);
                  n2.gzhead.hcrc && n2.pending > o2 && (t3.adler = s(t3.adler, n2.pending_buf, n2.pending - o2, o2)), 0 === h2 && (n2.status = H);
                } else
                  n2.status = H;
              if (n2.status === H && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && tt(t3), n2.pending + 2 <= n2.pending_buf_size && (rt(n2, 255 & t3.adler), rt(n2, t3.adler >> 8 & 255), t3.adler = 0, n2.status = W)) : n2.status = W), 0 !== n2.pending) {
                if (tt(t3), 0 === t3.avail_out)
                  return n2.last_flush = -1, p;
              } else if (0 === t3.avail_in && K(e3) <= K(r3) && e3 !== c)
                return J(t3, _);
              if (n2.status === q && 0 !== t3.avail_in)
                return J(t3, _);
              if (0 !== t3.avail_in || 0 !== n2.lookahead || e3 !== f && n2.status !== q) {
                var y2 = n2.strategy === v ? function(t4, e4) {
                  for (var r4; ; ) {
                    if (0 === t4.lookahead && (at(t4), 0 === t4.lookahead)) {
                      if (e4 === f)
                        return Z;
                      break;
                    }
                    if (t4.match_length = 0, r4 = a._tr_tally(t4, 0, t4.window[t4.strstart]), t4.lookahead--, t4.strstart++, r4 && (et(t4, false), 0 === t4.strm.avail_out))
                      return Z;
                  }
                  return t4.insert = 0, e4 === c ? (et(t4, true), 0 === t4.strm.avail_out ? V : X) : t4.last_lit && (et(t4, false), 0 === t4.strm.avail_out) ? Z : Y;
                }(n2, e3) : n2.strategy === x ? function(t4, e4) {
                  for (var r4, i2, n3, o3, s2 = t4.window; ; ) {
                    if (t4.lookahead <= U) {
                      if (at(t4), t4.lookahead <= U && e4 === f)
                        return Z;
                      if (0 === t4.lookahead)
                        break;
                    }
                    if (t4.match_length = 0, t4.lookahead >= C && t4.strstart > 0 && (i2 = s2[n3 = t4.strstart - 1]) === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3]) {
                      o3 = t4.strstart + U;
                      do {
                      } while (i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && i2 === s2[++n3] && n3 < o3);
                      t4.match_length = U - (o3 - n3), t4.match_length > t4.lookahead && (t4.match_length = t4.lookahead);
                    }
                    if (t4.match_length >= C ? (r4 = a._tr_tally(t4, 1, t4.match_length - C), t4.lookahead -= t4.match_length, t4.strstart += t4.match_length, t4.match_length = 0) : (r4 = a._tr_tally(t4, 0, t4.window[t4.strstart]), t4.lookahead--, t4.strstart++), r4 && (et(t4, false), 0 === t4.strm.avail_out))
                      return Z;
                  }
                  return t4.insert = 0, e4 === c ? (et(t4, true), 0 === t4.strm.avail_out ? V : X) : t4.last_lit && (et(t4, false), 0 === t4.strm.avail_out) ? Z : Y;
                }(n2, e3) : i[n2.level].func(n2, e3);
                if (y2 !== V && y2 !== X || (n2.status = q), y2 === Z || y2 === V)
                  return 0 === t3.avail_out && (n2.last_flush = -1), p;
                if (y2 === Y && (e3 === u ? a._tr_align(n2) : e3 !== d && (a._tr_stored_block(n2, 0, 0, false), e3 === l && ($(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), tt(t3), 0 === t3.avail_out))
                  return n2.last_flush = -1, p;
              }
              return e3 !== c ? p : n2.wrap <= 0 ? m : (2 === n2.wrap ? (rt(n2, 255 & t3.adler), rt(n2, t3.adler >> 8 & 255), rt(n2, t3.adler >> 16 & 255), rt(n2, t3.adler >> 24 & 255), rt(n2, 255 & t3.total_in), rt(n2, t3.total_in >> 8 & 255), rt(n2, t3.total_in >> 16 & 255), rt(n2, t3.total_in >> 24 & 255)) : (it(n2, t3.adler >>> 16), it(n2, 65535 & t3.adler)), tt(t3), n2.wrap > 0 && (n2.wrap = -n2.wrap), 0 !== n2.pending ? p : m);
            }, r2.deflateEnd = function(t3) {
              var e3;
              return t3 && t3.state ? (e3 = t3.state.status) !== N && e3 !== F && e3 !== j && e3 !== G && e3 !== H && e3 !== W && e3 !== q ? J(t3, g) : (t3.state = null, e3 === W ? J(t3, b) : p) : g;
            }, r2.deflateSetDictionary = function(t3, e3) {
              var r3, i2, a2, s2, h2, f2, u2, l2, c2 = e3.length;
              if (!t3 || !t3.state)
                return g;
              if (2 === (s2 = (r3 = t3.state).wrap) || 1 === s2 && r3.status !== N || r3.lookahead)
                return g;
              for (1 === s2 && (t3.adler = o(t3.adler, e3, c2, 0)), r3.wrap = 0, c2 >= r3.w_size && (0 === s2 && ($(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), l2 = new n.Buf8(r3.w_size), n.arraySet(l2, e3, c2 - r3.w_size, r3.w_size, 0), e3 = l2, c2 = r3.w_size), h2 = t3.avail_in, f2 = t3.next_in, u2 = t3.input, t3.avail_in = c2, t3.next_in = 0, t3.input = e3, at(r3); r3.lookahead >= C; ) {
                i2 = r3.strstart, a2 = r3.lookahead - (C - 1);
                do {
                  r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[i2 + C - 1]) & r3.hash_mask, r3.prev[i2 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = i2, i2++;
                } while (--a2);
                r3.strstart = i2, r3.lookahead = C - 1, at(r3);
              }
              return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = C - 1, r3.match_available = 0, t3.next_in = f2, t3.input = u2, t3.avail_in = h2, r3.wrap = s2, p;
            }, r2.deflateInfo = "pako deflate (from Nodeca project)";
          }, { "../utils/common": 49, "./adler32": 50, "./crc32": 52, "./messages": 57, "./trees": 58 }], 54: [function(t2, e2, r2) {
            "use strict";
            e2.exports = function(t3, e3) {
              var r3, i, n, a, o, s, h, f, u, l, c, d, p, m, g, b, _, y, w, v, x, E, k, S, M;
              r3 = t3.state, i = t3.next_in, S = t3.input, n = i + (t3.avail_in - 5), a = t3.next_out, M = t3.output, o = a - (e3 - t3.avail_out), s = a + (t3.avail_out - 257), h = r3.dmax, f = r3.wsize, u = r3.whave, l = r3.wnext, c = r3.window, d = r3.hold, p = r3.bits, m = r3.lencode, g = r3.distcode, b = (1 << r3.lenbits) - 1, _ = (1 << r3.distbits) - 1;
              t:
                do {
                  p < 15 && (d += S[i++] << p, p += 8, d += S[i++] << p, p += 8), y = m[d & b];
                  e:
                    for (; ; ) {
                      if (d >>>= w = y >>> 24, p -= w, 0 == (w = y >>> 16 & 255))
                        M[a++] = 65535 & y;
                      else {
                        if (!(16 & w)) {
                          if (0 == (64 & w)) {
                            y = m[(65535 & y) + (d & (1 << w) - 1)];
                            continue e;
                          }
                          if (32 & w) {
                            r3.mode = 12;
                            break t;
                          }
                          t3.msg = "invalid literal/length code", r3.mode = 30;
                          break t;
                        }
                        v = 65535 & y, (w &= 15) && (p < w && (d += S[i++] << p, p += 8), v += d & (1 << w) - 1, d >>>= w, p -= w), p < 15 && (d += S[i++] << p, p += 8, d += S[i++] << p, p += 8), y = g[d & _];
                        r:
                          for (; ; ) {
                            if (d >>>= w = y >>> 24, p -= w, !(16 & (w = y >>> 16 & 255))) {
                              if (0 == (64 & w)) {
                                y = g[(65535 & y) + (d & (1 << w) - 1)];
                                continue r;
                              }
                              t3.msg = "invalid distance code", r3.mode = 30;
                              break t;
                            }
                            if (x = 65535 & y, p < (w &= 15) && (d += S[i++] << p, (p += 8) < w && (d += S[i++] << p, p += 8)), (x += d & (1 << w) - 1) > h) {
                              t3.msg = "invalid distance too far back", r3.mode = 30;
                              break t;
                            }
                            if (d >>>= w, p -= w, x > (w = a - o)) {
                              if ((w = x - w) > u && r3.sane) {
                                t3.msg = "invalid distance too far back", r3.mode = 30;
                                break t;
                              }
                              if (E = 0, k = c, 0 === l) {
                                if (E += f - w, w < v) {
                                  v -= w;
                                  do {
                                    M[a++] = c[E++];
                                  } while (--w);
                                  E = a - x, k = M;
                                }
                              } else if (l < w) {
                                if (E += f + l - w, (w -= l) < v) {
                                  v -= w;
                                  do {
                                    M[a++] = c[E++];
                                  } while (--w);
                                  if (E = 0, l < v) {
                                    v -= w = l;
                                    do {
                                      M[a++] = c[E++];
                                    } while (--w);
                                    E = a - x, k = M;
                                  }
                                }
                              } else if (E += l - w, w < v) {
                                v -= w;
                                do {
                                  M[a++] = c[E++];
                                } while (--w);
                                E = a - x, k = M;
                              }
                              for (; v > 2; )
                                M[a++] = k[E++], M[a++] = k[E++], M[a++] = k[E++], v -= 3;
                              v && (M[a++] = k[E++], v > 1 && (M[a++] = k[E++]));
                            } else {
                              E = a - x;
                              do {
                                M[a++] = M[E++], M[a++] = M[E++], M[a++] = M[E++], v -= 3;
                              } while (v > 2);
                              v && (M[a++] = M[E++], v > 1 && (M[a++] = M[E++]));
                            }
                            break;
                          }
                      }
                      break;
                    }
                } while (i < n && a < s);
              i -= v = p >> 3, d &= (1 << (p -= v << 3)) - 1, t3.next_in = i, t3.next_out = a, t3.avail_in = i < n ? n - i + 5 : 5 - (i - n), t3.avail_out = a < s ? s - a + 257 : 257 - (a - s), r3.hold = d, r3.bits = p;
            };
          }, {}], 55: [function(t2, e2, r2) {
            "use strict";
            var i = t2("../utils/common"), n = t2("./adler32"), a = t2("./crc32"), o = t2("./inffast"), s = t2("./inftrees"), h = 0, f = 1, u = 2, l = 4, c = 5, d = 6, p = 0, m = 1, g = 2, b = -2, _ = -3, y = -4, w = -5, v = 8, x = 1, E = 2, k = 3, S = 4, M = 5, A = 6, I = 7, T = 8, B = 9, R = 10, P = 11, O = 12, L = 13, C = 14, U = 15, D = 16, z = 17, N = 18, F = 19, j = 20, G = 21, H = 22, W = 23, q = 24, Z = 25, Y = 26, V = 27, X = 28, Q = 29, J = 30, K = 31, $ = 852, tt = 592, et = 15;
            function rt(t3) {
              return (t3 >>> 24 & 255) + (t3 >>> 8 & 65280) + ((65280 & t3) << 8) + ((255 & t3) << 24);
            }
            function it() {
              this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i.Buf16(320), this.work = new i.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function nt(t3) {
              var e3;
              return t3 && t3.state ? (e3 = t3.state, t3.total_in = t3.total_out = e3.total = 0, t3.msg = "", e3.wrap && (t3.adler = 1 & e3.wrap), e3.mode = x, e3.last = 0, e3.havedict = 0, e3.dmax = 32768, e3.head = null, e3.hold = 0, e3.bits = 0, e3.lencode = e3.lendyn = new i.Buf32($), e3.distcode = e3.distdyn = new i.Buf32(tt), e3.sane = 1, e3.back = -1, p) : b;
            }
            function at(t3) {
              var e3;
              return t3 && t3.state ? ((e3 = t3.state).wsize = 0, e3.whave = 0, e3.wnext = 0, nt(t3)) : b;
            }
            function ot(t3, e3) {
              var r3, i2;
              return t3 && t3.state ? (i2 = t3.state, e3 < 0 ? (r3 = 0, e3 = -e3) : (r3 = 1 + (e3 >> 4), e3 < 48 && (e3 &= 15)), e3 && (e3 < 8 || e3 > 15) ? b : (null !== i2.window && i2.wbits !== e3 && (i2.window = null), i2.wrap = r3, i2.wbits = e3, at(t3))) : b;
            }
            function st(t3, e3) {
              var r3, i2;
              return t3 ? (i2 = new it(), t3.state = i2, i2.window = null, (r3 = ot(t3, e3)) !== p && (t3.state = null), r3) : b;
            }
            var ht, ft, ut = true;
            function lt(t3) {
              if (ut) {
                var e3;
                for (ht = new i.Buf32(512), ft = new i.Buf32(32), e3 = 0; e3 < 144; )
                  t3.lens[e3++] = 8;
                for (; e3 < 256; )
                  t3.lens[e3++] = 9;
                for (; e3 < 280; )
                  t3.lens[e3++] = 7;
                for (; e3 < 288; )
                  t3.lens[e3++] = 8;
                for (s(f, t3.lens, 0, 288, ht, 0, t3.work, { bits: 9 }), e3 = 0; e3 < 32; )
                  t3.lens[e3++] = 5;
                s(u, t3.lens, 0, 32, ft, 0, t3.work, { bits: 5 }), ut = false;
              }
              t3.lencode = ht, t3.lenbits = 9, t3.distcode = ft, t3.distbits = 5;
            }
            function ct(t3, e3, r3, n2) {
              var a2, o2 = t3.state;
              return null === o2.window && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new i.Buf8(o2.wsize)), n2 >= o2.wsize ? (i.arraySet(o2.window, e3, r3 - o2.wsize, o2.wsize, 0), o2.wnext = 0, o2.whave = o2.wsize) : ((a2 = o2.wsize - o2.wnext) > n2 && (a2 = n2), i.arraySet(o2.window, e3, r3 - n2, a2, o2.wnext), (n2 -= a2) ? (i.arraySet(o2.window, e3, r3 - n2, n2, 0), o2.wnext = n2, o2.whave = o2.wsize) : (o2.wnext += a2, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += a2))), 0;
            }
            r2.inflateReset = at, r2.inflateReset2 = ot, r2.inflateResetKeep = nt, r2.inflateInit = function(t3) {
              return st(t3, et);
            }, r2.inflateInit2 = st, r2.inflate = function(t3, e3) {
              var r3, $2, tt2, et2, it2, nt2, at2, ot2, st2, ht2, ft2, ut2, dt, pt, mt, gt, bt, _t, yt, wt, vt, xt, Et, kt, St = 0, Mt = new i.Buf8(4), At = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
              if (!t3 || !t3.state || !t3.output || !t3.input && 0 !== t3.avail_in)
                return b;
              (r3 = t3.state).mode === O && (r3.mode = L), it2 = t3.next_out, tt2 = t3.output, at2 = t3.avail_out, et2 = t3.next_in, $2 = t3.input, nt2 = t3.avail_in, ot2 = r3.hold, st2 = r3.bits, ht2 = nt2, ft2 = at2, xt = p;
              t:
                for (; ; )
                  switch (r3.mode) {
                    case x:
                      if (0 === r3.wrap) {
                        r3.mode = L;
                        break;
                      }
                      for (; st2 < 16; ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      if (2 & r3.wrap && 35615 === ot2) {
                        r3.check = 0, Mt[0] = 255 & ot2, Mt[1] = ot2 >>> 8 & 255, r3.check = a(r3.check, Mt, 2, 0), ot2 = 0, st2 = 0, r3.mode = E;
                        break;
                      }
                      if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & ot2) << 8) + (ot2 >> 8)) % 31) {
                        t3.msg = "incorrect header check", r3.mode = J;
                        break;
                      }
                      if ((15 & ot2) !== v) {
                        t3.msg = "unknown compression method", r3.mode = J;
                        break;
                      }
                      if (st2 -= 4, vt = 8 + (15 & (ot2 >>>= 4)), 0 === r3.wbits)
                        r3.wbits = vt;
                      else if (vt > r3.wbits) {
                        t3.msg = "invalid window size", r3.mode = J;
                        break;
                      }
                      r3.dmax = 1 << vt, t3.adler = r3.check = 1, r3.mode = 512 & ot2 ? R : O, ot2 = 0, st2 = 0;
                      break;
                    case E:
                      for (; st2 < 16; ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      if (r3.flags = ot2, (255 & r3.flags) !== v) {
                        t3.msg = "unknown compression method", r3.mode = J;
                        break;
                      }
                      if (57344 & r3.flags) {
                        t3.msg = "unknown header flags set", r3.mode = J;
                        break;
                      }
                      r3.head && (r3.head.text = ot2 >> 8 & 1), 512 & r3.flags && (Mt[0] = 255 & ot2, Mt[1] = ot2 >>> 8 & 255, r3.check = a(r3.check, Mt, 2, 0)), ot2 = 0, st2 = 0, r3.mode = k;
                    case k:
                      for (; st2 < 32; ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      r3.head && (r3.head.time = ot2), 512 & r3.flags && (Mt[0] = 255 & ot2, Mt[1] = ot2 >>> 8 & 255, Mt[2] = ot2 >>> 16 & 255, Mt[3] = ot2 >>> 24 & 255, r3.check = a(r3.check, Mt, 4, 0)), ot2 = 0, st2 = 0, r3.mode = S;
                    case S:
                      for (; st2 < 16; ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      r3.head && (r3.head.xflags = 255 & ot2, r3.head.os = ot2 >> 8), 512 & r3.flags && (Mt[0] = 255 & ot2, Mt[1] = ot2 >>> 8 & 255, r3.check = a(r3.check, Mt, 2, 0)), ot2 = 0, st2 = 0, r3.mode = M;
                    case M:
                      if (1024 & r3.flags) {
                        for (; st2 < 16; ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        r3.length = ot2, r3.head && (r3.head.extra_len = ot2), 512 & r3.flags && (Mt[0] = 255 & ot2, Mt[1] = ot2 >>> 8 & 255, r3.check = a(r3.check, Mt, 2, 0)), ot2 = 0, st2 = 0;
                      } else
                        r3.head && (r3.head.extra = null);
                      r3.mode = A;
                    case A:
                      if (1024 & r3.flags && ((ut2 = r3.length) > nt2 && (ut2 = nt2), ut2 && (r3.head && (vt = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), i.arraySet(r3.head.extra, $2, et2, ut2, vt)), 512 & r3.flags && (r3.check = a(r3.check, $2, ut2, et2)), nt2 -= ut2, et2 += ut2, r3.length -= ut2), r3.length))
                        break t;
                      r3.length = 0, r3.mode = I;
                    case I:
                      if (2048 & r3.flags) {
                        if (0 === nt2)
                          break t;
                        ut2 = 0;
                        do {
                          vt = $2[et2 + ut2++], r3.head && vt && r3.length < 65536 && (r3.head.name += String.fromCharCode(vt));
                        } while (vt && ut2 < nt2);
                        if (512 & r3.flags && (r3.check = a(r3.check, $2, ut2, et2)), nt2 -= ut2, et2 += ut2, vt)
                          break t;
                      } else
                        r3.head && (r3.head.name = null);
                      r3.length = 0, r3.mode = T;
                    case T:
                      if (4096 & r3.flags) {
                        if (0 === nt2)
                          break t;
                        ut2 = 0;
                        do {
                          vt = $2[et2 + ut2++], r3.head && vt && r3.length < 65536 && (r3.head.comment += String.fromCharCode(vt));
                        } while (vt && ut2 < nt2);
                        if (512 & r3.flags && (r3.check = a(r3.check, $2, ut2, et2)), nt2 -= ut2, et2 += ut2, vt)
                          break t;
                      } else
                        r3.head && (r3.head.comment = null);
                      r3.mode = B;
                    case B:
                      if (512 & r3.flags) {
                        for (; st2 < 16; ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        if (ot2 !== (65535 & r3.check)) {
                          t3.msg = "header crc mismatch", r3.mode = J;
                          break;
                        }
                        ot2 = 0, st2 = 0;
                      }
                      r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), t3.adler = r3.check = 0, r3.mode = O;
                      break;
                    case R:
                      for (; st2 < 32; ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      t3.adler = r3.check = rt(ot2), ot2 = 0, st2 = 0, r3.mode = P;
                    case P:
                      if (0 === r3.havedict)
                        return t3.next_out = it2, t3.avail_out = at2, t3.next_in = et2, t3.avail_in = nt2, r3.hold = ot2, r3.bits = st2, g;
                      t3.adler = r3.check = 1, r3.mode = O;
                    case O:
                      if (e3 === c || e3 === d)
                        break t;
                    case L:
                      if (r3.last) {
                        ot2 >>>= 7 & st2, st2 -= 7 & st2, r3.mode = V;
                        break;
                      }
                      for (; st2 < 3; ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      switch (r3.last = 1 & ot2, st2 -= 1, 3 & (ot2 >>>= 1)) {
                        case 0:
                          r3.mode = C;
                          break;
                        case 1:
                          if (lt(r3), r3.mode = j, e3 === d) {
                            ot2 >>>= 2, st2 -= 2;
                            break t;
                          }
                          break;
                        case 2:
                          r3.mode = z;
                          break;
                        case 3:
                          t3.msg = "invalid block type", r3.mode = J;
                      }
                      ot2 >>>= 2, st2 -= 2;
                      break;
                    case C:
                      for (ot2 >>>= 7 & st2, st2 -= 7 & st2; st2 < 32; ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      if ((65535 & ot2) != (ot2 >>> 16 ^ 65535)) {
                        t3.msg = "invalid stored block lengths", r3.mode = J;
                        break;
                      }
                      if (r3.length = 65535 & ot2, ot2 = 0, st2 = 0, r3.mode = U, e3 === d)
                        break t;
                    case U:
                      r3.mode = D;
                    case D:
                      if (ut2 = r3.length) {
                        if (ut2 > nt2 && (ut2 = nt2), ut2 > at2 && (ut2 = at2), 0 === ut2)
                          break t;
                        i.arraySet(tt2, $2, et2, ut2, it2), nt2 -= ut2, et2 += ut2, at2 -= ut2, it2 += ut2, r3.length -= ut2;
                        break;
                      }
                      r3.mode = O;
                      break;
                    case z:
                      for (; st2 < 14; ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      if (r3.nlen = 257 + (31 & ot2), ot2 >>>= 5, st2 -= 5, r3.ndist = 1 + (31 & ot2), ot2 >>>= 5, st2 -= 5, r3.ncode = 4 + (15 & ot2), ot2 >>>= 4, st2 -= 4, r3.nlen > 286 || r3.ndist > 30) {
                        t3.msg = "too many length or distance symbols", r3.mode = J;
                        break;
                      }
                      r3.have = 0, r3.mode = N;
                    case N:
                      for (; r3.have < r3.ncode; ) {
                        for (; st2 < 3; ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        r3.lens[At[r3.have++]] = 7 & ot2, ot2 >>>= 3, st2 -= 3;
                      }
                      for (; r3.have < 19; )
                        r3.lens[At[r3.have++]] = 0;
                      if (r3.lencode = r3.lendyn, r3.lenbits = 7, Et = { bits: r3.lenbits }, xt = s(h, r3.lens, 0, 19, r3.lencode, 0, r3.work, Et), r3.lenbits = Et.bits, xt) {
                        t3.msg = "invalid code lengths set", r3.mode = J;
                        break;
                      }
                      r3.have = 0, r3.mode = F;
                    case F:
                      for (; r3.have < r3.nlen + r3.ndist; ) {
                        for (; gt = (St = r3.lencode[ot2 & (1 << r3.lenbits) - 1]) >>> 16 & 255, bt = 65535 & St, !((mt = St >>> 24) <= st2); ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        if (bt < 16)
                          ot2 >>>= mt, st2 -= mt, r3.lens[r3.have++] = bt;
                        else {
                          if (16 === bt) {
                            for (kt = mt + 2; st2 < kt; ) {
                              if (0 === nt2)
                                break t;
                              nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                            }
                            if (ot2 >>>= mt, st2 -= mt, 0 === r3.have) {
                              t3.msg = "invalid bit length repeat", r3.mode = J;
                              break;
                            }
                            vt = r3.lens[r3.have - 1], ut2 = 3 + (3 & ot2), ot2 >>>= 2, st2 -= 2;
                          } else if (17 === bt) {
                            for (kt = mt + 3; st2 < kt; ) {
                              if (0 === nt2)
                                break t;
                              nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                            }
                            st2 -= mt, vt = 0, ut2 = 3 + (7 & (ot2 >>>= mt)), ot2 >>>= 3, st2 -= 3;
                          } else {
                            for (kt = mt + 7; st2 < kt; ) {
                              if (0 === nt2)
                                break t;
                              nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                            }
                            st2 -= mt, vt = 0, ut2 = 11 + (127 & (ot2 >>>= mt)), ot2 >>>= 7, st2 -= 7;
                          }
                          if (r3.have + ut2 > r3.nlen + r3.ndist) {
                            t3.msg = "invalid bit length repeat", r3.mode = J;
                            break;
                          }
                          for (; ut2--; )
                            r3.lens[r3.have++] = vt;
                        }
                      }
                      if (r3.mode === J)
                        break;
                      if (0 === r3.lens[256]) {
                        t3.msg = "invalid code -- missing end-of-block", r3.mode = J;
                        break;
                      }
                      if (r3.lenbits = 9, Et = { bits: r3.lenbits }, xt = s(f, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, Et), r3.lenbits = Et.bits, xt) {
                        t3.msg = "invalid literal/lengths set", r3.mode = J;
                        break;
                      }
                      if (r3.distbits = 6, r3.distcode = r3.distdyn, Et = { bits: r3.distbits }, xt = s(u, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, Et), r3.distbits = Et.bits, xt) {
                        t3.msg = "invalid distances set", r3.mode = J;
                        break;
                      }
                      if (r3.mode = j, e3 === d)
                        break t;
                    case j:
                      r3.mode = G;
                    case G:
                      if (nt2 >= 6 && at2 >= 258) {
                        t3.next_out = it2, t3.avail_out = at2, t3.next_in = et2, t3.avail_in = nt2, r3.hold = ot2, r3.bits = st2, o(t3, ft2), it2 = t3.next_out, tt2 = t3.output, at2 = t3.avail_out, et2 = t3.next_in, $2 = t3.input, nt2 = t3.avail_in, ot2 = r3.hold, st2 = r3.bits, r3.mode === O && (r3.back = -1);
                        break;
                      }
                      for (r3.back = 0; gt = (St = r3.lencode[ot2 & (1 << r3.lenbits) - 1]) >>> 16 & 255, bt = 65535 & St, !((mt = St >>> 24) <= st2); ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      if (gt && 0 == (240 & gt)) {
                        for (_t = mt, yt = gt, wt = bt; gt = (St = r3.lencode[wt + ((ot2 & (1 << _t + yt) - 1) >> _t)]) >>> 16 & 255, bt = 65535 & St, !(_t + (mt = St >>> 24) <= st2); ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        ot2 >>>= _t, st2 -= _t, r3.back += _t;
                      }
                      if (ot2 >>>= mt, st2 -= mt, r3.back += mt, r3.length = bt, 0 === gt) {
                        r3.mode = Y;
                        break;
                      }
                      if (32 & gt) {
                        r3.back = -1, r3.mode = O;
                        break;
                      }
                      if (64 & gt) {
                        t3.msg = "invalid literal/length code", r3.mode = J;
                        break;
                      }
                      r3.extra = 15 & gt, r3.mode = H;
                    case H:
                      if (r3.extra) {
                        for (kt = r3.extra; st2 < kt; ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        r3.length += ot2 & (1 << r3.extra) - 1, ot2 >>>= r3.extra, st2 -= r3.extra, r3.back += r3.extra;
                      }
                      r3.was = r3.length, r3.mode = W;
                    case W:
                      for (; gt = (St = r3.distcode[ot2 & (1 << r3.distbits) - 1]) >>> 16 & 255, bt = 65535 & St, !((mt = St >>> 24) <= st2); ) {
                        if (0 === nt2)
                          break t;
                        nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                      }
                      if (0 == (240 & gt)) {
                        for (_t = mt, yt = gt, wt = bt; gt = (St = r3.distcode[wt + ((ot2 & (1 << _t + yt) - 1) >> _t)]) >>> 16 & 255, bt = 65535 & St, !(_t + (mt = St >>> 24) <= st2); ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        ot2 >>>= _t, st2 -= _t, r3.back += _t;
                      }
                      if (ot2 >>>= mt, st2 -= mt, r3.back += mt, 64 & gt) {
                        t3.msg = "invalid distance code", r3.mode = J;
                        break;
                      }
                      r3.offset = bt, r3.extra = 15 & gt, r3.mode = q;
                    case q:
                      if (r3.extra) {
                        for (kt = r3.extra; st2 < kt; ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        r3.offset += ot2 & (1 << r3.extra) - 1, ot2 >>>= r3.extra, st2 -= r3.extra, r3.back += r3.extra;
                      }
                      if (r3.offset > r3.dmax) {
                        t3.msg = "invalid distance too far back", r3.mode = J;
                        break;
                      }
                      r3.mode = Z;
                    case Z:
                      if (0 === at2)
                        break t;
                      if (ut2 = ft2 - at2, r3.offset > ut2) {
                        if ((ut2 = r3.offset - ut2) > r3.whave && r3.sane) {
                          t3.msg = "invalid distance too far back", r3.mode = J;
                          break;
                        }
                        ut2 > r3.wnext ? (ut2 -= r3.wnext, dt = r3.wsize - ut2) : dt = r3.wnext - ut2, ut2 > r3.length && (ut2 = r3.length), pt = r3.window;
                      } else
                        pt = tt2, dt = it2 - r3.offset, ut2 = r3.length;
                      ut2 > at2 && (ut2 = at2), at2 -= ut2, r3.length -= ut2;
                      do {
                        tt2[it2++] = pt[dt++];
                      } while (--ut2);
                      0 === r3.length && (r3.mode = G);
                      break;
                    case Y:
                      if (0 === at2)
                        break t;
                      tt2[it2++] = r3.length, at2--, r3.mode = G;
                      break;
                    case V:
                      if (r3.wrap) {
                        for (; st2 < 32; ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 |= $2[et2++] << st2, st2 += 8;
                        }
                        if (ft2 -= at2, t3.total_out += ft2, r3.total += ft2, ft2 && (t3.adler = r3.check = r3.flags ? a(r3.check, tt2, ft2, it2 - ft2) : n(r3.check, tt2, ft2, it2 - ft2)), ft2 = at2, (r3.flags ? ot2 : rt(ot2)) !== r3.check) {
                          t3.msg = "incorrect data check", r3.mode = J;
                          break;
                        }
                        ot2 = 0, st2 = 0;
                      }
                      r3.mode = X;
                    case X:
                      if (r3.wrap && r3.flags) {
                        for (; st2 < 32; ) {
                          if (0 === nt2)
                            break t;
                          nt2--, ot2 += $2[et2++] << st2, st2 += 8;
                        }
                        if (ot2 !== (4294967295 & r3.total)) {
                          t3.msg = "incorrect length check", r3.mode = J;
                          break;
                        }
                        ot2 = 0, st2 = 0;
                      }
                      r3.mode = Q;
                    case Q:
                      xt = m;
                      break t;
                    case J:
                      xt = _;
                      break t;
                    case K:
                      return y;
                    default:
                      return b;
                  }
              return t3.next_out = it2, t3.avail_out = at2, t3.next_in = et2, t3.avail_in = nt2, r3.hold = ot2, r3.bits = st2, (r3.wsize || ft2 !== t3.avail_out && r3.mode < J && (r3.mode < V || e3 !== l)) && ct(t3, t3.output, t3.next_out, ft2 - t3.avail_out) ? (r3.mode = K, y) : (ht2 -= t3.avail_in, ft2 -= t3.avail_out, t3.total_in += ht2, t3.total_out += ft2, r3.total += ft2, r3.wrap && ft2 && (t3.adler = r3.check = r3.flags ? a(r3.check, tt2, ft2, t3.next_out - ft2) : n(r3.check, tt2, ft2, t3.next_out - ft2)), t3.data_type = r3.bits + (r3.last ? 64 : 0) + (r3.mode === O ? 128 : 0) + (r3.mode === j || r3.mode === U ? 256 : 0), (0 === ht2 && 0 === ft2 || e3 === l) && xt === p && (xt = w), xt);
            }, r2.inflateEnd = function(t3) {
              if (!t3 || !t3.state)
                return b;
              var e3 = t3.state;
              return e3.window && (e3.window = null), t3.state = null, p;
            }, r2.inflateGetHeader = function(t3, e3) {
              var r3;
              return t3 && t3.state ? 0 == (2 & (r3 = t3.state).wrap) ? b : (r3.head = e3, e3.done = false, p) : b;
            }, r2.inflateSetDictionary = function(t3, e3) {
              var r3, i2 = e3.length;
              return t3 && t3.state ? 0 !== (r3 = t3.state).wrap && r3.mode !== P ? b : r3.mode === P && n(1, e3, i2, 0) !== r3.check ? _ : ct(t3, e3, i2, i2) ? (r3.mode = K, y) : (r3.havedict = 1, p) : b;
            }, r2.inflateInfo = "pako inflate (from Nodeca project)";
          }, { "../utils/common": 49, "./adler32": 50, "./crc32": 52, "./inffast": 54, "./inftrees": 56 }], 56: [function(t2, e2, r2) {
            "use strict";
            var i = t2("../utils/common"), n = 15, a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], h = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
            e2.exports = function(t3, e3, r3, f, u, l, c, d) {
              var p, m, g, b, _, y, w, v, x, E = d.bits, k = 0, S = 0, M = 0, A = 0, I = 0, T = 0, B = 0, R = 0, P = 0, O = 0, L = null, C = 0, U = new i.Buf16(16), D = new i.Buf16(16), z = null, N = 0;
              for (k = 0; k <= n; k++)
                U[k] = 0;
              for (S = 0; S < f; S++)
                U[e3[r3 + S]]++;
              for (I = E, A = n; A >= 1 && 0 === U[A]; A--)
                ;
              if (I > A && (I = A), 0 === A)
                return u[l++] = 20971520, u[l++] = 20971520, d.bits = 1, 0;
              for (M = 1; M < A && 0 === U[M]; M++)
                ;
              for (I < M && (I = M), R = 1, k = 1; k <= n; k++)
                if (R <<= 1, (R -= U[k]) < 0)
                  return -1;
              if (R > 0 && (0 === t3 || 1 !== A))
                return -1;
              for (D[1] = 0, k = 1; k < n; k++)
                D[k + 1] = D[k] + U[k];
              for (S = 0; S < f; S++)
                0 !== e3[r3 + S] && (c[D[e3[r3 + S]]++] = S);
              if (0 === t3 ? (L = z = c, y = 19) : 1 === t3 ? (L = a, C -= 257, z = o, N -= 257, y = 256) : (L = s, z = h, y = -1), O = 0, S = 0, k = M, _ = l, T = I, B = 0, g = -1, b = (P = 1 << I) - 1, 1 === t3 && P > 852 || 2 === t3 && P > 592)
                return 1;
              for (; ; ) {
                w = k - B, c[S] < y ? (v = 0, x = c[S]) : c[S] > y ? (v = z[N + c[S]], x = L[C + c[S]]) : (v = 96, x = 0), p = 1 << k - B, M = m = 1 << T;
                do {
                  u[_ + (O >> B) + (m -= p)] = w << 24 | v << 16 | x | 0;
                } while (0 !== m);
                for (p = 1 << k - 1; O & p; )
                  p >>= 1;
                if (0 !== p ? (O &= p - 1, O += p) : O = 0, S++, 0 == --U[k]) {
                  if (k === A)
                    break;
                  k = e3[r3 + c[S]];
                }
                if (k > I && (O & b) !== g) {
                  for (0 === B && (B = I), _ += M, R = 1 << (T = k - B); T + B < A && !((R -= U[T + B]) <= 0); )
                    T++, R <<= 1;
                  if (P += 1 << T, 1 === t3 && P > 852 || 2 === t3 && P > 592)
                    return 1;
                  u[g = O & b] = I << 24 | T << 16 | _ - l | 0;
                }
              }
              return 0 !== O && (u[_ + O] = k - B << 24 | 64 << 16 | 0), d.bits = I, 0;
            };
          }, { "../utils/common": 49 }], 57: [function(t2, e2, r2) {
            "use strict";
            e2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
          }, {}], 58: [function(t2, e2, r2) {
            "use strict";
            var i = t2("../utils/common"), n = 4, a = 0, o = 1, s = 2;
            function h(t3) {
              for (var e3 = t3.length; --e3 >= 0; )
                t3[e3] = 0;
            }
            var f = 0, u = 1, l = 2, c = 29, d = 256, p = d + 1 + c, m = 30, g = 19, b = 2 * p + 1, _ = 15, y = 16, w = 7, v = 256, x = 16, E = 17, k = 18, S = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], M = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], A = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], I = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], T = new Array(2 * (p + 2));
            h(T);
            var B = new Array(2 * m);
            h(B);
            var R = new Array(512);
            h(R);
            var P = new Array(256);
            h(P);
            var O = new Array(c);
            h(O);
            var L, C, U, D = new Array(m);
            function z(t3, e3, r3, i2, n2) {
              this.static_tree = t3, this.extra_bits = e3, this.extra_base = r3, this.elems = i2, this.max_length = n2, this.has_stree = t3 && t3.length;
            }
            function N(t3, e3) {
              this.dyn_tree = t3, this.max_code = 0, this.stat_desc = e3;
            }
            function F(t3) {
              return t3 < 256 ? R[t3] : R[256 + (t3 >>> 7)];
            }
            function j(t3, e3) {
              t3.pending_buf[t3.pending++] = 255 & e3, t3.pending_buf[t3.pending++] = e3 >>> 8 & 255;
            }
            function G(t3, e3, r3) {
              t3.bi_valid > y - r3 ? (t3.bi_buf |= e3 << t3.bi_valid & 65535, j(t3, t3.bi_buf), t3.bi_buf = e3 >> y - t3.bi_valid, t3.bi_valid += r3 - y) : (t3.bi_buf |= e3 << t3.bi_valid & 65535, t3.bi_valid += r3);
            }
            function H(t3, e3, r3) {
              G(t3, r3[2 * e3], r3[2 * e3 + 1]);
            }
            function W(t3, e3) {
              var r3 = 0;
              do {
                r3 |= 1 & t3, t3 >>>= 1, r3 <<= 1;
              } while (--e3 > 0);
              return r3 >>> 1;
            }
            function q(t3, e3, r3) {
              var i2, n2, a2 = new Array(_ + 1), o2 = 0;
              for (i2 = 1; i2 <= _; i2++)
                a2[i2] = o2 = o2 + r3[i2 - 1] << 1;
              for (n2 = 0; n2 <= e3; n2++) {
                var s2 = t3[2 * n2 + 1];
                0 !== s2 && (t3[2 * n2] = W(a2[s2]++, s2));
              }
            }
            function Z(t3) {
              var e3;
              for (e3 = 0; e3 < p; e3++)
                t3.dyn_ltree[2 * e3] = 0;
              for (e3 = 0; e3 < m; e3++)
                t3.dyn_dtree[2 * e3] = 0;
              for (e3 = 0; e3 < g; e3++)
                t3.bl_tree[2 * e3] = 0;
              t3.dyn_ltree[2 * v] = 1, t3.opt_len = t3.static_len = 0, t3.last_lit = t3.matches = 0;
            }
            function Y(t3) {
              t3.bi_valid > 8 ? j(t3, t3.bi_buf) : t3.bi_valid > 0 && (t3.pending_buf[t3.pending++] = t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0;
            }
            function V(t3, e3, r3, i2) {
              var n2 = 2 * e3, a2 = 2 * r3;
              return t3[n2] < t3[a2] || t3[n2] === t3[a2] && i2[e3] <= i2[r3];
            }
            function X(t3, e3, r3) {
              for (var i2 = t3.heap[r3], n2 = r3 << 1; n2 <= t3.heap_len && (n2 < t3.heap_len && V(e3, t3.heap[n2 + 1], t3.heap[n2], t3.depth) && n2++, !V(e3, i2, t3.heap[n2], t3.depth)); )
                t3.heap[r3] = t3.heap[n2], r3 = n2, n2 <<= 1;
              t3.heap[r3] = i2;
            }
            function Q(t3, e3, r3) {
              var i2, n2, a2, o2, s2 = 0;
              if (0 !== t3.last_lit)
                do {
                  i2 = t3.pending_buf[t3.d_buf + 2 * s2] << 8 | t3.pending_buf[t3.d_buf + 2 * s2 + 1], n2 = t3.pending_buf[t3.l_buf + s2], s2++, 0 === i2 ? H(t3, n2, e3) : (H(t3, (a2 = P[n2]) + d + 1, e3), 0 !== (o2 = S[a2]) && G(t3, n2 -= O[a2], o2), H(t3, a2 = F(--i2), r3), 0 !== (o2 = M[a2]) && G(t3, i2 -= D[a2], o2));
                } while (s2 < t3.last_lit);
              H(t3, v, e3);
            }
            function J(t3, e3) {
              var r3, i2, n2, a2 = e3.dyn_tree, o2 = e3.stat_desc.static_tree, s2 = e3.stat_desc.has_stree, h2 = e3.stat_desc.elems, f2 = -1;
              for (t3.heap_len = 0, t3.heap_max = b, r3 = 0; r3 < h2; r3++)
                0 !== a2[2 * r3] ? (t3.heap[++t3.heap_len] = f2 = r3, t3.depth[r3] = 0) : a2[2 * r3 + 1] = 0;
              for (; t3.heap_len < 2; )
                a2[2 * (n2 = t3.heap[++t3.heap_len] = f2 < 2 ? ++f2 : 0)] = 1, t3.depth[n2] = 0, t3.opt_len--, s2 && (t3.static_len -= o2[2 * n2 + 1]);
              for (e3.max_code = f2, r3 = t3.heap_len >> 1; r3 >= 1; r3--)
                X(t3, a2, r3);
              n2 = h2;
              do {
                r3 = t3.heap[1], t3.heap[1] = t3.heap[t3.heap_len--], X(t3, a2, 1), i2 = t3.heap[1], t3.heap[--t3.heap_max] = r3, t3.heap[--t3.heap_max] = i2, a2[2 * n2] = a2[2 * r3] + a2[2 * i2], t3.depth[n2] = (t3.depth[r3] >= t3.depth[i2] ? t3.depth[r3] : t3.depth[i2]) + 1, a2[2 * r3 + 1] = a2[2 * i2 + 1] = n2, t3.heap[1] = n2++, X(t3, a2, 1);
              } while (t3.heap_len >= 2);
              t3.heap[--t3.heap_max] = t3.heap[1], function(t4, e4) {
                var r4, i3, n3, a3, o3, s3, h3 = e4.dyn_tree, f3 = e4.max_code, u2 = e4.stat_desc.static_tree, l2 = e4.stat_desc.has_stree, c2 = e4.stat_desc.extra_bits, d2 = e4.stat_desc.extra_base, p2 = e4.stat_desc.max_length, m2 = 0;
                for (a3 = 0; a3 <= _; a3++)
                  t4.bl_count[a3] = 0;
                for (h3[2 * t4.heap[t4.heap_max] + 1] = 0, r4 = t4.heap_max + 1; r4 < b; r4++)
                  (a3 = h3[2 * h3[2 * (i3 = t4.heap[r4]) + 1] + 1] + 1) > p2 && (a3 = p2, m2++), h3[2 * i3 + 1] = a3, i3 > f3 || (t4.bl_count[a3]++, o3 = 0, i3 >= d2 && (o3 = c2[i3 - d2]), s3 = h3[2 * i3], t4.opt_len += s3 * (a3 + o3), l2 && (t4.static_len += s3 * (u2[2 * i3 + 1] + o3)));
                if (0 !== m2) {
                  do {
                    for (a3 = p2 - 1; 0 === t4.bl_count[a3]; )
                      a3--;
                    t4.bl_count[a3]--, t4.bl_count[a3 + 1] += 2, t4.bl_count[p2]--, m2 -= 2;
                  } while (m2 > 0);
                  for (a3 = p2; 0 !== a3; a3--)
                    for (i3 = t4.bl_count[a3]; 0 !== i3; )
                      (n3 = t4.heap[--r4]) > f3 || (h3[2 * n3 + 1] !== a3 && (t4.opt_len += (a3 - h3[2 * n3 + 1]) * h3[2 * n3], h3[2 * n3 + 1] = a3), i3--);
                }
              }(t3, e3), q(a2, f2, t3.bl_count);
            }
            function K(t3, e3, r3) {
              var i2, n2, a2 = -1, o2 = e3[1], s2 = 0, h2 = 7, f2 = 4;
              for (0 === o2 && (h2 = 138, f2 = 3), e3[2 * (r3 + 1) + 1] = 65535, i2 = 0; i2 <= r3; i2++)
                n2 = o2, o2 = e3[2 * (i2 + 1) + 1], ++s2 < h2 && n2 === o2 || (s2 < f2 ? t3.bl_tree[2 * n2] += s2 : 0 !== n2 ? (n2 !== a2 && t3.bl_tree[2 * n2]++, t3.bl_tree[2 * x]++) : s2 <= 10 ? t3.bl_tree[2 * E]++ : t3.bl_tree[2 * k]++, s2 = 0, a2 = n2, 0 === o2 ? (h2 = 138, f2 = 3) : n2 === o2 ? (h2 = 6, f2 = 3) : (h2 = 7, f2 = 4));
            }
            function $(t3, e3, r3) {
              var i2, n2, a2 = -1, o2 = e3[1], s2 = 0, h2 = 7, f2 = 4;
              for (0 === o2 && (h2 = 138, f2 = 3), i2 = 0; i2 <= r3; i2++)
                if (n2 = o2, o2 = e3[2 * (i2 + 1) + 1], !(++s2 < h2 && n2 === o2)) {
                  if (s2 < f2)
                    do {
                      H(t3, n2, t3.bl_tree);
                    } while (0 != --s2);
                  else
                    0 !== n2 ? (n2 !== a2 && (H(t3, n2, t3.bl_tree), s2--), H(t3, x, t3.bl_tree), G(t3, s2 - 3, 2)) : s2 <= 10 ? (H(t3, E, t3.bl_tree), G(t3, s2 - 3, 3)) : (H(t3, k, t3.bl_tree), G(t3, s2 - 11, 7));
                  s2 = 0, a2 = n2, 0 === o2 ? (h2 = 138, f2 = 3) : n2 === o2 ? (h2 = 6, f2 = 3) : (h2 = 7, f2 = 4);
                }
            }
            h(D);
            var tt = false;
            function et(t3, e3, r3, n2) {
              G(t3, (f << 1) + (n2 ? 1 : 0), 3), function(t4, e4, r4, n3) {
                Y(t4), n3 && (j(t4, r4), j(t4, ~r4)), i.arraySet(t4.pending_buf, t4.window, e4, r4, t4.pending), t4.pending += r4;
              }(t3, e3, r3, true);
            }
            r2._tr_init = function(t3) {
              tt || (function() {
                var t4, e3, r3, i2, n2, a2 = new Array(_ + 1);
                for (r3 = 0, i2 = 0; i2 < c - 1; i2++)
                  for (O[i2] = r3, t4 = 0; t4 < 1 << S[i2]; t4++)
                    P[r3++] = i2;
                for (P[r3 - 1] = i2, n2 = 0, i2 = 0; i2 < 16; i2++)
                  for (D[i2] = n2, t4 = 0; t4 < 1 << M[i2]; t4++)
                    R[n2++] = i2;
                for (n2 >>= 7; i2 < m; i2++)
                  for (D[i2] = n2 << 7, t4 = 0; t4 < 1 << M[i2] - 7; t4++)
                    R[256 + n2++] = i2;
                for (e3 = 0; e3 <= _; e3++)
                  a2[e3] = 0;
                for (t4 = 0; t4 <= 143; )
                  T[2 * t4 + 1] = 8, t4++, a2[8]++;
                for (; t4 <= 255; )
                  T[2 * t4 + 1] = 9, t4++, a2[9]++;
                for (; t4 <= 279; )
                  T[2 * t4 + 1] = 7, t4++, a2[7]++;
                for (; t4 <= 287; )
                  T[2 * t4 + 1] = 8, t4++, a2[8]++;
                for (q(T, p + 1, a2), t4 = 0; t4 < m; t4++)
                  B[2 * t4 + 1] = 5, B[2 * t4] = W(t4, 5);
                L = new z(T, S, d + 1, p, _), C = new z(B, M, 0, m, _), U = new z(new Array(0), A, 0, g, w);
              }(), tt = true), t3.l_desc = new N(t3.dyn_ltree, L), t3.d_desc = new N(t3.dyn_dtree, C), t3.bl_desc = new N(t3.bl_tree, U), t3.bi_buf = 0, t3.bi_valid = 0, Z(t3);
            }, r2._tr_stored_block = et, r2._tr_flush_block = function(t3, e3, r3, i2) {
              var h2, f2, c2 = 0;
              t3.level > 0 ? (t3.strm.data_type === s && (t3.strm.data_type = function(t4) {
                var e4, r4 = 4093624447;
                for (e4 = 0; e4 <= 31; e4++, r4 >>>= 1)
                  if (1 & r4 && 0 !== t4.dyn_ltree[2 * e4])
                    return a;
                if (0 !== t4.dyn_ltree[18] || 0 !== t4.dyn_ltree[20] || 0 !== t4.dyn_ltree[26])
                  return o;
                for (e4 = 32; e4 < d; e4++)
                  if (0 !== t4.dyn_ltree[2 * e4])
                    return o;
                return a;
              }(t3)), J(t3, t3.l_desc), J(t3, t3.d_desc), c2 = function(t4) {
                var e4;
                for (K(t4, t4.dyn_ltree, t4.l_desc.max_code), K(t4, t4.dyn_dtree, t4.d_desc.max_code), J(t4, t4.bl_desc), e4 = g - 1; e4 >= 3 && 0 === t4.bl_tree[2 * I[e4] + 1]; e4--)
                  ;
                return t4.opt_len += 3 * (e4 + 1) + 5 + 5 + 4, e4;
              }(t3), h2 = t3.opt_len + 3 + 7 >>> 3, (f2 = t3.static_len + 3 + 7 >>> 3) <= h2 && (h2 = f2)) : h2 = f2 = r3 + 5, r3 + 4 <= h2 && -1 !== e3 ? et(t3, e3, r3, i2) : t3.strategy === n || f2 === h2 ? (G(t3, (u << 1) + (i2 ? 1 : 0), 3), Q(t3, T, B)) : (G(t3, (l << 1) + (i2 ? 1 : 0), 3), function(t4, e4, r4, i3) {
                var n2;
                for (G(t4, e4 - 257, 5), G(t4, r4 - 1, 5), G(t4, i3 - 4, 4), n2 = 0; n2 < i3; n2++)
                  G(t4, t4.bl_tree[2 * I[n2] + 1], 3);
                $(t4, t4.dyn_ltree, e4 - 1), $(t4, t4.dyn_dtree, r4 - 1);
              }(t3, t3.l_desc.max_code + 1, t3.d_desc.max_code + 1, c2 + 1), Q(t3, t3.dyn_ltree, t3.dyn_dtree)), Z(t3), i2 && Y(t3);
            }, r2._tr_tally = function(t3, e3, r3) {
              return t3.pending_buf[t3.d_buf + 2 * t3.last_lit] = e3 >>> 8 & 255, t3.pending_buf[t3.d_buf + 2 * t3.last_lit + 1] = 255 & e3, t3.pending_buf[t3.l_buf + t3.last_lit] = 255 & r3, t3.last_lit++, 0 === e3 ? t3.dyn_ltree[2 * r3]++ : (t3.matches++, e3--, t3.dyn_ltree[2 * (P[r3] + d + 1)]++, t3.dyn_dtree[2 * F(e3)]++), t3.last_lit === t3.lit_bufsize - 1;
            }, r2._tr_align = function(t3) {
              G(t3, u << 1, 3), H(t3, v, T), function(t4) {
                16 === t4.bi_valid ? (j(t4, t4.bi_buf), t4.bi_buf = 0, t4.bi_valid = 0) : t4.bi_valid >= 8 && (t4.pending_buf[t4.pending++] = 255 & t4.bi_buf, t4.bi_buf >>= 8, t4.bi_valid -= 8);
              }(t3);
            };
          }, { "../utils/common": 49 }], 59: [function(t2, e2, r2) {
            "use strict";
            e2.exports = function() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            };
          }, {}], 60: [function(t2, e2, r2) {
            var i, n, a = e2.exports = {};
            function o() {
              throw new Error("setTimeout has not been defined");
            }
            function s() {
              throw new Error("clearTimeout has not been defined");
            }
            function h(t3) {
              if (i === setTimeout)
                return setTimeout(t3, 0);
              if ((i === o || !i) && setTimeout)
                return i = setTimeout, setTimeout(t3, 0);
              try {
                return i(t3, 0);
              } catch (e3) {
                try {
                  return i.call(null, t3, 0);
                } catch (e4) {
                  return i.call(this, t3, 0);
                }
              }
            }
            !function() {
              try {
                i = "function" == typeof setTimeout ? setTimeout : o;
              } catch (t3) {
                i = o;
              }
              try {
                n = "function" == typeof clearTimeout ? clearTimeout : s;
              } catch (t3) {
                n = s;
              }
            }();
            var f, u = [], l = false, c = -1;
            function d() {
              l && f && (l = false, f.length ? u = f.concat(u) : c = -1, u.length && p());
            }
            function p() {
              if (!l) {
                var t3 = h(d);
                l = true;
                for (var e3 = u.length; e3; ) {
                  for (f = u, u = []; ++c < e3; )
                    f && f[c].run();
                  c = -1, e3 = u.length;
                }
                f = null, l = false, function(t4) {
                  if (n === clearTimeout)
                    return clearTimeout(t4);
                  if ((n === s || !n) && clearTimeout)
                    return n = clearTimeout, clearTimeout(t4);
                  try {
                    n(t4);
                  } catch (e4) {
                    try {
                      return n.call(null, t4);
                    } catch (e5) {
                      return n.call(this, t4);
                    }
                  }
                }(t3);
              }
            }
            function m(t3, e3) {
              this.fun = t3, this.array = e3;
            }
            function g() {
            }
            a.nextTick = function(t3) {
              var e3 = new Array(arguments.length - 1);
              if (arguments.length > 1)
                for (var r3 = 1; r3 < arguments.length; r3++)
                  e3[r3 - 1] = arguments[r3];
              u.push(new m(t3, e3)), 1 !== u.length || l || h(p);
            }, m.prototype.run = function() {
              this.fun.apply(null, this.array);
            }, a.title = "browser", a.browser = true, a.env = {}, a.argv = [], a.version = "", a.versions = {}, a.on = g, a.addListener = g, a.once = g, a.off = g, a.removeListener = g, a.removeAllListeners = g, a.emit = g, a.prependListener = g, a.prependOnceListener = g, a.listeners = function(t3) {
              return [];
            }, a.binding = function(t3) {
              throw new Error("process.binding is not supported");
            }, a.cwd = function() {
              return "/";
            }, a.chdir = function(t3) {
              throw new Error("process.chdir is not supported");
            }, a.umask = function() {
              return 0;
            };
          }, {}], 61: [function(t2, e2, r2) {
            e2.exports = n;
            var i = t2("events").EventEmitter;
            function n() {
              i.call(this);
            }
            t2("inherits")(n, i), n.Readable = t2("readable-stream/lib/_stream_readable.js"), n.Writable = t2("readable-stream/lib/_stream_writable.js"), n.Duplex = t2("readable-stream/lib/_stream_duplex.js"), n.Transform = t2("readable-stream/lib/_stream_transform.js"), n.PassThrough = t2("readable-stream/lib/_stream_passthrough.js"), n.finished = t2("readable-stream/lib/internal/streams/end-of-stream.js"), n.pipeline = t2("readable-stream/lib/internal/streams/pipeline.js"), n.Stream = n, n.prototype.pipe = function(t3, e3) {
              var r3 = this;
              function n2(e4) {
                t3.writable && false === t3.write(e4) && r3.pause && r3.pause();
              }
              function a() {
                r3.readable && r3.resume && r3.resume();
              }
              r3.on("data", n2), t3.on("drain", a), t3._isStdio || e3 && false === e3.end || (r3.on("end", s), r3.on("close", h));
              var o = false;
              function s() {
                o || (o = true, t3.end());
              }
              function h() {
                o || (o = true, "function" == typeof t3.destroy && t3.destroy());
              }
              function f(t4) {
                if (u(), 0 === i.listenerCount(this, "error"))
                  throw t4;
              }
              function u() {
                r3.removeListener("data", n2), t3.removeListener("drain", a), r3.removeListener("end", s), r3.removeListener("close", h), r3.removeListener("error", f), t3.removeListener("error", f), r3.removeListener("end", u), r3.removeListener("close", u), t3.removeListener("close", u);
              }
              return r3.on("error", f), t3.on("error", f), r3.on("end", u), r3.on("close", u), t3.on("close", u), t3.emit("pipe", r3), t3;
            };
          }, { events: 38, inherits: 45, "readable-stream/lib/_stream_duplex.js": 63, "readable-stream/lib/_stream_passthrough.js": 64, "readable-stream/lib/_stream_readable.js": 65, "readable-stream/lib/_stream_transform.js": 66, "readable-stream/lib/_stream_writable.js": 67, "readable-stream/lib/internal/streams/end-of-stream.js": 71, "readable-stream/lib/internal/streams/pipeline.js": 73 }], 62: [function(t2, e2, r2) {
            "use strict";
            var i = {};
            function n(t3, e3, r3) {
              r3 || (r3 = Error);
              var n2 = function(t4) {
                function r4(r5, i3, n4) {
                  return t4.call(this, function(t5, r6, i4) {
                    return "string" == typeof e3 ? e3 : e3(t5, r6, i4);
                  }(r5, i3, n4)) || this;
                }
                return n3 = t4, (i2 = r4).prototype = Object.create(n3.prototype), i2.prototype.constructor = i2, i2.__proto__ = n3, r4;
                var i2, n3;
              }(r3);
              n2.prototype.name = r3.name, n2.prototype.code = t3, i[t3] = n2;
            }
            function a(t3, e3) {
              if (Array.isArray(t3)) {
                var r3 = t3.length;
                return t3 = t3.map(function(t4) {
                  return String(t4);
                }), r3 > 2 ? "one of ".concat(e3, " ").concat(t3.slice(0, r3 - 1).join(", "), ", or ") + t3[r3 - 1] : 2 === r3 ? "one of ".concat(e3, " ").concat(t3[0], " or ").concat(t3[1]) : "of ".concat(e3, " ").concat(t3[0]);
              }
              return "of ".concat(e3, " ").concat(String(t3));
            }
            n("ERR_INVALID_OPT_VALUE", function(t3, e3) {
              return 'The value "' + e3 + '" is invalid for option "' + t3 + '"';
            }, TypeError), n("ERR_INVALID_ARG_TYPE", function(t3, e3, r3) {
              var i2, n2, o, s;
              if ("string" == typeof e3 && (o = "not ", e3.substr(!s || s < 0 ? 0 : +s, o.length) === o) ? (i2 = "must not be", e3 = e3.replace(/^not /, "")) : i2 = "must be", function(t4, e4, r4) {
                return (void 0 === r4 || r4 > t4.length) && (r4 = t4.length), t4.substring(r4 - e4.length, r4) === e4;
              }(t3, " argument"))
                n2 = "The ".concat(t3, " ").concat(i2, " ").concat(a(e3, "type"));
              else {
                var h = function(t4, e4, r4) {
                  return "number" != typeof r4 && (r4 = 0), !(r4 + e4.length > t4.length) && -1 !== t4.indexOf(e4, r4);
                }(t3, ".") ? "property" : "argument";
                n2 = 'The "'.concat(t3, '" ').concat(h, " ").concat(i2, " ").concat(a(e3, "type"));
              }
              return n2 + ". Received type ".concat(typeof r3);
            }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(t3) {
              return "The " + t3 + " method is not implemented";
            }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(t3) {
              return "Cannot call " + t3 + " after a stream was destroyed";
            }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(t3) {
              return "Unknown encoding: " + t3;
            }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e2.exports.codes = i;
          }, {}], 63: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                var i = Object.keys || function(t3) {
                  var e3 = [];
                  for (var r4 in t3)
                    e3.push(r4);
                  return e3;
                };
                e2.exports = f;
                var n = t2("./_stream_readable"), a = t2("./_stream_writable");
                t2("inherits")(f, n);
                for (var o = i(a.prototype), s = 0; s < o.length; s++) {
                  var h = o[s];
                  f.prototype[h] || (f.prototype[h] = a.prototype[h]);
                }
                function f(t3) {
                  if (!(this instanceof f))
                    return new f(t3);
                  n.call(this, t3), a.call(this, t3), this.allowHalfOpen = true, t3 && (false === t3.readable && (this.readable = false), false === t3.writable && (this.writable = false), false === t3.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", u)));
                }
                function u() {
                  this._writableState.ended || r3.nextTick(l, this);
                }
                function l(t3) {
                  t3.end();
                }
                Object.defineProperty(f.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
                  return this._writableState.highWaterMark;
                } }), Object.defineProperty(f.prototype, "writableBuffer", { enumerable: false, get: function() {
                  return this._writableState && this._writableState.getBuffer();
                } }), Object.defineProperty(f.prototype, "writableLength", { enumerable: false, get: function() {
                  return this._writableState.length;
                } }), Object.defineProperty(f.prototype, "destroyed", { enumerable: false, get: function() {
                  return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
                }, set: function(t3) {
                  void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t3, this._writableState.destroyed = t3);
                } });
              }).call(this);
            }).call(this, t2("_process"));
          }, { "./_stream_readable": 65, "./_stream_writable": 67, _process: 60, inherits: 45 }], 64: [function(t2, e2, r2) {
            "use strict";
            e2.exports = n;
            var i = t2("./_stream_transform");
            function n(t3) {
              if (!(this instanceof n))
                return new n(t3);
              i.call(this, t3);
            }
            t2("inherits")(n, i), n.prototype._transform = function(t3, e3, r3) {
              r3(null, t3);
            };
          }, { "./_stream_transform": 66, inherits: 45 }], 65: [function(t2, e2, i) {
            (function(r2, i2) {
              (function() {
                "use strict";
                var n;
                e2.exports = S, S.ReadableState = k, t2("events").EventEmitter;
                var a = function(t3, e3) {
                  return t3.listeners(e3).length;
                }, o = t2("./internal/streams/stream"), s = t2("buffer").Buffer, h = i2.Uint8Array || function() {
                };
                var f, u = t2("util");
                f = u && u.debuglog ? u.debuglog("stream") : function() {
                };
                var l, c, d, p = t2("./internal/streams/buffer_list"), m = t2("./internal/streams/destroy"), g = t2("./internal/streams/state").getHighWaterMark, b = t2("../errors").codes, _ = b.ERR_INVALID_ARG_TYPE, y = b.ERR_STREAM_PUSH_AFTER_EOF, w = b.ERR_METHOD_NOT_IMPLEMENTED, v = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
                t2("inherits")(S, o);
                var x = m.errorOrDestroy, E = ["error", "close", "destroy", "pause", "resume"];
                function k(e3, r3, i3) {
                  n = n || t2("./_stream_duplex"), e3 = e3 || {}, "boolean" != typeof i3 && (i3 = r3 instanceof n), this.objectMode = !!e3.objectMode, i3 && (this.objectMode = this.objectMode || !!e3.readableObjectMode), this.highWaterMark = g(this, e3, "readableHighWaterMark", i3), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== e3.emitClose, this.autoDestroy = !!e3.autoDestroy, this.destroyed = false, this.defaultEncoding = e3.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e3.encoding && (l || (l = t2("string_decoder/").StringDecoder), this.decoder = new l(e3.encoding), this.encoding = e3.encoding);
                }
                function S(e3) {
                  if (n = n || t2("./_stream_duplex"), !(this instanceof S))
                    return new S(e3);
                  var r3 = this instanceof n;
                  this._readableState = new k(e3, this, r3), this.readable = true, e3 && ("function" == typeof e3.read && (this._read = e3.read), "function" == typeof e3.destroy && (this._destroy = e3.destroy)), o.call(this);
                }
                function M(t3, e3, r3, i3, n2) {
                  f("readableAddChunk", e3);
                  var a2, o2 = t3._readableState;
                  if (null === e3)
                    o2.reading = false, function(t4, e4) {
                      if (f("onEofChunk"), !e4.ended) {
                        if (e4.decoder) {
                          var r4 = e4.decoder.end();
                          r4 && r4.length && (e4.buffer.push(r4), e4.length += e4.objectMode ? 1 : r4.length);
                        }
                        e4.ended = true, e4.sync ? B(t4) : (e4.needReadable = false, e4.emittedReadable || (e4.emittedReadable = true, R(t4)));
                      }
                    }(t3, o2);
                  else if (n2 || (a2 = function(t4, e4) {
                    var r4;
                    return i4 = e4, s.isBuffer(i4) || i4 instanceof h || "string" == typeof e4 || void 0 === e4 || t4.objectMode || (r4 = new _("chunk", ["string", "Buffer", "Uint8Array"], e4)), r4;
                    var i4;
                  }(o2, e3)), a2)
                    x(t3, a2);
                  else if (o2.objectMode || e3 && e3.length > 0)
                    if ("string" == typeof e3 || o2.objectMode || Object.getPrototypeOf(e3) === s.prototype || (e3 = function(t4) {
                      return s.from(t4);
                    }(e3)), i3)
                      o2.endEmitted ? x(t3, new v()) : A(t3, o2, e3, true);
                    else if (o2.ended)
                      x(t3, new y());
                    else {
                      if (o2.destroyed)
                        return false;
                      o2.reading = false, o2.decoder && !r3 ? (e3 = o2.decoder.write(e3), o2.objectMode || 0 !== e3.length ? A(t3, o2, e3, false) : P(t3, o2)) : A(t3, o2, e3, false);
                    }
                  else
                    i3 || (o2.reading = false, P(t3, o2));
                  return !o2.ended && (o2.length < o2.highWaterMark || 0 === o2.length);
                }
                function A(t3, e3, r3, i3) {
                  e3.flowing && 0 === e3.length && !e3.sync ? (e3.awaitDrain = 0, t3.emit("data", r3)) : (e3.length += e3.objectMode ? 1 : r3.length, i3 ? e3.buffer.unshift(r3) : e3.buffer.push(r3), e3.needReadable && B(t3)), P(t3, e3);
                }
                Object.defineProperty(S.prototype, "destroyed", { enumerable: false, get: function() {
                  return void 0 !== this._readableState && this._readableState.destroyed;
                }, set: function(t3) {
                  this._readableState && (this._readableState.destroyed = t3);
                } }), S.prototype.destroy = m.destroy, S.prototype._undestroy = m.undestroy, S.prototype._destroy = function(t3, e3) {
                  e3(t3);
                }, S.prototype.push = function(t3, e3) {
                  var r3, i3 = this._readableState;
                  return i3.objectMode ? r3 = true : "string" == typeof t3 && ((e3 = e3 || i3.defaultEncoding) !== i3.encoding && (t3 = s.from(t3, e3), e3 = ""), r3 = true), M(this, t3, e3, false, r3);
                }, S.prototype.unshift = function(t3) {
                  return M(this, t3, null, true, false);
                }, S.prototype.isPaused = function() {
                  return false === this._readableState.flowing;
                }, S.prototype.setEncoding = function(e3) {
                  l || (l = t2("string_decoder/").StringDecoder);
                  var r3 = new l(e3);
                  this._readableState.decoder = r3, this._readableState.encoding = this._readableState.decoder.encoding;
                  for (var i3 = this._readableState.buffer.head, n2 = ""; null !== i3; )
                    n2 += r3.write(i3.data), i3 = i3.next;
                  return this._readableState.buffer.clear(), "" !== n2 && this._readableState.buffer.push(n2), this._readableState.length = n2.length, this;
                };
                var I = 1073741824;
                function T(t3, e3) {
                  return t3 <= 0 || 0 === e3.length && e3.ended ? 0 : e3.objectMode ? 1 : t3 != t3 ? e3.flowing && e3.length ? e3.buffer.head.data.length : e3.length : (t3 > e3.highWaterMark && (e3.highWaterMark = function(t4) {
                    return t4 >= I ? t4 = I : (t4--, t4 |= t4 >>> 1, t4 |= t4 >>> 2, t4 |= t4 >>> 4, t4 |= t4 >>> 8, t4 |= t4 >>> 16, t4++), t4;
                  }(t3)), t3 <= e3.length ? t3 : e3.ended ? e3.length : (e3.needReadable = true, 0));
                }
                function B(t3) {
                  var e3 = t3._readableState;
                  f("emitReadable", e3.needReadable, e3.emittedReadable), e3.needReadable = false, e3.emittedReadable || (f("emitReadable", e3.flowing), e3.emittedReadable = true, r2.nextTick(R, t3));
                }
                function R(t3) {
                  var e3 = t3._readableState;
                  f("emitReadable_", e3.destroyed, e3.length, e3.ended), e3.destroyed || !e3.length && !e3.ended || (t3.emit("readable"), e3.emittedReadable = false), e3.needReadable = !e3.flowing && !e3.ended && e3.length <= e3.highWaterMark, D(t3);
                }
                function P(t3, e3) {
                  e3.readingMore || (e3.readingMore = true, r2.nextTick(O, t3, e3));
                }
                function O(t3, e3) {
                  for (; !e3.reading && !e3.ended && (e3.length < e3.highWaterMark || e3.flowing && 0 === e3.length); ) {
                    var r3 = e3.length;
                    if (f("maybeReadMore read 0"), t3.read(0), r3 === e3.length)
                      break;
                  }
                  e3.readingMore = false;
                }
                function L(t3) {
                  var e3 = t3._readableState;
                  e3.readableListening = t3.listenerCount("readable") > 0, e3.resumeScheduled && !e3.paused ? e3.flowing = true : t3.listenerCount("data") > 0 && t3.resume();
                }
                function C(t3) {
                  f("readable nexttick read 0"), t3.read(0);
                }
                function U(t3, e3) {
                  f("resume", e3.reading), e3.reading || t3.read(0), e3.resumeScheduled = false, t3.emit("resume"), D(t3), e3.flowing && !e3.reading && t3.read(0);
                }
                function D(t3) {
                  var e3 = t3._readableState;
                  for (f("flow", e3.flowing); e3.flowing && null !== t3.read(); )
                    ;
                }
                function z(t3, e3) {
                  return 0 === e3.length ? null : (e3.objectMode ? r3 = e3.buffer.shift() : !t3 || t3 >= e3.length ? (r3 = e3.decoder ? e3.buffer.join("") : 1 === e3.buffer.length ? e3.buffer.first() : e3.buffer.concat(e3.length), e3.buffer.clear()) : r3 = e3.buffer.consume(t3, e3.decoder), r3);
                  var r3;
                }
                function N(t3) {
                  var e3 = t3._readableState;
                  f("endReadable", e3.endEmitted), e3.endEmitted || (e3.ended = true, r2.nextTick(F, e3, t3));
                }
                function F(t3, e3) {
                  if (f("endReadableNT", t3.endEmitted, t3.length), !t3.endEmitted && 0 === t3.length && (t3.endEmitted = true, e3.readable = false, e3.emit("end"), t3.autoDestroy)) {
                    var r3 = e3._writableState;
                    (!r3 || r3.autoDestroy && r3.finished) && e3.destroy();
                  }
                }
                function j(t3, e3) {
                  for (var r3 = 0, i3 = t3.length; r3 < i3; r3++)
                    if (t3[r3] === e3)
                      return r3;
                  return -1;
                }
                S.prototype.read = function(t3) {
                  f("read", t3), t3 = parseInt(t3, 10);
                  var e3 = this._readableState, r3 = t3;
                  if (0 !== t3 && (e3.emittedReadable = false), 0 === t3 && e3.needReadable && ((0 !== e3.highWaterMark ? e3.length >= e3.highWaterMark : e3.length > 0) || e3.ended))
                    return f("read: emitReadable", e3.length, e3.ended), 0 === e3.length && e3.ended ? N(this) : B(this), null;
                  if (0 === (t3 = T(t3, e3)) && e3.ended)
                    return 0 === e3.length && N(this), null;
                  var i3, n2 = e3.needReadable;
                  return f("need readable", n2), (0 === e3.length || e3.length - t3 < e3.highWaterMark) && f("length less than watermark", n2 = true), e3.ended || e3.reading ? f("reading or ended", n2 = false) : n2 && (f("do read"), e3.reading = true, e3.sync = true, 0 === e3.length && (e3.needReadable = true), this._read(e3.highWaterMark), e3.sync = false, e3.reading || (t3 = T(r3, e3))), null === (i3 = t3 > 0 ? z(t3, e3) : null) ? (e3.needReadable = e3.length <= e3.highWaterMark, t3 = 0) : (e3.length -= t3, e3.awaitDrain = 0), 0 === e3.length && (e3.ended || (e3.needReadable = true), r3 !== t3 && e3.ended && N(this)), null !== i3 && this.emit("data", i3), i3;
                }, S.prototype._read = function(t3) {
                  x(this, new w("_read()"));
                }, S.prototype.pipe = function(t3, e3) {
                  var i3 = this, n2 = this._readableState;
                  switch (n2.pipesCount) {
                    case 0:
                      n2.pipes = t3;
                      break;
                    case 1:
                      n2.pipes = [n2.pipes, t3];
                      break;
                    default:
                      n2.pipes.push(t3);
                  }
                  n2.pipesCount += 1, f("pipe count=%d opts=%j", n2.pipesCount, e3);
                  var o2 = e3 && false === e3.end || t3 === r2.stdout || t3 === r2.stderr ? g2 : h2;
                  function s2(e4, r3) {
                    f("onunpipe"), e4 === i3 && r3 && false === r3.hasUnpiped && (r3.hasUnpiped = true, f("cleanup"), t3.removeListener("close", p2), t3.removeListener("finish", m2), t3.removeListener("drain", u2), t3.removeListener("error", d2), t3.removeListener("unpipe", s2), i3.removeListener("end", h2), i3.removeListener("end", g2), i3.removeListener("data", c2), l2 = true, !n2.awaitDrain || t3._writableState && !t3._writableState.needDrain || u2());
                  }
                  function h2() {
                    f("onend"), t3.end();
                  }
                  n2.endEmitted ? r2.nextTick(o2) : i3.once("end", o2), t3.on("unpipe", s2);
                  var u2 = function(t4) {
                    return function() {
                      var e4 = t4._readableState;
                      f("pipeOnDrain", e4.awaitDrain), e4.awaitDrain && e4.awaitDrain--, 0 === e4.awaitDrain && a(t4, "data") && (e4.flowing = true, D(t4));
                    };
                  }(i3);
                  t3.on("drain", u2);
                  var l2 = false;
                  function c2(e4) {
                    f("ondata");
                    var r3 = t3.write(e4);
                    f("dest.write", r3), false === r3 && ((1 === n2.pipesCount && n2.pipes === t3 || n2.pipesCount > 1 && -1 !== j(n2.pipes, t3)) && !l2 && (f("false write response, pause", n2.awaitDrain), n2.awaitDrain++), i3.pause());
                  }
                  function d2(e4) {
                    f("onerror", e4), g2(), t3.removeListener("error", d2), 0 === a(t3, "error") && x(t3, e4);
                  }
                  function p2() {
                    t3.removeListener("finish", m2), g2();
                  }
                  function m2() {
                    f("onfinish"), t3.removeListener("close", p2), g2();
                  }
                  function g2() {
                    f("unpipe"), i3.unpipe(t3);
                  }
                  return i3.on("data", c2), function(t4, e4, r3) {
                    if ("function" == typeof t4.prependListener)
                      return t4.prependListener(e4, r3);
                    t4._events && t4._events[e4] ? Array.isArray(t4._events[e4]) ? t4._events[e4].unshift(r3) : t4._events[e4] = [r3, t4._events[e4]] : t4.on(e4, r3);
                  }(t3, "error", d2), t3.once("close", p2), t3.once("finish", m2), t3.emit("pipe", i3), n2.flowing || (f("pipe resume"), i3.resume()), t3;
                }, S.prototype.unpipe = function(t3) {
                  var e3 = this._readableState, r3 = { hasUnpiped: false };
                  if (0 === e3.pipesCount)
                    return this;
                  if (1 === e3.pipesCount)
                    return t3 && t3 !== e3.pipes || (t3 || (t3 = e3.pipes), e3.pipes = null, e3.pipesCount = 0, e3.flowing = false, t3 && t3.emit("unpipe", this, r3)), this;
                  if (!t3) {
                    var i3 = e3.pipes, n2 = e3.pipesCount;
                    e3.pipes = null, e3.pipesCount = 0, e3.flowing = false;
                    for (var a2 = 0; a2 < n2; a2++)
                      i3[a2].emit("unpipe", this, { hasUnpiped: false });
                    return this;
                  }
                  var o2 = j(e3.pipes, t3);
                  return -1 === o2 || (e3.pipes.splice(o2, 1), e3.pipesCount -= 1, 1 === e3.pipesCount && (e3.pipes = e3.pipes[0]), t3.emit("unpipe", this, r3)), this;
                }, S.prototype.on = function(t3, e3) {
                  var i3 = o.prototype.on.call(this, t3, e3), n2 = this._readableState;
                  return "data" === t3 ? (n2.readableListening = this.listenerCount("readable") > 0, false !== n2.flowing && this.resume()) : "readable" === t3 && (n2.endEmitted || n2.readableListening || (n2.readableListening = n2.needReadable = true, n2.flowing = false, n2.emittedReadable = false, f("on readable", n2.length, n2.reading), n2.length ? B(this) : n2.reading || r2.nextTick(C, this))), i3;
                }, S.prototype.addListener = S.prototype.on, S.prototype.removeListener = function(t3, e3) {
                  var i3 = o.prototype.removeListener.call(this, t3, e3);
                  return "readable" === t3 && r2.nextTick(L, this), i3;
                }, S.prototype.removeAllListeners = function(t3) {
                  var e3 = o.prototype.removeAllListeners.apply(this, arguments);
                  return "readable" !== t3 && void 0 !== t3 || r2.nextTick(L, this), e3;
                }, S.prototype.resume = function() {
                  var t3 = this._readableState;
                  return t3.flowing || (f("resume"), t3.flowing = !t3.readableListening, function(t4, e3) {
                    e3.resumeScheduled || (e3.resumeScheduled = true, r2.nextTick(U, t4, e3));
                  }(this, t3)), t3.paused = false, this;
                }, S.prototype.pause = function() {
                  return f("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (f("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
                }, S.prototype.wrap = function(t3) {
                  var e3 = this, r3 = this._readableState, i3 = false;
                  for (var n2 in t3.on("end", function() {
                    if (f("wrapped end"), r3.decoder && !r3.ended) {
                      var t4 = r3.decoder.end();
                      t4 && t4.length && e3.push(t4);
                    }
                    e3.push(null);
                  }), t3.on("data", function(n3) {
                    f("wrapped data"), r3.decoder && (n3 = r3.decoder.write(n3)), r3.objectMode && null == n3 || (r3.objectMode || n3 && n3.length) && (e3.push(n3) || (i3 = true, t3.pause()));
                  }), t3)
                    void 0 === this[n2] && "function" == typeof t3[n2] && (this[n2] = function(e4) {
                      return function() {
                        return t3[e4].apply(t3, arguments);
                      };
                    }(n2));
                  for (var a2 = 0; a2 < E.length; a2++)
                    t3.on(E[a2], this.emit.bind(this, E[a2]));
                  return this._read = function(e4) {
                    f("wrapped _read", e4), i3 && (i3 = false, t3.resume());
                  }, this;
                }, "function" == typeof Symbol && (S.prototype[Symbol.asyncIterator] = function() {
                  return void 0 === c && (c = t2("./internal/streams/async_iterator")), c(this);
                }), Object.defineProperty(S.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
                  return this._readableState.highWaterMark;
                } }), Object.defineProperty(S.prototype, "readableBuffer", { enumerable: false, get: function() {
                  return this._readableState && this._readableState.buffer;
                } }), Object.defineProperty(S.prototype, "readableFlowing", { enumerable: false, get: function() {
                  return this._readableState.flowing;
                }, set: function(t3) {
                  this._readableState && (this._readableState.flowing = t3);
                } }), S._fromList = z, Object.defineProperty(S.prototype, "readableLength", { enumerable: false, get: function() {
                  return this._readableState.length;
                } }), "function" == typeof Symbol && (S.from = function(e3, r3) {
                  return void 0 === d && (d = t2("./internal/streams/from")), d(S, e3, r3);
                });
              }).call(this);
            }).call(this, t2("_process"), void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, { "../errors": 62, "./_stream_duplex": 63, "./internal/streams/async_iterator": 68, "./internal/streams/buffer_list": 69, "./internal/streams/destroy": 70, "./internal/streams/from": 72, "./internal/streams/state": 74, "./internal/streams/stream": 75, _process: 60, buffer: 33, events: 38, inherits: 45, "string_decoder/": 76, util: 30 }], 66: [function(t2, e2, r2) {
            "use strict";
            e2.exports = u;
            var i = t2("../errors").codes, n = i.ERR_METHOD_NOT_IMPLEMENTED, a = i.ERR_MULTIPLE_CALLBACK, o = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = i.ERR_TRANSFORM_WITH_LENGTH_0, h = t2("./_stream_duplex");
            function f(t3, e3) {
              var r3 = this._transformState;
              r3.transforming = false;
              var i2 = r3.writecb;
              if (null === i2)
                return this.emit("error", new a());
              r3.writechunk = null, r3.writecb = null, null != e3 && this.push(e3), i2(t3);
              var n2 = this._readableState;
              n2.reading = false, (n2.needReadable || n2.length < n2.highWaterMark) && this._read(n2.highWaterMark);
            }
            function u(t3) {
              if (!(this instanceof u))
                return new u(t3);
              h.call(this, t3), this._transformState = { afterTransform: f.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t3 && ("function" == typeof t3.transform && (this._transform = t3.transform), "function" == typeof t3.flush && (this._flush = t3.flush)), this.on("prefinish", l);
            }
            function l() {
              var t3 = this;
              "function" != typeof this._flush || this._readableState.destroyed ? c(this, null, null) : this._flush(function(e3, r3) {
                c(t3, e3, r3);
              });
            }
            function c(t3, e3, r3) {
              if (e3)
                return t3.emit("error", e3);
              if (null != r3 && t3.push(r3), t3._writableState.length)
                throw new s();
              if (t3._transformState.transforming)
                throw new o();
              return t3.push(null);
            }
            t2("inherits")(u, h), u.prototype.push = function(t3, e3) {
              return this._transformState.needTransform = false, h.prototype.push.call(this, t3, e3);
            }, u.prototype._transform = function(t3, e3, r3) {
              r3(new n("_transform()"));
            }, u.prototype._write = function(t3, e3, r3) {
              var i2 = this._transformState;
              if (i2.writecb = r3, i2.writechunk = t3, i2.writeencoding = e3, !i2.transforming) {
                var n2 = this._readableState;
                (i2.needTransform || n2.needReadable || n2.length < n2.highWaterMark) && this._read(n2.highWaterMark);
              }
            }, u.prototype._read = function(t3) {
              var e3 = this._transformState;
              null === e3.writechunk || e3.transforming ? e3.needTransform = true : (e3.transforming = true, this._transform(e3.writechunk, e3.writeencoding, e3.afterTransform));
            }, u.prototype._destroy = function(t3, e3) {
              h.prototype._destroy.call(this, t3, function(t4) {
                e3(t4);
              });
            };
          }, { "../errors": 62, "./_stream_duplex": 63, inherits: 45 }], 67: [function(t2, e2, i) {
            (function(r2, i2) {
              (function() {
                "use strict";
                function n(t3) {
                  var e3 = this;
                  this.next = null, this.entry = null, this.finish = function() {
                    !function(t4, e4, r3) {
                      var i3 = t4.entry;
                      for (t4.entry = null; i3; ) {
                        var n2 = i3.callback;
                        e4.pendingcb--, n2(r3), i3 = i3.next;
                      }
                      e4.corkedRequestsFree.next = t4;
                    }(e3, t3);
                  };
                }
                var a;
                e2.exports = S, S.WritableState = k;
                var o = { deprecate: t2("util-deprecate") }, s = t2("./internal/streams/stream"), h = t2("buffer").Buffer, f = i2.Uint8Array || function() {
                };
                var u, l = t2("./internal/streams/destroy"), c = t2("./internal/streams/state").getHighWaterMark, d = t2("../errors").codes, p = d.ERR_INVALID_ARG_TYPE, m = d.ERR_METHOD_NOT_IMPLEMENTED, g = d.ERR_MULTIPLE_CALLBACK, b = d.ERR_STREAM_CANNOT_PIPE, _ = d.ERR_STREAM_DESTROYED, y = d.ERR_STREAM_NULL_VALUES, w = d.ERR_STREAM_WRITE_AFTER_END, v = d.ERR_UNKNOWN_ENCODING, x = l.errorOrDestroy;
                function E() {
                }
                function k(e3, i3, o2) {
                  a = a || t2("./_stream_duplex"), e3 = e3 || {}, "boolean" != typeof o2 && (o2 = i3 instanceof a), this.objectMode = !!e3.objectMode, o2 && (this.objectMode = this.objectMode || !!e3.writableObjectMode), this.highWaterMark = c(this, e3, "writableHighWaterMark", o2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
                  var s2 = false === e3.decodeStrings;
                  this.decodeStrings = !s2, this.defaultEncoding = e3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(t3) {
                    !function(t4, e4) {
                      var i4 = t4._writableState, n2 = i4.sync, a2 = i4.writecb;
                      if ("function" != typeof a2)
                        throw new g();
                      if (function(t5) {
                        t5.writing = false, t5.writecb = null, t5.length -= t5.writelen, t5.writelen = 0;
                      }(i4), e4)
                        !function(t5, e5, i5, n3, a3) {
                          --e5.pendingcb, i5 ? (r2.nextTick(a3, n3), r2.nextTick(P, t5, e5), t5._writableState.errorEmitted = true, x(t5, n3)) : (a3(n3), t5._writableState.errorEmitted = true, x(t5, n3), P(t5, e5));
                        }(t4, i4, n2, e4, a2);
                      else {
                        var o3 = B(i4) || t4.destroyed;
                        o3 || i4.corked || i4.bufferProcessing || !i4.bufferedRequest || T(t4, i4), n2 ? r2.nextTick(I, t4, i4, o3, a2) : I(t4, i4, o3, a2);
                      }
                    }(i3, t3);
                  }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== e3.emitClose, this.autoDestroy = !!e3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
                }
                function S(e3) {
                  var r3 = this instanceof (a = a || t2("./_stream_duplex"));
                  if (!r3 && !u.call(S, this))
                    return new S(e3);
                  this._writableState = new k(e3, this, r3), this.writable = true, e3 && ("function" == typeof e3.write && (this._write = e3.write), "function" == typeof e3.writev && (this._writev = e3.writev), "function" == typeof e3.destroy && (this._destroy = e3.destroy), "function" == typeof e3.final && (this._final = e3.final)), s.call(this);
                }
                function M(t3, e3, r3, i3, n2, a2) {
                  if (!r3) {
                    var o2 = function(t4, e4, r4) {
                      return t4.objectMode || false === t4.decodeStrings || "string" != typeof e4 || (e4 = h.from(e4, r4)), e4;
                    }(e3, i3, n2);
                    i3 !== o2 && (r3 = true, n2 = "buffer", i3 = o2);
                  }
                  var s2 = e3.objectMode ? 1 : i3.length;
                  e3.length += s2;
                  var f2 = e3.length < e3.highWaterMark;
                  if (f2 || (e3.needDrain = true), e3.writing || e3.corked) {
                    var u2 = e3.lastBufferedRequest;
                    e3.lastBufferedRequest = { chunk: i3, encoding: n2, isBuf: r3, callback: a2, next: null }, u2 ? u2.next = e3.lastBufferedRequest : e3.bufferedRequest = e3.lastBufferedRequest, e3.bufferedRequestCount += 1;
                  } else
                    A(t3, e3, false, s2, i3, n2, a2);
                  return f2;
                }
                function A(t3, e3, r3, i3, n2, a2, o2) {
                  e3.writelen = i3, e3.writecb = o2, e3.writing = true, e3.sync = true, e3.destroyed ? e3.onwrite(new _("write")) : r3 ? t3._writev(n2, e3.onwrite) : t3._write(n2, a2, e3.onwrite), e3.sync = false;
                }
                function I(t3, e3, r3, i3) {
                  r3 || function(t4, e4) {
                    0 === e4.length && e4.needDrain && (e4.needDrain = false, t4.emit("drain"));
                  }(t3, e3), e3.pendingcb--, i3(), P(t3, e3);
                }
                function T(t3, e3) {
                  e3.bufferProcessing = true;
                  var r3 = e3.bufferedRequest;
                  if (t3._writev && r3 && r3.next) {
                    var i3 = e3.bufferedRequestCount, a2 = new Array(i3), o2 = e3.corkedRequestsFree;
                    o2.entry = r3;
                    for (var s2 = 0, h2 = true; r3; )
                      a2[s2] = r3, r3.isBuf || (h2 = false), r3 = r3.next, s2 += 1;
                    a2.allBuffers = h2, A(t3, e3, true, e3.length, a2, "", o2.finish), e3.pendingcb++, e3.lastBufferedRequest = null, o2.next ? (e3.corkedRequestsFree = o2.next, o2.next = null) : e3.corkedRequestsFree = new n(e3), e3.bufferedRequestCount = 0;
                  } else {
                    for (; r3; ) {
                      var f2 = r3.chunk, u2 = r3.encoding, l2 = r3.callback;
                      if (A(t3, e3, false, e3.objectMode ? 1 : f2.length, f2, u2, l2), r3 = r3.next, e3.bufferedRequestCount--, e3.writing)
                        break;
                    }
                    null === r3 && (e3.lastBufferedRequest = null);
                  }
                  e3.bufferedRequest = r3, e3.bufferProcessing = false;
                }
                function B(t3) {
                  return t3.ending && 0 === t3.length && null === t3.bufferedRequest && !t3.finished && !t3.writing;
                }
                function R(t3, e3) {
                  t3._final(function(r3) {
                    e3.pendingcb--, r3 && x(t3, r3), e3.prefinished = true, t3.emit("prefinish"), P(t3, e3);
                  });
                }
                function P(t3, e3) {
                  var i3 = B(e3);
                  if (i3 && (function(t4, e4) {
                    e4.prefinished || e4.finalCalled || ("function" != typeof t4._final || e4.destroyed ? (e4.prefinished = true, t4.emit("prefinish")) : (e4.pendingcb++, e4.finalCalled = true, r2.nextTick(R, t4, e4)));
                  }(t3, e3), 0 === e3.pendingcb && (e3.finished = true, t3.emit("finish"), e3.autoDestroy))) {
                    var n2 = t3._readableState;
                    (!n2 || n2.autoDestroy && n2.endEmitted) && t3.destroy();
                  }
                  return i3;
                }
                t2("inherits")(S, s), k.prototype.getBuffer = function() {
                  for (var t3 = this.bufferedRequest, e3 = []; t3; )
                    e3.push(t3), t3 = t3.next;
                  return e3;
                }, function() {
                  try {
                    Object.defineProperty(k.prototype, "buffer", { get: o.deprecate(function() {
                      return this.getBuffer();
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
                  } catch (t3) {
                  }
                }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (u = Function.prototype[Symbol.hasInstance], Object.defineProperty(S, Symbol.hasInstance, { value: function(t3) {
                  return !!u.call(this, t3) || this === S && t3 && t3._writableState instanceof k;
                } })) : u = function(t3) {
                  return t3 instanceof this;
                }, S.prototype.pipe = function() {
                  x(this, new b());
                }, S.prototype.write = function(t3, e3, i3) {
                  var n2, a2 = this._writableState, o2 = false, s2 = !a2.objectMode && (n2 = t3, h.isBuffer(n2) || n2 instanceof f);
                  return s2 && !h.isBuffer(t3) && (t3 = function(t4) {
                    return h.from(t4);
                  }(t3)), "function" == typeof e3 && (i3 = e3, e3 = null), s2 ? e3 = "buffer" : e3 || (e3 = a2.defaultEncoding), "function" != typeof i3 && (i3 = E), a2.ending ? function(t4, e4) {
                    var i4 = new w();
                    x(t4, i4), r2.nextTick(e4, i4);
                  }(this, i3) : (s2 || function(t4, e4, i4, n3) {
                    var a3;
                    return null === i4 ? a3 = new y() : "string" == typeof i4 || e4.objectMode || (a3 = new p("chunk", ["string", "Buffer"], i4)), !a3 || (x(t4, a3), r2.nextTick(n3, a3), false);
                  }(this, a2, t3, i3)) && (a2.pendingcb++, o2 = M(this, a2, s2, t3, e3, i3)), o2;
                }, S.prototype.cork = function() {
                  this._writableState.corked++;
                }, S.prototype.uncork = function() {
                  var t3 = this._writableState;
                  t3.corked && (t3.corked--, t3.writing || t3.corked || t3.bufferProcessing || !t3.bufferedRequest || T(this, t3));
                }, S.prototype.setDefaultEncoding = function(t3) {
                  if ("string" == typeof t3 && (t3 = t3.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t3 + "").toLowerCase()) > -1))
                    throw new v(t3);
                  return this._writableState.defaultEncoding = t3, this;
                }, Object.defineProperty(S.prototype, "writableBuffer", { enumerable: false, get: function() {
                  return this._writableState && this._writableState.getBuffer();
                } }), Object.defineProperty(S.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
                  return this._writableState.highWaterMark;
                } }), S.prototype._write = function(t3, e3, r3) {
                  r3(new m("_write()"));
                }, S.prototype._writev = null, S.prototype.end = function(t3, e3, i3) {
                  var n2 = this._writableState;
                  return "function" == typeof t3 ? (i3 = t3, t3 = null, e3 = null) : "function" == typeof e3 && (i3 = e3, e3 = null), null != t3 && this.write(t3, e3), n2.corked && (n2.corked = 1, this.uncork()), n2.ending || function(t4, e4, i4) {
                    e4.ending = true, P(t4, e4), i4 && (e4.finished ? r2.nextTick(i4) : t4.once("finish", i4)), e4.ended = true, t4.writable = false;
                  }(this, n2, i3), this;
                }, Object.defineProperty(S.prototype, "writableLength", { enumerable: false, get: function() {
                  return this._writableState.length;
                } }), Object.defineProperty(S.prototype, "destroyed", { enumerable: false, get: function() {
                  return void 0 !== this._writableState && this._writableState.destroyed;
                }, set: function(t3) {
                  this._writableState && (this._writableState.destroyed = t3);
                } }), S.prototype.destroy = l.destroy, S.prototype._undestroy = l.undestroy, S.prototype._destroy = function(t3, e3) {
                  e3(t3);
                };
              }).call(this);
            }).call(this, t2("_process"), void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, { "../errors": 62, "./_stream_duplex": 63, "./internal/streams/destroy": 70, "./internal/streams/state": 74, "./internal/streams/stream": 75, _process: 60, buffer: 33, inherits: 45, "util-deprecate": 78 }], 68: [function(t2, e2, r2) {
            (function(r3) {
              (function() {
                "use strict";
                var i;
                function n(t3, e3, r4) {
                  return e3 in t3 ? Object.defineProperty(t3, e3, { value: r4, enumerable: true, configurable: true, writable: true }) : t3[e3] = r4, t3;
                }
                var a = t2("./end-of-stream"), o = Symbol("lastResolve"), s = Symbol("lastReject"), h = Symbol("error"), f = Symbol("ended"), u = Symbol("lastPromise"), l = Symbol("handlePromise"), c = Symbol("stream");
                function d(t3, e3) {
                  return { value: t3, done: e3 };
                }
                function p(t3) {
                  var e3 = t3[o];
                  if (null !== e3) {
                    var r4 = t3[c].read();
                    null !== r4 && (t3[u] = null, t3[o] = null, t3[s] = null, e3(d(r4, false)));
                  }
                }
                function m(t3) {
                  r3.nextTick(p, t3);
                }
                var g = Object.getPrototypeOf(function() {
                }), b = Object.setPrototypeOf((n(i = { get stream() {
                  return this[c];
                }, next: function() {
                  var t3 = this, e3 = this[h];
                  if (null !== e3)
                    return Promise.reject(e3);
                  if (this[f])
                    return Promise.resolve(d(void 0, true));
                  if (this[c].destroyed)
                    return new Promise(function(e4, i3) {
                      r3.nextTick(function() {
                        t3[h] ? i3(t3[h]) : e4(d(void 0, true));
                      });
                    });
                  var i2, n2 = this[u];
                  if (n2)
                    i2 = new Promise(function(t4, e4) {
                      return function(r4, i3) {
                        t4.then(function() {
                          e4[f] ? r4(d(void 0, true)) : e4[l](r4, i3);
                        }, i3);
                      };
                    }(n2, this));
                  else {
                    var a2 = this[c].read();
                    if (null !== a2)
                      return Promise.resolve(d(a2, false));
                    i2 = new Promise(this[l]);
                  }
                  return this[u] = i2, i2;
                } }, Symbol.asyncIterator, function() {
                  return this;
                }), n(i, "return", function() {
                  var t3 = this;
                  return new Promise(function(e3, r4) {
                    t3[c].destroy(null, function(t4) {
                      t4 ? r4(t4) : e3(d(void 0, true));
                    });
                  });
                }), i), g);
                e2.exports = function(t3) {
                  var e3, r4 = Object.create(b, (n(e3 = {}, c, { value: t3, writable: true }), n(e3, o, { value: null, writable: true }), n(e3, s, { value: null, writable: true }), n(e3, h, { value: null, writable: true }), n(e3, f, { value: t3._readableState.endEmitted, writable: true }), n(e3, l, { value: function(t4, e4) {
                    var i2 = r4[c].read();
                    i2 ? (r4[u] = null, r4[o] = null, r4[s] = null, t4(d(i2, false))) : (r4[o] = t4, r4[s] = e4);
                  }, writable: true }), e3));
                  return r4[u] = null, a(t3, function(t4) {
                    if (t4 && "ERR_STREAM_PREMATURE_CLOSE" !== t4.code) {
                      var e4 = r4[s];
                      return null !== e4 && (r4[u] = null, r4[o] = null, r4[s] = null, e4(t4)), void (r4[h] = t4);
                    }
                    var i2 = r4[o];
                    null !== i2 && (r4[u] = null, r4[o] = null, r4[s] = null, i2(d(void 0, true))), r4[f] = true;
                  }), t3.on("readable", m.bind(null, r4)), r4;
                };
              }).call(this);
            }).call(this, t2("_process"));
          }, { "./end-of-stream": 71, _process: 60 }], 69: [function(t2, e2, r2) {
            "use strict";
            function i(t3, e3) {
              var r3 = Object.keys(t3);
              if (Object.getOwnPropertySymbols) {
                var i2 = Object.getOwnPropertySymbols(t3);
                e3 && (i2 = i2.filter(function(e4) {
                  return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
                })), r3.push.apply(r3, i2);
              }
              return r3;
            }
            function n(t3, e3, r3) {
              return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
            }
            function a(t3, e3) {
              for (var r3 = 0; r3 < e3.length; r3++) {
                var i2 = e3[r3];
                i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(t3, i2.key, i2);
              }
            }
            var o = t2("buffer").Buffer, s = t2("util").inspect, h = s && s.custom || "inspect";
            e2.exports = function() {
              function t3() {
                (function(t4, e4) {
                  if (!(t4 instanceof e4))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t3), this.head = null, this.tail = null, this.length = 0;
              }
              return e3 = t3, r3 = [{ key: "push", value: function(t4) {
                var e4 = { data: t4, next: null };
                this.length > 0 ? this.tail.next = e4 : this.head = e4, this.tail = e4, ++this.length;
              } }, { key: "unshift", value: function(t4) {
                var e4 = { data: t4, next: this.head };
                0 === this.length && (this.tail = e4), this.head = e4, ++this.length;
              } }, { key: "shift", value: function() {
                if (0 !== this.length) {
                  var t4 = this.head.data;
                  return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t4;
                }
              } }, { key: "clear", value: function() {
                this.head = this.tail = null, this.length = 0;
              } }, { key: "join", value: function(t4) {
                if (0 === this.length)
                  return "";
                for (var e4 = this.head, r4 = "" + e4.data; e4 = e4.next; )
                  r4 += t4 + e4.data;
                return r4;
              } }, { key: "concat", value: function(t4) {
                if (0 === this.length)
                  return o.alloc(0);
                for (var e4 = o.allocUnsafe(t4 >>> 0), r4 = this.head, i2 = 0; r4; )
                  n2 = r4.data, a2 = e4, s2 = i2, o.prototype.copy.call(n2, a2, s2), i2 += r4.data.length, r4 = r4.next;
                var n2, a2, s2;
                return e4;
              } }, { key: "consume", value: function(t4, e4) {
                var r4;
                return t4 < this.head.data.length ? (r4 = this.head.data.slice(0, t4), this.head.data = this.head.data.slice(t4)) : r4 = t4 === this.head.data.length ? this.shift() : e4 ? this._getString(t4) : this._getBuffer(t4), r4;
              } }, { key: "first", value: function() {
                return this.head.data;
              } }, { key: "_getString", value: function(t4) {
                var e4 = this.head, r4 = 1, i2 = e4.data;
                for (t4 -= i2.length; e4 = e4.next; ) {
                  var n2 = e4.data, a2 = t4 > n2.length ? n2.length : t4;
                  if (a2 === n2.length ? i2 += n2 : i2 += n2.slice(0, t4), 0 == (t4 -= a2)) {
                    a2 === n2.length ? (++r4, e4.next ? this.head = e4.next : this.head = this.tail = null) : (this.head = e4, e4.data = n2.slice(a2));
                    break;
                  }
                  ++r4;
                }
                return this.length -= r4, i2;
              } }, { key: "_getBuffer", value: function(t4) {
                var e4 = o.allocUnsafe(t4), r4 = this.head, i2 = 1;
                for (r4.data.copy(e4), t4 -= r4.data.length; r4 = r4.next; ) {
                  var n2 = r4.data, a2 = t4 > n2.length ? n2.length : t4;
                  if (n2.copy(e4, e4.length - t4, 0, a2), 0 == (t4 -= a2)) {
                    a2 === n2.length ? (++i2, r4.next ? this.head = r4.next : this.head = this.tail = null) : (this.head = r4, r4.data = n2.slice(a2));
                    break;
                  }
                  ++i2;
                }
                return this.length -= i2, e4;
              } }, { key: h, value: function(t4, e4) {
                return s(this, function(t5) {
                  for (var e5 = 1; e5 < arguments.length; e5++) {
                    var r4 = null != arguments[e5] ? arguments[e5] : {};
                    e5 % 2 ? i(Object(r4), true).forEach(function(e6) {
                      n(t5, e6, r4[e6]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(r4)) : i(Object(r4)).forEach(function(e6) {
                      Object.defineProperty(t5, e6, Object.getOwnPropertyDescriptor(r4, e6));
                    });
                  }
                  return t5;
                }({}, e4, { depth: 0, customInspect: false }));
              } }], r3 && a(e3.prototype, r3), f && a(e3, f), t3;
              var e3, r3, f;
            }();
          }, { buffer: 33, util: 30 }], 70: [function(t2, e2, r2) {
            (function(t3) {
              (function() {
                "use strict";
                function r3(t4, e3) {
                  n(t4, e3), i(t4);
                }
                function i(t4) {
                  t4._writableState && !t4._writableState.emitClose || t4._readableState && !t4._readableState.emitClose || t4.emit("close");
                }
                function n(t4, e3) {
                  t4.emit("error", e3);
                }
                e2.exports = { destroy: function(e3, a) {
                  var o = this, s = this._readableState && this._readableState.destroyed, h = this._writableState && this._writableState.destroyed;
                  return s || h ? (a ? a(e3) : e3 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, t3.nextTick(n, this, e3)) : t3.nextTick(n, this, e3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e3 || null, function(e4) {
                    !a && e4 ? o._writableState ? o._writableState.errorEmitted ? t3.nextTick(i, o) : (o._writableState.errorEmitted = true, t3.nextTick(r3, o, e4)) : t3.nextTick(r3, o, e4) : a ? (t3.nextTick(i, o), a(e4)) : t3.nextTick(i, o);
                  }), this);
                }, undestroy: function() {
                  this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
                }, errorOrDestroy: function(t4, e3) {
                  var r4 = t4._readableState, i2 = t4._writableState;
                  r4 && r4.autoDestroy || i2 && i2.autoDestroy ? t4.destroy(e3) : t4.emit("error", e3);
                } };
              }).call(this);
            }).call(this, t2("_process"));
          }, { _process: 60 }], 71: [function(t2, e2, r2) {
            "use strict";
            var i = t2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
            function n() {
            }
            e2.exports = function t3(e3, r3, a) {
              if ("function" == typeof r3)
                return t3(e3, null, r3);
              r3 || (r3 = {}), a = function(t4) {
                var e4 = false;
                return function() {
                  if (!e4) {
                    e4 = true;
                    for (var r4 = arguments.length, i2 = new Array(r4), n2 = 0; n2 < r4; n2++)
                      i2[n2] = arguments[n2];
                    t4.apply(this, i2);
                  }
                };
              }(a || n);
              var o = r3.readable || false !== r3.readable && e3.readable, s = r3.writable || false !== r3.writable && e3.writable, h = function() {
                e3.writable || u();
              }, f = e3._writableState && e3._writableState.finished, u = function() {
                s = false, f = true, o || a.call(e3);
              }, l = e3._readableState && e3._readableState.endEmitted, c = function() {
                o = false, l = true, s || a.call(e3);
              }, d = function(t4) {
                a.call(e3, t4);
              }, p = function() {
                var t4;
                return o && !l ? (e3._readableState && e3._readableState.ended || (t4 = new i()), a.call(e3, t4)) : s && !f ? (e3._writableState && e3._writableState.ended || (t4 = new i()), a.call(e3, t4)) : void 0;
              }, m = function() {
                e3.req.on("finish", u);
              };
              return function(t4) {
                return t4.setHeader && "function" == typeof t4.abort;
              }(e3) ? (e3.on("complete", u), e3.on("abort", p), e3.req ? m() : e3.on("request", m)) : s && !e3._writableState && (e3.on("end", h), e3.on("close", h)), e3.on("end", c), e3.on("finish", u), false !== r3.error && e3.on("error", d), e3.on("close", p), function() {
                e3.removeListener("complete", u), e3.removeListener("abort", p), e3.removeListener("request", m), e3.req && e3.req.removeListener("finish", u), e3.removeListener("end", h), e3.removeListener("close", h), e3.removeListener("finish", u), e3.removeListener("end", c), e3.removeListener("error", d), e3.removeListener("close", p);
              };
            };
          }, { "../../../errors": 62 }], 72: [function(t2, e2, r2) {
            e2.exports = function() {
              throw new Error("Readable.from is not available in the browser");
            };
          }, {}], 73: [function(t2, e2, r2) {
            "use strict";
            var i;
            var n = t2("../../../errors").codes, a = n.ERR_MISSING_ARGS, o = n.ERR_STREAM_DESTROYED;
            function s(t3) {
              if (t3)
                throw t3;
            }
            function h(t3) {
              t3();
            }
            function f(t3, e3) {
              return t3.pipe(e3);
            }
            e2.exports = function() {
              for (var e3 = arguments.length, r3 = new Array(e3), n2 = 0; n2 < e3; n2++)
                r3[n2] = arguments[n2];
              var u, l = function(t3) {
                return t3.length ? "function" != typeof t3[t3.length - 1] ? s : t3.pop() : s;
              }(r3);
              if (Array.isArray(r3[0]) && (r3 = r3[0]), r3.length < 2)
                throw new a("streams");
              var c = r3.map(function(e4, n3) {
                var a2 = n3 < r3.length - 1;
                return function(e5, r4, n4, a3) {
                  a3 = function(t3) {
                    var e6 = false;
                    return function() {
                      e6 || (e6 = true, t3.apply(void 0, arguments));
                    };
                  }(a3);
                  var s2 = false;
                  e5.on("close", function() {
                    s2 = true;
                  }), void 0 === i && (i = t2("./end-of-stream")), i(e5, { readable: r4, writable: n4 }, function(t3) {
                    if (t3)
                      return a3(t3);
                    s2 = true, a3();
                  });
                  var h2 = false;
                  return function(t3) {
                    if (!s2 && !h2)
                      return h2 = true, function(t4) {
                        return t4.setHeader && "function" == typeof t4.abort;
                      }(e5) ? e5.abort() : "function" == typeof e5.destroy ? e5.destroy() : void a3(t3 || new o("pipe"));
                  };
                }(e4, a2, n3 > 0, function(t3) {
                  u || (u = t3), t3 && c.forEach(h), a2 || (c.forEach(h), l(u));
                });
              });
              return r3.reduce(f);
            };
          }, { "../../../errors": 62, "./end-of-stream": 71 }], 74: [function(t2, e2, r2) {
            "use strict";
            var i = t2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
            e2.exports = { getHighWaterMark: function(t3, e3, r3, n) {
              var a = function(t4, e4, r4) {
                return null != t4.highWaterMark ? t4.highWaterMark : e4 ? t4[r4] : null;
              }(e3, n, r3);
              if (null != a) {
                if (!isFinite(a) || Math.floor(a) !== a || a < 0)
                  throw new i(n ? r3 : "highWaterMark", a);
                return Math.floor(a);
              }
              return t3.objectMode ? 16 : 16384;
            } };
          }, { "../../../errors": 62 }], 75: [function(t2, e2, r2) {
            e2.exports = t2("events").EventEmitter;
          }, { events: 38 }], 76: [function(t2, e2, r2) {
            "use strict";
            var i = t2("safe-buffer").Buffer, n = i.isEncoding || function(t3) {
              switch ((t3 = "" + t3) && t3.toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                case "raw":
                  return true;
                default:
                  return false;
              }
            };
            function a(t3) {
              var e3;
              switch (this.encoding = function(t4) {
                var e4 = function(t5) {
                  if (!t5)
                    return "utf8";
                  for (var e5; ; )
                    switch (t5) {
                      case "utf8":
                      case "utf-8":
                        return "utf8";
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return "utf16le";
                      case "latin1":
                      case "binary":
                        return "latin1";
                      case "base64":
                      case "ascii":
                      case "hex":
                        return t5;
                      default:
                        if (e5)
                          return;
                        t5 = ("" + t5).toLowerCase(), e5 = true;
                    }
                }(t4);
                if ("string" != typeof e4 && (i.isEncoding === n || !n(t4)))
                  throw new Error("Unknown encoding: " + t4);
                return e4 || t4;
              }(t3), this.encoding) {
                case "utf16le":
                  this.text = h, this.end = f, e3 = 4;
                  break;
                case "utf8":
                  this.fillLast = s, e3 = 4;
                  break;
                case "base64":
                  this.text = u, this.end = l, e3 = 3;
                  break;
                default:
                  return this.write = c, void (this.end = d);
              }
              this.lastNeed = 0, this.lastTotal = 0, this.lastChar = i.allocUnsafe(e3);
            }
            function o(t3) {
              return t3 <= 127 ? 0 : t3 >> 5 == 6 ? 2 : t3 >> 4 == 14 ? 3 : t3 >> 3 == 30 ? 4 : t3 >> 6 == 2 ? -1 : -2;
            }
            function s(t3) {
              var e3 = this.lastTotal - this.lastNeed, r3 = function(t4, e4, r4) {
                if (128 != (192 & e4[0]))
                  return t4.lastNeed = 0, "\uFFFD";
                if (t4.lastNeed > 1 && e4.length > 1) {
                  if (128 != (192 & e4[1]))
                    return t4.lastNeed = 1, "\uFFFD";
                  if (t4.lastNeed > 2 && e4.length > 2 && 128 != (192 & e4[2]))
                    return t4.lastNeed = 2, "\uFFFD";
                }
              }(this, t3);
              return void 0 !== r3 ? r3 : this.lastNeed <= t3.length ? (t3.copy(this.lastChar, e3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t3.copy(this.lastChar, e3, 0, t3.length), void (this.lastNeed -= t3.length));
            }
            function h(t3, e3) {
              if ((t3.length - e3) % 2 == 0) {
                var r3 = t3.toString("utf16le", e3);
                if (r3) {
                  var i2 = r3.charCodeAt(r3.length - 1);
                  if (i2 >= 55296 && i2 <= 56319)
                    return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t3[t3.length - 2], this.lastChar[1] = t3[t3.length - 1], r3.slice(0, -1);
                }
                return r3;
              }
              return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t3[t3.length - 1], t3.toString("utf16le", e3, t3.length - 1);
            }
            function f(t3) {
              var e3 = t3 && t3.length ? this.write(t3) : "";
              if (this.lastNeed) {
                var r3 = this.lastTotal - this.lastNeed;
                return e3 + this.lastChar.toString("utf16le", 0, r3);
              }
              return e3;
            }
            function u(t3, e3) {
              var r3 = (t3.length - e3) % 3;
              return 0 === r3 ? t3.toString("base64", e3) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 === r3 ? this.lastChar[0] = t3[t3.length - 1] : (this.lastChar[0] = t3[t3.length - 2], this.lastChar[1] = t3[t3.length - 1]), t3.toString("base64", e3, t3.length - r3));
            }
            function l(t3) {
              var e3 = t3 && t3.length ? this.write(t3) : "";
              return this.lastNeed ? e3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e3;
            }
            function c(t3) {
              return t3.toString(this.encoding);
            }
            function d(t3) {
              return t3 && t3.length ? this.write(t3) : "";
            }
            r2.StringDecoder = a, a.prototype.write = function(t3) {
              if (0 === t3.length)
                return "";
              var e3, r3;
              if (this.lastNeed) {
                if (void 0 === (e3 = this.fillLast(t3)))
                  return "";
                r3 = this.lastNeed, this.lastNeed = 0;
              } else
                r3 = 0;
              return r3 < t3.length ? e3 ? e3 + this.text(t3, r3) : this.text(t3, r3) : e3 || "";
            }, a.prototype.end = function(t3) {
              var e3 = t3 && t3.length ? this.write(t3) : "";
              return this.lastNeed ? e3 + "\uFFFD" : e3;
            }, a.prototype.text = function(t3, e3) {
              var r3 = function(t4, e4, r4) {
                var i3 = e4.length - 1;
                if (i3 < r4)
                  return 0;
                var n2 = o(e4[i3]);
                return n2 >= 0 ? (n2 > 0 && (t4.lastNeed = n2 - 1), n2) : --i3 < r4 || -2 === n2 ? 0 : (n2 = o(e4[i3])) >= 0 ? (n2 > 0 && (t4.lastNeed = n2 - 2), n2) : --i3 < r4 || -2 === n2 ? 0 : (n2 = o(e4[i3])) >= 0 ? (n2 > 0 && (2 === n2 ? n2 = 0 : t4.lastNeed = n2 - 3), n2) : 0;
              }(this, t3, e3);
              if (!this.lastNeed)
                return t3.toString("utf8", e3);
              this.lastTotal = r3;
              var i2 = t3.length - (r3 - this.lastNeed);
              return t3.copy(this.lastChar, 0, i2), t3.toString("utf8", e3, i2);
            }, a.prototype.fillLast = function(t3) {
              if (this.lastNeed <= t3.length)
                return t3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
              t3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t3.length), this.lastNeed -= t3.length;
            };
          }, { "safe-buffer": 77 }], 77: [function(t2, e2, r2) {
            var i = t2("buffer"), n = i.Buffer;
            function a(t3, e3) {
              for (var r3 in t3)
                e3[r3] = t3[r3];
            }
            function o(t3, e3, r3) {
              return n(t3, e3, r3);
            }
            n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e2.exports = i : (a(i, r2), r2.Buffer = o), o.prototype = Object.create(n.prototype), a(n, o), o.from = function(t3, e3, r3) {
              if ("number" == typeof t3)
                throw new TypeError("Argument must not be a number");
              return n(t3, e3, r3);
            }, o.alloc = function(t3, e3, r3) {
              if ("number" != typeof t3)
                throw new TypeError("Argument must be a number");
              var i2 = n(t3);
              return void 0 !== e3 ? "string" == typeof r3 ? i2.fill(e3, r3) : i2.fill(e3) : i2.fill(0), i2;
            }, o.allocUnsafe = function(t3) {
              if ("number" != typeof t3)
                throw new TypeError("Argument must be a number");
              return n(t3);
            }, o.allocUnsafeSlow = function(t3) {
              if ("number" != typeof t3)
                throw new TypeError("Argument must be a number");
              return i.SlowBuffer(t3);
            };
          }, { buffer: 33 }], 78: [function(t2, e2, i) {
            (function(t3) {
              (function() {
                function r2(e3) {
                  try {
                    if (!t3.localStorage)
                      return false;
                  } catch (t4) {
                    return false;
                  }
                  var r3 = t3.localStorage[e3];
                  return null != r3 && "true" === String(r3).toLowerCase();
                }
                e2.exports = function(t4, e3) {
                  if (r2("noDeprecation"))
                    return t4;
                  var i2 = false;
                  return function() {
                    if (!i2) {
                      if (r2("throwDeprecation"))
                        throw new Error(e3);
                      r2("traceDeprecation") ? console.trace(e3) : console.warn(e3), i2 = true;
                    }
                    return t4.apply(this, arguments);
                  };
                };
              }).call(this);
            }).call(this, void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, {}], 79: [function(t2, e2, r2) {
            arguments[4][25][0].apply(r2, arguments);
          }, { dup: 25 }], 80: [function(t2, e2, r2) {
            "use strict";
            var i = t2("is-arguments"), n = t2("is-generator-function"), a = t2("which-typed-array"), o = t2("is-typed-array");
            function s(t3) {
              return t3.call.bind(t3);
            }
            var h = "undefined" != typeof BigInt, f = "undefined" != typeof Symbol, u = s(Object.prototype.toString), l = s(Number.prototype.valueOf), c = s(String.prototype.valueOf), d = s(Boolean.prototype.valueOf);
            if (h)
              var p = s(BigInt.prototype.valueOf);
            if (f)
              var m = s(Symbol.prototype.valueOf);
            function g(t3, e3) {
              if ("object" != typeof t3)
                return false;
              try {
                return e3(t3), true;
              } catch (t4) {
                return false;
              }
            }
            function b(t3) {
              return "[object Map]" === u(t3);
            }
            function _(t3) {
              return "[object Set]" === u(t3);
            }
            function y(t3) {
              return "[object WeakMap]" === u(t3);
            }
            function w(t3) {
              return "[object WeakSet]" === u(t3);
            }
            function v(t3) {
              return "[object ArrayBuffer]" === u(t3);
            }
            function x(t3) {
              return "undefined" != typeof ArrayBuffer && (v.working ? v(t3) : t3 instanceof ArrayBuffer);
            }
            function E(t3) {
              return "[object DataView]" === u(t3);
            }
            function k(t3) {
              return "undefined" != typeof DataView && (E.working ? E(t3) : t3 instanceof DataView);
            }
            function S(t3) {
              return "[object SharedArrayBuffer]" === u(t3);
            }
            function M(t3) {
              return "undefined" != typeof SharedArrayBuffer && (S.working ? S(t3) : t3 instanceof SharedArrayBuffer);
            }
            function A(t3) {
              return g(t3, l);
            }
            function I(t3) {
              return g(t3, c);
            }
            function T(t3) {
              return g(t3, d);
            }
            function B(t3) {
              return h && g(t3, p);
            }
            function R(t3) {
              return f && g(t3, m);
            }
            r2.isArgumentsObject = i, r2.isGeneratorFunction = n, r2.isTypedArray = o, r2.isPromise = function(t3) {
              return "undefined" != typeof Promise && t3 instanceof Promise || null !== t3 && "object" == typeof t3 && "function" == typeof t3.then && "function" == typeof t3.catch;
            }, r2.isArrayBufferView = function(t3) {
              return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t3) : o(t3) || k(t3);
            }, r2.isUint8Array = function(t3) {
              return "Uint8Array" === a(t3);
            }, r2.isUint8ClampedArray = function(t3) {
              return "Uint8ClampedArray" === a(t3);
            }, r2.isUint16Array = function(t3) {
              return "Uint16Array" === a(t3);
            }, r2.isUint32Array = function(t3) {
              return "Uint32Array" === a(t3);
            }, r2.isInt8Array = function(t3) {
              return "Int8Array" === a(t3);
            }, r2.isInt16Array = function(t3) {
              return "Int16Array" === a(t3);
            }, r2.isInt32Array = function(t3) {
              return "Int32Array" === a(t3);
            }, r2.isFloat32Array = function(t3) {
              return "Float32Array" === a(t3);
            }, r2.isFloat64Array = function(t3) {
              return "Float64Array" === a(t3);
            }, r2.isBigInt64Array = function(t3) {
              return "BigInt64Array" === a(t3);
            }, r2.isBigUint64Array = function(t3) {
              return "BigUint64Array" === a(t3);
            }, b.working = "undefined" != typeof Map && b(/* @__PURE__ */ new Map()), r2.isMap = function(t3) {
              return "undefined" != typeof Map && (b.working ? b(t3) : t3 instanceof Map);
            }, _.working = "undefined" != typeof Set && _(/* @__PURE__ */ new Set()), r2.isSet = function(t3) {
              return "undefined" != typeof Set && (_.working ? _(t3) : t3 instanceof Set);
            }, y.working = "undefined" != typeof WeakMap && y(/* @__PURE__ */ new WeakMap()), r2.isWeakMap = function(t3) {
              return "undefined" != typeof WeakMap && (y.working ? y(t3) : t3 instanceof WeakMap);
            }, w.working = "undefined" != typeof WeakSet && w(/* @__PURE__ */ new WeakSet()), r2.isWeakSet = function(t3) {
              return w(t3);
            }, v.working = "undefined" != typeof ArrayBuffer && v(new ArrayBuffer()), r2.isArrayBuffer = x, E.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && E(new DataView(new ArrayBuffer(1), 0, 1)), r2.isDataView = k, S.working = "undefined" != typeof SharedArrayBuffer && S(new SharedArrayBuffer()), r2.isSharedArrayBuffer = M, r2.isAsyncFunction = function(t3) {
              return "[object AsyncFunction]" === u(t3);
            }, r2.isMapIterator = function(t3) {
              return "[object Map Iterator]" === u(t3);
            }, r2.isSetIterator = function(t3) {
              return "[object Set Iterator]" === u(t3);
            }, r2.isGeneratorObject = function(t3) {
              return "[object Generator]" === u(t3);
            }, r2.isWebAssemblyCompiledModule = function(t3) {
              return "[object WebAssembly.Module]" === u(t3);
            }, r2.isNumberObject = A, r2.isStringObject = I, r2.isBooleanObject = T, r2.isBigIntObject = B, r2.isSymbolObject = R, r2.isBoxedPrimitive = function(t3) {
              return A(t3) || I(t3) || T(t3) || B(t3) || R(t3);
            }, r2.isAnyArrayBuffer = function(t3) {
              return "undefined" != typeof Uint8Array && (x(t3) || M(t3));
            }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(t3) {
              Object.defineProperty(r2, t3, { enumerable: false, value: function() {
                throw new Error(t3 + " is not supported in userland");
              } });
            });
          }, { "is-arguments": 46, "is-generator-function": 47, "is-typed-array": 48, "which-typed-array": 82 }], 81: [function(t2, e2, r2) {
            (function(e3) {
              (function() {
                var i = Object.getOwnPropertyDescriptors || function(t3) {
                  for (var e4 = Object.keys(t3), r3 = {}, i2 = 0; i2 < e4.length; i2++)
                    r3[e4[i2]] = Object.getOwnPropertyDescriptor(t3, e4[i2]);
                  return r3;
                }, n = /%[sdj%]/g;
                r2.format = function(t3) {
                  if (!_(t3)) {
                    for (var e4 = [], r3 = 0; r3 < arguments.length; r3++)
                      e4.push(h(arguments[r3]));
                    return e4.join(" ");
                  }
                  r3 = 1;
                  for (var i2 = arguments, a2 = i2.length, o2 = String(t3).replace(n, function(t4) {
                    if ("%%" === t4)
                      return "%";
                    if (r3 >= a2)
                      return t4;
                    switch (t4) {
                      case "%s":
                        return String(i2[r3++]);
                      case "%d":
                        return Number(i2[r3++]);
                      case "%j":
                        try {
                          return JSON.stringify(i2[r3++]);
                        } catch (t5) {
                          return "[Circular]";
                        }
                      default:
                        return t4;
                    }
                  }), s2 = i2[r3]; r3 < a2; s2 = i2[++r3])
                    g(s2) || !v(s2) ? o2 += " " + s2 : o2 += " " + h(s2);
                  return o2;
                }, r2.deprecate = function(t3, i2) {
                  if (void 0 !== e3 && true === e3.noDeprecation)
                    return t3;
                  if (void 0 === e3)
                    return function() {
                      return r2.deprecate(t3, i2).apply(this, arguments);
                    };
                  var n2 = false;
                  return function() {
                    if (!n2) {
                      if (e3.throwDeprecation)
                        throw new Error(i2);
                      e3.traceDeprecation ? console.trace(i2) : console.error(i2), n2 = true;
                    }
                    return t3.apply(this, arguments);
                  };
                };
                var a = {}, o = /^$/;
                if (e3.env.NODE_DEBUG) {
                  var s = e3.env.NODE_DEBUG;
                  s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), o = new RegExp("^" + s + "$", "i");
                }
                function h(t3, e4) {
                  var i2 = { seen: [], stylize: u };
                  return arguments.length >= 3 && (i2.depth = arguments[2]), arguments.length >= 4 && (i2.colors = arguments[3]), m(e4) ? i2.showHidden = e4 : e4 && r2._extend(i2, e4), y(i2.showHidden) && (i2.showHidden = false), y(i2.depth) && (i2.depth = 2), y(i2.colors) && (i2.colors = false), y(i2.customInspect) && (i2.customInspect = true), i2.colors && (i2.stylize = f), l(i2, t3, i2.depth);
                }
                function f(t3, e4) {
                  var r3 = h.styles[e4];
                  return r3 ? "\x1B[" + h.colors[r3][0] + "m" + t3 + "\x1B[" + h.colors[r3][1] + "m" : t3;
                }
                function u(t3, e4) {
                  return t3;
                }
                function l(t3, e4, i2) {
                  if (t3.customInspect && e4 && k(e4.inspect) && e4.inspect !== r2.inspect && (!e4.constructor || e4.constructor.prototype !== e4)) {
                    var n2 = e4.inspect(i2, t3);
                    return _(n2) || (n2 = l(t3, n2, i2)), n2;
                  }
                  var a2 = function(t4, e5) {
                    if (y(e5))
                      return t4.stylize("undefined", "undefined");
                    if (_(e5)) {
                      var r3 = "'" + JSON.stringify(e5).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                      return t4.stylize(r3, "string");
                    }
                    return b(e5) ? t4.stylize("" + e5, "number") : m(e5) ? t4.stylize("" + e5, "boolean") : g(e5) ? t4.stylize("null", "null") : void 0;
                  }(t3, e4);
                  if (a2)
                    return a2;
                  var o2 = Object.keys(e4), s2 = function(t4) {
                    var e5 = {};
                    return t4.forEach(function(t5, r3) {
                      e5[t5] = true;
                    }), e5;
                  }(o2);
                  if (t3.showHidden && (o2 = Object.getOwnPropertyNames(e4)), E(e4) && (o2.indexOf("message") >= 0 || o2.indexOf("description") >= 0))
                    return c(e4);
                  if (0 === o2.length) {
                    if (k(e4)) {
                      var h2 = e4.name ? ": " + e4.name : "";
                      return t3.stylize("[Function" + h2 + "]", "special");
                    }
                    if (w(e4))
                      return t3.stylize(RegExp.prototype.toString.call(e4), "regexp");
                    if (x(e4))
                      return t3.stylize(Date.prototype.toString.call(e4), "date");
                    if (E(e4))
                      return c(e4);
                  }
                  var f2, u2 = "", v2 = false, S2 = ["{", "}"];
                  return p(e4) && (v2 = true, S2 = ["[", "]"]), k(e4) && (u2 = " [Function" + (e4.name ? ": " + e4.name : "") + "]"), w(e4) && (u2 = " " + RegExp.prototype.toString.call(e4)), x(e4) && (u2 = " " + Date.prototype.toUTCString.call(e4)), E(e4) && (u2 = " " + c(e4)), 0 !== o2.length || v2 && 0 != e4.length ? i2 < 0 ? w(e4) ? t3.stylize(RegExp.prototype.toString.call(e4), "regexp") : t3.stylize("[Object]", "special") : (t3.seen.push(e4), f2 = v2 ? function(t4, e5, r3, i3, n3) {
                    for (var a3 = [], o3 = 0, s3 = e5.length; o3 < s3; ++o3)
                      I(e5, String(o3)) ? a3.push(d(t4, e5, r3, i3, String(o3), true)) : a3.push("");
                    return n3.forEach(function(n4) {
                      n4.match(/^\d+$/) || a3.push(d(t4, e5, r3, i3, n4, true));
                    }), a3;
                  }(t3, e4, i2, s2, o2) : o2.map(function(r3) {
                    return d(t3, e4, i2, s2, r3, v2);
                  }), t3.seen.pop(), function(t4, e5, r3) {
                    return t4.reduce(function(t5, e6) {
                      return e6.indexOf("\n"), t5 + e6.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0) > 60 ? r3[0] + ("" === e5 ? "" : e5 + "\n ") + " " + t4.join(",\n  ") + " " + r3[1] : r3[0] + e5 + " " + t4.join(", ") + " " + r3[1];
                  }(f2, u2, S2)) : S2[0] + u2 + S2[1];
                }
                function c(t3) {
                  return "[" + Error.prototype.toString.call(t3) + "]";
                }
                function d(t3, e4, r3, i2, n2, a2) {
                  var o2, s2, h2;
                  if ((h2 = Object.getOwnPropertyDescriptor(e4, n2) || { value: e4[n2] }).get ? s2 = h2.set ? t3.stylize("[Getter/Setter]", "special") : t3.stylize("[Getter]", "special") : h2.set && (s2 = t3.stylize("[Setter]", "special")), I(i2, n2) || (o2 = "[" + n2 + "]"), s2 || (t3.seen.indexOf(h2.value) < 0 ? (s2 = g(r3) ? l(t3, h2.value, null) : l(t3, h2.value, r3 - 1)).indexOf("\n") > -1 && (s2 = a2 ? s2.split("\n").map(function(t4) {
                    return "  " + t4;
                  }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(t4) {
                    return "   " + t4;
                  }).join("\n")) : s2 = t3.stylize("[Circular]", "special")), y(o2)) {
                    if (a2 && n2.match(/^\d+$/))
                      return s2;
                    (o2 = JSON.stringify("" + n2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = t3.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = t3.stylize(o2, "string"));
                  }
                  return o2 + ": " + s2;
                }
                function p(t3) {
                  return Array.isArray(t3);
                }
                function m(t3) {
                  return "boolean" == typeof t3;
                }
                function g(t3) {
                  return null === t3;
                }
                function b(t3) {
                  return "number" == typeof t3;
                }
                function _(t3) {
                  return "string" == typeof t3;
                }
                function y(t3) {
                  return void 0 === t3;
                }
                function w(t3) {
                  return v(t3) && "[object RegExp]" === S(t3);
                }
                function v(t3) {
                  return "object" == typeof t3 && null !== t3;
                }
                function x(t3) {
                  return v(t3) && "[object Date]" === S(t3);
                }
                function E(t3) {
                  return v(t3) && ("[object Error]" === S(t3) || t3 instanceof Error);
                }
                function k(t3) {
                  return "function" == typeof t3;
                }
                function S(t3) {
                  return Object.prototype.toString.call(t3);
                }
                function M(t3) {
                  return t3 < 10 ? "0" + t3.toString(10) : t3.toString(10);
                }
                r2.debuglog = function(t3) {
                  if (t3 = t3.toUpperCase(), !a[t3])
                    if (o.test(t3)) {
                      var i2 = e3.pid;
                      a[t3] = function() {
                        var e4 = r2.format.apply(r2, arguments);
                        console.error("%s %d: %s", t3, i2, e4);
                      };
                    } else
                      a[t3] = function() {
                      };
                  return a[t3];
                }, r2.inspect = h, h.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, h.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, r2.types = t2("./support/types"), r2.isArray = p, r2.isBoolean = m, r2.isNull = g, r2.isNullOrUndefined = function(t3) {
                  return null == t3;
                }, r2.isNumber = b, r2.isString = _, r2.isSymbol = function(t3) {
                  return "symbol" == typeof t3;
                }, r2.isUndefined = y, r2.isRegExp = w, r2.types.isRegExp = w, r2.isObject = v, r2.isDate = x, r2.types.isDate = x, r2.isError = E, r2.types.isNativeError = E, r2.isFunction = k, r2.isPrimitive = function(t3) {
                  return null === t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || "symbol" == typeof t3 || void 0 === t3;
                }, r2.isBuffer = t2("./support/isBuffer");
                var A = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                function I(t3, e4) {
                  return Object.prototype.hasOwnProperty.call(t3, e4);
                }
                r2.log = function() {
                  var t3, e4;
                  console.log("%s - %s", (t3 = /* @__PURE__ */ new Date(), e4 = [M(t3.getHours()), M(t3.getMinutes()), M(t3.getSeconds())].join(":"), [t3.getDate(), A[t3.getMonth()], e4].join(" ")), r2.format.apply(r2, arguments));
                }, r2.inherits = t2("inherits"), r2._extend = function(t3, e4) {
                  if (!e4 || !v(e4))
                    return t3;
                  for (var r3 = Object.keys(e4), i2 = r3.length; i2--; )
                    t3[r3[i2]] = e4[r3[i2]];
                  return t3;
                };
                var T = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
                function B(t3, e4) {
                  if (!t3) {
                    var r3 = new Error("Promise was rejected with a falsy value");
                    r3.reason = t3, t3 = r3;
                  }
                  return e4(t3);
                }
                r2.promisify = function(t3) {
                  if ("function" != typeof t3)
                    throw new TypeError('The "original" argument must be of type Function');
                  if (T && t3[T]) {
                    var e4;
                    if ("function" != typeof (e4 = t3[T]))
                      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                    return Object.defineProperty(e4, T, { value: e4, enumerable: false, writable: false, configurable: true }), e4;
                  }
                  function e4() {
                    for (var e5, r3, i2 = new Promise(function(t4, i3) {
                      e5 = t4, r3 = i3;
                    }), n2 = [], a2 = 0; a2 < arguments.length; a2++)
                      n2.push(arguments[a2]);
                    n2.push(function(t4, i3) {
                      t4 ? r3(t4) : e5(i3);
                    });
                    try {
                      t3.apply(this, n2);
                    } catch (t4) {
                      r3(t4);
                    }
                    return i2;
                  }
                  return Object.setPrototypeOf(e4, Object.getPrototypeOf(t3)), T && Object.defineProperty(e4, T, { value: e4, enumerable: false, writable: false, configurable: true }), Object.defineProperties(e4, i(t3));
                }, r2.promisify.custom = T, r2.callbackify = function(t3) {
                  if ("function" != typeof t3)
                    throw new TypeError('The "original" argument must be of type Function');
                  function r3() {
                    for (var r4 = [], i2 = 0; i2 < arguments.length; i2++)
                      r4.push(arguments[i2]);
                    var n2 = r4.pop();
                    if ("function" != typeof n2)
                      throw new TypeError("The last argument must be of type Function");
                    var a2 = this, o2 = function() {
                      return n2.apply(a2, arguments);
                    };
                    t3.apply(this, r4).then(function(t4) {
                      e3.nextTick(o2.bind(null, null, t4));
                    }, function(t4) {
                      e3.nextTick(B.bind(null, t4, o2));
                    });
                  }
                  return Object.setPrototypeOf(r3, Object.getPrototypeOf(t3)), Object.defineProperties(r3, i(t3)), r3;
                };
              }).call(this);
            }).call(this, t2("_process"));
          }, { "./support/isBuffer": 79, "./support/types": 80, _process: 60, inherits: 45 }], 82: [function(t2, e2, i) {
            (function(r2) {
              (function() {
                "use strict";
                var i2 = t2("foreach"), n = t2("available-typed-arrays"), a = t2("es-abstract/helpers/callBound"), o = a("Object.prototype.toString"), s = t2("has-symbols")() && "symbol" == typeof Symbol.toStringTag, h = n(), f = a("String.prototype.slice"), u = {}, l = t2("es-abstract/helpers/getOwnPropertyDescriptor"), c = Object.getPrototypeOf;
                s && l && c && i2(h, function(t3) {
                  if ("function" == typeof r2[t3]) {
                    var e3 = new r2[t3]();
                    if (!(Symbol.toStringTag in e3))
                      throw new EvalError("this engine has support for Symbol.toStringTag, but " + t3 + " does not have the property! Please report this.");
                    var i3 = c(e3), n2 = l(i3, Symbol.toStringTag);
                    if (!n2) {
                      var a2 = c(i3);
                      n2 = l(a2, Symbol.toStringTag);
                    }
                    u[t3] = n2.get;
                  }
                });
                var d = t2("is-typed-array");
                e2.exports = function(t3) {
                  return !!d(t3) && (s ? function(t4) {
                    var e3 = false;
                    return i2(u, function(r3, i3) {
                      if (!e3)
                        try {
                          var n2 = r3.call(t4);
                          n2 === i3 && (e3 = n2);
                        } catch (t5) {
                        }
                    }), e3;
                  }(t3) : f(o(t3), 8, -1));
                };
              }).call(this);
            }).call(this, void 0 !== r.g ? r.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
          }, { "available-typed-arrays": 27, "es-abstract/helpers/callBound": 36, "es-abstract/helpers/getOwnPropertyDescriptor": 37, foreach: 39, "has-symbols": 42, "is-typed-array": 48 }] }, {}, [20])(20);
        }, 4406: (t) => {
          var e = t.exports = {};
          e.nextTick = function() {
            var t2 = "undefined" != typeof window && window.setImmediate, e2 = "undefined" != typeof window && window.postMessage && window.addEventListener;
            if (t2)
              return function(t3) {
                return window.setImmediate(t3);
              };
            if (e2) {
              var r = [];
              return window.addEventListener("message", function(t3) {
                var e3 = t3.source;
                e3 !== window && null !== e3 || "process-tick" !== t3.data || (t3.stopPropagation(), r.length > 0 && r.shift()());
              }, true), function(t3) {
                r.push(t3), window.postMessage("process-tick", "*");
              };
            }
            return function(t3) {
              setTimeout(t3, 0);
            };
          }(), e.title = "browser", e.browser = true, e.env = {}, e.argv = [], e.binding = function(t2) {
            throw new Error("process.binding is not supported");
          }, e.cwd = function() {
            return "/";
          }, e.chdir = function(t2) {
            throw new Error("process.chdir is not supported");
          };
        }, 6197: (t, e, r) => {
          "use strict";
          var i = r(8834).lW;
          Object.defineProperty(e, "__esModule", { value: true }), e.AbstractTokenizer = void 0;
          const n = r(4644);
          e.AbstractTokenizer = class {
            constructor(t2) {
              this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = t2 || {};
            }
            async readToken(t2, e2 = this.position) {
              const r2 = i.alloc(t2.len);
              if (await this.readBuffer(r2, { position: e2 }) < t2.len)
                throw new n.EndOfStreamError();
              return t2.get(r2, 0);
            }
            async peekToken(t2, e2 = this.position) {
              const r2 = i.alloc(t2.len);
              if (await this.peekBuffer(r2, { position: e2 }) < t2.len)
                throw new n.EndOfStreamError();
              return t2.get(r2, 0);
            }
            async readNumber(t2) {
              if (await this.readBuffer(this.numBuffer, { length: t2.len }) < t2.len)
                throw new n.EndOfStreamError();
              return t2.get(this.numBuffer, 0);
            }
            async peekNumber(t2) {
              if (await this.peekBuffer(this.numBuffer, { length: t2.len }) < t2.len)
                throw new n.EndOfStreamError();
              return t2.get(this.numBuffer, 0);
            }
            async ignore(t2) {
              if (void 0 !== this.fileInfo.size) {
                const e2 = this.fileInfo.size - this.position;
                if (t2 > e2)
                  return this.position += e2, e2;
              }
              return this.position += t2, t2;
            }
            async close() {
            }
            normalizeOptions(t2, e2) {
              if (e2 && void 0 !== e2.position && e2.position < this.position)
                throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
              return e2 ? { mayBeLess: true === e2.mayBeLess, offset: e2.offset ? e2.offset : 0, length: e2.length ? e2.length : t2.length - (e2.offset ? e2.offset : 0), position: e2.position ? e2.position : this.position } : { mayBeLess: false, offset: 0, length: t2.length, position: this.position };
            }
          };
        }, 932: (t, e, r) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.BufferTokenizer = void 0;
          const i = r(4644), n = r(6197);
          class a extends n.AbstractTokenizer {
            constructor(t2, e2) {
              super(e2), this.uint8Array = t2, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : t2.length;
            }
            async readBuffer(t2, e2) {
              if (e2 && e2.position) {
                if (e2.position < this.position)
                  throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
                this.position = e2.position;
              }
              const r2 = await this.peekBuffer(t2, e2);
              return this.position += r2, r2;
            }
            async peekBuffer(t2, e2) {
              const r2 = this.normalizeOptions(t2, e2), n2 = Math.min(this.uint8Array.length - r2.position, r2.length);
              if (!r2.mayBeLess && n2 < r2.length)
                throw new i.EndOfStreamError();
              return t2.set(this.uint8Array.subarray(r2.position, r2.position + n2), r2.offset), n2;
            }
            async close() {
            }
          }
          e.BufferTokenizer = a;
        }, 9425: (t, e, r) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.fromFile = e.FileTokenizer = void 0;
          const i = r(6197), n = r(4644), a = r(5187);
          class o extends i.AbstractTokenizer {
            constructor(t2, e2) {
              super(e2), this.fd = t2;
            }
            async readBuffer(t2, e2) {
              const r2 = this.normalizeOptions(t2, e2);
              this.position = r2.position;
              const i2 = await a.read(this.fd, t2, r2.offset, r2.length, r2.position);
              if (this.position += i2.bytesRead, i2.bytesRead < r2.length && (!e2 || !e2.mayBeLess))
                throw new n.EndOfStreamError();
              return i2.bytesRead;
            }
            async peekBuffer(t2, e2) {
              const r2 = this.normalizeOptions(t2, e2), i2 = await a.read(this.fd, t2, r2.offset, r2.length, r2.position);
              if (!r2.mayBeLess && i2.bytesRead < r2.length)
                throw new n.EndOfStreamError();
              return i2.bytesRead;
            }
            async close() {
              return a.close(this.fd);
            }
          }
          e.FileTokenizer = o, e.fromFile = async function(t2) {
            const e2 = await a.stat(t2);
            if (!e2.isFile)
              throw new Error(`File not a file: ${t2}`);
            const r2 = await a.open(t2, "r");
            return new o(r2, { path: t2, size: e2.size });
          };
        }, 5187: (t, e, r) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.readFile = e.writeFileSync = e.writeFile = e.read = e.open = e.close = e.stat = e.createReadStream = e.pathExists = void 0;
          const i = r(6777);
          e.pathExists = i.existsSync, e.createReadStream = i.createReadStream, e.stat = async function(t2) {
            return new Promise((e2, r2) => {
              i.stat(t2, (t3, i2) => {
                t3 ? r2(t3) : e2(i2);
              });
            });
          }, e.close = async function(t2) {
            return new Promise((e2, r2) => {
              i.close(t2, (t3) => {
                t3 ? r2(t3) : e2();
              });
            });
          }, e.open = async function(t2, e2) {
            return new Promise((r2, n) => {
              i.open(t2, e2, (t3, e3) => {
                t3 ? n(t3) : r2(e3);
              });
            });
          }, e.read = async function(t2, e2, r2, n, a) {
            return new Promise((o, s) => {
              i.read(t2, e2, r2, n, a, (t3, e3, r3) => {
                t3 ? s(t3) : o({ bytesRead: e3, buffer: r3 });
              });
            });
          }, e.writeFile = async function(t2, e2) {
            return new Promise((r2, n) => {
              i.writeFile(t2, e2, (t3) => {
                t3 ? n(t3) : r2();
              });
            });
          }, e.writeFileSync = function(t2, e2) {
            i.writeFileSync(t2, e2);
          }, e.readFile = async function(t2) {
            return new Promise((e2, r2) => {
              i.readFile(t2, (t3, i2) => {
                t3 ? r2(t3) : e2(i2);
              });
            });
          };
        }, 8286: (t, e, r) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.ReadStreamTokenizer = void 0;
          const i = r(6197), n = r(4644);
          class a extends i.AbstractTokenizer {
            constructor(t2, e2) {
              super(e2), this.streamReader = new n.StreamReader(t2);
            }
            async getFileInfo() {
              return this.fileInfo;
            }
            async readBuffer(t2, e2) {
              const r2 = this.normalizeOptions(t2, e2), i2 = r2.position - this.position;
              if (i2 > 0)
                return await this.ignore(i2), this.readBuffer(t2, e2);
              if (i2 < 0)
                throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
              if (0 === r2.length)
                return 0;
              const a2 = await this.streamReader.read(t2, r2.offset, r2.length);
              if (this.position += a2, (!e2 || !e2.mayBeLess) && a2 < r2.length)
                throw new n.EndOfStreamError();
              return a2;
            }
            async peekBuffer(t2, e2) {
              const r2 = this.normalizeOptions(t2, e2);
              let i2 = 0;
              if (r2.position) {
                const e3 = r2.position - this.position;
                if (e3 > 0) {
                  const n2 = new Uint8Array(r2.length + e3);
                  return i2 = await this.peekBuffer(n2, { mayBeLess: r2.mayBeLess }), t2.set(n2.subarray(e3), r2.offset), i2 - e3;
                }
                if (e3 < 0)
                  throw new Error("Cannot peek from a negative offset in a stream");
              }
              if (r2.length > 0) {
                try {
                  i2 = await this.streamReader.peek(t2, r2.offset, r2.length);
                } catch (t3) {
                  if (e2 && e2.mayBeLess && t3 instanceof n.EndOfStreamError)
                    return 0;
                  throw t3;
                }
                if (!r2.mayBeLess && i2 < r2.length)
                  throw new n.EndOfStreamError();
              }
              return i2;
            }
            async ignore(t2) {
              const e2 = Math.min(256e3, t2), r2 = new Uint8Array(e2);
              let i2 = 0;
              for (; i2 < t2; ) {
                const n2 = t2 - i2, a2 = await this.readBuffer(r2, { length: Math.min(e2, n2) });
                if (a2 < 0)
                  return a2;
                i2 += a2;
              }
              return i2;
            }
          }
          e.ReadStreamTokenizer = a;
        }, 7378: (t, e, r) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.fromBuffer = e.fromStream = e.EndOfStreamError = void 0;
          const i = r(8286), n = r(932);
          var a = r(4644);
          Object.defineProperty(e, "EndOfStreamError", { enumerable: true, get: function() {
            return a.EndOfStreamError;
          } }), e.fromStream = function(t2, e2) {
            return e2 = e2 || {}, new i.ReadStreamTokenizer(t2, e2);
          }, e.fromBuffer = function(t2, e2) {
            return new n.BufferTokenizer(t2, e2);
          };
        }, 3569: (t, e, r) => {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.fromStream = e.fromBuffer = e.EndOfStreamError = e.fromFile = void 0;
          const i = r(5187), n = r(7378);
          var a = r(9425);
          Object.defineProperty(e, "fromFile", { enumerable: true, get: function() {
            return a.fromFile;
          } });
          var o = r(7378);
          Object.defineProperty(e, "EndOfStreamError", { enumerable: true, get: function() {
            return o.EndOfStreamError;
          } }), Object.defineProperty(e, "fromBuffer", { enumerable: true, get: function() {
            return o.fromBuffer;
          } }), e.fromStream = async function(t2, e2) {
            if (e2 = e2 || {}, t2.path) {
              const r2 = await i.stat(t2.path);
              e2.path = t2.path, e2.size = r2.size;
            }
            return n.fromStream(t2, e2);
          };
        }, 643: (t, e) => {
          "use strict";
          var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
            return typeof t2;
          } : function(t2) {
            return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
          };
          e.Ee = function(t2, e2, r2, i2, n2, a2) {
            for (var o2 = arguments.length, h2 = Array(o2 > 6 ? o2 - 6 : 0), f = 6; f < o2; f++)
              h2[f - 6] = arguments[f];
            return h2.length ? s.call.apply(s, [null, false, true, t2, e2, r2, i2, n2, a2].concat(h2)) : s(false, true, t2, e2, r2, i2, n2, a2);
          };
          var i = "INVALID_ARGS";
          function n(t2) {
            throw new Error(t2);
          }
          function a(t2) {
            var e2 = Object.keys(t2);
            return Object.getOwnPropertySymbols ? e2.concat(Object.getOwnPropertySymbols(t2)) : e2;
          }
          function o(t2) {
            if (Array.isArray(t2))
              return t2.slice();
            for (var e2 = a(t2), r2 = {}, i2 = 0; i2 < e2.length; i2++) {
              var n2 = e2[i2];
              r2[n2] = t2[n2];
            }
            return r2;
          }
          function s(t2, e2, r2) {
            var f = r2;
            null == f && n(i);
            for (var u = false, l = arguments.length, c = Array(l > 3 ? l - 3 : 0), d = 3; d < l; d++)
              c[d - 3] = arguments[d];
            for (var p = 0; p < c.length; p++) {
              var m = c[p];
              if (null != m) {
                var g = a(m);
                if (g.length)
                  for (var b = 0; b <= g.length; b++) {
                    var _ = g[b];
                    if (!t2 || void 0 === f[_]) {
                      var y = m[_];
                      e2 && h(f[_]) && h(y) && (y = s(t2, e2, f[_], y)), void 0 !== y && y !== f[_] && (u || (u = true, f = o(f)), f[_] = y);
                    }
                  }
              }
            }
            return f;
          }
          function h(t2) {
            var e2 = void 0 === t2 ? "undefined" : r(t2);
            return null != t2 && "object" === e2;
          }
        }, 5010: (t, e, r) => {
          "use strict";
          var i = r(8834).lW;
          Object.defineProperty(e, "__esModule", { value: true }), e.AnsiStringType = e.StringType = e.BufferType = e.Uint8ArrayType = e.IgnoreType = e.Float80_LE = e.Float80_BE = e.Float64_LE = e.Float64_BE = e.Float32_LE = e.Float32_BE = e.Float16_LE = e.Float16_BE = e.INT64_BE = e.UINT64_BE = e.INT64_LE = e.UINT64_LE = e.INT32_LE = e.INT32_BE = e.INT24_BE = e.INT24_LE = e.INT16_LE = e.INT16_BE = e.INT8 = e.UINT32_BE = e.UINT32_LE = e.UINT24_BE = e.UINT24_LE = e.UINT16_BE = e.UINT16_LE = e.UINT8 = void 0;
          const n = r(2333);
          function a(t2) {
            return new DataView(t2.buffer, t2.byteOffset);
          }
          e.UINT8 = { len: 1, get: (t2, e2) => a(t2).getUint8(e2), put: (t2, e2, r2) => (a(t2).setUint8(e2, r2), e2 + 1) }, e.UINT16_LE = { len: 2, get: (t2, e2) => a(t2).getUint16(e2, true), put: (t2, e2, r2) => (a(t2).setUint16(e2, r2, true), e2 + 2) }, e.UINT16_BE = { len: 2, get: (t2, e2) => a(t2).getUint16(e2), put: (t2, e2, r2) => (a(t2).setUint16(e2, r2), e2 + 2) }, e.UINT24_LE = { len: 3, get(t2, e2) {
            const r2 = a(t2);
            return r2.getUint8(e2) + (r2.getUint16(e2 + 1, true) << 8);
          }, put(t2, e2, r2) {
            const i2 = a(t2);
            return i2.setUint8(e2, 255 & r2), i2.setUint16(e2 + 1, r2 >> 8, true), e2 + 3;
          } }, e.UINT24_BE = { len: 3, get(t2, e2) {
            const r2 = a(t2);
            return (r2.getUint16(e2) << 8) + r2.getUint8(e2 + 2);
          }, put(t2, e2, r2) {
            const i2 = a(t2);
            return i2.setUint16(e2, r2 >> 8), i2.setUint8(e2 + 2, 255 & r2), e2 + 3;
          } }, e.UINT32_LE = { len: 4, get: (t2, e2) => a(t2).getUint32(e2, true), put: (t2, e2, r2) => (a(t2).setUint32(e2, r2, true), e2 + 4) }, e.UINT32_BE = { len: 4, get: (t2, e2) => a(t2).getUint32(e2), put: (t2, e2, r2) => (a(t2).setUint32(e2, r2), e2 + 4) }, e.INT8 = { len: 1, get: (t2, e2) => a(t2).getInt8(e2), put: (t2, e2, r2) => (a(t2).setInt8(e2, r2), e2 + 1) }, e.INT16_BE = { len: 2, get: (t2, e2) => a(t2).getInt16(e2), put: (t2, e2, r2) => (a(t2).setInt16(e2, r2), e2 + 2) }, e.INT16_LE = { len: 2, get: (t2, e2) => a(t2).getInt16(e2, true), put: (t2, e2, r2) => (a(t2).setInt16(e2, r2, true), e2 + 2) }, e.INT24_LE = { len: 3, get(t2, r2) {
            const i2 = e.UINT24_LE.get(t2, r2);
            return i2 > 8388607 ? i2 - 16777216 : i2;
          }, put(t2, e2, r2) {
            const i2 = a(t2);
            return i2.setUint8(e2, 255 & r2), i2.setUint16(e2 + 1, r2 >> 8, true), e2 + 3;
          } }, e.INT24_BE = { len: 3, get(t2, r2) {
            const i2 = e.UINT24_BE.get(t2, r2);
            return i2 > 8388607 ? i2 - 16777216 : i2;
          }, put(t2, e2, r2) {
            const i2 = a(t2);
            return i2.setUint16(e2, r2 >> 8), i2.setUint8(e2 + 2, 255 & r2), e2 + 3;
          } }, e.INT32_BE = { len: 4, get: (t2, e2) => a(t2).getInt32(e2), put: (t2, e2, r2) => (a(t2).setInt32(e2, r2), e2 + 4) }, e.INT32_LE = { len: 4, get: (t2, e2) => a(t2).getInt32(e2, true), put: (t2, e2, r2) => (a(t2).setInt32(e2, r2, true), e2 + 4) }, e.UINT64_LE = { len: 8, get: (t2, e2) => a(t2).getBigUint64(e2, true), put: (t2, e2, r2) => (a(t2).setBigUint64(e2, r2, true), e2 + 8) }, e.INT64_LE = { len: 8, get: (t2, e2) => a(t2).getBigInt64(e2, true), put: (t2, e2, r2) => (a(t2).setBigInt64(e2, r2, true), e2 + 8) }, e.UINT64_BE = { len: 8, get: (t2, e2) => a(t2).getBigUint64(e2), put: (t2, e2, r2) => (a(t2).setBigUint64(e2, r2), e2 + 8) }, e.INT64_BE = { len: 8, get: (t2, e2) => a(t2).getBigInt64(e2), put: (t2, e2, r2) => (a(t2).setBigInt64(e2, r2), e2 + 8) }, e.Float16_BE = { len: 2, get(t2, e2) {
            return n.read(t2, e2, false, 10, this.len);
          }, put(t2, e2, r2) {
            return n.write(t2, r2, e2, false, 10, this.len), e2 + this.len;
          } }, e.Float16_LE = { len: 2, get(t2, e2) {
            return n.read(t2, e2, true, 10, this.len);
          }, put(t2, e2, r2) {
            return n.write(t2, r2, e2, true, 10, this.len), e2 + this.len;
          } }, e.Float32_BE = { len: 4, get: (t2, e2) => a(t2).getFloat32(e2), put: (t2, e2, r2) => (a(t2).setFloat32(e2, r2), e2 + 4) }, e.Float32_LE = { len: 4, get: (t2, e2) => a(t2).getFloat32(e2, true), put: (t2, e2, r2) => (a(t2).setFloat32(e2, r2, true), e2 + 4) }, e.Float64_BE = { len: 8, get: (t2, e2) => a(t2).getFloat64(e2), put: (t2, e2, r2) => (a(t2).setFloat64(e2, r2), e2 + 8) }, e.Float64_LE = { len: 8, get: (t2, e2) => a(t2).getFloat64(e2, true), put: (t2, e2, r2) => (a(t2).setFloat64(e2, r2, true), e2 + 8) }, e.Float80_BE = { len: 10, get(t2, e2) {
            return n.read(t2, e2, false, 63, this.len);
          }, put(t2, e2, r2) {
            return n.write(t2, r2, e2, false, 63, this.len), e2 + this.len;
          } }, e.Float80_LE = { len: 10, get(t2, e2) {
            return n.read(t2, e2, true, 63, this.len);
          }, put(t2, e2, r2) {
            return n.write(t2, r2, e2, true, 63, this.len), e2 + this.len;
          } }, e.IgnoreType = class {
            constructor(t2) {
              this.len = t2;
            }
            get(t2, e2) {
            }
          }, e.Uint8ArrayType = class {
            constructor(t2) {
              this.len = t2;
            }
            get(t2, e2) {
              return t2.subarray(e2, e2 + this.len);
            }
          }, e.BufferType = class {
            constructor(t2) {
              this.len = t2;
            }
            get(t2, e2) {
              return i.from(t2.subarray(e2, e2 + this.len));
            }
          }, e.StringType = class {
            constructor(t2, e2) {
              this.len = t2, this.encoding = e2;
            }
            get(t2, e2) {
              return i.from(t2).toString(this.encoding, e2, e2 + this.len);
            }
          };
          class o {
            constructor(t2) {
              this.len = t2;
            }
            static decode(t2, e2, r2) {
              let i2 = "";
              for (let n2 = e2; n2 < r2; ++n2)
                i2 += o.codePointToString(o.singleByteDecoder(t2[n2]));
              return i2;
            }
            static inRange(t2, e2, r2) {
              return e2 <= t2 && t2 <= r2;
            }
            static codePointToString(t2) {
              return t2 <= 65535 ? String.fromCharCode(t2) : (t2 -= 65536, String.fromCharCode(55296 + (t2 >> 10), 56320 + (1023 & t2)));
            }
            static singleByteDecoder(t2) {
              if (o.inRange(t2, 0, 127))
                return t2;
              const e2 = o.windows1252[t2 - 128];
              if (null === e2)
                throw Error("invaliding encoding");
              return e2;
            }
            get(t2, e2 = 0) {
              return o.decode(t2, e2, e2 + this.len);
            }
          }
          e.AnsiStringType = o, o.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
        }, 311: (t, e) => {
          (e = t.exports = function(t2) {
            return t2.replace(/^\s*|\s*$/g, "");
          }).left = function(t2) {
            return t2.replace(/^\s*/, "");
          }, e.right = function(t2) {
            return t2.replace(/\s*$/, "");
          };
        }, 9299: (t, e, r) => {
          var i = r(4406);
          !function() {
            var e2 = {};
            function n() {
              void 0 === i && console.log.apply(console, arguments);
            }
            t.exports = e2, function(t2, e3) {
              var r2, i2, a, o, s, h, f, u, l, c, d, p, m, g, b;
              !function() {
                "use strict";
                var e4 = function() {
                  function t3(t4) {
                    this.message = "JPEG error: " + t4;
                  }
                  return t3.prototype = new Error(), t3.prototype.name = "JpegError", t3.constructor = t3, t3;
                }(), r3 = function() {
                  var t3 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), r4 = 4017, n2 = 799, a2 = 3406, o2 = 2276, s2 = 1567, h2 = 3784, f2 = 5793, u2 = 2896;
                  function l2(t4) {
                    null == t4 && (t4 = {}), null == t4.w && (t4.w = -1), this.V = t4.n, this.N = t4.w;
                  }
                  function c2(t4, e5) {
                    for (var r5, i4, n3, a3 = 0, o3 = [], s3 = 16; s3 > 0 && !t4[s3 - 1]; )
                      s3--;
                    o3.push({ children: [], index: 0 });
                    var h3 = o3[0];
                    for (r5 = 0; r5 < s3; r5++) {
                      for (i4 = 0; i4 < t4[r5]; i4++) {
                        for ((h3 = o3.pop()).children[h3.index] = e5[a3]; h3.index > 0; )
                          h3 = o3.pop();
                        for (h3.index++, o3.push(h3); o3.length <= r5; )
                          o3.push(n3 = { children: [], index: 0 }), h3.children[h3.index] = n3.children, h3 = n3;
                        a3++;
                      }
                      r5 + 1 < s3 && (o3.push(n3 = { children: [], index: 0 }), h3.children[h3.index] = n3.children, h3 = n3);
                    }
                    return o3[0].children;
                  }
                  function d2(t4, e5, r5) {
                    return 64 * ((t4.P + 1) * e5 + r5);
                  }
                  function p2(r5, n3, a3, o3, s3, h3, f3, u3, l3, c3) {
                    null == c3 && (c3 = false);
                    var p3, m3, g3, _, y, w, v, x, E, k, S, M = a3.m, A = a3.Z, I = n3, T = 0, B = 0, R = 0, P = 0, O = 0, L = 0;
                    function C() {
                      if (B > 0)
                        return B--, T >> B & 1;
                      if (255 === (T = r5[n3++])) {
                        var t4 = r5[n3++];
                        if (t4) {
                          if (220 === t4 && c3) {
                            var o4 = i3(r5, n3 += 2);
                            if (n3 += 2, o4 > 0 && o4 !== a3.s)
                              throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", o4);
                          } else if (217 === t4) {
                            if (c3) {
                              var s4 = 8 * O;
                              if (s4 > 0 && s4 < a3.s / 10)
                                throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", s4);
                            }
                            throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                          }
                          throw new e4("unexpected marker");
                        }
                      }
                      return B = 7, T >>> 7;
                    }
                    function U(t4) {
                      for (var r6 = t4; ; ) {
                        switch (typeof (r6 = r6[C()])) {
                          case "number":
                            return r6;
                          case "object":
                            continue;
                        }
                        throw new e4("invalid huffman sequence");
                      }
                    }
                    function D(t4) {
                      for (var e5 = 0; t4 > 0; )
                        e5 = e5 << 1 | C(), t4--;
                      return e5;
                    }
                    function z(t4) {
                      if (1 === t4)
                        return 1 === C() ? 1 : -1;
                      var e5 = D(t4);
                      return e5 >= 1 << t4 - 1 ? e5 : e5 + (-1 << t4) + 1;
                    }
                    function N(t4, e5, r6, i4, n4) {
                      var a4 = r6 % M;
                      O = (r6 / M | 0) * t4.A + i4;
                      var o4 = a4 * t4.h + n4;
                      e5(t4, d2(t4, O, o4));
                    }
                    function F(t4, e5, r6) {
                      O = r6 / t4.P | 0;
                      var i4 = r6 % t4.P;
                      e5(t4, d2(t4, O, i4));
                    }
                    var j = o3.length;
                    for (v = A ? 0 === h3 ? 0 === u3 ? function(t4, e5) {
                      var r6 = U(t4.J), i4 = 0 === r6 ? 0 : z(r6) << l3;
                      t4.D[e5] = t4.Q += i4;
                    } : function(t4, e5) {
                      t4.D[e5] |= C() << l3;
                    } : 0 === u3 ? function(e5, r6) {
                      if (R > 0)
                        R--;
                      else
                        for (var i4 = h3, n4 = f3; i4 <= n4; ) {
                          var a4 = U(e5.i), o4 = 15 & a4, s4 = a4 >> 4;
                          if (0 !== o4) {
                            var u4 = t3[i4 += s4];
                            e5.D[r6 + u4] = z(o4) * (1 << l3), i4++;
                          } else {
                            if (s4 < 15) {
                              R = D(s4) + (1 << s4) - 1;
                              break;
                            }
                            i4 += 16;
                          }
                        }
                    } : function(r6, i4) {
                      for (var n4, a4, o4 = h3, s4 = f3, u4 = 0; o4 <= s4; ) {
                        var c4 = i4 + t3[o4], d3 = r6.D[c4] < 0 ? -1 : 1;
                        switch (P) {
                          case 0:
                            if (u4 = (a4 = U(r6.i)) >> 4, 0 == (n4 = 15 & a4))
                              u4 < 15 ? (R = D(u4) + (1 << u4), P = 4) : (u4 = 16, P = 1);
                            else {
                              if (1 !== n4)
                                throw new e4("invalid ACn encoding");
                              p3 = z(n4), P = u4 ? 2 : 3;
                            }
                            continue;
                          case 1:
                          case 2:
                            r6.D[c4] ? r6.D[c4] += d3 * (C() << l3) : 0 == --u4 && (P = 2 === P ? 3 : 0);
                            break;
                          case 3:
                            r6.D[c4] ? r6.D[c4] += d3 * (C() << l3) : (r6.D[c4] = p3 << l3, P = 0);
                            break;
                          case 4:
                            r6.D[c4] && (r6.D[c4] += d3 * (C() << l3));
                        }
                        o4++;
                      }
                      4 === P && 0 == --R && (P = 0);
                    } : function(e5, r6) {
                      var i4 = U(e5.J), n4 = 0 === i4 ? 0 : z(i4), a4 = 1;
                      for (e5.D[r6] = e5.Q += n4; a4 < 64; ) {
                        var o4 = U(e5.i), s4 = 15 & o4, h4 = o4 >> 4;
                        if (0 !== s4) {
                          var f4 = t3[a4 += h4];
                          e5.D[r6 + f4] = z(s4), a4++;
                        } else {
                          if (h4 < 15)
                            break;
                          a4 += 16;
                        }
                      }
                    }, E = 1 === j ? o3[0].P * o3[0].c : M * a3.R; L <= E; ) {
                      var G = s3 ? Math.min(E - L, s3) : E;
                      if (G > 0) {
                        for (g3 = 0; g3 < j; g3++)
                          o3[g3].Q = 0;
                        if (R = 0, 1 === j)
                          for (m3 = o3[0], w = 0; w < G; w++)
                            F(m3, v, L), L++;
                        else
                          for (w = 0; w < G; w++) {
                            for (g3 = 0; g3 < j; g3++)
                              for (k = (m3 = o3[g3]).h, S = m3.A, _ = 0; _ < S; _++)
                                for (y = 0; y < k; y++)
                                  N(m3, v, L, _, y);
                            L++;
                          }
                      }
                      if (B = 0, !(x = b2(r5, n3)))
                        break;
                      if (x.u && (n3 = x.offset), !(x.M >= 65488 && x.M <= 65495))
                        break;
                      n3 += 2;
                    }
                    return n3 - I;
                  }
                  function m2(t4, i4, l3) {
                    var c3, d3, p3, m3, g3, b3, _, y, w, v, x, E, k, S, M, A, I, T = t4.$, B = t4.D;
                    if (!T)
                      throw new e4("missing required Quantization Table.");
                    for (var R = 0; R < 64; R += 8)
                      w = B[i4 + R], v = B[i4 + R + 1], x = B[i4 + R + 2], E = B[i4 + R + 3], k = B[i4 + R + 4], S = B[i4 + R + 5], M = B[i4 + R + 6], A = B[i4 + R + 7], w *= T[R], 0 != (v | x | E | k | S | M | A) ? (v *= T[R + 1], x *= T[R + 2], E *= T[R + 3], k *= T[R + 4], S *= T[R + 5], M *= T[R + 6], A *= T[R + 7], d3 = (c3 = (c3 = f2 * w + 128 >> 8) + (d3 = f2 * k + 128 >> 8) + 1 >> 1) - d3, I = (p3 = x) * h2 + (m3 = M) * s2 + 128 >> 8, p3 = p3 * s2 - m3 * h2 + 128 >> 8, _ = (g3 = (g3 = u2 * (v - A) + 128 >> 8) + (_ = S << 4) + 1 >> 1) - _, b3 = (y = (y = u2 * (v + A) + 128 >> 8) + (b3 = E << 4) + 1 >> 1) - b3, m3 = (c3 = c3 + (m3 = I) + 1 >> 1) - m3, p3 = (d3 = d3 + p3 + 1 >> 1) - p3, I = g3 * o2 + y * a2 + 2048 >> 12, g3 = g3 * a2 - y * o2 + 2048 >> 12, y = I, I = b3 * n2 + _ * r4 + 2048 >> 12, b3 = b3 * r4 - _ * n2 + 2048 >> 12, _ = I, l3[R] = c3 + y, l3[R + 7] = c3 - y, l3[R + 1] = d3 + _, l3[R + 6] = d3 - _, l3[R + 2] = p3 + b3, l3[R + 5] = p3 - b3, l3[R + 3] = m3 + g3, l3[R + 4] = m3 - g3) : (I = f2 * w + 512 >> 10, l3[R] = I, l3[R + 1] = I, l3[R + 2] = I, l3[R + 3] = I, l3[R + 4] = I, l3[R + 5] = I, l3[R + 6] = I, l3[R + 7] = I);
                    for (var P = 0; P < 8; ++P)
                      w = l3[P], 0 != ((v = l3[P + 8]) | (x = l3[P + 16]) | (E = l3[P + 24]) | (k = l3[P + 32]) | (S = l3[P + 40]) | (M = l3[P + 48]) | (A = l3[P + 56])) ? (d3 = (c3 = 4112 + ((c3 = f2 * w + 2048 >> 12) + (d3 = f2 * k + 2048 >> 12) + 1 >> 1)) - d3, I = (p3 = x) * h2 + (m3 = M) * s2 + 2048 >> 12, p3 = p3 * s2 - m3 * h2 + 2048 >> 12, m3 = I, _ = (g3 = (g3 = u2 * (v - A) + 2048 >> 12) + (_ = S) + 1 >> 1) - _, b3 = (y = (y = u2 * (v + A) + 2048 >> 12) + (b3 = E) + 1 >> 1) - b3, I = g3 * o2 + y * a2 + 2048 >> 12, g3 = g3 * a2 - y * o2 + 2048 >> 12, y = I, I = b3 * n2 + _ * r4 + 2048 >> 12, b3 = b3 * r4 - _ * n2 + 2048 >> 12, (w = (c3 = c3 + m3 + 1 >> 1) + y) < 16 ? w = 0 : w >= 4080 ? w = 255 : w >>= 4, (v = (d3 = d3 + p3 + 1 >> 1) + (_ = I)) < 16 ? v = 0 : v >= 4080 ? v = 255 : v >>= 4, (x = (p3 = d3 - p3) + b3) < 16 ? x = 0 : x >= 4080 ? x = 255 : x >>= 4, (E = (m3 = c3 - m3) + g3) < 16 ? E = 0 : E >= 4080 ? E = 255 : E >>= 4, (k = m3 - g3) < 16 ? k = 0 : k >= 4080 ? k = 255 : k >>= 4, (S = p3 - b3) < 16 ? S = 0 : S >= 4080 ? S = 255 : S >>= 4, (M = d3 - _) < 16 ? M = 0 : M >= 4080 ? M = 255 : M >>= 4, (A = c3 - y) < 16 ? A = 0 : A >= 4080 ? A = 255 : A >>= 4, B[i4 + P] = w, B[i4 + P + 8] = v, B[i4 + P + 16] = x, B[i4 + P + 24] = E, B[i4 + P + 32] = k, B[i4 + P + 40] = S, B[i4 + P + 48] = M, B[i4 + P + 56] = A) : (I = (I = f2 * w + 8192 >> 14) < -2040 ? 0 : I >= 2024 ? 255 : I + 2056 >> 4, B[i4 + P] = I, B[i4 + P + 8] = I, B[i4 + P + 16] = I, B[i4 + P + 24] = I, B[i4 + P + 32] = I, B[i4 + P + 40] = I, B[i4 + P + 48] = I, B[i4 + P + 56] = I);
                  }
                  function g2(t4, e5) {
                    for (var r5 = e5.P, i4 = e5.c, n3 = new Int16Array(64), a3 = 0; a3 < i4; a3++)
                      for (var o3 = 0; o3 < r5; o3++)
                        m2(e5, d2(e5, a3, o3), n3);
                    return e5.D;
                  }
                  function b2(t4, e5, r5) {
                    null == r5 && (r5 = e5);
                    var n3 = t4.length - 1, a3 = r5 < e5 ? r5 : e5;
                    if (e5 >= n3)
                      return null;
                    var o3 = i3(t4, e5);
                    if (o3 >= 65472 && o3 <= 65534)
                      return { u: null, M: o3, offset: e5 };
                    for (var s3 = i3(t4, a3); !(s3 >= 65472 && s3 <= 65534); ) {
                      if (++a3 >= n3)
                        return null;
                      s3 = i3(t4, a3);
                    }
                    return { u: o3.toString(16), M: s3, offset: a3 };
                  }
                  return l2.prototype = { parse(r5, n3) {
                    null == n3 && (n3 = {});
                    var a3, o3, s3 = n3.F, h3 = 0, f3 = null, u3 = null, l3 = 0;
                    function d3() {
                      var t4 = i3(r5, h3), e5 = (h3 += 2) + t4 - 2, n4 = b2(r5, e5, h3);
                      n4 && n4.u && (e5 = n4.offset);
                      var a4 = r5.subarray(h3, e5);
                      return h3 += a4.length, a4;
                    }
                    function m3(t4) {
                      for (var e5 = Math.ceil(t4.o / 8 / t4.X), r6 = Math.ceil(t4.s / 8 / t4.B), i4 = 0; i4 < t4.W.length; i4++) {
                        G = t4.W[i4];
                        var n4 = Math.ceil(Math.ceil(t4.o / 8) * G.h / t4.X), a4 = Math.ceil(Math.ceil(t4.s / 8) * G.A / t4.B), o4 = e5 * G.h, s4 = r6 * G.A * 64 * (o4 + 1);
                        G.D = new Int16Array(s4), G.P = n4, G.c = a4;
                      }
                      t4.m = e5, t4.R = r6;
                    }
                    var _ = [], y = [], w = [], v = i3(r5, h3);
                    if (h3 += 2, 65496 !== v)
                      throw new e4("SOI not found");
                    v = i3(r5, h3), h3 += 2;
                    t:
                      for (; 65497 !== v; ) {
                        var x, E, k;
                        switch (v) {
                          case 65504:
                          case 65505:
                          case 65506:
                          case 65507:
                          case 65508:
                          case 65509:
                          case 65510:
                          case 65511:
                          case 65512:
                          case 65513:
                          case 65514:
                          case 65515:
                          case 65516:
                          case 65517:
                          case 65518:
                          case 65519:
                          case 65534:
                            var S = d3();
                            65504 === v && 74 === S[0] && 70 === S[1] && 73 === S[2] && 70 === S[3] && 0 === S[4] && (f3 = { version: { d: S[5], T: S[6] }, K: S[7], j: S[8] << 8 | S[9], H: S[10] << 8 | S[11], S: S[12], I: S[13], C: S.subarray(14, 14 + 3 * S[12] * S[13]) }), 65518 === v && 65 === S[0] && 100 === S[1] && 111 === S[2] && 98 === S[3] && 101 === S[4] && (u3 = { version: S[5] << 8 | S[6], k: S[7] << 8 | S[8], q: S[9] << 8 | S[10], a: S[11] });
                            break;
                          case 65499:
                            for (var M = i3(r5, h3) + (h3 += 2) - 2; h3 < M; ) {
                              var A = r5[h3++], I = new Uint16Array(64);
                              if (A >> 4 == 0)
                                for (E = 0; E < 64; E++)
                                  I[t3[E]] = r5[h3++];
                              else {
                                if (A >> 4 != 1)
                                  throw new e4("DQT - invalid table spec");
                                for (E = 0; E < 64; E++)
                                  I[t3[E]] = i3(r5, h3), h3 += 2;
                              }
                              _[15 & A] = I;
                            }
                            break;
                          case 65472:
                          case 65473:
                          case 65474:
                            if (a3)
                              throw new e4("Only single frame JPEGs supported");
                            h3 += 2, (a3 = {}).G = 65473 === v, a3.Z = 65474 === v, a3.precision = r5[h3++];
                            var T, B = i3(r5, h3), R = 0, P = 0;
                            h3 += 2, a3.s = s3 || B, a3.o = i3(r5, h3), h3 += 2, a3.W = [], a3._ = {};
                            var O = r5[h3++];
                            for (x = 0; x < O; x++) {
                              T = r5[h3];
                              var L = r5[h3 + 1] >> 4, C = 15 & r5[h3 + 1];
                              R < L && (R = L), P < C && (P = C);
                              var U = r5[h3 + 2];
                              k = a3.W.push({ h: L, A: C, L: U, $: null }), a3._[T] = k - 1, h3 += 3;
                            }
                            a3.X = R, a3.B = P, m3(a3);
                            break;
                          case 65476:
                            var D = i3(r5, h3);
                            for (h3 += 2, x = 2; x < D; ) {
                              var z = r5[h3++], N = new Uint8Array(16), F = 0;
                              for (E = 0; E < 16; E++, h3++)
                                F += N[E] = r5[h3];
                              var j = new Uint8Array(F);
                              for (E = 0; E < F; E++, h3++)
                                j[E] = r5[h3];
                              x += 17 + F, (z >> 4 == 0 ? w : y)[15 & z] = c2(N, j);
                            }
                            break;
                          case 65501:
                            o3 = i3(r5, h3 += 2), h3 += 2;
                            break;
                          case 65498:
                            var G, H = 1 == ++l3 && !s3;
                            h3 += 2;
                            var W = r5[h3++], q = [];
                            for (x = 0; x < W; x++) {
                              var Z = r5[h3++], Y = a3._[Z];
                              (G = a3.W[Y]).index = Z;
                              var V = r5[h3++];
                              G.J = w[V >> 4], G.i = y[15 & V], q.push(G);
                            }
                            var X = r5[h3++], Q = r5[h3++], J = r5[h3++];
                            try {
                              var K = p2(r5, h3, a3, q, o3, X, Q, J >> 4, 15 & J, H);
                              h3 += K;
                            } catch (t4) {
                              if (t4 instanceof DNLMarkerError)
                                return this.parse(r5, { F: t4.s });
                              if (t4 instanceof EOIMarkerError)
                                break t;
                              throw t4;
                            }
                            break;
                          case 65500:
                            h3 += 4;
                            break;
                          case 65535:
                            255 !== r5[h3] && h3--;
                            break;
                          default:
                            var $ = b2(r5, h3 - 2, h3 - 3);
                            if ($ && $.u) {
                              h3 = $.offset;
                              break;
                            }
                            if (h3 >= r5.length - 1)
                              break t;
                            throw new e4("JpegImage.parse - unknown marker: " + v.toString(16));
                        }
                        v = i3(r5, h3), h3 += 2;
                      }
                    for (this.width = a3.o, this.height = a3.s, this.g = f3, this.b = u3, this.W = [], x = 0; x < a3.W.length; x++) {
                      var tt = _[(G = a3.W[x]).L];
                      tt && (G.$ = tt), this.W.push({ index: G.index, e: g2(0, G), l: G.h / a3.X, t: G.A / a3.B, P: G.P, c: G.c });
                    }
                    this.p = this.W.length;
                  }, Y(t4, e5, r5) {
                    null == r5 && (r5 = false);
                    var i4, n3, a3, o3, s3, h3, f3, u3, l3, c3, d3, p3, m3 = this.width / t4, g3 = this.height / e5, b3 = 0, _ = this.W.length, y = t4 * e5 * _, w = new Uint8ClampedArray(y), v = new Uint32Array(t4), x = 4294967288;
                    for (f3 = 0; f3 < _; f3++) {
                      if (n3 = (i4 = this.W[f3]).l * m3, a3 = i4.t * g3, b3 = f3, d3 = i4.e, o3 = i4.P + 1 << 3, n3 !== p3) {
                        for (s3 = 0; s3 < t4; s3++)
                          u3 = 0 | s3 * n3, v[s3] = (u3 & x) << 3 | 7 & u3;
                        p3 = n3;
                      }
                      for (h3 = 0; h3 < e5; h3++)
                        for (c3 = o3 * ((u3 = 0 | h3 * a3) & x) | (7 & u3) << 3, s3 = 0; s3 < t4; s3++)
                          w[b3] = d3[c3 + v[s3]], b3 += _;
                    }
                    var E = this.V;
                    if (r5 || 4 !== _ || E || (E = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), E)
                      for (f3 = 0; f3 < y; )
                        for (u3 = 0, l3 = 0; u3 < _; u3++, f3++, l3 += 2)
                          w[f3] = (w[f3] * E[l3] >> 8) + E[l3 + 1];
                    return w;
                  }, get f() {
                    return this.b ? !!this.b.a : 3 === this.p ? 0 !== this.N && (82 !== this.W[0].index || 71 !== this.W[1].index || 66 !== this.W[2].index) : 1 === this.N;
                  }, z: function(t4) {
                    for (var e5, r5, i4, n3 = 0, a3 = t4.length; n3 < a3; n3 += 3)
                      e5 = t4[n3], r5 = t4[n3 + 1], i4 = t4[n3 + 2], t4[n3] = e5 - 179.456 + 1.402 * i4, t4[n3 + 1] = e5 + 135.459 - 0.344 * r5 - 0.714 * i4, t4[n3 + 2] = e5 - 226.816 + 1.772 * r5;
                    return t4;
                  }, O: function(t4) {
                    for (var e5, r5, i4, n3, a3 = 0, o3 = 0, s3 = t4.length; o3 < s3; o3 += 4)
                      e5 = t4[o3], r5 = t4[o3 + 1], i4 = t4[o3 + 2], n3 = t4[o3 + 3], t4[a3++] = r5 * (-660635669420364e-19 * r5 + 437130475926232e-18 * i4 - 54080610064599e-18 * e5 + 48449797120281e-17 * n3 - 0.154362151871126) - 122.67195406894 + i4 * (-957964378445773e-18 * i4 + 817076911346625e-18 * e5 - 0.00477271405408747 * n3 + 1.53380253221734) + e5 * (961250184130688e-18 * e5 - 0.00266257332283933 * n3 + 0.48357088451265) + n3 * (-336197177618394e-18 * n3 + 0.484791561490776), t4[a3++] = 107.268039397724 + r5 * (219927104525741e-19 * r5 - 640992018297945e-18 * i4 + 659397001245577e-18 * e5 + 426105652938837e-18 * n3 - 0.176491792462875) + i4 * (-778269941513683e-18 * i4 + 0.00130872261408275 * e5 + 770482631801132e-18 * n3 - 0.151051492775562) + e5 * (0.00126935368114843 * e5 - 0.00265090189010898 * n3 + 0.25802910206845) + n3 * (-318913117588328e-18 * n3 - 0.213742400323665), t4[a3++] = r5 * (-570115196973677e-18 * r5 - 263409051004589e-19 * i4 + 0.0020741088115012 * e5 - 0.00288260236853442 * n3 + 0.814272968359295) - 20.810012546947 + i4 * (-153496057440975e-19 * i4 - 132689043961446e-18 * e5 + 560833691242812e-18 * n3 - 0.195152027534049) + e5 * (0.00174418132927582 * e5 - 0.00255243321439347 * n3 + 0.116935020465145) + n3 * (-343531996510555e-18 * n3 + 0.24165260232407);
                    return t4.subarray(0, a3);
                  }, r: function(t4) {
                    for (var e5, r5, i4, n3 = 0, a3 = t4.length; n3 < a3; n3 += 4)
                      e5 = t4[n3], r5 = t4[n3 + 1], i4 = t4[n3 + 2], t4[n3] = 434.456 - e5 - 1.402 * i4, t4[n3 + 1] = 119.541 - e5 + 0.344 * r5 + 0.714 * i4, t4[n3 + 2] = 481.816 - e5 - 1.772 * r5;
                    return t4;
                  }, U: function(t4) {
                    for (var e5, r5, i4, n3, a3 = 0, o3 = 0, s3 = t4.length; o3 < s3; o3 += 4)
                      e5 = t4[o3], r5 = t4[o3 + 1], i4 = t4[o3 + 2], n3 = t4[o3 + 3], t4[a3++] = 255 + e5 * (-6747147073602441e-20 * e5 + 8379262121013727e-19 * r5 + 2894718188643294e-19 * i4 + 0.003264231057537806 * n3 - 1.1185611867203937) + r5 * (26374107616089405e-21 * r5 - 8626949158638572e-20 * i4 - 2748769067499491e-19 * n3 - 0.02155688794978967) + i4 * (-3878099212869363e-20 * i4 - 3267808279485286e-19 * n3 + 0.0686742238595345) - n3 * (3361971776183937e-19 * n3 + 0.7430659151342254), t4[a3++] = 255 + e5 * (13596372813588848e-20 * e5 + 924537132573585e-18 * r5 + 10567359618683593e-20 * i4 + 4791864687436512e-19 * n3 - 0.3109689587515875) + r5 * (-23545346108370344e-20 * r5 + 2702845253534714e-19 * i4 + 0.0020200308977307156 * n3 - 0.7488052167015494) + i4 * (6834815998235662e-20 * i4 + 15168452363460973e-20 * n3 - 0.09751927774728933) - n3 * (3189131175883281e-19 * n3 + 0.7364883807733168), t4[a3++] = 255 + e5 * (13598650411385307e-21 * e5 + 12423956175490851e-20 * r5 + 4751985097583589e-19 * i4 - 36729317476630422e-22 * n3 - 0.05562186980264034) + r5 * (16141380598724676e-20 * r5 + 9692239130725186e-19 * i4 + 7782692450036253e-19 * n3 - 0.44015232367526463) + i4 * (5068882914068769e-22 * i4 + 0.0017778369011375071 * n3 - 0.7591454649749609) - n3 * (3435319965105553e-19 * n3 + 0.7063770186160144);
                    return t4.subarray(0, a3);
                  }, getData: function(t4) {
                    var r5 = t4.width, i4 = t4.height, n3 = t4.forceRGB, a3 = t4.isSourcePDF;
                    if (this.p > 4)
                      throw new e4("Unsupported color mode");
                    var o3 = this.Y(r5, i4, a3);
                    if (1 === this.p && n3) {
                      for (var s3 = o3.length, h3 = new Uint8ClampedArray(3 * s3), f3 = 0, u3 = 0; u3 < s3; u3++) {
                        var l3 = o3[u3];
                        h3[f3++] = l3, h3[f3++] = l3, h3[f3++] = l3;
                      }
                      return h3;
                    }
                    if (3 === this.p && this.f)
                      return this.z(o3);
                    if (4 === this.p) {
                      if (this.f)
                        return n3 ? this.O(o3) : this.r(o3);
                      if (n3)
                        return this.U(o3);
                    }
                    return o3;
                  } }, l2;
                }();
                function i3(t3, e5) {
                  return t3[e5] << 8 | t3[e5 + 1];
                }
                t2.JpegDecoder = r3;
              }(), t2.encodeImage = function(e4, r3, i3, n2) {
                var a2 = { t256: [r3], t257: [i3], t258: [8, 8, 8, 8], t259: [1], t262: [2], t273: [1e3], t277: [4], t278: [i3], t279: [r3 * i3 * 4], t282: [[72, 1]], t283: [[72, 1]], t284: [1], t286: [[0, 1]], t287: [[0, 1]], t296: [1], t305: ["Photopea (UTIF.js)"], t338: [1] };
                if (n2)
                  for (var o2 in n2)
                    a2[o2] = n2[o2];
                var s2 = new Uint8Array(t2.encode([a2])), h2 = new Uint8Array(e4), f2 = new Uint8Array(1e3 + r3 * i3 * 4);
                for (o2 = 0; o2 < s2.length; o2++)
                  f2[o2] = s2[o2];
                for (o2 = 0; o2 < h2.length; o2++)
                  f2[1e3 + o2] = h2[o2];
                return f2.buffer;
              }, t2.encode = function(e4) {
                var r3 = new Uint8Array(2e4), i3 = 4, n2 = t2._binBE;
                r3[0] = r3[1] = 77, n2.writeUshort(r3, 2, 42);
                var a2 = 8;
                n2.writeUint(r3, i3, a2), i3 += 4;
                for (var o2 = 0; o2 < e4.length; o2++) {
                  var s2 = t2._writeIFD(n2, t2._types.basic, r3, a2, e4[o2]);
                  a2 = s2[1], o2 < e4.length - 1 && (0 != (3 & a2) && (a2 += 4 - (3 & a2)), n2.writeUint(r3, s2[0], a2));
                }
                return r3.slice(0, a2).buffer;
              }, t2.decode = function(e4, r3) {
                null == r3 && (r3 = { parseMN: true, debug: false });
                var i3 = new Uint8Array(e4), a2 = 0, o2 = t2._binBE.readASCII(i3, a2, 2);
                a2 += 2;
                var s2 = "II" == o2 ? t2._binLE : t2._binBE;
                s2.readUshort(i3, a2), a2 += 2;
                var h2 = s2.readUint(i3, a2);
                a2 += 4;
                for (var f2 = []; ; ) {
                  var u2 = s2.readUshort(i3, h2), l2 = s2.readUshort(i3, h2 + 4);
                  if (0 != u2 && (l2 < 1 || 13 < l2)) {
                    n("error in TIFF");
                    break;
                  }
                  if (t2._readIFD(s2, i3, h2, f2, 0, r3), 0 == (h2 = s2.readUint(i3, h2 + 2 + 12 * u2)))
                    break;
                }
                return f2;
              }, t2.decodeImage = function(e4, r3, i3) {
                if (!r3.data) {
                  var a2 = new Uint8Array(e4), o2 = t2._binBE.readASCII(a2, 0, 2);
                  if (null != r3.t256) {
                    r3.isLE = "II" == o2, r3.width = r3.t256[0], r3.height = r3.t257[0];
                    var s2, h2 = r3.t259 ? r3.t259[0] : 1, f2 = r3.t266 ? r3.t266[0] : 1;
                    r3.t284 && 2 == r3.t284[0] && n("PlanarConfiguration 2 should not be used!"), 7 == h2 && r3.t258 && r3.t258.length > 3 && (r3.t258 = r3.t258.slice(0, 3)), s2 = r3.t258 ? Math.min(32, r3.t258[0]) * r3.t258.length : r3.t277 ? r3.t277[0] : 1, 1 == h2 && null != r3.t279 && r3.t278 && 32803 == r3.t262[0] && (s2 = Math.round(8 * r3.t279[0] / (r3.width * r3.t278[0]))), r3.t50885 && 4 == r3.t50885[0] && (s2 = 3 * r3.t258[0]);
                    var u2 = 8 * Math.ceil(r3.width * s2 / 8), l2 = r3.t273;
                    (null == l2 || r3.t322) && (l2 = r3.t324);
                    var c2 = r3.t279;
                    1 == h2 && 1 == l2.length && (c2 = [r3.height * (u2 >>> 3)]), (null == c2 || r3.t322) && (c2 = r3.t325);
                    var d2 = new Uint8Array(r3.height * (u2 >>> 3)), p2 = 0;
                    if (null != r3.t322) {
                      var m2 = r3.t322[0], g2 = r3.t323[0], b2 = Math.floor((r3.width + m2 - 1) / m2), _ = Math.floor((r3.height + g2 - 1) / g2), y = new Uint8Array(0 | Math.ceil(m2 * g2 * s2 / 8));
                      console.log("====", b2, _);
                      for (var w = 0; w < _; w++)
                        for (var v = 0; v < b2; v++) {
                          var x = w * b2 + v;
                          y.fill(0), t2.decode._decompress(r3, i3, a2, l2[x], c2[x], h2, y, 0, f2), 6 == h2 ? d2 = y : t2._copyTile(y, 0 | Math.ceil(m2 * s2 / 8), g2, d2, 0 | Math.ceil(r3.width * s2 / 8), r3.height, 0 | Math.ceil(v * m2 * s2 / 8), w * g2);
                        }
                      p2 = 8 * d2.length;
                    } else {
                      var E = r3.t278 ? r3.t278[0] : r3.height;
                      for (E = Math.min(E, r3.height), console.log("====", r3.width, E), x = 0; x < l2.length; x++)
                        t2.decode._decompress(r3, i3, a2, l2[x], c2[x], h2, d2, 0 | Math.ceil(p2 / 8), f2), p2 += u2 * E;
                      p2 = Math.min(p2, 8 * d2.length);
                    }
                    r3.data = new Uint8Array(d2.buffer, 0, 0 | Math.ceil(p2 / 8));
                  }
                }
              }, t2.decode._decompress = function(r3, i3, a2, o2, s2, h2, f2, u2, l2) {
                if (1 == h2)
                  for (var c2 = 0; c2 < s2; c2++)
                    f2[u2 + c2] = a2[o2 + c2];
                else if (2 == h2)
                  t2.decode._decodeG2(a2, o2, s2, f2, u2, r3.width, l2);
                else if (3 == h2)
                  t2.decode._decodeG3(a2, o2, s2, f2, u2, r3.width, l2, !!r3.t292 && 1 == (1 & r3.t292[0]));
                else if (4 == h2)
                  t2.decode._decodeG4(a2, o2, s2, f2, u2, r3.width, l2);
                else if (5 == h2)
                  t2.decode._decodeLZW(a2, o2, s2, f2, u2, 8);
                else if (6 == h2)
                  t2.decode._decodeOldJPEG(r3, a2, o2, s2, f2, u2);
                else if (7 == h2 || 34892 == h2)
                  t2.decode._decodeNewJPEG(r3, a2, o2, s2, f2, u2);
                else if (8 == h2 || 32946 == h2)
                  for (var d2 = new Uint8Array(a2.buffer, o2, s2), p2 = e3.inflate(d2), m2 = 0; m2 < p2.length; m2++)
                    f2[u2 + m2] = p2[m2];
                else
                  9 == h2 ? t2.decode._decodeVC5(a2, o2, s2, f2, u2) : 32767 == h2 ? t2.decode._decodeARW(r3, a2, o2, s2, f2, u2) : 32773 == h2 ? t2.decode._decodePackBits(a2, o2, s2, f2, u2) : 32809 == h2 ? t2.decode._decodeThunder(a2, o2, s2, f2, u2) : 34713 == h2 ? t2.decode._decodeNikon(r3, i3, a2, o2, s2, f2, u2) : 34676 == h2 ? t2.decode._decodeLogLuv32(r3, a2, o2, s2, f2, u2) : n("Unknown compression", h2);
                var g2 = r3.t258 ? Math.min(32, r3.t258[0]) : 1, b2 = r3.t277 ? r3.t277[0] : 1, _ = g2 * b2 >>> 3, y = r3.t278 ? r3.t278[0] : r3.height, w = Math.ceil(g2 * b2 * r3.width / 8);
                if (16 == g2 && !r3.isLE && null == r3.t33422)
                  for (var v = 0; v < y; v++)
                    for (var x = u2 + v * w, E = 1; E < w; E += 2) {
                      var k = f2[x + E];
                      f2[x + E] = f2[x + E - 1], f2[x + E - 1] = k;
                    }
                if (r3.t317 && 2 == r3.t317[0])
                  for (v = 0; v < y; v++) {
                    var S = u2 + v * w;
                    if (16 == g2)
                      for (c2 = _; c2 < w; c2 += 2) {
                        var M = (f2[S + c2 + 1] << 8 | f2[S + c2]) + (f2[S + c2 - _ + 1] << 8 | f2[S + c2 - _]);
                        f2[S + c2] = 255 & M, f2[S + c2 + 1] = M >>> 8 & 255;
                      }
                    else if (3 == b2)
                      for (c2 = 3; c2 < w; c2 += 3)
                        f2[S + c2] = f2[S + c2] + f2[S + c2 - 3] & 255, f2[S + c2 + 1] = f2[S + c2 + 1] + f2[S + c2 - 2] & 255, f2[S + c2 + 2] = f2[S + c2 + 2] + f2[S + c2 - 1] & 255;
                    else
                      for (c2 = _; c2 < w; c2++)
                        f2[S + c2] = f2[S + c2] + f2[S + c2 - _] & 255;
                  }
              }, t2.decode._decodeVC5 = t2.decode._decodeVC5 = function() {
                var e4, r3, i3, n2 = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], a2 = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1];
                function o2(t3) {
                  var e5 = t3[1], r4 = t3[0][e5 >>> 3] >>> 7 - (7 & e5) & 1;
                  return t3[1]++, r4;
                }
                function s2(t3, r4) {
                  if (null == e4) {
                    e4 = {};
                    for (var i4 = 0; i4 < n2.length; i4 += 4)
                      e4[n2[i4 + 1]] = n2.slice(i4, i4 + 4);
                  }
                  for (var a3 = o2(t3), s3 = e4[a3]; null == s3; )
                    a3 = a3 << 1 | o2(t3), s3 = e4[a3];
                  var h3 = s3[3];
                  0 != h3 && (h3 = 0 == o2(t3) ? h3 : -h3), r4[0] = s3[2], r4[1] = h3;
                }
                function h2(t3, e5) {
                  for (var r4 = 0; r4 < e5; r4++)
                    1 == (1 & t3) && t3++, t3 >>>= 1;
                  return t3;
                }
                function f2(t3, e5) {
                  return t3 >> e5;
                }
                function u2(t3, e5, r4, i4, n3, a3) {
                  e5[r4] = f2(f2(11 * t3[n3] - 4 * t3[n3 + a3] + t3[n3 + a3 + a3] + 4, 3) + t3[i4], 1), e5[r4 + a3] = f2(f2(5 * t3[n3] + 4 * t3[n3 + a3] - t3[n3 + a3 + a3] + 4, 3) - t3[i4], 1);
                }
                function l2(t3, e5, r4, i4, n3, a3) {
                  var o3 = t3[n3 - a3] - t3[n3 + a3], s3 = t3[n3], h3 = t3[i4];
                  e5[r4] = f2(f2(o3 + 4, 3) + s3 + h3, 1), e5[r4 + a3] = f2(f2(4 - o3, 3) + s3 - h3, 1);
                }
                function c2(t3, e5, r4, i4, n3, a3) {
                  e5[r4] = f2(f2(5 * t3[n3] + 4 * t3[n3 - a3] - t3[n3 - a3 - a3] + 4, 3) + t3[i4], 1), e5[r4 + a3] = f2(f2(11 * t3[n3] - 4 * t3[n3 - a3] + t3[n3 - a3 - a3] + 4, 3) - t3[i4], 1);
                }
                function d2(t3) {
                  return i3[t3 = t3 < 0 ? 0 : t3 > 4095 ? 4095 : t3] >>> 2;
                }
                return function(e5, n3, o3, f3, p2) {
                  f3 = new Uint16Array(f3.buffer);
                  var m2, g2, b2, _, y, w, v, x, E = Date.now(), k = t2._binBE, S = n3 + o3;
                  for (n3 += 4; n3 < S; ) {
                    var M = k.readShort(e5, n3), A = k.readUshort(e5, n3 + 2);
                    if (n3 += 4, 12 == M)
                      L = A;
                    else if (20 == M)
                      m2 = A;
                    else if (21 == M)
                      g2 = A;
                    else if (48 == M)
                      b2 = A;
                    else if (53 == M)
                      _ = A;
                    else if (35 == M)
                      ;
                    else if (62 == M)
                      y = A;
                    else if (101 == M)
                      ;
                    else if (109 == M)
                      w = A;
                    else if (84 == M)
                      ;
                    else if (106 == M)
                      ;
                    else if (107 == M)
                      ;
                    else if (108 == M)
                      ;
                    else if (102 == M)
                      ;
                    else if (104 == M)
                      tt = A;
                    else if (105 == M)
                      ;
                    else {
                      var I = M < 0 ? -M : M, T = 65280 & I, B = 0;
                      if (24576 & I && (8192 & I ? (B = 65535 & A, B += (255 & I) << 16) : B = 65535 & A), 24576 == (24576 & I)) {
                        if (null == v) {
                          v = [];
                          for (var R = 0; R < 4; R++)
                            v[R] = new Int16Array((m2 >>> 1) * (g2 >>> 1));
                          for (x = new Int16Array((m2 >>> 1) * (g2 >>> 1)), r3 = new Int16Array(1024), R = 0; R < 1024; R++) {
                            var P = R - 512, O = Math.abs(P), L = Math.floor(768 * O * O * O / 16581375) + O;
                            r3[R] = Math.sign(P) * L;
                          }
                          for (i3 = new Uint16Array(4096), R = 0; R < 4096; R++) {
                            var C = R, U = 65535 * (Math.pow(113, C / 4095) - 1) / 112;
                            i3[R] = Math.min(U, 65535);
                          }
                        }
                        var D = v[y], z = h2(m2, 1 + a2[b2]), N = h2(g2, 1 + a2[b2]);
                        if (0 == b2)
                          for (var F = 0; F < N; F++)
                            for (var j = 0; j < z; j++) {
                              var G = n3 + 2 * (F * z + j);
                              D[F * (m2 >>> 1) + j] = e5[G] << 8 | e5[G + 1];
                            }
                        else {
                          var H = [e5, 8 * n3], W = [], q = 0, Z = z * N, Y = [0, 0], V = 0;
                          for (A = 0; q < Z; )
                            for (s2(H, Y), V = Y[0], A = Y[1]; V > 0; )
                              W[q++] = A, V--;
                          var X = (b2 - 1) % 3, Q = 1 != X ? z : 0, J = 0 != X ? N : 0;
                          for (F = 0; F < N; F++) {
                            var K = (F + J) * (m2 >>> 1) + Q, $ = F * z;
                            for (j = 0; j < z; j++)
                              D[K + j] = r3[W[$ + j] + 512] * _;
                          }
                          if (2 == X) {
                            var tt = m2 >>> 1, et = 2 * z, rt = 2 * N;
                            for (F = 0; F < N; F++)
                              for (j = 0; j < et; j++) {
                                R = 2 * F * tt + j;
                                var it = N * tt + (at = F * tt + j);
                                0 == F ? u2(D, x, R, it, at, tt) : F == N - 1 ? c2(D, x, R, it, at, tt) : l2(D, x, R, it, at, tt);
                              }
                            var nt = D;
                            for (D = x, x = nt, F = 0; F < rt; F++)
                              for (j = 0; j < z; j++) {
                                var at;
                                R = F * tt + 2 * j, it = z + (at = F * tt + j), 0 == j ? u2(D, x, R, it, at, 1) : j == z - 1 ? c2(D, x, R, it, at, 1) : l2(D, x, R, it, at, 1);
                              }
                            nt = D, D = x, x = nt;
                            for (var ot = [], st = 2 - ~~((b2 - 1) / 3), ht = 0; ht < 3; ht++)
                              ot[ht] = w >> 14 - 2 * ht & 3;
                            var ft = ot[st];
                            if (0 != ft)
                              for (F = 0; F < rt; F++)
                                for (j = 0; j < et; j++)
                                  D[R = F * tt + j] = D[R] << ft;
                          }
                        }
                        if (9 == b2 && 3 == y) {
                          var ut = v[0], lt = v[1], ct = v[2], dt = v[3];
                          for (F = 0; F < g2; F += 2)
                            for (j = 0; j < m2; j += 2) {
                              var pt = F * m2 + j, mt = ut[G = (F >>> 1) * (m2 >>> 1) + (j >>> 1)], gt = lt[G] - 2048, bt = ct[G] - 2048, _t = dt[G] - 2048, yt = (gt << 1) + mt, wt = (bt << 1) + mt, vt = mt + _t, xt = mt - _t;
                              f3[pt] = d2(yt), f3[pt + 1] = d2(vt), f3[pt + m2] = d2(xt), f3[pt + m2 + 1] = d2(wt);
                            }
                        }
                        n3 += 4 * B;
                      } else if (16388 == I)
                        n3 += 4 * B;
                      else if (8192 != T && 8448 != T && 9216 != T)
                        throw I.toString(16);
                    }
                  }
                  console.log(Date.now() - E);
                };
              }(), t2.decode._decodeLogLuv32 = function(t3, e4, r3, i3, n2, a2) {
                for (var o2 = t3.width, s2 = 4 * o2, h2 = 0, f2 = new Uint8Array(s2); h2 < i3; ) {
                  for (var u2 = 0; u2 < s2; ) {
                    var l2 = e4[r3 + h2];
                    if (h2++, l2 < 128) {
                      for (var c2 = 0; c2 < l2; c2++)
                        f2[u2 + c2] = e4[r3 + h2 + c2];
                      u2 += l2, h2 += l2;
                    } else {
                      for (l2 -= 126, c2 = 0; c2 < l2; c2++)
                        f2[u2 + c2] = e4[r3 + h2];
                      u2 += l2, h2++;
                    }
                  }
                  for (var d2 = 0; d2 < o2; d2++)
                    n2[a2 + 0] = f2[d2], n2[a2 + 1] = f2[d2 + o2], n2[a2 + 2] = f2[d2 + 2 * o2], n2[a2 + 4] = f2[d2 + 3 * o2], a2 += 6;
                }
              }, t2.decode._ljpeg_diff = function(e4, r3, i3) {
                var n2, a2, o2 = t2.decode._getbithuff;
                return n2 = o2(e4, r3, i3[0], i3), 0 == ((a2 = o2(e4, r3, n2, 0)) & 1 << n2 - 1) && (a2 -= (1 << n2) - 1), a2;
              }, t2.decode._decodeARW = function(e4, r3, i3, n2, a2, o2) {
                var s2 = e4.t256[0], h2 = e4.t257[0], f2 = e4.t258[0], u2 = e4.isLE ? t2._binLE : t2._binBE;
                if (s2 * h2 == n2 || s2 * h2 * 1.5 == n2)
                  if (s2 * h2 * 1.5 != n2) {
                    var l2, c2, d2, p2, m2, g2, b2, _, y = new Uint16Array(16), w = new Uint8Array(s2 + 1);
                    for (I = 0; I < h2; I++) {
                      for (var v = 0; v < s2; v++)
                        w[v] = r3[i3++];
                      for (_ = 0, A = 0; A < s2 - 30; _ += 16) {
                        for (c2 = 2047 & (l2 = u2.readUint(w, _)), d2 = 2047 & l2 >>> 11, p2 = 15 & l2 >>> 22, m2 = 15 & l2 >>> 26, g2 = 0; g2 < 4 && 128 << g2 <= c2 - d2; g2++)
                          ;
                        for (b2 = 30, x = 0; x < 16; x++)
                          x == p2 ? y[x] = c2 : x == m2 ? y[x] = d2 : (y[x] = ((u2.readUshort(w, _ + (b2 >> 3)) >>> (7 & b2) & 127) << g2) + d2, y[x] > 2047 && (y[x] = 2047), b2 += 7);
                        for (x = 0; x < 16; x++, A += 2)
                          U = y[x] << 1, t2.decode._putsF(a2, (I * s2 + A) * f2, U << 16 - f2);
                        A -= 1 & A ? 1 : 31;
                      }
                    }
                  } else
                    for (var x = 0; x < n2; x += 3) {
                      var E = r3[i3 + x + 0], k = r3[i3 + x + 1], S = r3[i3 + x + 2];
                      a2[o2 + x] = k << 4 | E >>> 4, a2[o2 + x + 1] = E << 4 | S >>> 4, a2[o2 + x + 2] = S << 4 | k >>> 4;
                    }
                else {
                  h2 += 8;
                  var M, A, I, T = [i3, 0, 0, 0], B = new Uint16Array(32770), R = [3857, 3856, 3599, 3342, 3085, 2828, 2571, 2314, 2057, 1800, 1543, 1286, 1029, 772, 771, 768, 514, 513], P = 0, O = t2.decode._ljpeg_diff;
                  for (B[0] = 15, M = x = 0; x < 18; x++)
                    for (var L = 32768 >>> (R[x] >>> 8), C = 0; C < L; C++)
                      B[++M] = R[x];
                  for (A = s2; A--; )
                    for (I = 0; I < h2 + 1; I += 2)
                      if (I == h2 && (I = 1), P += O(r3, T, B), I < h2) {
                        var U = 4095 & P;
                        t2.decode._putsF(a2, (I * s2 + A) * f2, U << 16 - f2);
                      }
                }
              }, t2.decode._decodeNikon = function(e4, r3, i3, n2, a2, o2, s2) {
                var h2 = [[0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 57, 90, 56, 39, 22, 5, 4, 3, 2, 1, 0, 11, 12, 12], [0, 0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12], [0, 0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 8, 92, 75, 58, 41, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14], [0, 0, 1, 4, 2, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14]], f2 = e4.t256[0], u2 = e4.t257[0], l2 = e4.t258[0], c2 = 0, d2 = 0, p2 = t2.decode._make_decoder, m2 = t2.decode._getbithuff, g2 = r3[0].exifIFD.makerNote, b2 = g2.t150 ? g2.t150 : g2.t140, _ = 0, y = b2[_++], w = b2[_++];
                73 != y && 88 != w || (_ += 2110), 70 == y && (c2 = 2), 14 == l2 && (c2 += 3);
                for (var v = [[0, 0], [0, 0]], x = e4.isLE ? t2._binLE : t2._binBE, E = 0; E < 2; E++)
                  for (var k = 0; k < 2; k++)
                    v[E][k] = x.readShort(b2, _), _ += 2;
                var S, M, A, I, T, B = 1 << l2 & 32767, R = 0, P = x.readShort(b2, _);
                _ += 2, P > 1 && (R = Math.floor(B / (P - 1))), 68 == y && 32 == w && R > 0 && (d2 = x.readShort(b2, 562));
                var O = [0, 0], L = p2(h2[c2]), C = [n2, 0, 0, 0];
                for (S = 0; S < u2; S++)
                  for (d2 && S == d2 && (L = p2(h2[c2 + 1])), M = 0; M < f2; M++) {
                    E = m2(i3, C, L[0], L), 0 == ((T = 1 + (m2(i3, C, (A = 15 & E) - (I = E >>> 4), 0) << 1) << I >>> 1) & 1 << A - 1) && (T -= (1 << A) - (0 == I ? 1 : 0)), M < 2 ? O[M] = v[1 & S][M] += T : O[1 & M] += T;
                    var U = Math.min(Math.max(O[1 & M], 0), (1 << l2) - 1), D = (S * f2 + M) * l2;
                    t2.decode._putsF(o2, D, U << 16 - l2);
                  }
              }, t2.decode._putsF = function(t3, e4, r3) {
                r3 <<= 8 - (7 & e4);
                var i3 = e4 >>> 3;
                t3[i3] |= r3 >>> 16, t3[i3 + 1] |= r3 >>> 8, t3[i3 + 2] |= r3;
              }, t2.decode._getbithuff = function(e4, r3, i3, n2) {
                t2.decode._get_byte;
                var a2, o2 = r3[0], s2 = r3[1], h2 = r3[2], f2 = r3[3];
                if (0 == i3 || h2 < 0)
                  return 0;
                for (; !f2 && h2 < i3 && -1 != (a2 = e4[o2++]) && !(f2 = 0); )
                  s2 = (s2 << 8) + a2, h2 += 8;
                if (a2 = s2 << 32 - h2 >>> 32 - i3, n2 ? (h2 -= n2[a2 + 1] >>> 8, a2 = 255 & n2[a2 + 1]) : h2 -= i3, h2 < 0)
                  throw "e";
                return r3[0] = o2, r3[1] = s2, r3[2] = h2, r3[3] = f2, a2;
              }, t2.decode._make_decoder = function(t3) {
                var e4, r3, i3, n2, a2, o2 = [];
                for (e4 = 16; 0 != e4 && !t3[e4]; e4--)
                  ;
                var s2 = 17;
                for (o2[0] = e4, i3 = r3 = 1; r3 <= e4; r3++)
                  for (n2 = 0; n2 < t3[r3]; n2++, ++s2)
                    for (a2 = 0; a2 < 1 << e4 - r3; a2++)
                      i3 <= 1 << e4 && (o2[i3++] = r3 << 8 | t3[s2]);
                return o2;
              }, t2.decode._decodeNewJPEG = function(e4, r3, i3, n2, a2, o2) {
                n2 = Math.min(n2, r3.length - i3);
                var s2 = e4.t347, h2 = s2 ? s2.length : 0, f2 = new Uint8Array(h2 + n2);
                if (s2) {
                  for (var u2 = 0, l2 = 0; l2 < h2 - 1 && (255 != s2[l2] || 217 != s2[l2 + 1]); l2++)
                    f2[u2++] = s2[l2];
                  var c2 = r3[i3], d2 = r3[i3 + 1];
                  for (255 == c2 && 216 == d2 || (f2[u2++] = c2, f2[u2++] = d2), l2 = 2; l2 < n2; l2++)
                    f2[u2++] = r3[i3 + l2];
                } else
                  for (l2 = 0; l2 < n2; l2++)
                    f2[l2] = r3[i3 + l2];
                if (32803 == e4.t262[0] || 7 == e4.t259[0] && 34892 == e4.t262[0]) {
                  var p2 = e4.t258[0], m2 = t2.LosslessJpegDecode(f2), g2 = m2.length;
                  if (16 == p2)
                    if (e4.isLE)
                      for (l2 = 0; l2 < g2; l2++)
                        a2[o2 + (l2 << 1)] = 255 & m2[l2], a2[o2 + (l2 << 1) + 1] = m2[l2] >>> 8;
                    else
                      for (l2 = 0; l2 < g2; l2++)
                        a2[o2 + (l2 << 1)] = m2[l2] >>> 8, a2[o2 + (l2 << 1) + 1] = 255 & m2[l2];
                  else if (14 == p2 || 12 == p2) {
                    var b2 = 16 - p2;
                    for (l2 = 0; l2 < g2; l2++)
                      t2.decode._putsF(a2, l2 * p2, m2[l2] << b2);
                  } else {
                    if (8 != p2)
                      throw new Error("unsupported bit depth " + p2);
                    for (l2 = 0; l2 < g2; l2++)
                      a2[o2 + l2] = m2[l2];
                  }
                } else {
                  var _ = new t2.JpegDecoder();
                  _.parse(f2);
                  var y = _.getData({ width: _.width, height: _.height, forceRGB: true, isSourcePDF: false });
                  for (l2 = 0; l2 < y.length; l2++)
                    a2[o2 + l2] = y[l2];
                }
                6 == e4.t262[0] && (e4.t262[0] = 2);
              }, t2.decode._decodeOldJPEGInit = function(t3, e4, r3, i3) {
                var a2, o2, s2, h2, f2, u2 = 216, l2 = 0, c2 = 0, d2 = false, p2 = t3.t513, m2 = p2 ? p2[0] : 0, g2 = t3.t514, b2 = g2 ? g2[0] : 0, _ = t3.t324 || t3.t273 || p2, y = t3.t530, w = 0, v = 0, x = t3.t277 ? t3.t277[0] : 1, E = t3.t515;
                if (_ && (c2 = _[0], d2 = _.length > 1), !d2) {
                  if (255 == e4[r3] && e4[r3 + 1] == u2)
                    return { jpegOffset: r3 };
                  if (null != p2 && (255 == e4[r3 + m2] && e4[r3 + m2 + 1] == u2 ? l2 = r3 + m2 : n("JPEGInterchangeFormat does not point to SOI"), null == g2 ? n("JPEGInterchangeFormatLength field is missing") : (m2 >= c2 || m2 + b2 <= c2) && n("JPEGInterchangeFormatLength field value is invalid"), null != l2))
                    return { jpegOffset: l2 };
                }
                if (null != y && (w = y[0], v = y[1]), null != p2 && null != g2)
                  if (b2 >= 2 && m2 + b2 <= c2) {
                    for (a2 = 255 == e4[r3 + m2 + b2 - 2] && e4[r3 + m2 + b2 - 1] == u2 ? new Uint8Array(b2 - 2) : new Uint8Array(b2), s2 = 0; s2 < a2.length; s2++)
                      a2[s2] = e4[r3 + m2 + s2];
                    n("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
                  } else
                    n("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
                if (null == a2) {
                  var k = 0, S = [];
                  S[k++] = 255, S[k++] = u2;
                  var M = t3.t519;
                  if (null == M)
                    throw new Error("JPEGQTables tag is missing");
                  for (s2 = 0; s2 < M.length; s2++)
                    for (S[k++] = 255, S[k++] = 219, S[k++] = 0, S[k++] = 67, S[k++] = s2, h2 = 0; h2 < 64; h2++)
                      S[k++] = e4[r3 + M[s2] + h2];
                  for (f2 = 0; f2 < 2; f2++) {
                    var A = t3[0 == f2 ? "t520" : "t521"];
                    if (null == A)
                      throw new Error((0 == f2 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
                    for (s2 = 0; s2 < A.length; s2++) {
                      S[k++] = 255, S[k++] = 196;
                      var I = 19;
                      for (h2 = 0; h2 < 16; h2++)
                        I += e4[r3 + A[s2] + h2];
                      for (S[k++] = I >>> 8, S[k++] = 255 & I, S[k++] = s2 | f2 << 4, h2 = 0; h2 < 16; h2++)
                        S[k++] = e4[r3 + A[s2] + h2];
                      for (h2 = 0; h2 < I; h2++)
                        S[k++] = e4[r3 + A[s2] + 16 + h2];
                    }
                  }
                  if (S[k++] = 255, S[k++] = 192, S[k++] = 0, S[k++] = 8 + 3 * x, S[k++] = 8, S[k++] = t3.height >>> 8 & 255, S[k++] = 255 & t3.height, S[k++] = t3.width >>> 8 & 255, S[k++] = 255 & t3.width, S[k++] = x, 1 == x)
                    S[k++] = 1, S[k++] = 17, S[k++] = 0;
                  else
                    for (s2 = 0; s2 < 3; s2++)
                      S[k++] = s2 + 1, S[k++] = 0 != s2 ? 17 : (15 & w) << 4 | 15 & v, S[k++] = s2;
                  null != E && 0 != E[0] && (S[k++] = 255, S[k++] = 221, S[k++] = 0, S[k++] = 4, S[k++] = E[0] >>> 8 & 255, S[k++] = 255 & E[0]), a2 = new Uint8Array(S);
                }
                var T = -1;
                for (s2 = 0; s2 < a2.length - 1; ) {
                  if (255 == a2[s2] && 192 == a2[s2 + 1]) {
                    T = s2;
                    break;
                  }
                  s2++;
                }
                if (-1 == T) {
                  var B = new Uint8Array(a2.length + 10 + 3 * x);
                  B.set(a2);
                  var R = a2.length;
                  if (T = a2.length, (a2 = B)[R++] = 255, a2[R++] = 192, a2[R++] = 0, a2[R++] = 8 + 3 * x, a2[R++] = 8, a2[R++] = t3.height >>> 8 & 255, a2[R++] = 255 & t3.height, a2[R++] = t3.width >>> 8 & 255, a2[R++] = 255 & t3.width, a2[R++] = x, 1 == x)
                    a2[R++] = 1, a2[R++] = 17, a2[R++] = 0;
                  else
                    for (s2 = 0; s2 < 3; s2++)
                      a2[R++] = s2 + 1, a2[R++] = 0 != s2 ? 17 : (15 & w) << 4 | 15 & v, a2[R++] = s2;
                }
                if (255 == e4[c2] && 218 == e4[c2 + 1]) {
                  var P = e4[c2 + 2] << 8 | e4[c2 + 3];
                  for ((o2 = new Uint8Array(P + 2))[0] = e4[c2], o2[1] = e4[c2 + 1], o2[2] = e4[c2 + 2], o2[3] = e4[c2 + 3], s2 = 0; s2 < P - 2; s2++)
                    o2[s2 + 4] = e4[c2 + s2 + 4];
                } else {
                  var O = 0;
                  if ((o2 = new Uint8Array(8 + 2 * x))[O++] = 255, o2[O++] = 218, o2[O++] = 0, o2[O++] = 6 + 2 * x, o2[O++] = x, 1 == x)
                    o2[O++] = 1, o2[O++] = 0;
                  else
                    for (s2 = 0; s2 < 3; s2++)
                      o2[O++] = s2 + 1, o2[O++] = s2 << 4 | s2;
                  o2[O++] = 0, o2[O++] = 63, o2[O++] = 0;
                }
                return { jpegOffset: r3, tables: a2, sosMarker: o2, sofPosition: T };
              }, t2.decode._decodeOldJPEG = function(e4, r3, i3, n2, a2, o2) {
                var s2, h2, f2, u2, l2 = t2.decode._decodeOldJPEGInit(e4, r3, i3, n2);
                if (null != l2.jpegOffset)
                  for (s2 = i3 + n2 - l2.jpegOffset, f2 = new Uint8Array(s2), p2 = 0; p2 < s2; p2++)
                    f2[p2] = r3[l2.jpegOffset + p2];
                else {
                  for (h2 = l2.tables.length, (f2 = new Uint8Array(h2 + l2.sosMarker.length + n2 + 2)).set(l2.tables), u2 = h2, f2[l2.sofPosition + 5] = e4.height >>> 8 & 255, f2[l2.sofPosition + 6] = 255 & e4.height, f2[l2.sofPosition + 7] = e4.width >>> 8 & 255, f2[l2.sofPosition + 8] = 255 & e4.width, 255 == r3[i3] && r3[i3 + 1] == SOS || (f2.set(l2.sosMarker, u2), u2 += sosMarker.length), p2 = 0; p2 < n2; p2++)
                    f2[u2++] = r3[i3 + p2];
                  f2[u2++] = 255, f2[u2++] = EOI;
                }
                var c2 = new t2.JpegDecoder();
                c2.parse(f2);
                for (var d2 = c2.getData({ width: c2.width, height: c2.height, forceRGB: true, isSourcePDF: false }), p2 = 0; p2 < d2.length; p2++)
                  a2[o2 + p2] = d2[p2];
                e4.t262 && 6 == e4.t262[0] && (e4.t262[0] = 2);
              }, t2.decode._decodePackBits = function(t3, e4, r3, i3, n2) {
                for (var a2 = new Int8Array(t3.buffer), o2 = new Int8Array(i3.buffer), s2 = e4 + r3; e4 < s2; ) {
                  var h2 = a2[e4];
                  if (e4++, h2 >= 0 && h2 < 128)
                    for (var f2 = 0; f2 < h2 + 1; f2++)
                      o2[n2] = a2[e4], n2++, e4++;
                  if (h2 >= -127 && h2 < 0) {
                    for (f2 = 0; f2 < 1 - h2; f2++)
                      o2[n2] = a2[e4], n2++;
                    e4++;
                  }
                }
                return n2;
              }, t2.decode._decodeThunder = function(t3, e4, r3, i3, n2) {
                for (var a2 = [0, 1, 0, -1], o2 = [0, 1, 2, 3, 0, -3, -2, -1], s2 = e4 + r3, h2 = 2 * n2, f2 = 0; e4 < s2; ) {
                  var u2 = t3[e4], l2 = u2 >>> 6, c2 = 63 & u2;
                  if (e4++, 3 == l2 && (f2 = 15 & c2, i3[h2 >>> 1] |= f2 << 4 * (1 - h2 & 1), h2++), 0 == l2)
                    for (var d2 = 0; d2 < c2; d2++)
                      i3[h2 >>> 1] |= f2 << 4 * (1 - h2 & 1), h2++;
                  if (2 == l2)
                    for (d2 = 0; d2 < 2; d2++)
                      4 != (p2 = c2 >>> 3 * (1 - d2) & 7) && (f2 += o2[p2], i3[h2 >>> 1] |= f2 << 4 * (1 - h2 & 1), h2++);
                  if (1 == l2)
                    for (d2 = 0; d2 < 3; d2++) {
                      var p2;
                      2 != (p2 = c2 >>> 2 * (2 - d2) & 3) && (f2 += a2[p2], i3[h2 >>> 1] |= f2 << 4 * (1 - h2 & 1), h2++);
                    }
                }
              }, t2.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, t2.decode._lens = function() {
                var t3 = function(t4, e5, r4, i4) {
                  for (var n3 = 0; n3 < e5.length; n3++)
                    t4[e5[n3]] = r4 + n3 * i4;
                }, e4 = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", r3 = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", i3 = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", n2 = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", a2 = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
                e4 = e4.split(","), r3 = r3.split(","), i3 = i3.split(","), n2 = n2.split(","), a2 = a2.split(",");
                var o2 = {}, s2 = {};
                return t3(o2, e4, 0, 1), t3(o2, i3, 64, 64), t3(o2, a2, 1792, 64), t3(s2, r3, 0, 1), t3(s2, n2, 64, 64), t3(s2, a2, 1792, 64), [o2, s2];
              }(), t2.decode._decodeG4 = function(e4, r3, i3, n2, a2, o2, s2) {
                for (var h2 = t2.decode, f2 = r3 << 3, u2 = 0, l2 = "", c2 = [], d2 = [], p2 = 0; p2 < o2; p2++)
                  d2.push(0);
                d2 = h2._makeDiff(d2);
                for (var m2 = 0, g2 = 0, b2 = 0, _ = 0, y = 0, w = 0, v = "", x = 0, E = 8 * Math.ceil(o2 / 8); f2 >>> 3 < r3 + i3; ) {
                  b2 = h2._findDiff(d2, m2 + (0 == m2 ? 0 : 1), 1 - y), _ = h2._findDiff(d2, b2, y);
                  var k = 0;
                  if (1 == s2 && (k = e4[f2 >>> 3] >>> 7 - (7 & f2) & 1), 2 == s2 && (k = e4[f2 >>> 3] >>> (7 & f2) & 1), f2++, l2 += k, "H" == v) {
                    if (null != h2._lens[y][l2]) {
                      var S = h2._lens[y][l2];
                      l2 = "", u2 += S, S < 64 && (h2._addNtimes(c2, u2, y), m2 += u2, y = 1 - y, u2 = 0, 0 == --x && (v = ""));
                    }
                  } else
                    "0001" == l2 && (l2 = "", h2._addNtimes(c2, _ - m2, y), m2 = _), "001" == l2 && (l2 = "", v = "H", x = 2), null != h2._dmap[l2] && (g2 = b2 + h2._dmap[l2], h2._addNtimes(c2, g2 - m2, y), m2 = g2, l2 = "", y = 1 - y);
                  c2.length == o2 && "" == v && (h2._writeBits(c2, n2, 8 * a2 + w * E), y = 0, w++, m2 = 0, d2 = h2._makeDiff(c2), c2 = []);
                }
              }, t2.decode._findDiff = function(t3, e4, r3) {
                for (var i3 = 0; i3 < t3.length; i3 += 2)
                  if (t3[i3] >= e4 && t3[i3 + 1] == r3)
                    return t3[i3];
              }, t2.decode._makeDiff = function(t3) {
                var e4 = [];
                1 == t3[0] && e4.push(0, 1);
                for (var r3 = 1; r3 < t3.length; r3++)
                  t3[r3 - 1] != t3[r3] && e4.push(r3, t3[r3]);
                return e4.push(t3.length, 0, t3.length, 1), e4;
              }, t2.decode._decodeG2 = function(e4, r3, i3, n2, a2, o2, s2) {
                for (var h2 = t2.decode, f2 = r3 << 3, u2 = 0, l2 = "", c2 = [], d2 = 0, p2 = 0, m2 = 8 * Math.ceil(o2 / 8); f2 >>> 3 < r3 + i3; ) {
                  var g2 = 0;
                  1 == s2 && (g2 = e4[f2 >>> 3] >>> 7 - (7 & f2) & 1), 2 == s2 && (g2 = e4[f2 >>> 3] >>> (7 & f2) & 1), f2++, l2 += g2, null != (u2 = h2._lens[d2][l2]) && (h2._addNtimes(c2, u2, d2), l2 = "", u2 < 64 && (d2 = 1 - d2), c2.length == o2 && (h2._writeBits(c2, n2, 8 * a2 + p2 * m2), c2 = [], p2++, d2 = 0, 0 != (7 & f2) && (f2 += 8 - (7 & f2)), u2 >= 64 && (f2 += 8)));
                }
              }, t2.decode._decodeG3 = function(e4, r3, i3, n2, a2, o2, s2, h2) {
                for (var f2 = t2.decode, u2 = r3 << 3, l2 = 0, c2 = "", d2 = [], p2 = [], m2 = 0; m2 < o2; m2++)
                  d2.push(0);
                for (var g2 = 0, b2 = 0, _ = 0, y = 0, w = 0, v = -1, x = "", E = 0, k = true, S = 8 * Math.ceil(o2 / 8); u2 >>> 3 < r3 + i3; ) {
                  _ = f2._findDiff(p2, g2 + (0 == g2 ? 0 : 1), 1 - w), y = f2._findDiff(p2, _, w);
                  var M = 0;
                  if (1 == s2 && (M = e4[u2 >>> 3] >>> 7 - (7 & u2) & 1), 2 == s2 && (M = e4[u2 >>> 3] >>> (7 & u2) & 1), u2++, c2 += M, k) {
                    if (null != f2._lens[w][c2]) {
                      var A = f2._lens[w][c2];
                      c2 = "", l2 += A, A < 64 && (f2._addNtimes(d2, l2, w), w = 1 - w, l2 = 0);
                    }
                  } else
                    "H" == x ? null != f2._lens[w][c2] && (A = f2._lens[w][c2], c2 = "", l2 += A, A < 64 && (f2._addNtimes(d2, l2, w), g2 += l2, w = 1 - w, l2 = 0, 0 == --E && (x = ""))) : ("0001" == c2 && (c2 = "", f2._addNtimes(d2, y - g2, w), g2 = y), "001" == c2 && (c2 = "", x = "H", E = 2), null != f2._dmap[c2] && (b2 = _ + f2._dmap[c2], f2._addNtimes(d2, b2 - g2, w), g2 = b2, c2 = "", w = 1 - w));
                  c2.endsWith("000000000001") && (v >= 0 && f2._writeBits(d2, n2, 8 * a2 + v * S), h2 && (1 == s2 && (k = 1 == (e4[u2 >>> 3] >>> 7 - (7 & u2) & 1)), 2 == s2 && (k = 1 == (e4[u2 >>> 3] >>> (7 & u2) & 1)), u2++), c2 = "", w = 0, v++, g2 = 0, p2 = f2._makeDiff(d2), d2 = []);
                }
                d2.length == o2 && f2._writeBits(d2, n2, 8 * a2 + v * S);
              }, t2.decode._addNtimes = function(t3, e4, r3) {
                for (var i3 = 0; i3 < e4; i3++)
                  t3.push(r3);
              }, t2.decode._writeBits = function(t3, e4, r3) {
                for (var i3 = 0; i3 < t3.length; i3++)
                  e4[r3 + i3 >>> 3] |= t3[i3] << 7 - (r3 + i3 & 7);
              }, t2.decode._decodeLZW = t2.decode._decodeLZW = (s = 0, h = 0, f = 0, u = 0, l = function() {
                var t3 = r2 >>> 3, e4 = (i2[t3] << 16 | i2[t3 + 1] << 8 | i2[t3 + 2]) >>> 24 - (7 & r2) - h & (1 << h) - 1;
                return r2 += h, e4;
              }, c = new Uint32Array(16384), d = 0, p = function(t3) {
                h = t3 + 1, s = u + 1;
              }, m = function(t3) {
                for (var e4 = t3 << 2, r3 = c[e4 + 2], i3 = o + r3 - 1; 65535 != e4; )
                  a[i3--] = c[e4], e4 = c[e4 + 1];
                o += r3;
              }, g = function(t3, e4) {
                var r3 = s << 2, i3 = t3 << 2;
                c[r3] = c[3 + (e4 << 2)], c[r3 + 1] = i3, c[r3 + 2] = c[i3 + 2] + 1, c[r3 + 3] = c[i3 + 3], 1 + ++s == 1 << h && 12 != h && h++;
              }, function(t3, e4, n2, h2, b2, _) {
                r2 = e4 << 3, i2 = t3, a = h2, o = b2;
                var y = e4 + n2 << 3, w = 0, v = 0;
                for (function(t4) {
                  if (t4 != d) {
                    d = t4, u = 1 + (f = 1 << t4);
                    for (var e5 = 0; e5 < u + 1; e5++)
                      c[4 * e5] = c[4 * e5 + 3] = e5, c[4 * e5 + 1] = 65535, c[4 * e5 + 2] = 1;
                  }
                }(_), p(_); r2 < y && (w = l()) != u; ) {
                  if (w == f) {
                    if (p(_), (w = l()) == u)
                      break;
                    m(w);
                  } else
                    w < s ? (m(w), g(v, w)) : (g(v, v), m(s - 1));
                  v = w;
                }
                return o;
              }), t2.tags = {}, t2._types = ((b = new Array(250)).fill(0), { basic: { main: b = b.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), rest: { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 } }, gps: { main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9], rest: { 18: 2, 29: 2 } } }), t2._readIFD = function(e4, r3, i3, a2, o2, s2) {
                var h2 = e4.readUshort(r3, i3);
                i3 += 2;
                var f2 = {};
                s2.debug && n("   ".repeat(o2), a2.length - 1, ">>>----------------");
                for (var u2 = 0; u2 < h2; u2++) {
                  var l2 = e4.readUshort(r3, i3);
                  i3 += 2;
                  var c2 = e4.readUshort(r3, i3);
                  i3 += 2;
                  var d2 = e4.readUint(r3, i3);
                  i3 += 4;
                  var p2 = e4.readUint(r3, i3);
                  i3 += 4;
                  var m2 = [];
                  if (1 != c2 && 7 != c2 || (m2 = new Uint8Array(r3.buffer, d2 < 5 ? i3 - 4 : p2, d2)), 2 == c2) {
                    var g2 = d2 < 5 ? i3 - 4 : p2, b2 = r3[g2], _ = Math.max(0, Math.min(d2 - 1, r3.length - g2));
                    b2 < 128 || 0 == _ ? m2.push(e4.readASCII(r3, g2, _)) : m2 = new Uint8Array(r3.buffer, g2, _);
                  }
                  if (3 == c2)
                    for (var y = 0; y < d2; y++)
                      m2.push(e4.readUshort(r3, (d2 < 3 ? i3 - 4 : p2) + 2 * y));
                  if (4 == c2 || 13 == c2)
                    for (y = 0; y < d2; y++)
                      m2.push(e4.readUint(r3, (d2 < 2 ? i3 - 4 : p2) + 4 * y));
                  if (5 == c2 || 10 == c2) {
                    var w = 5 == c2 ? e4.readUint : e4.readInt;
                    for (y = 0; y < d2; y++)
                      m2.push([w(r3, p2 + 8 * y), w(r3, p2 + 8 * y + 4)]);
                  }
                  if (8 == c2)
                    for (y = 0; y < d2; y++)
                      m2.push(e4.readShort(r3, (d2 < 3 ? i3 - 4 : p2) + 2 * y));
                  if (9 == c2)
                    for (y = 0; y < d2; y++)
                      m2.push(e4.readInt(r3, (d2 < 2 ? i3 - 4 : p2) + 4 * y));
                  if (11 == c2)
                    for (y = 0; y < d2; y++)
                      m2.push(e4.readFloat(r3, p2 + 4 * y));
                  if (12 == c2)
                    for (y = 0; y < d2; y++)
                      m2.push(e4.readDouble(r3, p2 + 8 * y));
                  if (0 == d2 || 0 != m2.length) {
                    if (s2.debug && n("   ".repeat(o2), l2, c2, t2.tags[l2], m2), f2["t" + l2] = m2, 330 == l2 && f2.t272 && "DSLR-A100" == f2.t272[0])
                      ;
                    else if (330 == l2 || 34665 == l2 || 34853 == l2 || 50740 == l2 && e4.readUshort(r3, e4.readUint(m2, 0)) < 300 || 61440 == l2) {
                      var v = 50740 == l2 ? [e4.readUint(m2, 0)] : m2, x = [];
                      for (y = 0; y < v.length; y++)
                        t2._readIFD(e4, r3, v[y], x, o2 + 1, s2);
                      330 == l2 && (f2.subIFD = x), 34665 == l2 && (f2.exifIFD = x[0]), 34853 == l2 && (f2.gpsiIFD = x[0]), 50740 == l2 && (f2.dngPrvt = x[0]), 61440 == l2 && (f2.fujiIFD = x[0]);
                    }
                    if (37500 == l2 && s2.parseMN) {
                      var E = m2;
                      if ("Nikon" == e4.readASCII(E, 0, 5))
                        f2.makerNote = t2.decode(E.slice(10).buffer)[0];
                      else if (e4.readUshort(r3, p2) < 300 && e4.readUshort(r3, p2 + 4) <= 12) {
                        var k = [];
                        t2._readIFD(e4, r3, p2, k, o2 + 1, s2), f2.makerNote = k[0];
                      }
                    }
                  } else if (n(l2, "unknown TIFF tag type: ", c2, "num:", d2), 0 == u2)
                    return;
                }
                return a2.push(f2), s2.debug && n("   ".repeat(o2), "<<<---------------"), i3;
              }, t2._writeIFD = function(e4, r3, i3, n2, a2) {
                var o2 = Object.keys(a2), s2 = o2.length;
                a2.exifIFD && s2--, a2.gpsiIFD && s2--, e4.writeUshort(i3, n2, s2);
                for (var h2 = (n2 += 2) + 12 * s2 + 4, f2 = 0; f2 < o2.length; f2++) {
                  var u2 = o2[f2];
                  if ("t34665" != u2 && "t34853" != u2) {
                    "exifIFD" == u2 && (u2 = "t34665"), "gpsiIFD" == u2 && (u2 = "t34853");
                    var l2 = parseInt(u2.slice(1)), c2 = r3.main[l2];
                    if (null == c2 && (c2 = r3.rest[l2]), null == c2 || 0 == c2)
                      throw new Error("unknown type of tag: " + l2);
                    var d2 = a2[u2];
                    34665 == l2 && (d2 = [h2], h2 = t2._writeIFD(e4, r3, i3, h2, a2.exifIFD)[1]), 34853 == l2 && (d2 = [h2], h2 = t2._writeIFD(e4, t2._types.gps, i3, h2, a2.gpsiIFD)[1]), 2 == c2 && (d2 = d2[0] + "\0");
                    var p2 = d2.length;
                    e4.writeUshort(i3, n2, l2), n2 += 2, e4.writeUshort(i3, n2, c2), n2 += 2, e4.writeUint(i3, n2, p2);
                    var m2 = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][c2] * p2, g2 = n2 += 4;
                    if (m2 > 4 && (e4.writeUint(i3, n2, h2), g2 = h2), 1 == c2 || 7 == c2)
                      for (var b2 = 0; b2 < p2; b2++)
                        i3[g2 + b2] = d2[b2];
                    else if (2 == c2)
                      e4.writeASCII(i3, g2, d2);
                    else if (3 == c2)
                      for (b2 = 0; b2 < p2; b2++)
                        e4.writeUshort(i3, g2 + 2 * b2, d2[b2]);
                    else if (4 == c2)
                      for (b2 = 0; b2 < p2; b2++)
                        e4.writeUint(i3, g2 + 4 * b2, d2[b2]);
                    else if (5 == c2 || 10 == c2) {
                      var _ = 5 == c2 ? e4.writeUint : e4.writeInt;
                      for (b2 = 0; b2 < p2; b2++) {
                        var y = d2[b2], w = y[0], v = y[1];
                        if (null == w)
                          throw "e";
                        _(i3, g2 + 8 * b2, w), _(i3, g2 + 8 * b2 + 4, v);
                      }
                    } else if (9 == c2)
                      for (b2 = 0; b2 < p2; b2++)
                        e4.writeInt(i3, g2 + 4 * b2, d2[b2]);
                    else {
                      if (12 != c2)
                        throw c2;
                      for (b2 = 0; b2 < p2; b2++)
                        e4.writeDouble(i3, g2 + 8 * b2, d2[b2]);
                    }
                    m2 > 4 && (h2 += m2 += 1 & m2), n2 += 4;
                  }
                }
                return [n2, h2];
              }, t2.toRGBA8 = function(t3, e4) {
                var r3 = t3.width, i3 = t3.height, a2 = r3 * i3, o2 = 4 * a2, s2 = t3.data, h2 = new Uint8Array(4 * a2), f2 = t3.t262 ? t3.t262[0] : 2, u2 = t3.t258 ? Math.min(32, t3.t258[0]) : 1;
                if (null == t3.t262 && 1 == u2 && (f2 = 0), 0 == f2)
                  for (var l2 = Math.ceil(u2 * r3 / 8), c2 = 0; c2 < i3; c2++) {
                    var d2 = c2 * l2, p2 = c2 * r3;
                    if (1 == u2)
                      for (var m2 = 0; m2 < r3; m2++) {
                        var g2 = p2 + m2 << 2, b2 = s2[d2 + (m2 >> 3)] >> 7 - (7 & m2) & 1;
                        h2[g2] = h2[g2 + 1] = h2[g2 + 2] = 255 * (1 - b2), h2[g2 + 3] = 255;
                      }
                    if (4 == u2)
                      for (m2 = 0; m2 < r3; m2++)
                        g2 = p2 + m2 << 2, b2 = s2[d2 + (m2 >> 1)] >> 4 - 4 * (1 & m2) & 15, h2[g2] = h2[g2 + 1] = h2[g2 + 2] = 17 * (15 - b2), h2[g2 + 3] = 255;
                    if (8 == u2)
                      for (m2 = 0; m2 < r3; m2++)
                        g2 = p2 + m2 << 2, b2 = s2[d2 + m2], h2[g2] = h2[g2 + 1] = h2[g2 + 2] = 255 - b2, h2[g2 + 3] = 255;
                  }
                else if (1 == f2) {
                  var _ = t3.t258 ? t3.t258.length : 1;
                  for (l2 = Math.ceil(_ * u2 * r3 / 8), null == e4 && (e4 = 1 / 256), c2 = 0; c2 < i3; c2++) {
                    if (d2 = c2 * l2, p2 = c2 * r3, 1 == u2)
                      for (m2 = 0; m2 < r3; m2++)
                        g2 = p2 + m2 << 2, b2 = s2[d2 + (m2 >> 3)] >> 7 - (7 & m2) & 1, h2[g2] = h2[g2 + 1] = h2[g2 + 2] = 255 * b2, h2[g2 + 3] = 255;
                    if (2 == u2)
                      for (m2 = 0; m2 < r3; m2++)
                        g2 = p2 + m2 << 2, b2 = s2[d2 + (m2 >> 2)] >> 6 - 2 * (3 & m2) & 3, h2[g2] = h2[g2 + 1] = h2[g2 + 2] = 85 * b2, h2[g2 + 3] = 255;
                    if (8 == u2)
                      for (m2 = 0; m2 < r3; m2++)
                        g2 = p2 + m2 << 2, b2 = s2[d2 + m2 * _], h2[g2] = h2[g2 + 1] = h2[g2 + 2] = b2, h2[g2 + 3] = 255;
                    if (16 == u2)
                      for (m2 = 0; m2 < r3; m2++) {
                        g2 = p2 + m2 << 2;
                        var y = d2 + 2 * m2;
                        b2 = s2[y + 1] << 8 | s2[y], h2[g2] = h2[g2 + 1] = h2[g2 + 2] = Math.min(255, ~~(b2 * e4)), h2[g2 + 3] = 255;
                      }
                  }
                } else if (2 == f2)
                  if (_ = t3.t258 ? t3.t258.length : 3, 8 == u2) {
                    if (4 == _)
                      for (m2 = 0; m2 < o2; m2++)
                        h2[m2] = s2[m2];
                    if (3 == _)
                      for (m2 = 0; m2 < a2; m2++) {
                        var w = 3 * m2;
                        h2[g2 = m2 << 2] = s2[w], h2[g2 + 1] = s2[w + 1], h2[g2 + 2] = s2[w + 2], h2[g2 + 3] = 255;
                      }
                  } else if (16 == u2) {
                    if (4 == _)
                      for (m2 = 0; m2 < a2; m2++)
                        w = 8 * m2 + 1, h2[g2 = m2 << 2] = s2[w], h2[g2 + 1] = s2[w + 2], h2[g2 + 2] = s2[w + 4], h2[g2 + 3] = s2[w + 6];
                    if (3 == _)
                      for (m2 = 0; m2 < a2; m2++)
                        w = 6 * m2 + 1, h2[g2 = m2 << 2] = s2[w], h2[g2 + 1] = s2[w + 2], h2[g2 + 2] = s2[w + 4], h2[g2 + 3] = 255;
                  } else {
                    if (32 != u2)
                      throw u2;
                    if (!h2.isLE)
                      for (m2 = 0; m2 < s2.length; m2 += 4) {
                        var v = s2[m2];
                        s2[m2] = s2[m2 + 3], s2[m2 + 3] = v, v = s2[m2 + 1], s2[m2 + 1] = s2[m2 + 2], s2[m2 + 2] = v;
                      }
                    var x = new Float32Array(s2.buffer);
                    if (3 != _)
                      throw _;
                    for (m2 = 0; m2 < a2; m2++)
                      w = 3 * m2, h2[g2 = m2 << 2] = ~~(0.5 + 255 * x[w]), h2[g2 + 1] = ~~(0.5 + 255 * x[w + 1]), h2[g2 + 2] = ~~(0.5 + 255 * x[w + 2]), h2[g2 + 3] = 255;
                  }
                else if (3 == f2) {
                  var E = t3.t320, k = (_ = t3.t258 ? t3.t258.length : 1, l2 = Math.ceil(_ * u2 * r3 / 8), 1 << u2);
                  for (c2 = 0; c2 < i3; c2++)
                    for (var S = 0; S < r3; S++) {
                      g2 = (m2 = c2 * r3 + S) << 2;
                      var M = 0, A = c2 * l2;
                      if (1 == u2)
                        M = s2[A + (S >>> 3)] >>> 7 - (7 & S) & 1;
                      else if (2 == u2)
                        M = s2[A + (S >>> 2)] >>> 6 - 2 * (3 & S) & 3;
                      else if (4 == u2)
                        M = s2[A + (S >>> 1)] >>> 4 - 4 * (1 & S) & 15;
                      else {
                        if (8 != u2)
                          throw u2;
                        M = s2[A + S * _];
                      }
                      h2[g2] = E[M] >> 8, h2[g2 + 1] = E[k + M] >> 8, h2[g2 + 2] = E[k + k + M] >> 8, h2[g2 + 3] = 255;
                    }
                } else if (5 == f2) {
                  var I = (_ = t3.t258 ? t3.t258.length : 4) > 4 ? 1 : 0;
                  for (m2 = 0; m2 < a2; m2++) {
                    g2 = m2 << 2;
                    var T = m2 * _;
                    if (UDOC) {
                      var B = s2[T], R = s2[T + 1], P = s2[T + 2], O = s2[T + 3], L = UDOC.C.cmykToRgb([B * (1 / 255), R * (1 / 255), P * (1 / 255), O * (1 / 255)]);
                      h2[g2] = ~~(0.5 + 255 * L[0]), h2[g2 + 1] = ~~(0.5 + 255 * L[1]), h2[g2 + 2] = ~~(0.5 + 255 * L[2]);
                    } else
                      B = 255 - s2[T], R = 255 - s2[T + 1], P = 255 - s2[T + 2], O = (255 - s2[T + 3]) * (1 / 255), h2[g2] = ~~(B * O + 0.5), h2[g2 + 1] = ~~(R * O + 0.5), h2[g2 + 2] = ~~(P * O + 0.5);
                    h2[g2 + 3] = 255 * (1 - I) + s2[T + 4] * I;
                  }
                } else if (6 == f2 && t3.t278) {
                  var C = t3.t278[0];
                  for (c2 = 0; c2 < i3; c2 += C) {
                    m2 = c2 * r3;
                    for (var U = C * r3, D = 0; D < U; D++) {
                      g2 = 4 * (m2 + D), P = s2[(T = 3 * m2 + 4 * (D >>> 1)) + (1 & D)];
                      var z = s2[T + 2] - 128, N = s2[T + 3] - 128, F = P + ((N >> 2) + (N >> 3) + (N >> 5)), j = P - ((z >> 2) + (z >> 4) + (z >> 5)) - ((N >> 1) + (N >> 3) + (N >> 4) + (N >> 5)), G = P + (z + (z >> 1) + (z >> 2) + (z >> 6));
                      h2[g2] = Math.max(0, Math.min(255, F)), h2[g2 + 1] = Math.max(0, Math.min(255, j)), h2[g2 + 2] = Math.max(0, Math.min(255, G)), h2[g2 + 3] = 255;
                    }
                  }
                } else if (32845 == f2) {
                  let H2 = function(t4) {
                    return t4 < 31308e-7 ? 12.92 * t4 : 1.055 * Math.pow(t4, 1 / 2.4) - 0.055;
                  };
                  var H = H2;
                  for (c2 = 0; c2 < i3; c2++)
                    for (S = 0; S < r3; S++) {
                      g2 = 4 * (c2 * r3 + S);
                      var W = s2[1 + (T = 6 * (c2 * r3 + S))] << 8 | s2[T], q = (W = Math.pow(2, (W + 0.5) / 256 - 64), (s2[T + 3] + 0.5) / 410), Z = (s2[T + 5] + 0.5) / 410, Y = 9 * q / (6 * q - 16 * Z + 12), V = 4 * Z / (6 * q - 16 * Z + 12), X = Y * W / V, Q = (1 - Y - V) * W / V;
                      F = 2.69 * X - 1.276 * (P = W) - 0.414 * Q, j = -1.022 * X + 1.978 * P + 0.044 * Q, G = 0.061 * X - 0.224 * P + 1.163 * Q, h2[g2] = 255 * H2(Math.min(F, 1)), h2[g2 + 1] = 255 * H2(Math.min(j, 1)), h2[g2 + 2] = 255 * H2(Math.min(G, 1)), h2[g2 + 3] = 255;
                    }
                } else
                  n("Unknown Photometric interpretation: " + f2);
                return h2;
              }, t2.replaceIMG = function(e4) {
                null == e4 && (e4 = document.getElementsByTagName("img"));
                for (var r3 = ["tif", "tiff", "dng", "cr2", "nef"], i3 = 0; i3 < e4.length; i3++) {
                  var n2 = e4[i3], a2 = n2.getAttribute("src");
                  if (null != a2) {
                    var o2 = a2.split(".").pop().toLowerCase();
                    if (-1 != r3.indexOf(o2)) {
                      var s2 = new XMLHttpRequest();
                      t2._xhrs.push(s2), t2._imgs.push(n2), s2.open("GET", a2), s2.responseType = "arraybuffer", s2.onload = t2._imgLoaded, s2.send();
                    }
                  }
                }
              }, t2._xhrs = [], t2._imgs = [], t2._imgLoaded = function(e4) {
                var r3 = t2._xhrs.indexOf(e4.target), i3 = t2._imgs[r3];
                t2._xhrs.splice(r3, 1), t2._imgs.splice(r3, 1), i3.setAttribute("src", t2.bufferToURI(e4.target.response));
              }, t2.bufferToURI = function(e4) {
                var r3 = t2.decode(e4), i3 = r3, n2 = 0, a2 = i3[0];
                r3[0].subIFD && (i3 = i3.concat(r3[0].subIFD));
                for (var o2 = 0; o2 < i3.length; o2++) {
                  var s2 = i3[o2];
                  if (!(null == s2.t258 || s2.t258.length < 3)) {
                    var h2 = s2.t256 * s2.t257;
                    h2 > n2 && (n2 = h2, a2 = s2);
                  }
                }
                t2.decodeImage(e4, a2, r3);
                var f2 = t2.toRGBA8(a2), u2 = a2.width, l2 = a2.height, c2 = document.createElement("canvas");
                c2.width = u2, c2.height = l2;
                var d2 = c2.getContext("2d"), p2 = new ImageData(new Uint8ClampedArray(f2.buffer), u2, l2);
                return d2.putImageData(p2, 0, 0), c2.toDataURL();
              }, t2._binBE = { nextZero: function(t3, e4) {
                for (; 0 != t3[e4]; )
                  e4++;
                return e4;
              }, readUshort: function(t3, e4) {
                return t3[e4] << 8 | t3[e4 + 1];
              }, readShort: function(e4, r3) {
                var i3 = t2._binBE.ui8;
                return i3[0] = e4[r3 + 1], i3[1] = e4[r3 + 0], t2._binBE.i16[0];
              }, readInt: function(e4, r3) {
                var i3 = t2._binBE.ui8;
                return i3[0] = e4[r3 + 3], i3[1] = e4[r3 + 2], i3[2] = e4[r3 + 1], i3[3] = e4[r3 + 0], t2._binBE.i32[0];
              }, readUint: function(e4, r3) {
                var i3 = t2._binBE.ui8;
                return i3[0] = e4[r3 + 3], i3[1] = e4[r3 + 2], i3[2] = e4[r3 + 1], i3[3] = e4[r3 + 0], t2._binBE.ui32[0];
              }, readASCII: function(t3, e4, r3) {
                for (var i3 = "", n2 = 0; n2 < r3; n2++)
                  i3 += String.fromCharCode(t3[e4 + n2]);
                return i3;
              }, readFloat: function(e4, r3) {
                for (var i3 = t2._binBE.ui8, n2 = 0; n2 < 4; n2++)
                  i3[n2] = e4[r3 + 3 - n2];
                return t2._binBE.fl32[0];
              }, readDouble: function(e4, r3) {
                for (var i3 = t2._binBE.ui8, n2 = 0; n2 < 8; n2++)
                  i3[n2] = e4[r3 + 7 - n2];
                return t2._binBE.fl64[0];
              }, writeUshort: function(t3, e4, r3) {
                t3[e4] = r3 >> 8 & 255, t3[e4 + 1] = 255 & r3;
              }, writeInt: function(e4, r3, i3) {
                var n2 = t2._binBE.ui8;
                t2._binBE.i32[0] = i3, e4[r3 + 3] = n2[0], e4[r3 + 2] = n2[1], e4[r3 + 1] = n2[2], e4[r3 + 0] = n2[3];
              }, writeUint: function(t3, e4, r3) {
                t3[e4] = r3 >> 24 & 255, t3[e4 + 1] = r3 >> 16 & 255, t3[e4 + 2] = r3 >> 8 & 255, t3[e4 + 3] = r3 >> 0 & 255;
              }, writeASCII: function(t3, e4, r3) {
                for (var i3 = 0; i3 < r3.length; i3++)
                  t3[e4 + i3] = r3.charCodeAt(i3);
              }, writeDouble: function(e4, r3, i3) {
                t2._binBE.fl64[0] = i3;
                for (var n2 = 0; n2 < 8; n2++)
                  e4[r3 + n2] = t2._binBE.ui8[7 - n2];
              } }, t2._binBE.ui8 = new Uint8Array(8), t2._binBE.i16 = new Int16Array(t2._binBE.ui8.buffer), t2._binBE.i32 = new Int32Array(t2._binBE.ui8.buffer), t2._binBE.ui32 = new Uint32Array(t2._binBE.ui8.buffer), t2._binBE.fl32 = new Float32Array(t2._binBE.ui8.buffer), t2._binBE.fl64 = new Float64Array(t2._binBE.ui8.buffer), t2._binLE = { nextZero: t2._binBE.nextZero, readUshort: function(t3, e4) {
                return t3[e4 + 1] << 8 | t3[e4];
              }, readShort: function(e4, r3) {
                var i3 = t2._binBE.ui8;
                return i3[0] = e4[r3 + 0], i3[1] = e4[r3 + 1], t2._binBE.i16[0];
              }, readInt: function(e4, r3) {
                var i3 = t2._binBE.ui8;
                return i3[0] = e4[r3 + 0], i3[1] = e4[r3 + 1], i3[2] = e4[r3 + 2], i3[3] = e4[r3 + 3], t2._binBE.i32[0];
              }, readUint: function(e4, r3) {
                var i3 = t2._binBE.ui8;
                return i3[0] = e4[r3 + 0], i3[1] = e4[r3 + 1], i3[2] = e4[r3 + 2], i3[3] = e4[r3 + 3], t2._binBE.ui32[0];
              }, readASCII: t2._binBE.readASCII, readFloat: function(e4, r3) {
                for (var i3 = t2._binBE.ui8, n2 = 0; n2 < 4; n2++)
                  i3[n2] = e4[r3 + n2];
                return t2._binBE.fl32[0];
              }, readDouble: function(e4, r3) {
                for (var i3 = t2._binBE.ui8, n2 = 0; n2 < 8; n2++)
                  i3[n2] = e4[r3 + n2];
                return t2._binBE.fl64[0];
              }, writeUshort: function(t3, e4, r3) {
                t3[e4] = 255 & r3, t3[e4 + 1] = r3 >> 8 & 255;
              }, writeInt: function(e4, r3, i3) {
                var n2 = t2._binBE.ui8;
                t2._binBE.i32[0] = i3, e4[r3 + 0] = n2[0], e4[r3 + 1] = n2[1], e4[r3 + 2] = n2[2], e4[r3 + 3] = n2[3];
              }, writeUint: function(t3, e4, r3) {
                t3[e4] = r3 >>> 0 & 255, t3[e4 + 1] = r3 >>> 8 & 255, t3[e4 + 2] = r3 >>> 16 & 255, t3[e4 + 3] = r3 >>> 24 & 255;
              }, writeASCII: t2._binBE.writeASCII }, t2._copyTile = function(t3, e4, r3, i3, n2, a2, o2, s2) {
                for (var h2 = Math.min(e4, n2 - o2), f2 = Math.min(r3, a2 - s2), u2 = 0; u2 < f2; u2++)
                  for (var l2 = (s2 + u2) * n2 + o2, c2 = u2 * e4, d2 = 0; d2 < h2; d2++)
                    i3[l2 + d2] = t3[c2 + d2];
              }, t2.LosslessJpegDecode = function() {
                var t3, e4;
                function r3() {
                  return t3[e4++];
                }
                function i3() {
                  return t3[e4++] << 8 | t3[e4++];
                }
                function n2(t4) {
                  for (var e5 = r3(), i4 = [0, 0, 0, 255], n3 = [], o3 = 0; o3 < 16; o3++)
                    n3[o3] = r3();
                  for (o3 = 0; o3 < 16; o3++)
                    for (var s3 = 0; s3 < n3[o3]; s3++)
                      i4[a2(i4, 0, o3 + 1, 1) + 3] = r3();
                  var h3 = new Uint8Array(256);
                  for (t4[e5] = [new Uint8Array(i4), h3], o3 = 0; o3 < 256; o3++) {
                    for (var f3 = 8, u3 = o3, l3 = 0; 255 == i4[l3 + 3] && 0 != f3; )
                      l3 = i4[l3 + (u3 >> --f3 & 1)];
                    h3[o3] = l3;
                  }
                }
                function a2(t4, e5, r4, i4) {
                  if (255 != t4[e5 + 3])
                    return 0;
                  if (0 == r4)
                    return e5;
                  for (var n3 = 0; n3 < 2; n3++) {
                    0 == t4[e5 + n3] && (t4[e5 + n3] = t4.length, t4.push(0, 0, i4, 255));
                    var o3 = a2(t4, t4[e5 + n3], r4 - 1, i4 + 1);
                    if (0 != o3)
                      return o3;
                  }
                  return 0;
                }
                function o2(t4) {
                  for (var e5 = t4.b, r4 = t4.a; e5 < 25 && t4.e < t4.d; ) {
                    var i4 = t4.data[t4.e++];
                    t4.c || (t4.e += i4 + 1 >>> 8), r4 = r4 << 8 | i4, e5 += 8;
                  }
                  if (e5 < 0)
                    throw "e";
                  t4.b = e5, t4.a = r4;
                }
                function s2(t4, e5) {
                  return e5.b < t4 && o2(e5), e5.a >> (e5.b -= t4) & 65535 >> 16 - t4;
                }
                function h2(t4, e5) {
                  var r4 = t4[0], i4 = 0, n3 = 255;
                  e5.b < 16 && o2(e5);
                  var a3 = e5.a >> e5.b - 8 & 255;
                  for (n3 = r4[(i4 = t4[1][a3]) + 3], e5.b -= r4[i4 + 2]; 255 == n3; )
                    n3 = r4[(i4 = r4[i4 + (e5.a >> --e5.b & 1)]) + 3];
                  return n3;
                }
                function f2(t4, e5) {
                  return t4 < 32768 >> 16 - e5 && (t4 += 1 - (1 << e5)), t4;
                }
                function u2(t4, e5) {
                  var r4 = h2(t4, e5);
                  return 0 == r4 ? 0 : 16 == r4 ? -32768 : f2(s2(r4, e5), r4);
                }
                function l2(t4, e5, r4, i4, n3, a3) {
                  for (var o3 = 0; o3 < a3; o3++)
                    for (var s3 = o3 * e5, h3 = 0; h3 < e5; h3 += n3)
                      for (var f3 = 0; f3 < n3; f3++)
                        t4[s3 + h3 + f3] = u2(i4[f3], r4);
                }
                function c2(t4, e5) {
                  return f2(s2(t4, e5), t4);
                }
                function d2(t4, e5, r4, i4, n3, a3, o3, s3) {
                  for (var h3 = r4 * o3, f3 = n3; f3 < a3; f3++)
                    t4[f3] += 1 << s3 - 1;
                  for (var u3 = o3; u3 < h3; u3 += o3)
                    for (f3 = n3; f3 < a3; f3++)
                      t4[u3 + f3] += t4[u3 + f3 - o3];
                  for (var l3 = 1; l3 < i4; l3++) {
                    var c3 = l3 * h3;
                    for (f3 = n3; f3 < a3; f3++)
                      t4[c3 + f3] += t4[c3 + f3 - h3];
                    for (u3 = o3; u3 < h3; u3 += o3)
                      for (f3 = n3; f3 < a3; f3++) {
                        var d3 = c3 + u3 + f3, p2 = d3 - h3, m2 = t4[d3 - o3], g2 = 0;
                        if (0 == e5)
                          g2 = 0;
                        else if (1 == e5)
                          g2 = m2;
                        else if (2 == e5)
                          g2 = t4[p2];
                        else if (3 == e5)
                          g2 = t4[p2 - o3];
                        else if (4 == e5)
                          g2 = m2 + (t4[p2] - t4[p2 - o3]);
                        else if (5 == e5)
                          g2 = m2 + (t4[p2] - t4[p2 - o3] >>> 1);
                        else if (6 == e5)
                          g2 = t4[p2] + (m2 - t4[p2 - o3] >>> 1);
                        else {
                          if (7 != e5)
                            throw e5;
                          g2 = m2 + t4[p2] >>> 1;
                        }
                        t4[d3] += g2;
                      }
                  }
                }
                return function(a3) {
                  if (t3 = a3, e4 = 0, 65496 != i3())
                    throw "e";
                  for (var o3 = [], s3 = 0, f3 = 0, u3 = [], p2 = [], m2 = [], g2 = 0, b2 = 0, _ = 0; ; ) {
                    var y = i3();
                    if (65535 != y) {
                      var w = i3();
                      if (65475 == y) {
                        f3 = r3(), b2 = i3(), _ = i3(), g2 = r3();
                        for (var v = 0; v < g2; v++) {
                          var x = r3(), E = r3();
                          if (0 != r3())
                            throw "e";
                          o3[x] = [v, E >> 4, 15 & E];
                        }
                      } else if (65476 == y)
                        for (var k = e4 + w - 2; e4 < k; )
                          n2(p2);
                      else {
                        if (65498 == y) {
                          for (e4++, v = 0; v < g2; v++) {
                            var S = o3[r3()];
                            m2[S[0]] = p2[r3() >>> 4], u3[S[0]] = S.slice(1);
                          }
                          s3 = r3(), e4 += 2;
                          break;
                        }
                        e4 += w - 2;
                      }
                    } else
                      e4--;
                  }
                  var M = new (f3 > 8 ? Uint16Array : Uint8Array)(b2 * _ * g2), A = { b: 0, a: 0, c: 8 == s3, e: e4, data: t3, d: t3.length };
                  if (A.c)
                    !function(r4, i4, n3, a4, o4) {
                      for (var s4 = t3.length - e4, f4 = 0; f4 < s4; f4 += 4) {
                        var u4 = t3[e4 + f4];
                        t3[e4 + f4] = t3[e4 + f4 + 3], t3[e4 + f4 + 3] = u4, u4 = t3[e4 + f4 + 1], t3[e4 + f4 + 1] = t3[e4 + f4 + 2], t3[e4 + f4 + 2] = u4;
                      }
                      for (var l3 = 0; l3 < o4; l3++)
                        for (var d3 = 32768, p3 = 32768, m3 = 0; m3 < i4; m3 += 2) {
                          var g3 = h2(a4, n3), b3 = h2(a4, n3);
                          0 != g3 && (d3 += c2(g3, n3)), 0 != b3 && (p3 += c2(b3, n3)), r4[l3 * i4 + m3] = 65535 & d3, r4[l3 * i4 + m3 + 1] = 65535 & p3;
                        }
                    }(M, _ * g2, A, m2[0], b2);
                  else {
                    var I = [], T = 0, B = 0;
                    for (v = 0; v < g2; v++) {
                      var R = u3[v];
                      (N = R[0]) > T && (T = N), (z = R[1]) > B && (B = z), I.push(N * z);
                    }
                    if (1 != T || 1 != B) {
                      var P = [], O = 0;
                      for (v = 0; v < g2; v++) {
                        for (var L = 0; L < I[v]; L++)
                          P.push(m2[v]);
                        O += I[v];
                      }
                      var C = _ / T, U = b2 / B;
                      l2(M, C * O, A, P, O, U), d2(M, s3, C, U, O - 2, O, O, f3);
                      for (var D = M.slice(0), z = 0; z < b2; z++)
                        for (var N = 0; N < _; N++) {
                          var F = (z * _ + N) * g2, j = ~~(z / B) * C + ~~(N / T), G = 0;
                          for (v = 0; v < g2; v++) {
                            var H = 1 & N, W = j * O + G + (0 == v ? 1 == B ? H : 2 * H + (1 & z) : 0);
                            M[F + v] = D[W], G += I[v];
                          }
                        }
                      d2(M, s3, _, b2, 0, 1, g2, f3);
                    } else
                      l2(M, _ * g2, A, m2, g2, b2), d2(M, s3, _, b2, 0, g2, g2, f3);
                  }
                  return M;
                };
              }(), function() {
                var e4 = 2, r3 = 3, i3 = 4, n2 = 5, a2 = 6, o2 = 7, s2 = 8, h2 = 9, f2 = 10, u2 = 11, l2 = 12, c2 = 13, d2 = 14, p2 = 15, m2 = 16, g2 = 17;
                function b2(t3) {
                  for (var e5 = [[], [], []], r4 = Math.max(2, t3.w + 32 >>> 6), i4 = 0; i4 < 3; i4++)
                    for (var n3 = 0; n3 < 41; n3++)
                      e5[i4][n3] = [r4, 1];
                  return e5;
                }
                function _(t3, e5) {
                  var r4 = 0, i4 = 8 - t3.a;
                  if (t3.j, t3.a, e5) {
                    if (e5 >= i4)
                      do {
                        r4 <<= i4, e5 -= i4, r4 |= t3[t3.j] & (1 << i4) - 1, t3.j++, i4 = 8;
                      } while (e5 >= 8);
                    e5 && (r4 <<= e5, i4 -= e5, r4 |= t3[t3.j] >>> i4 & (1 << e5) - 1), t3.a = 8 - i4;
                  }
                  return r4;
                }
                function y(t3, e5, r4, i4, n3, a3, o3, s3) {
                  null == s3 && (s3 = 0);
                  var h3, f3, u3, l3, c3, d3, p3 = a3 + 1, m3 = p3 % 2, g3 = 0, b3 = i4[n3], y2 = i4[n3 - 1], w2 = i4[n3 - 2][p3], v2 = y2[p3 - 1], x2 = y2[p3], E2 = y2[p3 + 1], k2 = b3[p3 - 1], S = b3[p3 + 1], M = Math.abs;
                  if (m3 && (u3 = M(E2 - x2), l3 = M(w2 - x2), c3 = M(v2 - x2)), m3) {
                    if (d3 = (d3 = u3 > c3 && l3 < u3 ? w2 + v2 : u3 < c3 && l3 < c3 ? w2 + E2 : E2 + v2) + 2 * x2 >>> 2, s3)
                      return void (b3[p3] = d3);
                    h3 = e5.t * e5.c[t3.g + x2 - w2] + e5.c[t3.g + v2 - x2];
                  } else
                    d3 = x2 > v2 && x2 > E2 || x2 < v2 && x2 < E2 ? S + k2 + 2 * x2 >>> 2 : k2 + S >>> 1, h3 = e5.t * e5.c[t3.g + x2 - v2] + e5.c[t3.g + v2 - k2];
                  f3 = M(h3);
                  var A = function(t4) {
                    for (var e6 = -1, r5 = 0; !r5; e6++)
                      r5 = t4[t4.j] >>> 7 - t4.a & 1, t4.a++, t4.a &= 7, t4.a || t4.j++;
                    return e6;
                  }(r4);
                  if (A < t3.n - e5.v - 1) {
                    var I = function(t4, e6) {
                      var r5 = 0;
                      if (e6 < t4)
                        for (; r5 <= 14 && e6 << ++r5 < t4; )
                          ;
                      return r5;
                    }(o3[f3][0], o3[f3][1]);
                    g3 = _(r4, I) + (A << I);
                  } else
                    g3 = _(r4, e5.v) + 1;
                  g3 = 1 & g3 ? -1 - (g3 >>> 1) : g3 >>> 1, o3[f3][0] += M(g3), o3[f3][1] == t3.f && (o3[f3][0] >>>= 1, o3[f3][1] >>>= 1), o3[f3][1]++, d3 = h3 < 0 ? d3 - g3 : d3 + g3, t3.i && (d3 < 0 ? d3 += e5.w : d3 > t3.g && (d3 -= e5.w)), b3[p3] = d3 >= 0 ? Math.min(d3, t3.g) : 0;
                }
                function w(t3, e5, r4) {
                  for (var i4 = t3[0].length, n3 = e5; n3 <= r4; n3++)
                    t3[n3][0] = t3[n3 - 1][1], t3[n3][i4 - 1] = t3[n3 - 1][i4 - 2];
                }
                function v(t3) {
                  w(t3, o2, l2), w(t3, e4, i3), w(t3, p2, g2);
                }
                function x(t3, e5, r4, n3, a3, o3, s3, h3, f3, u3, l3, d3, p3) {
                  for (var m3 = 0, g3 = 1, b3 = a3 < c2 && a3 > i3; g3 < t3.m; )
                    m3 < t3.m && (y(t3, e5, r4, n3, a3, m3, s3[f3], t3.h && (b3 && u3 || !b3 && (l3 || (m3 & d3) == p3))), y(t3, e5, r4, n3, o3, m3, s3[f3], t3.h && (!b3 && u3 || b3 && (l3 || (m3 & d3) == p3))), m3 += 2), m3 > 8 && (y(t3, e5, r4, n3, a3, g3, h3[f3]), y(t3, e5, r4, n3, o3, g3, h3[f3]), g3 += 2);
                  v(n3);
                }
                function E(t3, n3, a3, c3, d3, b3) {
                  x(t3, n3, a3, c3, e4, o2, d3, b3, 0, 0, 1, 0, 8), x(t3, n3, a3, c3, s2, p2, d3, b3, 1, 0, 1, 0, 8), x(t3, n3, a3, c3, r3, h2, d3, b3, 2, 1, 0, 3, 0), x(t3, n3, a3, c3, f2, m2, d3, b3, 0, 0, 0, 3, 2), x(t3, n3, a3, c3, i3, u2, d3, b3, 1, 0, 0, 3, 2), x(t3, n3, a3, c3, l2, g2, d3, b3, 2, 1, 0, 3, 0);
                }
                function k(t3, r4, i4, n3, a3, s3) {
                  var h3 = s3.length, f3 = t3.l;
                  a3 + 1 == t3.s && (f3 = t3.e - a3 * t3.l);
                  for (var u3 = 6 * t3.e * n3 + a3 * t3.l, l3 = 0; l3 < 6; l3++) {
                    for (var c3 = 0; c3 < f3; c3++) {
                      var d3, m3 = s3[l3 % h3][c3 % h3];
                      d3 = 0 == m3 ? e4 + (l3 >>> 1) : 2 == m3 ? p2 + (l3 >>> 1) : o2 + l3;
                      var g3 = t3.h ? (2 * c3 / 3 & 2147483646 | c3 % 3 & 1) + (c3 % 3 >>> 1) : c3 >>> 1;
                      r4[u3 + c3] = i4[d3][g3 + 1];
                    }
                    u3 += t3.e;
                  }
                }
                t2._decompressRAF = function(o3, s3) {
                  var h3 = function(e5) {
                    var r4 = t2._binBE.readUshort, i4 = { b: r4(e5, 0), i: e5[2], C: e5[3], u: e5[4], q: r4(e5, 5), k: r4(e5, 7), e: r4(e5, 9), l: r4(e5, 11), s: e5[13], d: r4(e5, 14) };
                    if (18771 != i4.b || i4.i > 1 || i4.q < 6 || i4.q % 6 || i4.e < 768 || i4.e % 24 || 768 != i4.l || i4.k < i4.l || i4.k % i4.l || i4.k - i4.e >= i4.l || i4.s > 16 || i4.s != i4.k / i4.l || i4.s != Math.ceil(i4.e / i4.l) || i4.d != i4.q / 6 || 12 != i4.u && 14 != i4.u && 16 != i4.u || 16 != i4.C && 0 != i4.C)
                      throw "Invalid data";
                    if (0 == i4.i)
                      throw "Not implemented. We need this file!";
                    return i4.h = 16 == i4.C, i4.m = 0 | (i4.h ? 2 * i4.l / 3 : i4.l >>> 1), i4.A = i4.m + 2, i4.f = 64, i4.g = (1 << i4.u) - 1, i4.n = 4 * i4.u, i4;
                  }(o3), f3 = function(e5, r4) {
                    var i4 = new Array(r4.s), n3 = 4 * r4.s, a3 = 16 + n3;
                    12 & n3 && (a3 += 16 - (12 & n3));
                    for (var o4 = 0, s4 = 16; o4 < r4.s; s4 += 4) {
                      var h4 = t2._binBE.readUint(e5, s4);
                      i4[o4] = e5.slice(a3, a3 + h4), i4[o4].j = 0, i4[o4].a = 0, a3 += h4, o4++;
                    }
                    if (a3 != e5.length)
                      throw "Invalid data";
                    return i4;
                  }(o3, h3), p3 = function(t3) {
                    var e5 = { c: new Int8Array(2 << t3.u) };
                    return function(t4, e6, r4) {
                      var i4 = [0, 18, 67, 276, r4];
                      t4.o = 0, t4.w = (i4[4] + 0) / 1 + 1 | 0, t4.v = Math.ceil(Math.log2(t4.w)), t4.t = 9, function(t5, e7) {
                        for (var r5 = -e7[4], i5 = 0; r5 <= e7[4]; i5++, r5++)
                          t5[i5] = r5 <= -e7[3] ? -4 : r5 <= -e7[2] ? -3 : r5 <= -e7[1] ? -2 : r5 < -e7[0] ? -1 : r5 <= e7[0] ? 0 : r5 < e7[1] ? 1 : r5 < e7[2] ? 2 : r5 < e7[3] ? 3 : 4;
                      }(t4.c, i4);
                    }(e5, 0, t3.g), e5;
                  }(h3), _2 = new Int16Array(h3.e * h3.q);
                  null == s3 && (s3 = h3.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]]);
                  for (var y2 = [[0, r3], [1, i3], [n2, u2], [a2, l2], [c2, m2], [d2, g2]], w2 = [], x2 = 0; x2 < 18; x2++)
                    w2[x2] = new Uint16Array(h3.A);
                  for (var S = 0; S < h3.s; S++) {
                    var M = b2(p3), A = b2(p3);
                    for (x2 = 0; x2 < 18; x2++)
                      for (var I = 0; I < h3.A; I++)
                        w2[x2][I] = 0;
                    for (var T = 0; T < h3.d; T++) {
                      for (E(h3, p3, f3[S], w2, M, A), x2 = 0; x2 < 6; x2++)
                        for (I = 0; I < h3.A; I++)
                          w2[y2[x2][0]][I] = w2[y2[x2][1]][I];
                      for (k(h3, _2, w2, T, S, s3), x2 = e4; x2 < 18; x2++)
                        if (-1 == [n2, a2, c2, d2].indexOf(x2))
                          for (I = 0; I < h3.A; I++)
                            w2[x2][I] = 0;
                      v(w2);
                    }
                  }
                  return _2;
                };
              }();
            }(e2, r(2845));
          }();
        }, 6168: (t, e, r) => {
          "use strict";
          r.r(e), r.d(e, { DOMException: () => v, Headers: () => u, Request: () => b, Response: () => y, fetch: () => x });
          var i = "undefined" != typeof globalThis && globalThis || "undefined" != typeof self && self || void 0 !== i && i, n = { searchParams: "URLSearchParams" in i, iterable: "Symbol" in i && "iterator" in Symbol, blob: "FileReader" in i && "Blob" in i && function() {
            try {
              return new Blob(), true;
            } catch (t2) {
              return false;
            }
          }(), formData: "FormData" in i, arrayBuffer: "ArrayBuffer" in i };
          if (n.arrayBuffer)
            var a = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], o = ArrayBuffer.isView || function(t2) {
              return t2 && a.indexOf(Object.prototype.toString.call(t2)) > -1;
            };
          function s(t2) {
            if ("string" != typeof t2 && (t2 = String(t2)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(t2) || "" === t2)
              throw new TypeError('Invalid character in header field name: "' + t2 + '"');
            return t2.toLowerCase();
          }
          function h(t2) {
            return "string" != typeof t2 && (t2 = String(t2)), t2;
          }
          function f(t2) {
            var e2 = { next: function() {
              var e3 = t2.shift();
              return { done: void 0 === e3, value: e3 };
            } };
            return n.iterable && (e2[Symbol.iterator] = function() {
              return e2;
            }), e2;
          }
          function u(t2) {
            this.map = {}, t2 instanceof u ? t2.forEach(function(t3, e2) {
              this.append(e2, t3);
            }, this) : Array.isArray(t2) ? t2.forEach(function(t3) {
              this.append(t3[0], t3[1]);
            }, this) : t2 && Object.getOwnPropertyNames(t2).forEach(function(e2) {
              this.append(e2, t2[e2]);
            }, this);
          }
          function l(t2) {
            if (t2.bodyUsed)
              return Promise.reject(new TypeError("Already read"));
            t2.bodyUsed = true;
          }
          function c(t2) {
            return new Promise(function(e2, r2) {
              t2.onload = function() {
                e2(t2.result);
              }, t2.onerror = function() {
                r2(t2.error);
              };
            });
          }
          function d(t2) {
            var e2 = new FileReader(), r2 = c(e2);
            return e2.readAsArrayBuffer(t2), r2;
          }
          function p(t2) {
            if (t2.slice)
              return t2.slice(0);
            var e2 = new Uint8Array(t2.byteLength);
            return e2.set(new Uint8Array(t2)), e2.buffer;
          }
          function m() {
            return this.bodyUsed = false, this._initBody = function(t2) {
              var e2;
              this.bodyUsed = this.bodyUsed, this._bodyInit = t2, t2 ? "string" == typeof t2 ? this._bodyText = t2 : n.blob && Blob.prototype.isPrototypeOf(t2) ? this._bodyBlob = t2 : n.formData && FormData.prototype.isPrototypeOf(t2) ? this._bodyFormData = t2 : n.searchParams && URLSearchParams.prototype.isPrototypeOf(t2) ? this._bodyText = t2.toString() : n.arrayBuffer && n.blob && (e2 = t2) && DataView.prototype.isPrototypeOf(e2) ? (this._bodyArrayBuffer = p(t2.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : n.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(t2) || o(t2)) ? this._bodyArrayBuffer = p(t2) : this._bodyText = t2 = Object.prototype.toString.call(t2) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof t2 ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : n.searchParams && URLSearchParams.prototype.isPrototypeOf(t2) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
            }, n.blob && (this.blob = function() {
              var t2 = l(this);
              if (t2)
                return t2;
              if (this._bodyBlob)
                return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as blob");
              return Promise.resolve(new Blob([this._bodyText]));
            }, this.arrayBuffer = function() {
              return this._bodyArrayBuffer ? l(this) || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer)) : this.blob().then(d);
            }), this.text = function() {
              var t2, e2, r2, i2 = l(this);
              if (i2)
                return i2;
              if (this._bodyBlob)
                return t2 = this._bodyBlob, r2 = c(e2 = new FileReader()), e2.readAsText(t2), r2;
              if (this._bodyArrayBuffer)
                return Promise.resolve(function(t3) {
                  for (var e3 = new Uint8Array(t3), r3 = new Array(e3.length), i3 = 0; i3 < e3.length; i3++)
                    r3[i3] = String.fromCharCode(e3[i3]);
                  return r3.join("");
                }(this._bodyArrayBuffer));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as text");
              return Promise.resolve(this._bodyText);
            }, n.formData && (this.formData = function() {
              return this.text().then(_);
            }), this.json = function() {
              return this.text().then(JSON.parse);
            }, this;
          }
          u.prototype.append = function(t2, e2) {
            t2 = s(t2), e2 = h(e2);
            var r2 = this.map[t2];
            this.map[t2] = r2 ? r2 + ", " + e2 : e2;
          }, u.prototype.delete = function(t2) {
            delete this.map[s(t2)];
          }, u.prototype.get = function(t2) {
            return t2 = s(t2), this.has(t2) ? this.map[t2] : null;
          }, u.prototype.has = function(t2) {
            return this.map.hasOwnProperty(s(t2));
          }, u.prototype.set = function(t2, e2) {
            this.map[s(t2)] = h(e2);
          }, u.prototype.forEach = function(t2, e2) {
            for (var r2 in this.map)
              this.map.hasOwnProperty(r2) && t2.call(e2, this.map[r2], r2, this);
          }, u.prototype.keys = function() {
            var t2 = [];
            return this.forEach(function(e2, r2) {
              t2.push(r2);
            }), f(t2);
          }, u.prototype.values = function() {
            var t2 = [];
            return this.forEach(function(e2) {
              t2.push(e2);
            }), f(t2);
          }, u.prototype.entries = function() {
            var t2 = [];
            return this.forEach(function(e2, r2) {
              t2.push([r2, e2]);
            }), f(t2);
          }, n.iterable && (u.prototype[Symbol.iterator] = u.prototype.entries);
          var g = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function b(t2, e2) {
            if (!(this instanceof b))
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            var r2, i2, n2 = (e2 = e2 || {}).body;
            if (t2 instanceof b) {
              if (t2.bodyUsed)
                throw new TypeError("Already read");
              this.url = t2.url, this.credentials = t2.credentials, e2.headers || (this.headers = new u(t2.headers)), this.method = t2.method, this.mode = t2.mode, this.signal = t2.signal, n2 || null == t2._bodyInit || (n2 = t2._bodyInit, t2.bodyUsed = true);
            } else
              this.url = String(t2);
            if (this.credentials = e2.credentials || this.credentials || "same-origin", !e2.headers && this.headers || (this.headers = new u(e2.headers)), this.method = (i2 = (r2 = e2.method || this.method || "GET").toUpperCase(), g.indexOf(i2) > -1 ? i2 : r2), this.mode = e2.mode || this.mode || null, this.signal = e2.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && n2)
              throw new TypeError("Body not allowed for GET or HEAD requests");
            if (this._initBody(n2), !("GET" !== this.method && "HEAD" !== this.method || "no-store" !== e2.cache && "no-cache" !== e2.cache)) {
              var a2 = /([?&])_=[^&]*/;
              a2.test(this.url) ? this.url = this.url.replace(a2, "$1_=" + (/* @__PURE__ */ new Date()).getTime()) : this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
            }
          }
          function _(t2) {
            var e2 = new FormData();
            return t2.trim().split("&").forEach(function(t3) {
              if (t3) {
                var r2 = t3.split("="), i2 = r2.shift().replace(/\+/g, " "), n2 = r2.join("=").replace(/\+/g, " ");
                e2.append(decodeURIComponent(i2), decodeURIComponent(n2));
              }
            }), e2;
          }
          function y(t2, e2) {
            if (!(this instanceof y))
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            e2 || (e2 = {}), this.type = "default", this.status = void 0 === e2.status ? 200 : e2.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = void 0 === e2.statusText ? "" : "" + e2.statusText, this.headers = new u(e2.headers), this.url = e2.url || "", this._initBody(t2);
          }
          b.prototype.clone = function() {
            return new b(this, { body: this._bodyInit });
          }, m.call(b.prototype), m.call(y.prototype), y.prototype.clone = function() {
            return new y(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new u(this.headers), url: this.url });
          }, y.error = function() {
            var t2 = new y(null, { status: 0, statusText: "" });
            return t2.type = "error", t2;
          };
          var w = [301, 302, 303, 307, 308];
          y.redirect = function(t2, e2) {
            if (-1 === w.indexOf(e2))
              throw new RangeError("Invalid status code");
            return new y(null, { status: e2, headers: { location: t2 } });
          };
          var v = i.DOMException;
          try {
            new v();
          } catch (t2) {
            (v = function(t3, e2) {
              this.message = t3, this.name = e2;
              var r2 = Error(t3);
              this.stack = r2.stack;
            }).prototype = Object.create(Error.prototype), v.prototype.constructor = v;
          }
          function x(t2, e2) {
            return new Promise(function(r2, a2) {
              var o2 = new b(t2, e2);
              if (o2.signal && o2.signal.aborted)
                return a2(new v("Aborted", "AbortError"));
              var s2 = new XMLHttpRequest();
              function f2() {
                s2.abort();
              }
              s2.onload = function() {
                var t3, e3, i2 = { status: s2.status, statusText: s2.statusText, headers: (t3 = s2.getAllResponseHeaders() || "", e3 = new u(), t3.replace(/\r?\n[\t ]+/g, " ").split("\r").map(function(t4) {
                  return 0 === t4.indexOf("\n") ? t4.substr(1, t4.length) : t4;
                }).forEach(function(t4) {
                  var r3 = t4.split(":"), i3 = r3.shift().trim();
                  if (i3) {
                    var n3 = r3.join(":").trim();
                    e3.append(i3, n3);
                  }
                }), e3) };
                i2.url = "responseURL" in s2 ? s2.responseURL : i2.headers.get("X-Request-URL");
                var n2 = "response" in s2 ? s2.response : s2.responseText;
                setTimeout(function() {
                  r2(new y(n2, i2));
                }, 0);
              }, s2.onerror = function() {
                setTimeout(function() {
                  a2(new TypeError("Network request failed"));
                }, 0);
              }, s2.ontimeout = function() {
                setTimeout(function() {
                  a2(new TypeError("Network request failed"));
                }, 0);
              }, s2.onabort = function() {
                setTimeout(function() {
                  a2(new v("Aborted", "AbortError"));
                }, 0);
              }, s2.open(o2.method, function(t3) {
                try {
                  return "" === t3 && i.location.href ? i.location.href : t3;
                } catch (e3) {
                  return t3;
                }
              }(o2.url), true), "include" === o2.credentials ? s2.withCredentials = true : "omit" === o2.credentials && (s2.withCredentials = false), "responseType" in s2 && (n.blob ? s2.responseType = "blob" : n.arrayBuffer && o2.headers.get("Content-Type") && -1 !== o2.headers.get("Content-Type").indexOf("application/octet-stream") && (s2.responseType = "arraybuffer")), !e2 || "object" != typeof e2.headers || e2.headers instanceof u ? o2.headers.forEach(function(t3, e3) {
                s2.setRequestHeader(e3, t3);
              }) : Object.getOwnPropertyNames(e2.headers).forEach(function(t3) {
                s2.setRequestHeader(t3, h(e2.headers[t3]));
              }), o2.signal && (o2.signal.addEventListener("abort", f2), s2.onreadystatechange = function() {
                4 === s2.readyState && o2.signal.removeEventListener("abort", f2);
              }), s2.send(void 0 === o2._bodyInit ? null : o2._bodyInit);
            });
          }
          x.polyfill = true, i.fetch || (i.fetch = x, i.Headers = u, i.Request = b, i.Response = y);
        }, 6290: (t, e, r) => {
          "use strict";
          var i = r(5048), n = r(9748), a = r(4655), o = r(1960);
          function s(t2, e2, r2) {
            var i2 = t2;
            return n(e2) ? (r2 = e2, "string" == typeof t2 && (i2 = { uri: t2 })) : i2 = o(e2, { uri: t2 }), i2.callback = r2, i2;
          }
          function h(t2, e2, r2) {
            return f(e2 = s(t2, e2, r2));
          }
          function f(t2) {
            if (void 0 === t2.callback)
              throw new Error("callback argument missing");
            var e2 = false, r2 = function(r3, i3, n3) {
              e2 || (e2 = true, t2.callback(r3, i3, n3));
            };
            function i2() {
              var t3 = void 0;
              if (t3 = u.response ? u.response : u.responseText || function(t4) {
                try {
                  if ("document" === t4.responseType)
                    return t4.responseXML;
                  var e3 = t4.responseXML && "parsererror" === t4.responseXML.documentElement.nodeName;
                  if ("" === t4.responseType && !e3)
                    return t4.responseXML;
                } catch (t5) {
                }
                return null;
              }(u), b)
                try {
                  t3 = JSON.parse(t3);
                } catch (t4) {
                }
              return t3;
            }
            function n2(t3) {
              return clearTimeout(l), t3 instanceof Error || (t3 = new Error("" + (t3 || "Unknown XMLHttpRequest Error"))), t3.statusCode = 0, r2(t3, _);
            }
            function o2() {
              if (!f2) {
                var e3;
                clearTimeout(l), e3 = t2.useXDR && void 0 === u.status ? 200 : 1223 === u.status ? 204 : u.status;
                var n3 = _, o3 = null;
                return 0 !== e3 ? (n3 = { body: i2(), statusCode: e3, method: d, headers: {}, url: c, rawRequest: u }, u.getAllResponseHeaders && (n3.headers = a(u.getAllResponseHeaders()))) : o3 = new Error("Internal XMLHttpRequest Error"), r2(o3, n3, n3.body);
              }
            }
            var s2, f2, u = t2.xhr || null;
            u || (u = t2.cors || t2.useXDR ? new h.XDomainRequest() : new h.XMLHttpRequest());
            var l, c = u.url = t2.uri || t2.url, d = u.method = t2.method || "GET", p = t2.body || t2.data, m = u.headers = t2.headers || {}, g = !!t2.sync, b = false, _ = { body: void 0, headers: {}, statusCode: 0, method: d, url: c, rawRequest: u };
            if ("json" in t2 && false !== t2.json && (b = true, m.accept || m.Accept || (m.Accept = "application/json"), "GET" !== d && "HEAD" !== d && (m["content-type"] || m["Content-Type"] || (m["Content-Type"] = "application/json"), p = JSON.stringify(true === t2.json ? p : t2.json))), u.onreadystatechange = function() {
              4 === u.readyState && setTimeout(o2, 0);
            }, u.onload = o2, u.onerror = n2, u.onprogress = function() {
            }, u.onabort = function() {
              f2 = true;
            }, u.ontimeout = n2, u.open(d, c, !g, t2.username, t2.password), g || (u.withCredentials = !!t2.withCredentials), !g && t2.timeout > 0 && (l = setTimeout(function() {
              if (!f2) {
                f2 = true, u.abort("timeout");
                var t3 = new Error("XMLHttpRequest timeout");
                t3.code = "ETIMEDOUT", n2(t3);
              }
            }, t2.timeout)), u.setRequestHeader)
              for (s2 in m)
                m.hasOwnProperty(s2) && u.setRequestHeader(s2, m[s2]);
            else if (t2.headers && !function(t3) {
              for (var e3 in t3)
                if (t3.hasOwnProperty(e3))
                  return false;
              return true;
            }(t2.headers))
              throw new Error("Headers cannot be set on an XDomainRequest object");
            return "responseType" in t2 && (u.responseType = t2.responseType), "beforeSend" in t2 && "function" == typeof t2.beforeSend && t2.beforeSend(u), u.send(p || null), u;
          }
          t.exports = h, t.exports.default = h, h.XMLHttpRequest = i.XMLHttpRequest || function() {
          }, h.XDomainRequest = "withCredentials" in new h.XMLHttpRequest() ? h.XMLHttpRequest : i.XDomainRequest, function(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2(t2[r2]);
          }(["get", "put", "post", "patch", "head", "delete"], function(t2) {
            h["delete" === t2 ? "del" : t2] = function(e2, r2, i2) {
              return (r2 = s(e2, r2, i2)).method = t2.toUpperCase(), f(r2);
            };
          });
        }, 1596: (t) => {
          t.exports = void 0 !== self.DOMParser ? function(t2) {
            return new self.DOMParser().parseFromString(t2, "application/xml");
          } : void 0 !== self.ActiveXObject && new self.ActiveXObject("Microsoft.XMLDOM") ? function(t2) {
            var e = new self.ActiveXObject("Microsoft.XMLDOM");
            return e.async = "false", e.loadXML(t2), e;
          } : function(t2) {
            var e = document.createElement("div");
            return e.innerHTML = t2, e;
          };
        }, 1960: (t) => {
          t.exports = function() {
            for (var t2 = {}, r = 0; r < arguments.length; r++) {
              var i = arguments[r];
              for (var n in i)
                e.call(i, n) && (t2[n] = i[n]);
            }
            return t2;
          };
          var e = Object.prototype.hasOwnProperty;
        }, 8522: () => {
        }, 6777: () => {
        }, 5546: () => {
        } }, __webpack_module_cache__ = {};
        function __webpack_require__(t) {
          var e = __webpack_module_cache__[t];
          if (void 0 !== e)
            return e.exports;
          var r = __webpack_module_cache__[t] = { exports: {} };
          return __webpack_modules__[t].call(r.exports, r, r.exports, __webpack_require__), r.exports;
        }
        __webpack_require__.n = (t) => {
          var e = t && t.__esModule ? () => t.default : () => t;
          return __webpack_require__.d(e, { a: e }), e;
        }, __webpack_require__.d = (t, e) => {
          for (var r in e)
            __webpack_require__.o(e, r) && !__webpack_require__.o(t, r) && Object.defineProperty(t, r, { enumerable: true, get: e[r] });
        }, __webpack_require__.g = function() {
          if ("object" == typeof globalThis)
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (t) {
            if ("object" == typeof window)
              return window;
          }
        }(), __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = (t) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: true });
        };
        var __webpack_exports__ = {};
        (() => {
          "use strict";
          var t = {};
          __webpack_require__.r(t), __webpack_require__.d(t, { AUTO: () => it, BLEND_ADD: () => dt, BLEND_DARKEN: () => gt, BLEND_DESTINATION_OVER: () => lt, BLEND_DIFFERENCE: () => yt, BLEND_EXCLUSION: () => wt, BLEND_HARDLIGHT: () => _t, BLEND_LIGHTEN: () => bt, BLEND_MULTIPLY: () => ct, BLEND_OVERLAY: () => mt, BLEND_SCREEN: () => pt, BLEND_SOURCE_OVER: () => ut, EDGE_CROP: () => Et, EDGE_EXTEND: () => vt, EDGE_WRAP: () => xt, HORIZONTAL_ALIGN_CENTER: () => at, HORIZONTAL_ALIGN_LEFT: () => nt, HORIZONTAL_ALIGN_RIGHT: () => ot, VERTICAL_ALIGN_BOTTOM: () => ft, VERTICAL_ALIGN_MIDDLE: () => ht, VERTICAL_ALIGN_TOP: () => st });
          var e = {};
          __webpack_require__.r(e), __webpack_require__.d(e, { add: () => At, darken: () => Bt, difference: () => Ot, dstOver: () => St, exclusion: () => Lt, hardLight: () => Pt, lighten: () => Rt, multiply: () => Mt, overlay: () => Tt, screen: () => It, srcOver: () => kt });
          var r = __webpack_require__(5546), i = __webpack_require__.n(r), n = __webpack_require__(1023), a = __webpack_require__.n(n), o = __webpack_require__(2699), s = __webpack_require__.n(o);
          function h(t2) {
            if (void 0 === t2)
              return false;
            if ("function" != typeof t2)
              throw new TypeError("Callback must be a function");
            return true;
          }
          function f(t2, e2) {
            if ("string" == typeof t2 && (t2 = new Error(t2)), "function" == typeof e2)
              return e2.call(this, t2);
            throw t2;
          }
          function u(t2, e2, r2, i2, n2, a2) {
            e2 = Math.round(e2), r2 = Math.round(r2), i2 = Math.round(i2), n2 = Math.round(n2);
            for (let o2 = r2; o2 < r2 + n2; o2++)
              for (let r3 = e2; r3 < e2 + i2; r3++) {
                const e3 = t2.bitmap.width * o2 + r3 << 2;
                a2.call(t2, r3, o2, e3);
              }
            return t2;
          }
          var l = __webpack_require__(236), c = __webpack_require__.n(l), d = __webpack_require__(869), p = __webpack_require__.n(d), m = __webpack_require__(1294), g = __webpack_require__.n(m);
          function b(t2) {
            return b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
              return typeof t3;
            } : function(t3) {
              return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
            }, b(t2);
          }
          var _ = /^\s+/, y = /\s+$/;
          function w(t2, e2) {
            if (e2 = e2 || {}, (t2 = t2 || "") instanceof w)
              return t2;
            if (!(this instanceof w))
              return new w(t2, e2);
            var r2 = function(t3) {
              var e3, r3, i2, n2 = { r: 0, g: 0, b: 0 }, a2 = 1, o2 = null, s2 = null, h2 = null, f2 = false, u2 = false;
              return "string" == typeof t3 && (t3 = function(t4) {
                t4 = t4.replace(_, "").replace(y, "").toLowerCase();
                var e4, r4 = false;
                if (D[t4])
                  t4 = D[t4], r4 = true;
                else if ("transparent" == t4)
                  return { r: 0, g: 0, b: 0, a: 0, format: "name" };
                return (e4 = Q.rgb.exec(t4)) ? { r: e4[1], g: e4[2], b: e4[3] } : (e4 = Q.rgba.exec(t4)) ? { r: e4[1], g: e4[2], b: e4[3], a: e4[4] } : (e4 = Q.hsl.exec(t4)) ? { h: e4[1], s: e4[2], l: e4[3] } : (e4 = Q.hsla.exec(t4)) ? { h: e4[1], s: e4[2], l: e4[3], a: e4[4] } : (e4 = Q.hsv.exec(t4)) ? { h: e4[1], s: e4[2], v: e4[3] } : (e4 = Q.hsva.exec(t4)) ? { h: e4[1], s: e4[2], v: e4[3], a: e4[4] } : (e4 = Q.hex8.exec(t4)) ? { r: G(e4[1]), g: G(e4[2]), b: G(e4[3]), a: Z(e4[4]), format: r4 ? "name" : "hex8" } : (e4 = Q.hex6.exec(t4)) ? { r: G(e4[1]), g: G(e4[2]), b: G(e4[3]), format: r4 ? "name" : "hex" } : (e4 = Q.hex4.exec(t4)) ? { r: G(e4[1] + "" + e4[1]), g: G(e4[2] + "" + e4[2]), b: G(e4[3] + "" + e4[3]), a: Z(e4[4] + "" + e4[4]), format: r4 ? "name" : "hex8" } : !!(e4 = Q.hex3.exec(t4)) && { r: G(e4[1] + "" + e4[1]), g: G(e4[2] + "" + e4[2]), b: G(e4[3] + "" + e4[3]), format: r4 ? "name" : "hex" };
              }(t3)), "object" == b(t3) && (J(t3.r) && J(t3.g) && J(t3.b) ? (e3 = t3.r, r3 = t3.g, i2 = t3.b, n2 = { r: 255 * F(e3, 255), g: 255 * F(r3, 255), b: 255 * F(i2, 255) }, f2 = true, u2 = "%" === String(t3.r).substr(-1) ? "prgb" : "rgb") : J(t3.h) && J(t3.s) && J(t3.v) ? (o2 = W(t3.s), s2 = W(t3.v), n2 = function(t4, e4, r4) {
                t4 = 6 * F(t4, 360), e4 = F(e4, 100), r4 = F(r4, 100);
                var i3 = Math.floor(t4), n3 = t4 - i3, a3 = r4 * (1 - e4), o3 = r4 * (1 - n3 * e4), s3 = r4 * (1 - (1 - n3) * e4), h3 = i3 % 6;
                return { r: 255 * [r4, o3, a3, a3, s3, r4][h3], g: 255 * [s3, r4, r4, o3, a3, a3][h3], b: 255 * [a3, a3, s3, r4, r4, o3][h3] };
              }(t3.h, o2, s2), f2 = true, u2 = "hsv") : J(t3.h) && J(t3.s) && J(t3.l) && (o2 = W(t3.s), h2 = W(t3.l), n2 = function(t4, e4, r4) {
                var i3, n3, a3;
                function o3(t5, e5, r5) {
                  return r5 < 0 && (r5 += 1), r5 > 1 && (r5 -= 1), r5 < 1 / 6 ? t5 + 6 * (e5 - t5) * r5 : r5 < 0.5 ? e5 : r5 < 2 / 3 ? t5 + (e5 - t5) * (2 / 3 - r5) * 6 : t5;
                }
                if (t4 = F(t4, 360), e4 = F(e4, 100), r4 = F(r4, 100), 0 === e4)
                  i3 = n3 = a3 = r4;
                else {
                  var s3 = r4 < 0.5 ? r4 * (1 + e4) : r4 + e4 - r4 * e4, h3 = 2 * r4 - s3;
                  i3 = o3(h3, s3, t4 + 1 / 3), n3 = o3(h3, s3, t4), a3 = o3(h3, s3, t4 - 1 / 3);
                }
                return { r: 255 * i3, g: 255 * n3, b: 255 * a3 };
              }(t3.h, o2, h2), f2 = true, u2 = "hsl"), t3.hasOwnProperty("a") && (a2 = t3.a)), a2 = N(a2), { ok: f2, format: t3.format || u2, r: Math.min(255, Math.max(n2.r, 0)), g: Math.min(255, Math.max(n2.g, 0)), b: Math.min(255, Math.max(n2.b, 0)), a: a2 };
            }(t2);
            this._originalInput = t2, this._r = r2.r, this._g = r2.g, this._b = r2.b, this._a = r2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e2.format || r2.format, this._gradientType = e2.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = r2.ok;
          }
          function v(t2, e2, r2) {
            t2 = F(t2, 255), e2 = F(e2, 255), r2 = F(r2, 255);
            var i2, n2, a2 = Math.max(t2, e2, r2), o2 = Math.min(t2, e2, r2), s2 = (a2 + o2) / 2;
            if (a2 == o2)
              i2 = n2 = 0;
            else {
              var h2 = a2 - o2;
              switch (n2 = s2 > 0.5 ? h2 / (2 - a2 - o2) : h2 / (a2 + o2), a2) {
                case t2:
                  i2 = (e2 - r2) / h2 + (e2 < r2 ? 6 : 0);
                  break;
                case e2:
                  i2 = (r2 - t2) / h2 + 2;
                  break;
                case r2:
                  i2 = (t2 - e2) / h2 + 4;
              }
              i2 /= 6;
            }
            return { h: i2, s: n2, l: s2 };
          }
          function x(t2, e2, r2) {
            t2 = F(t2, 255), e2 = F(e2, 255), r2 = F(r2, 255);
            var i2, n2, a2 = Math.max(t2, e2, r2), o2 = Math.min(t2, e2, r2), s2 = a2, h2 = a2 - o2;
            if (n2 = 0 === a2 ? 0 : h2 / a2, a2 == o2)
              i2 = 0;
            else {
              switch (a2) {
                case t2:
                  i2 = (e2 - r2) / h2 + (e2 < r2 ? 6 : 0);
                  break;
                case e2:
                  i2 = (r2 - t2) / h2 + 2;
                  break;
                case r2:
                  i2 = (t2 - e2) / h2 + 4;
              }
              i2 /= 6;
            }
            return { h: i2, s: n2, v: s2 };
          }
          function E(t2, e2, r2, i2) {
            var n2 = [H(Math.round(t2).toString(16)), H(Math.round(e2).toString(16)), H(Math.round(r2).toString(16))];
            return i2 && n2[0].charAt(0) == n2[0].charAt(1) && n2[1].charAt(0) == n2[1].charAt(1) && n2[2].charAt(0) == n2[2].charAt(1) ? n2[0].charAt(0) + n2[1].charAt(0) + n2[2].charAt(0) : n2.join("");
          }
          function k(t2, e2, r2, i2) {
            return [H(q(i2)), H(Math.round(t2).toString(16)), H(Math.round(e2).toString(16)), H(Math.round(r2).toString(16))].join("");
          }
          function S(t2, e2) {
            e2 = 0 === e2 ? 0 : e2 || 10;
            var r2 = w(t2).toHsl();
            return r2.s -= e2 / 100, r2.s = j(r2.s), w(r2);
          }
          function M(t2, e2) {
            e2 = 0 === e2 ? 0 : e2 || 10;
            var r2 = w(t2).toHsl();
            return r2.s += e2 / 100, r2.s = j(r2.s), w(r2);
          }
          function A(t2) {
            return w(t2).desaturate(100);
          }
          function I(t2, e2) {
            e2 = 0 === e2 ? 0 : e2 || 10;
            var r2 = w(t2).toHsl();
            return r2.l += e2 / 100, r2.l = j(r2.l), w(r2);
          }
          function T(t2, e2) {
            e2 = 0 === e2 ? 0 : e2 || 10;
            var r2 = w(t2).toRgb();
            return r2.r = Math.max(0, Math.min(255, r2.r - Math.round(-e2 / 100 * 255))), r2.g = Math.max(0, Math.min(255, r2.g - Math.round(-e2 / 100 * 255))), r2.b = Math.max(0, Math.min(255, r2.b - Math.round(-e2 / 100 * 255))), w(r2);
          }
          function B(t2, e2) {
            e2 = 0 === e2 ? 0 : e2 || 10;
            var r2 = w(t2).toHsl();
            return r2.l -= e2 / 100, r2.l = j(r2.l), w(r2);
          }
          function R(t2, e2) {
            var r2 = w(t2).toHsl(), i2 = (r2.h + e2) % 360;
            return r2.h = i2 < 0 ? 360 + i2 : i2, w(r2);
          }
          function P(t2) {
            var e2 = w(t2).toHsl();
            return e2.h = (e2.h + 180) % 360, w(e2);
          }
          function O(t2, e2) {
            if (isNaN(e2) || e2 <= 0)
              throw new Error("Argument to polyad must be a positive number");
            for (var r2 = w(t2).toHsl(), i2 = [w(t2)], n2 = 360 / e2, a2 = 1; a2 < e2; a2++)
              i2.push(w({ h: (r2.h + a2 * n2) % 360, s: r2.s, l: r2.l }));
            return i2;
          }
          function L(t2) {
            var e2 = w(t2).toHsl(), r2 = e2.h;
            return [w(t2), w({ h: (r2 + 72) % 360, s: e2.s, l: e2.l }), w({ h: (r2 + 216) % 360, s: e2.s, l: e2.l })];
          }
          function C(t2, e2, r2) {
            e2 = e2 || 6, r2 = r2 || 30;
            var i2 = w(t2).toHsl(), n2 = 360 / r2, a2 = [w(t2)];
            for (i2.h = (i2.h - (n2 * e2 >> 1) + 720) % 360; --e2; )
              i2.h = (i2.h + n2) % 360, a2.push(w(i2));
            return a2;
          }
          function U(t2, e2) {
            e2 = e2 || 6;
            for (var r2 = w(t2).toHsv(), i2 = r2.h, n2 = r2.s, a2 = r2.v, o2 = [], s2 = 1 / e2; e2--; )
              o2.push(w({ h: i2, s: n2, v: a2 })), a2 = (a2 + s2) % 1;
            return o2;
          }
          w.prototype = { isDark: function() {
            return this.getBrightness() < 128;
          }, isLight: function() {
            return !this.isDark();
          }, isValid: function() {
            return this._ok;
          }, getOriginalInput: function() {
            return this._originalInput;
          }, getFormat: function() {
            return this._format;
          }, getAlpha: function() {
            return this._a;
          }, getBrightness: function() {
            var t2 = this.toRgb();
            return (299 * t2.r + 587 * t2.g + 114 * t2.b) / 1e3;
          }, getLuminance: function() {
            var t2, e2, r2, i2 = this.toRgb();
            return t2 = i2.r / 255, e2 = i2.g / 255, r2 = i2.b / 255, 0.2126 * (t2 <= 0.03928 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4)) + 0.7152 * (e2 <= 0.03928 ? e2 / 12.92 : Math.pow((e2 + 0.055) / 1.055, 2.4)) + 0.0722 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4));
          }, setAlpha: function(t2) {
            return this._a = N(t2), this._roundA = Math.round(100 * this._a) / 100, this;
          }, toHsv: function() {
            var t2 = x(this._r, this._g, this._b);
            return { h: 360 * t2.h, s: t2.s, v: t2.v, a: this._a };
          }, toHsvString: function() {
            var t2 = x(this._r, this._g, this._b), e2 = Math.round(360 * t2.h), r2 = Math.round(100 * t2.s), i2 = Math.round(100 * t2.v);
            return 1 == this._a ? "hsv(" + e2 + ", " + r2 + "%, " + i2 + "%)" : "hsva(" + e2 + ", " + r2 + "%, " + i2 + "%, " + this._roundA + ")";
          }, toHsl: function() {
            var t2 = v(this._r, this._g, this._b);
            return { h: 360 * t2.h, s: t2.s, l: t2.l, a: this._a };
          }, toHslString: function() {
            var t2 = v(this._r, this._g, this._b), e2 = Math.round(360 * t2.h), r2 = Math.round(100 * t2.s), i2 = Math.round(100 * t2.l);
            return 1 == this._a ? "hsl(" + e2 + ", " + r2 + "%, " + i2 + "%)" : "hsla(" + e2 + ", " + r2 + "%, " + i2 + "%, " + this._roundA + ")";
          }, toHex: function(t2) {
            return E(this._r, this._g, this._b, t2);
          }, toHexString: function(t2) {
            return "#" + this.toHex(t2);
          }, toHex8: function(t2) {
            return function(t3, e2, r2, i2, n2) {
              var a2 = [H(Math.round(t3).toString(16)), H(Math.round(e2).toString(16)), H(Math.round(r2).toString(16)), H(q(i2))];
              return n2 && a2[0].charAt(0) == a2[0].charAt(1) && a2[1].charAt(0) == a2[1].charAt(1) && a2[2].charAt(0) == a2[2].charAt(1) && a2[3].charAt(0) == a2[3].charAt(1) ? a2[0].charAt(0) + a2[1].charAt(0) + a2[2].charAt(0) + a2[3].charAt(0) : a2.join("");
            }(this._r, this._g, this._b, this._a, t2);
          }, toHex8String: function(t2) {
            return "#" + this.toHex8(t2);
          }, toRgb: function() {
            return { r: Math.round(this._r), g: Math.round(this._g), b: Math.round(this._b), a: this._a };
          }, toRgbString: function() {
            return 1 == this._a ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
          }, toPercentageRgb: function() {
            return { r: Math.round(100 * F(this._r, 255)) + "%", g: Math.round(100 * F(this._g, 255)) + "%", b: Math.round(100 * F(this._b, 255)) + "%", a: this._a };
          }, toPercentageRgbString: function() {
            return 1 == this._a ? "rgb(" + Math.round(100 * F(this._r, 255)) + "%, " + Math.round(100 * F(this._g, 255)) + "%, " + Math.round(100 * F(this._b, 255)) + "%)" : "rgba(" + Math.round(100 * F(this._r, 255)) + "%, " + Math.round(100 * F(this._g, 255)) + "%, " + Math.round(100 * F(this._b, 255)) + "%, " + this._roundA + ")";
          }, toName: function() {
            return 0 === this._a ? "transparent" : !(this._a < 1) && (z[E(this._r, this._g, this._b, true)] || false);
          }, toFilter: function(t2) {
            var e2 = "#" + k(this._r, this._g, this._b, this._a), r2 = e2, i2 = this._gradientType ? "GradientType = 1, " : "";
            if (t2) {
              var n2 = w(t2);
              r2 = "#" + k(n2._r, n2._g, n2._b, n2._a);
            }
            return "progid:DXImageTransform.Microsoft.gradient(" + i2 + "startColorstr=" + e2 + ",endColorstr=" + r2 + ")";
          }, toString: function(t2) {
            var e2 = !!t2;
            t2 = t2 || this._format;
            var r2 = false, i2 = this._a < 1 && this._a >= 0;
            return e2 || !i2 || "hex" !== t2 && "hex6" !== t2 && "hex3" !== t2 && "hex4" !== t2 && "hex8" !== t2 && "name" !== t2 ? ("rgb" === t2 && (r2 = this.toRgbString()), "prgb" === t2 && (r2 = this.toPercentageRgbString()), "hex" !== t2 && "hex6" !== t2 || (r2 = this.toHexString()), "hex3" === t2 && (r2 = this.toHexString(true)), "hex4" === t2 && (r2 = this.toHex8String(true)), "hex8" === t2 && (r2 = this.toHex8String()), "name" === t2 && (r2 = this.toName()), "hsl" === t2 && (r2 = this.toHslString()), "hsv" === t2 && (r2 = this.toHsvString()), r2 || this.toHexString()) : "name" === t2 && 0 === this._a ? this.toName() : this.toRgbString();
          }, clone: function() {
            return w(this.toString());
          }, _applyModification: function(t2, e2) {
            var r2 = t2.apply(null, [this].concat([].slice.call(e2)));
            return this._r = r2._r, this._g = r2._g, this._b = r2._b, this.setAlpha(r2._a), this;
          }, lighten: function() {
            return this._applyModification(I, arguments);
          }, brighten: function() {
            return this._applyModification(T, arguments);
          }, darken: function() {
            return this._applyModification(B, arguments);
          }, desaturate: function() {
            return this._applyModification(S, arguments);
          }, saturate: function() {
            return this._applyModification(M, arguments);
          }, greyscale: function() {
            return this._applyModification(A, arguments);
          }, spin: function() {
            return this._applyModification(R, arguments);
          }, _applyCombination: function(t2, e2) {
            return t2.apply(null, [this].concat([].slice.call(e2)));
          }, analogous: function() {
            return this._applyCombination(C, arguments);
          }, complement: function() {
            return this._applyCombination(P, arguments);
          }, monochromatic: function() {
            return this._applyCombination(U, arguments);
          }, splitcomplement: function() {
            return this._applyCombination(L, arguments);
          }, triad: function() {
            return this._applyCombination(O, [3]);
          }, tetrad: function() {
            return this._applyCombination(O, [4]);
          } }, w.fromRatio = function(t2, e2) {
            if ("object" == b(t2)) {
              var r2 = {};
              for (var i2 in t2)
                t2.hasOwnProperty(i2) && (r2[i2] = "a" === i2 ? t2[i2] : W(t2[i2]));
              t2 = r2;
            }
            return w(t2, e2);
          }, w.equals = function(t2, e2) {
            return !(!t2 || !e2) && w(t2).toRgbString() == w(e2).toRgbString();
          }, w.random = function() {
            return w.fromRatio({ r: Math.random(), g: Math.random(), b: Math.random() });
          }, w.mix = function(t2, e2, r2) {
            r2 = 0 === r2 ? 0 : r2 || 50;
            var i2 = w(t2).toRgb(), n2 = w(e2).toRgb(), a2 = r2 / 100;
            return w({ r: (n2.r - i2.r) * a2 + i2.r, g: (n2.g - i2.g) * a2 + i2.g, b: (n2.b - i2.b) * a2 + i2.b, a: (n2.a - i2.a) * a2 + i2.a });
          }, w.readability = function(t2, e2) {
            var r2 = w(t2), i2 = w(e2);
            return (Math.max(r2.getLuminance(), i2.getLuminance()) + 0.05) / (Math.min(r2.getLuminance(), i2.getLuminance()) + 0.05);
          }, w.isReadable = function(t2, e2, r2) {
            var i2, n2, a2, o2, s2, h2 = w.readability(t2, e2);
            switch (n2 = false, (a2 = r2, "AA" !== (o2 = ((a2 = a2 || { level: "AA", size: "small" }).level || "AA").toUpperCase()) && "AAA" !== o2 && (o2 = "AA"), "small" !== (s2 = (a2.size || "small").toLowerCase()) && "large" !== s2 && (s2 = "small"), i2 = { level: o2, size: s2 }).level + i2.size) {
              case "AAsmall":
              case "AAAlarge":
                n2 = h2 >= 4.5;
                break;
              case "AAlarge":
                n2 = h2 >= 3;
                break;
              case "AAAsmall":
                n2 = h2 >= 7;
            }
            return n2;
          }, w.mostReadable = function(t2, e2, r2) {
            var i2, n2, a2, o2, s2 = null, h2 = 0;
            n2 = (r2 = r2 || {}).includeFallbackColors, a2 = r2.level, o2 = r2.size;
            for (var f2 = 0; f2 < e2.length; f2++)
              (i2 = w.readability(t2, e2[f2])) > h2 && (h2 = i2, s2 = w(e2[f2]));
            return w.isReadable(t2, s2, { level: a2, size: o2 }) || !n2 ? s2 : (r2.includeFallbackColors = false, w.mostReadable(t2, ["#fff", "#000"], r2));
          };
          var D = w.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, z = w.hexNames = function(t2) {
            var e2 = {};
            for (var r2 in t2)
              t2.hasOwnProperty(r2) && (e2[t2[r2]] = r2);
            return e2;
          }(D);
          function N(t2) {
            return t2 = parseFloat(t2), (isNaN(t2) || t2 < 0 || t2 > 1) && (t2 = 1), t2;
          }
          function F(t2, e2) {
            (function(t3) {
              return "string" == typeof t3 && -1 != t3.indexOf(".") && 1 === parseFloat(t3);
            })(t2) && (t2 = "100%");
            var r2 = function(t3) {
              return "string" == typeof t3 && -1 != t3.indexOf("%");
            }(t2);
            return t2 = Math.min(e2, Math.max(0, parseFloat(t2))), r2 && (t2 = parseInt(t2 * e2, 10) / 100), Math.abs(t2 - e2) < 1e-6 ? 1 : t2 % e2 / parseFloat(e2);
          }
          function j(t2) {
            return Math.min(1, Math.max(0, t2));
          }
          function G(t2) {
            return parseInt(t2, 16);
          }
          function H(t2) {
            return 1 == t2.length ? "0" + t2 : "" + t2;
          }
          function W(t2) {
            return t2 <= 1 && (t2 = 100 * t2 + "%"), t2;
          }
          function q(t2) {
            return Math.round(255 * parseFloat(t2)).toString(16);
          }
          function Z(t2) {
            return G(t2) / 255;
          }
          var Y, V, X, Q = (V = "[\\s|\\(]+(" + (Y = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)") + ")[,|\\s]+(" + Y + ")[,|\\s]+(" + Y + ")\\s*\\)?", X = "[\\s|\\(]+(" + Y + ")[,|\\s]+(" + Y + ")[,|\\s]+(" + Y + ")[,|\\s]+(" + Y + ")\\s*\\)?", { CSS_UNIT: new RegExp(Y), rgb: new RegExp("rgb" + V), rgba: new RegExp("rgba" + X), hsl: new RegExp("hsl" + V), hsla: new RegExp("hsla" + X), hsv: new RegExp("hsv" + V), hsva: new RegExp("hsva" + X), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ });
          function J(t2) {
            return !!Q.CSS_UNIT.exec(t2);
          }
          function K(t2, e2) {
            this.size = this.size || t2, this.smallerSize = this.smallerSize || e2, function(t3) {
              for (let e3 = 1; e3 < t3; e3++)
                tt[e3] = 1;
              tt[0] = 1 / Math.sqrt(2);
            }(this.size);
          }
          function $(t2) {
            const e2 = {};
            return e2.r = Math.floor(t2 / Math.pow(256, 3)), e2.g = Math.floor((t2 - e2.r * Math.pow(256, 3)) / Math.pow(256, 2)), e2.b = Math.floor((t2 - e2.r * Math.pow(256, 3) - e2.g * Math.pow(256, 2)) / Math.pow(256, 1)), e2.a = Math.floor((t2 - e2.r * Math.pow(256, 3) - e2.g * Math.pow(256, 2) - e2.b * Math.pow(256, 1)) / Math.pow(256, 0)), e2;
          }
          K.prototype.size = 32, K.prototype.smallerSize = 8, K.prototype.distance = function(t2, e2) {
            let r2 = 0;
            for (let i2 = 0; i2 < t2.length; i2++)
              t2[i2] !== e2[i2] && r2++;
            return r2 / t2.length;
          }, K.prototype.getHash = function(t2) {
            (t2 = t2.clone().resize(this.size, this.size)).grayscale();
            const e2 = [];
            for (let r3 = 0; r3 < t2.bitmap.width; r3++) {
              e2[r3] = [];
              for (let i3 = 0; i3 < t2.bitmap.height; i3++)
                e2[r3][i3] = $(t2.getPixelColor(r3, i3)).b;
            }
            const r2 = function(t3, e3) {
              const r3 = e3, i3 = [];
              for (let e4 = 0; e4 < r3; e4++) {
                i3[e4] = [];
                for (let n3 = 0; n3 < r3; n3++) {
                  let a3 = 0;
                  for (let i4 = 0; i4 < r3; i4++)
                    for (let o2 = 0; o2 < r3; o2++)
                      a3 += Math.cos((2 * i4 + 1) / (2 * r3) * e4 * Math.PI) * Math.cos((2 * o2 + 1) / (2 * r3) * n3 * Math.PI) * t3[i4][o2];
                  a3 *= tt[e4] * tt[n3] / 4, i3[e4][n3] = a3;
                }
              }
              return i3;
            }(e2, this.size);
            let i2 = 0;
            for (let t3 = 0; t3 < this.smallerSize; t3++)
              for (let e3 = 0; e3 < this.smallerSize; e3++)
                i2 += r2[t3][e3];
            const n2 = i2 / (this.smallerSize * this.smallerSize);
            let a2 = "";
            for (let t3 = 0; t3 < this.smallerSize; t3++)
              for (let e3 = 0; e3 < this.smallerSize; e3++)
                a2 += r2[t3][e3] > n2 ? "1" : "0";
            return a2;
          };
          const tt = [], et = K;
          __webpack_require__(9307);
          const rt = (t2, e2) => {
            let { url: r2, ...i2 } = t2;
            fetch(r2, i2).then((t3) => {
              if (t3.ok)
                return t3.arrayBuffer().catch((t4) => {
                  throw new Error(`Response is not a buffer for url ${r2}. Error: ${t4.message}`);
                });
              throw new Error(`HTTP Status ${t3.status} for url ${r2}`);
            }).then((t3) => e2(null, t3)).catch((t3) => e2(t3));
          }, it = -1, nt = 1, at = 2, ot = 4, st = 8, ht = 16, ft = 32, ut = "srcOver", lt = "dstOver", ct = "multiply", dt = "add", pt = "screen", mt = "overlay", gt = "darken", bt = "lighten", _t = "hardLight", yt = "difference", wt = "exclusion", vt = 1, xt = 2, Et = 3;
          function kt(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a;
            return { r: (t2.r * t2.a + e2.r * e2.a * (1 - t2.a)) / i2, g: (t2.g * t2.a + e2.g * e2.a * (1 - t2.a)) / i2, b: (t2.b * t2.a + e2.b * e2.a * (1 - t2.a)) / i2, a: i2 };
          }
          function St(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a;
            return { r: (e2.r * e2.a + t2.r * t2.a * (1 - e2.a)) / i2, g: (e2.g * e2.a + t2.g * t2.a * (1 - e2.a)) / i2, b: (e2.b * e2.a + t2.b * t2.a * (1 - e2.a)) / i2, a: i2 };
          }
          function Mt(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a, s2 = e2.r * e2.a, h2 = e2.g * e2.a, f2 = e2.b * e2.a;
            return { r: (n2 * s2 + n2 * (1 - e2.a) + s2 * (1 - t2.a)) / i2, g: (a2 * h2 + a2 * (1 - e2.a) + h2 * (1 - t2.a)) / i2, b: (o2 * f2 + o2 * (1 - e2.a) + f2 * (1 - t2.a)) / i2, a: i2 };
          }
          function At(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a;
            return { r: (n2 + e2.r * e2.a) / i2, g: (a2 + e2.g * e2.a) / i2, b: (o2 + e2.b * e2.a) / i2, a: i2 };
          }
          function It(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a, s2 = e2.r * e2.a, h2 = e2.g * e2.a, f2 = e2.b * e2.a;
            return { r: (n2 * e2.a + s2 * t2.a - n2 * s2 + n2 * (1 - e2.a) + s2 * (1 - t2.a)) / i2, g: (a2 * e2.a + h2 * t2.a - a2 * h2 + a2 * (1 - e2.a) + h2 * (1 - t2.a)) / i2, b: (o2 * e2.a + f2 * t2.a - o2 * f2 + o2 * (1 - e2.a) + f2 * (1 - t2.a)) / i2, a: i2 };
          }
          function Tt(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a, s2 = e2.r * e2.a, h2 = e2.g * e2.a, f2 = e2.b * e2.a;
            return { r: (2 * s2 <= e2.a ? 2 * n2 * s2 + n2 * (1 - e2.a) + s2 * (1 - t2.a) : n2 * (1 + e2.a) + s2 * (1 + t2.a) - 2 * s2 * n2 - e2.a * t2.a) / i2, g: (2 * h2 <= e2.a ? 2 * a2 * h2 + a2 * (1 - e2.a) + h2 * (1 - t2.a) : a2 * (1 + e2.a) + h2 * (1 + t2.a) - 2 * h2 * a2 - e2.a * t2.a) / i2, b: (2 * f2 <= e2.a ? 2 * o2 * f2 + o2 * (1 - e2.a) + f2 * (1 - t2.a) : o2 * (1 + e2.a) + f2 * (1 + t2.a) - 2 * f2 * o2 - e2.a * t2.a) / i2, a: i2 };
          }
          function Bt(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a, s2 = e2.r * e2.a, h2 = e2.g * e2.a, f2 = e2.b * e2.a;
            return { r: (Math.min(n2 * e2.a, s2 * t2.a) + n2 * (1 - e2.a) + s2 * (1 - t2.a)) / i2, g: (Math.min(a2 * e2.a, h2 * t2.a) + a2 * (1 - e2.a) + h2 * (1 - t2.a)) / i2, b: (Math.min(o2 * e2.a, f2 * t2.a) + o2 * (1 - e2.a) + f2 * (1 - t2.a)) / i2, a: i2 };
          }
          function Rt(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a, s2 = e2.r * e2.a, h2 = e2.g * e2.a, f2 = e2.b * e2.a;
            return { r: (Math.max(n2 * e2.a, s2 * t2.a) + n2 * (1 - e2.a) + s2 * (1 - t2.a)) / i2, g: (Math.max(a2 * e2.a, h2 * t2.a) + a2 * (1 - e2.a) + h2 * (1 - t2.a)) / i2, b: (Math.max(o2 * e2.a, f2 * t2.a) + o2 * (1 - e2.a) + f2 * (1 - t2.a)) / i2, a: i2 };
          }
          function Pt(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a, s2 = e2.r * e2.a, h2 = e2.g * e2.a, f2 = e2.b * e2.a;
            return { r: (2 * n2 <= t2.a ? 2 * n2 * s2 + n2 * (1 - e2.a) + s2 * (1 - t2.a) : n2 * (1 + e2.a) + s2 * (1 + t2.a) - 2 * s2 * n2 - e2.a * t2.a) / i2, g: (2 * a2 <= t2.a ? 2 * a2 * h2 + a2 * (1 - e2.a) + h2 * (1 - t2.a) : a2 * (1 + e2.a) + h2 * (1 + t2.a) - 2 * h2 * a2 - e2.a * t2.a) / i2, b: (2 * o2 <= t2.a ? 2 * o2 * f2 + o2 * (1 - e2.a) + f2 * (1 - t2.a) : o2 * (1 + e2.a) + f2 * (1 + t2.a) - 2 * f2 * o2 - e2.a * t2.a) / i2, a: i2 };
          }
          function Ot(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a, s2 = e2.r * e2.a, h2 = e2.g * e2.a, f2 = e2.b * e2.a;
            return { r: (n2 + s2 - 2 * Math.min(n2 * e2.a, s2 * t2.a)) / i2, g: (a2 + h2 - 2 * Math.min(a2 * e2.a, h2 * t2.a)) / i2, b: (o2 + f2 - 2 * Math.min(o2 * e2.a, f2 * t2.a)) / i2, a: i2 };
          }
          function Lt(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            t2.a *= r2;
            const i2 = e2.a + t2.a - e2.a * t2.a, n2 = t2.r * t2.a, a2 = t2.g * t2.a, o2 = t2.b * t2.a, s2 = e2.r * e2.a, h2 = e2.g * e2.a, f2 = e2.b * e2.a;
            return { r: (n2 * e2.a + s2 * t2.a - 2 * n2 * s2 + n2 * (1 - e2.a) + s2 * (1 - t2.a)) / i2, g: (a2 * e2.a + h2 * t2.a - 2 * a2 * h2 + a2 * (1 - e2.a) + h2 * (1 - t2.a)) / i2, b: (o2 * e2.a + f2 * t2.a - 2 * o2 * f2 + o2 * (1 - e2.a) + f2 * (1 - t2.a)) / i2, a: i2 };
          }
          const Ct = function(t2, e2) {
            for (var r2 = arguments.length, i2 = new Array(r2 > 2 ? r2 - 2 : 0), n2 = 2; n2 < r2; n2++)
              i2[n2 - 2] = arguments[n2];
            return new Promise((r3, n3) => {
              i2.push((t3, e3) => {
                t3 && n3(t3), r3(e3);
              }), t2.bind(e2)(...i2);
            });
          }, Ut = {}, Dt = (t2, e2) => {
            Ut[t2] = e2;
          }, zt = (t2) => {
            const e2 = t2.split("/").slice(-1);
            var r2;
            return (r2 = e2[e2.length - 1].split(".").pop(), Object.entries(Ut).find((t3) => t3[1].includes(r2)) || [])[0];
          };
          var Nt = __webpack_require__(5025), Ft = __webpack_require__.n(Nt), jt = __webpack_require__(6551), Gt = __webpack_require__.n(jt), Ht = __webpack_require__(8834).lW;
          function Wt(t2) {
            return t2._exif && t2._exif.tags && t2._exif.tags.Orientation || 1;
          }
          async function qt(t2, e2, r2) {
            const i2 = await async function(t3, e3) {
              const r3 = await Ft().fromBuffer(t3);
              return r3 ? r3.mime : e3 ? zt(e3) : null;
            }(t2, e2);
            if ("string" != typeof i2)
              return r2(new Error("Could not find MIME for Buffer <" + e2 + ">"));
            this._originalMime = i2.toLowerCase();
            try {
              const e3 = this.getMIME();
              if (!this.constructor.decoders[e3])
                return f.call(this, "Unsupported MIME type: " + e3, r2);
              this.bitmap = this.constructor.decoders[e3](t2);
            } catch (t3) {
              return r2.call(this, t3, this);
            }
            try {
              this._exif = Gt().create(t2).parse(), function(t3) {
                if (Wt(t3) < 2)
                  return;
                const e3 = function(t4) {
                  const e4 = t4.getWidth(), r4 = t4.getHeight();
                  switch (Wt(t4)) {
                    case 1:
                    default:
                      return null;
                    case 2:
                      return function(t5, r5) {
                        return [e4 - t5 - 1, r5];
                      };
                    case 3:
                      return function(t5, i3) {
                        return [e4 - t5 - 1, r4 - i3 - 1];
                      };
                    case 4:
                      return function(t5, e5) {
                        return [t5, r4 - e5 - 1];
                      };
                    case 5:
                      return function(t5, e5) {
                        return [e5, t5];
                      };
                    case 6:
                      return function(t5, e5) {
                        return [e5, r4 - t5 - 1];
                      };
                    case 7:
                      return function(t5, i3) {
                        return [e4 - i3 - 1, r4 - t5 - 1];
                      };
                    case 8:
                      return function(t5, r5) {
                        return [e4 - r5 - 1, t5];
                      };
                  }
                }(t3), r3 = Wt(t3) > 4;
                !function(t4, e4, r4, i3) {
                  const n2 = t4.bitmap.data, a2 = t4.bitmap.width, o2 = Ht.alloc(n2.length);
                  for (let t5 = 0; t5 < e4; t5++)
                    for (let s2 = 0; s2 < r4; s2++) {
                      const [r5, h2] = i3(t5, s2), f2 = e4 * s2 + t5 << 2, u2 = a2 * h2 + r5 << 2, l2 = n2.readUInt32BE(u2);
                      o2.writeUInt32BE(l2, f2);
                    }
                  t4.bitmap.data = o2, t4.bitmap.width = e4, t4.bitmap.height = r4;
                }(t3, r3 ? t3.bitmap.height : t3.bitmap.width, r3 ? t3.bitmap.width : t3.bitmap.height, e3);
              }(this);
            } catch (t3) {
            }
            return r2.call(this, null, this), this;
          }
          function Zt(t2, e2) {
            if (t2 === it && (t2 = this.getMIME()), "string" != typeof t2)
              return f.call(this, "mime must be a string", e2);
            if ("function" != typeof e2)
              return f.call(this, "cb must be a function", e2);
            if (t2 = t2.toLowerCase(), this._rgba && this.constructor.hasAlpha[t2] ? this.bitmap.data = Ht.from(this.bitmap.data) : this.bitmap.data = function(t3, e3) {
              return new t3(e3.bitmap.width, e3.bitmap.height, e3._background).composite(e3, 0, 0).bitmap;
            }(this.constructor, this).data, !this.constructor.encoders[t2])
              return f.call(this, "Unsupported MIME type: " + t2, e2);
            {
              const r2 = this.constructor.encoders[t2](this);
              e2.call(this, null, r2);
            }
            return this;
          }
          function Yt(t2) {
            return Ct(Zt, this, t2);
          }
          var Vt = __webpack_require__(8834).lW;
          function Xt(t2, e2, r2) {
            return (e2 = function(t3) {
              var e3 = function(t4, e4) {
                if ("object" != typeof t4 || null === t4)
                  return t4;
                var r3 = t4[Symbol.toPrimitive];
                if (void 0 !== r3) {
                  var i2 = r3.call(t4, "string");
                  if ("object" != typeof i2)
                    return i2;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t4);
              }(t3);
              return "symbol" == typeof e3 ? e3 : String(e3);
            }(e2)) in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
          }
          const Qt = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", Jt = [NaN, NaN];
          for (let t2 = 2; t2 < 65; t2++) {
            const e2 = c()(c().BIN, Qt.slice(0, t2))(new Array(65).join("1"));
            Jt.push(e2.length);
          }
          function Kt() {
          }
          function $t(t2) {
            return Object.prototype.toString.call(t2).toLowerCase().indexOf("arraybuffer") > -1;
          }
          function te(t2) {
            const e2 = Vt.alloc(t2.byteLength), r2 = new Uint8Array(t2);
            for (let t3 = 0; t3 < e2.length; ++t3)
              e2[t3] = r2[t3];
            return e2;
          }
          function ee(t2, e2) {
            rt(t2, (r2, i2) => r2 ? e2(r2) : "object" == typeof i2 && Vt.isBuffer(i2) ? e2(null, i2) : "object" == typeof i2 && $t(i2) ? e2(null, te(i2)) : new Error(`Could not load Buffer from <${t2.url}>`));
          }
          const re = { data: null, width: null, height: null };
          class ie extends s() {
            constructor() {
              for (var t2 = arguments.length, e2 = new Array(t2), r2 = 0; r2 < t2; r2++)
                e2[r2] = arguments[r2];
              super(), Xt(this, "bitmap", re), Xt(this, "_background", 0), Xt(this, "_originalMime", ie.MIME_PNG), Xt(this, "_exif", null), Xt(this, "_rgba", true), Xt(this, "writeAsync", (t3) => Ct(this.write, this, t3)), Xt(this, "getBase64Async", (t3) => Ct(this.getBase64, this, t3)), Xt(this, "getBuffer", Zt), Xt(this, "getBufferAsync", Yt), Xt(this, "getPixelColour", this.getPixelColor), Xt(this, "setPixelColour", this.setPixelColor);
              const n2 = this;
              let a2 = Kt;
              function o2() {
                for (var t3 = arguments.length, e3 = new Array(t3), r3 = 0; r3 < t3; r3++)
                  e3[r3] = arguments[r3];
                const [i2] = e3;
                (i2 || {}).methodName = "constructor", setTimeout(() => {
                  i2 && a2 === Kt ? n2.emitError("constructor", i2) : i2 || n2.emitMulti("constructor", "initialized"), a2.call(n2, ...e3);
                }, 1);
              }
              if ($t(e2[0]) && (e2[0] = te(e2[0])), "number" == typeof e2[0] && "number" == typeof e2[1] || parseInt(e2[0], 10) && parseInt(e2[1], 10)) {
                const t3 = parseInt(e2[0], 10), r3 = parseInt(e2[1], 10);
                if (a2 = e2[2], "number" == typeof e2[2] && (this._background = e2[2], a2 = e2[3]), "string" == typeof e2[2] && (this._background = ie.cssColorToHex(e2[2]), a2 = e2[3]), void 0 === a2 && (a2 = Kt), "function" != typeof a2)
                  return f.call(this, "cb must be a function", o2);
                this.bitmap = { data: Vt.alloc(t3 * r3 * 4), width: t3, height: r3 };
                for (let t4 = 0; t4 < this.bitmap.data.length; t4 += 4)
                  this.bitmap.data.writeUInt32BE(this._background, t4);
                o2(null, this);
              } else if ("object" == typeof e2[0] && e2[0].url) {
                if (a2 = e2[1] || Kt, "function" != typeof a2)
                  return f.call(this, "cb must be a function", o2);
                ee(e2[0], (t3, r3) => {
                  if (t3)
                    return f.call(this, t3, o2);
                  this.parseBitmap(r3, e2[0].url, o2);
                });
              } else if (e2[0] instanceof ie) {
                const [t3] = e2;
                if (a2 = e2[1], void 0 === a2 && (a2 = Kt), "function" != typeof a2)
                  return f.call(this, "cb must be a function", o2);
                this.bitmap = { data: Vt.from(t3.bitmap.data), width: t3.bitmap.width, height: t3.bitmap.height }, this._quality = t3._quality, this._deflateLevel = t3._deflateLevel, this._deflateStrategy = t3._deflateStrategy, this._filterType = t3._filterType, this._rgba = t3._rgba, this._background = t3._background, this._originalMime = t3._originalMime, o2(null, this);
              } else if ((s2 = e2[0]) && "object" == typeof s2 && "number" == typeof s2.width && "number" == typeof s2.height && (Vt.isBuffer(s2.data) || s2.data instanceof Uint8Array || "function" == typeof Uint8ClampedArray && s2.data instanceof Uint8ClampedArray) && (s2.data.length === s2.width * s2.height * 4 || s2.data.length === s2.width * s2.height * 3)) {
                const [t3] = e2;
                a2 = e2[1] || Kt;
                const r3 = t3.width * t3.height * 4 === t3.data.length ? Vt.from(t3.data) : function(t4) {
                  if (t4.length % 3 != 0)
                    throw new Error("Buffer length is incorrect");
                  const e3 = Vt.allocUnsafe(t4.length / 3 * 4);
                  let r4 = 0;
                  for (let i2 = 0; i2 < t4.length; i2++)
                    e3[r4] = t4[i2], (i2 + 1) % 3 == 0 && (e3[++r4] = 255), r4++;
                  return e3;
                }(t3.data);
                this.bitmap = { data: r3, width: t3.width, height: t3.height }, o2(null, this);
              } else if ("string" == typeof e2[0]) {
                const t3 = e2[0];
                if (a2 = e2[1], void 0 === a2 && (a2 = Kt), "function" != typeof a2)
                  return f.call(this, "cb must be a function", o2);
                !function(t4, e3) {
                  i() && "function" == typeof i().readFile && !t4.match(/^(http|ftp)s?:\/\/./) ? i().readFile(t4, e3) : ee({ url: t4 }, e3);
                }(t3, (e3, r3) => {
                  if (e3)
                    return f.call(this, e3, o2);
                  this.parseBitmap(r3, t3, o2);
                });
              } else if ("object" == typeof e2[0] && Vt.isBuffer(e2[0])) {
                const t3 = e2[0];
                if (a2 = e2[1], "function" != typeof a2)
                  return f.call(this, "cb must be a function", o2);
                this.parseBitmap(t3, null, o2);
              } else {
                a2 = e2[e2.length - 1], "function" != typeof a2 && (a2 = e2[e2.length - 2], "function" != typeof a2 && (a2 = Kt));
                const t3 = ie.__extraConstructors.find((t4) => t4.test(...e2));
                if (!t3)
                  return f.call(this, "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", o2);
                new Promise((r3, i2) => {
                  t3.run.call(this, r3, i2, ...e2);
                }).then(() => o2(null, this)).catch(o2);
              }
              var s2;
            }
            parseBitmap(t2, e2, r2) {
              qt.call(this, t2, null, r2);
            }
            rgba(t2, e2) {
              return "boolean" != typeof t2 ? f.call(this, "bool must be a boolean, true for RGBA or false for RGB", e2) : (this._rgba = t2, h(e2) && e2.call(this, null, this), this);
            }
            emitMulti(t2, e2) {
              let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              r2 = Object.assign(r2, { methodName: t2, eventName: e2 }), this.emit("any", r2), t2 && this.emit(t2, r2), this.emit(e2, r2);
            }
            emitError(t2, e2) {
              this.emitMulti(t2, "error", e2);
            }
            getHeight() {
              return this.bitmap.height;
            }
            getWidth() {
              return this.bitmap.width;
            }
            inspect() {
              return "<Jimp " + (this.bitmap === re ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
            }
            toString() {
              return "[object Jimp]";
            }
            getMIME() {
              return this._originalMime || ie.MIME_PNG;
            }
            getExtension() {
              const t2 = this.getMIME();
              return (Ut[t2.toLowerCase()] || [])[0];
            }
            write(t2, e2) {
              if (!i() || !i().createWriteStream)
                throw new Error("Cant access the filesystem. You can use the getBase64 method.");
              if ("string" != typeof t2)
                return f.call(this, "path must be a string", e2);
              if (void 0 === e2 && (e2 = Kt), "function" != typeof e2)
                return f.call(this, "cb must be a function", e2);
              const r2 = zt(t2) || this.getMIME(), n2 = a().parse(t2);
              return n2.dir && p().sync(n2.dir), this.getBuffer(r2, (r3, n3) => {
                if (r3)
                  return f.call(this, r3, e2);
                const a2 = i().createWriteStream(t2);
                a2.on("open", () => {
                  a2.write(n3), a2.end();
                }).on("error", (t3) => f.call(this, t3, e2)), a2.on("finish", () => {
                  e2.call(this, null, this);
                });
              }), this;
            }
            getBase64(t2, e2) {
              return t2 === ie.AUTO && (t2 = this.getMIME()), "string" != typeof t2 ? f.call(this, "mime must be a string", e2) : "function" != typeof e2 ? f.call(this, "cb must be a function", e2) : (this.getBuffer(t2, function(r2, i2) {
                if (r2)
                  return f.call(this, r2, e2);
                const n2 = "data:" + t2 + ";base64," + i2.toString("base64");
                e2.call(this, null, n2);
              }), this);
            }
            hash(t2, e2) {
              if ("function" == typeof (t2 = t2 || 64) && (e2 = t2, t2 = 64), "number" != typeof t2)
                return f.call(this, "base must be a number", e2);
              if (t2 < 2 || t2 > 64)
                return f.call(this, "base must be a number between 2 and 64", e2);
              let r2 = this.pHash();
              for (r2 = c()(c().BIN, Qt.slice(0, t2))(r2); r2.length < Jt[t2]; )
                r2 = "0" + r2;
              return h(e2) && e2.call(this, null, r2), r2;
            }
            pHash() {
              return new et().getHash(this);
            }
            distanceFromHash(t2) {
              const e2 = new et(), r2 = e2.getHash(this);
              return e2.distance(r2, t2);
            }
            getPixelIndex(t2, e2, r2, i2) {
              let n2, a2;
              if ("function" == typeof r2 && void 0 === i2 && (i2 = r2, r2 = null), r2 || (r2 = ie.EDGE_EXTEND), "number" != typeof t2 || "number" != typeof e2)
                return f.call(this, "x and y must be numbers", i2);
              n2 = t2 = Math.round(t2), a2 = e2 = Math.round(e2), r2 === ie.EDGE_EXTEND && (t2 < 0 && (n2 = 0), t2 >= this.bitmap.width && (n2 = this.bitmap.width - 1), e2 < 0 && (a2 = 0), e2 >= this.bitmap.height && (a2 = this.bitmap.height - 1)), r2 === ie.EDGE_WRAP && (t2 < 0 && (n2 = this.bitmap.width + t2), t2 >= this.bitmap.width && (n2 = t2 % this.bitmap.width), e2 < 0 && (a2 = this.bitmap.height + e2), e2 >= this.bitmap.height && (a2 = e2 % this.bitmap.height));
              let o2 = this.bitmap.width * a2 + n2 << 2;
              return (n2 < 0 || n2 >= this.bitmap.width) && (o2 = -1), (a2 < 0 || a2 >= this.bitmap.height) && (o2 = -1), h(i2) && i2.call(this, null, o2), o2;
            }
            getPixelColor(t2, e2, r2) {
              if ("number" != typeof t2 || "number" != typeof e2)
                return f.call(this, "x and y must be numbers", r2);
              t2 = Math.round(t2), e2 = Math.round(e2);
              const i2 = this.getPixelIndex(t2, e2), n2 = this.bitmap.data.readUInt32BE(i2);
              return h(r2) && r2.call(this, null, n2), n2;
            }
            setPixelColor(t2, e2, r2, i2) {
              if ("number" != typeof t2 || "number" != typeof e2 || "number" != typeof r2)
                return f.call(this, "hex, x and y must be numbers", i2);
              e2 = Math.round(e2), r2 = Math.round(r2);
              const n2 = this.getPixelIndex(e2, r2);
              return this.bitmap.data.writeUInt32BE(t2, n2), h(i2) && i2.call(this, null, this), this;
            }
            hasAlpha() {
              for (let t2 = 0; t2 < this.bitmap.height; t2++)
                for (let e2 = 0; e2 < this.bitmap.width; e2++) {
                  const r2 = this.bitmap.width * t2 + e2 << 2;
                  if (255 !== this.bitmap.data[r2 + 3])
                    return true;
                }
              return false;
            }
            scanIterator(t2, e2, r2, i2) {
              return "number" != typeof t2 || "number" != typeof e2 ? f.call(this, "x and y must be numbers") : "number" != typeof r2 || "number" != typeof i2 ? f.call(this, "w and h must be numbers") : function* (t3, e3, r3, i3, n2) {
                e3 = Math.round(e3), r3 = Math.round(r3), i3 = Math.round(i3), n2 = Math.round(n2);
                for (let a2 = r3; a2 < r3 + n2; a2++)
                  for (let r4 = e3; r4 < e3 + i3; r4++) {
                    const e4 = t3.bitmap.width * a2 + r4 << 2;
                    yield { x: r4, y: a2, idx: e4, image: t3 };
                  }
              }(this, t2, e2, r2, i2);
            }
          }
          function ne(t2) {
            let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ie;
            Object.entries(t2).forEach((t3) => {
              let [r2, i2] = t3;
              e2[r2] = i2;
            });
          }
          function ae(t2) {
            let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ie;
            Object.entries(t2).forEach((t3) => {
              let [r2, i2] = t3;
              e2.prototype[r2] = i2;
            });
          }
          function oe(t2, e2, r2) {
            const i2 = "before-" + e2, n2 = e2.replace(/e$/, "") + "ed";
            ie.prototype[t2] = function() {
              let e3;
              for (var a2 = arguments.length, o2 = new Array(a2), s2 = 0; s2 < a2; s2++)
                o2[s2] = arguments[s2];
              const h2 = o2[r2.length - 1], f2 = this;
              let u2;
              "function" == typeof h2 ? (e3 = function() {
                for (var e4 = arguments.length, r3 = new Array(e4), i3 = 0; i3 < e4; i3++)
                  r3[i3] = arguments[i3];
                const [a3, o3] = r3;
                a3 ? f2.emitError(t2, a3) : f2.emitMulti(t2, n2, { [t2]: o3 }), h2.apply(this, r3);
              }, o2[o2.length - 1] = e3) : e3 = false, this.emitMulti(t2, i2);
              try {
                u2 = r2.apply(this, o2), e3 || this.emitMulti(t2, n2, { [t2]: u2 });
              } catch (e4) {
                e4.methodName = t2, this.emitError(t2, e4);
              }
              return u2;
            }, ie.prototype[t2 + "Quiet"] = r2;
          }
          function se(t2, e2) {
            oe(t2, "change", e2);
          }
          ne(t), ae({ composite: function(t2, r2, i2) {
            let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, a2 = arguments.length > 4 ? arguments[4] : void 0;
            if ("function" == typeof n2 && (a2 = n2, n2 = {}), !(t2 instanceof this.constructor))
              return f.call(this, "The source must be a Jimp image", a2);
            if ("number" != typeof r2 || "number" != typeof i2)
              return f.call(this, "x and y must be numbers", a2);
            let { mode: o2, opacitySource: s2, opacityDest: u2 } = n2;
            o2 || (o2 = ut), ("number" != typeof s2 || s2 < 0 || s2 > 1) && (s2 = 1), ("number" != typeof u2 || u2 < 0 || u2 > 1) && (u2 = 1);
            const l2 = e[o2];
            r2 = Math.round(r2), i2 = Math.round(i2);
            const c2 = this;
            return 1 !== u2 && c2.opacity(u2), t2.scanQuiet(0, 0, t2.bitmap.width, t2.bitmap.height, function(t3, e2, n3) {
              const a3 = c2.getPixelIndex(r2 + t3, i2 + e2, Et), o3 = l2({ r: this.bitmap.data[n3 + 0] / 255, g: this.bitmap.data[n3 + 1] / 255, b: this.bitmap.data[n3 + 2] / 255, a: this.bitmap.data[n3 + 3] / 255 }, { r: c2.bitmap.data[a3 + 0] / 255, g: c2.bitmap.data[a3 + 1] / 255, b: c2.bitmap.data[a3 + 2] / 255, a: c2.bitmap.data[a3 + 3] / 255 }, s2);
              c2.bitmap.data[a3 + 0] = this.constructor.limit255(255 * o3.r), c2.bitmap.data[a3 + 1] = this.constructor.limit255(255 * o3.g), c2.bitmap.data[a3 + 2] = this.constructor.limit255(255 * o3.b), c2.bitmap.data[a3 + 3] = this.constructor.limit255(255 * o3.a);
            }), h(a2) && a2.call(this, null, this), this;
          } }), ie.__extraConstructors = [], ie.appendConstructorOption = function(t2, e2, r2) {
            ie.__extraConstructors.push({ name: t2, test: e2, run: r2 });
          }, ie.read = function() {
            for (var t2 = arguments.length, e2 = new Array(t2), r2 = 0; r2 < t2; r2++)
              e2[r2] = arguments[r2];
            return new Promise((t3, r3) => {
              new ie(...e2, (e3, i2) => {
                e3 ? r3(e3) : t3(i2);
              });
            });
          }, ie.create = ie.read, ie.rgbaToInt = function(t2, e2, r2, i2, n2) {
            if ("number" != typeof t2 || "number" != typeof e2 || "number" != typeof r2 || "number" != typeof i2)
              return f.call(this, "r, g, b and a must be numbers", n2);
            if (t2 < 0 || t2 > 255)
              return f.call(this, "r must be between 0 and 255", n2);
            if ((e2 < 0 || e2 > 255) && f.call(this, "g must be between 0 and 255", n2), r2 < 0 || r2 > 255)
              return f.call(this, "b must be between 0 and 255", n2);
            if (i2 < 0 || i2 > 255)
              return f.call(this, "a must be between 0 and 255", n2);
            t2 = Math.round(t2), r2 = Math.round(r2), e2 = Math.round(e2), i2 = Math.round(i2);
            const a2 = t2 * Math.pow(256, 3) + e2 * Math.pow(256, 2) + r2 * Math.pow(256, 1) + i2 * Math.pow(256, 0);
            return h(n2) && n2.call(this, null, a2), a2;
          }, ie.intToRGBA = function(t2, e2) {
            if ("number" != typeof t2)
              return f.call(this, "i must be a number", e2);
            const r2 = {};
            return r2.r = Math.floor(t2 / Math.pow(256, 3)), r2.g = Math.floor((t2 - r2.r * Math.pow(256, 3)) / Math.pow(256, 2)), r2.b = Math.floor((t2 - r2.r * Math.pow(256, 3) - r2.g * Math.pow(256, 2)) / Math.pow(256, 1)), r2.a = Math.floor((t2 - r2.r * Math.pow(256, 3) - r2.g * Math.pow(256, 2) - r2.b * Math.pow(256, 1)) / Math.pow(256, 0)), h(e2) && e2.call(this, null, r2), r2;
          }, ie.cssColorToHex = function(t2) {
            return "number" == typeof (t2 = t2 || 0) ? Number(t2) : parseInt(w(t2).toHex8(), 16);
          }, ie.limit255 = function(t2) {
            return t2 = Math.max(t2, 0), Math.min(t2, 255);
          }, ie.diff = function(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0.1;
            if (!(t2 instanceof ie && e2 instanceof ie))
              return f.call(this, "img1 and img2 must be an Jimp images");
            const i2 = t2.bitmap, n2 = e2.bitmap;
            if (i2.width === n2.width && i2.height === n2.height || (i2.width * i2.height > n2.width * n2.height ? t2 = t2.cloneQuiet().resize(n2.width, n2.height) : e2 = e2.cloneQuiet().resize(i2.width, i2.height)), "number" != typeof r2 || r2 < 0 || r2 > 1)
              return f.call(this, "threshold must be a number between 0 and 1");
            const a2 = new ie(i2.width, i2.height, 4294967295);
            return { percent: g()(i2.data, n2.data, a2.bitmap.data, a2.bitmap.width, a2.bitmap.height, { threshold: r2 }) / (a2.bitmap.width * a2.bitmap.height), image: a2 };
          }, ie.distance = function(t2, e2) {
            const r2 = new et(), i2 = r2.getHash(t2), n2 = r2.getHash(e2);
            return r2.distance(i2, n2);
          }, ie.compareHashes = function(t2, e2) {
            return new et().distance(t2, e2);
          }, ie.colorDiff = function(t2, e2) {
            const r2 = (t3) => Math.pow(t3, 2), { max: i2 } = Math;
            return 0 === t2.a || t2.a || (t2.a = 255), 0 === e2.a || e2.a || (e2.a = 255), (i2(r2(t2.r - e2.r), r2(t2.r - e2.r - t2.a + e2.a)) + i2(r2(t2.g - e2.g), r2(t2.g - e2.g - t2.a + e2.a)) + i2(r2(t2.b - e2.b), r2(t2.b - e2.b - t2.a + e2.a))) / 195075;
          }, oe("clone", "clone", function(t2) {
            const e2 = new ie(this);
            return h(t2) && t2.call(e2, null, e2), e2;
          }), se("background", function(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "hex must be a hexadecimal rgba value", e2) : (this._background = t2, h(e2) && e2.call(this, null, this), this);
          }), se("scan", function(t2, e2, r2, i2, n2, a2) {
            if ("number" != typeof t2 || "number" != typeof e2)
              return f.call(this, "x and y must be numbers", a2);
            if ("number" != typeof r2 || "number" != typeof i2)
              return f.call(this, "w and h must be numbers", a2);
            if ("function" != typeof n2)
              return f.call(this, "f must be a function", a2);
            const o2 = u(this, t2, e2, r2, i2, n2);
            return h(a2) && a2.call(this, null, o2), o2;
          });
          {
            let t2;
            "undefined" != typeof window && "object" == typeof window && (t2 = window), "undefined" != typeof self && "object" == typeof self && (t2 = self), t2.Jimp = ie, t2.Buffer = Vt;
          }
          const he = ie;
          var fe = __webpack_require__(643), ue = __webpack_require__(2691), le = __webpack_require__.n(ue);
          const ce = "image/jpeg", de = () => ({ mime: { [ce]: ["jpeg", "jpg", "jpe"] }, constants: { MIME_JPEG: ce }, decoders: { [ce]: le().decode }, encoders: { [ce]: (t2) => le().encode(t2.bitmap, t2._quality).data }, class: { _quality: 100, quality(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "n must be a number", e2) : t2 < 0 || t2 > 100 ? f.call(this, "n must be a number 0 - 100", e2) : (this._quality = Math.round(t2), h(e2) && e2.call(this, null, this), this);
          } } });
          var pe = __webpack_require__(9902);
          const me = "image/png", ge = () => ({ mime: { [me]: ["png"] }, constants: { MIME_PNG: me, PNG_FILTER_AUTO: -1, PNG_FILTER_NONE: 0, PNG_FILTER_SUB: 1, PNG_FILTER_UP: 2, PNG_FILTER_AVERAGE: 3, PNG_FILTER_PATH: 4 }, hasAlpha: { [me]: true }, decoders: { [me]: pe.PNG.sync.read }, encoders: { [me](t2) {
            const e2 = new pe.PNG({ width: t2.bitmap.width, height: t2.bitmap.height });
            return e2.data = t2.bitmap.data, pe.PNG.sync.write(e2, { deflateLevel: t2._deflateLevel, deflateStrategy: t2._deflateStrategy, filterType: t2._filterType, colorType: "number" == typeof t2._colorType ? t2._colorType : t2._rgba ? 6 : 2, inputHasAlpha: t2._rgba });
          } }, class: { _deflateLevel: 9, _deflateStrategy: 3, _filterType: -1, _colorType: null, deflateLevel(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "l must be a number", e2) : t2 < 0 || t2 > 9 ? f.call(this, "l must be a number 0 - 9", e2) : (this._deflateLevel = Math.round(t2), h(e2) && e2.call(this, null, this), this);
          }, deflateStrategy(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "s must be a number", e2) : t2 < 0 || t2 > 3 ? f.call(this, "s must be a number 0 - 3", e2) : (this._deflateStrategy = Math.round(t2), h(e2) && e2.call(this, null, this), this);
          }, filterType(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "n must be a number", e2) : t2 < -1 || t2 > 4 ? f.call(this, "n must be -1 (auto) or a number 0 - 4", e2) : (this._filterType = Math.round(t2), h(e2) && e2.call(this, null, this), this);
          }, colorType(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "s must be a number", e2) : 0 !== t2 && 2 !== t2 && 4 !== t2 && 6 !== t2 ? f.call(this, "s must be a number 0, 2, 4, 6.", e2) : (this._colorType = Math.round(t2), h(e2) && e2.call(this, null, this), this);
          } } });
          var be = __webpack_require__(486), _e = __webpack_require__.n(be);
          const ye = "image/bmp", we = "image/x-ms-bmp", ve = (t2) => {
            return u({ bitmap: e2 = _e().decode(t2) }, 0, 0, e2.width, e2.height, function(t3, r2, i2) {
              const n2 = this.bitmap.data[i2 + 0], a2 = this.bitmap.data[i2 + 1], o2 = this.bitmap.data[i2 + 2], s2 = this.bitmap.data[i2 + 3];
              this.bitmap.data[i2 + 0] = s2, this.bitmap.data[i2 + 1] = o2, this.bitmap.data[i2 + 2] = a2, this.bitmap.data[i2 + 3] = e2.is_with_alpha ? n2 : 255;
            }).bitmap;
            var e2;
          }, xe = (t2) => _e().encode(function(t3) {
            return u(t3, 0, 0, t3.bitmap.width, t3.bitmap.height, function(t4, e2, r2) {
              const i2 = this.bitmap.data[r2 + 0], n2 = this.bitmap.data[r2 + 1], a2 = this.bitmap.data[r2 + 2], o2 = this.bitmap.data[r2 + 3];
              this.bitmap.data[r2 + 0] = o2, this.bitmap.data[r2 + 1] = a2, this.bitmap.data[r2 + 2] = n2, this.bitmap.data[r2 + 3] = i2;
            }).bitmap;
          }(t2)).data;
          var Ee = __webpack_require__(9299), ke = __webpack_require__.n(Ee), Se = __webpack_require__(8834).lW;
          const Me = "image/tiff";
          var Ae = __webpack_require__(63), Ie = __webpack_require__(9455), Te = __webpack_require__(8834).lW;
          const Be = "image/gif", Re = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1], Pe = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
          var Oe = __webpack_require__(8834).lW;
          function Le(t2, e2, r2, i2) {
            const n2 = [0, 0, 0], a2 = (e2.length - 1) / 2;
            for (let o2 = 0; o2 < e2.length; o2 += 1)
              for (let s2 = 0; s2 < e2[o2].length; s2 += 1) {
                const h2 = t2.getPixelIndex(r2 + o2 - a2, i2 + s2 - a2);
                n2[0] += t2.bitmap.data[h2] * e2[o2][s2], n2[1] += t2.bitmap.data[h2 + 1] * e2[o2][s2], n2[2] += t2.bitmap.data[h2 + 2] * e2[o2][s2];
              }
            return n2;
          }
          const Ce = (t2) => null != t2;
          function Ue(t2) {
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, e2, r2) {
              const i2 = parseInt(0.2126 * this.bitmap.data[r2] + 0.7152 * this.bitmap.data[r2 + 1] + 0.0722 * this.bitmap.data[r2 + 2], 10);
              this.bitmap.data[r2] = i2, this.bitmap.data[r2 + 1] = i2, this.bitmap.data[r2 + 2] = i2;
            }), h(t2) && t2.call(this, null, this), this;
          }
          function De(t2, e2) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 50;
            return { r: (e2.r - t2.r) * (r2 / 100) + t2.r, g: (e2.g - t2.g) * (r2 / 100) + t2.g, b: (e2.b - t2.b) * (r2 / 100) + t2.b };
          }
          function ze(t2, e2) {
            return t2 && Array.isArray(t2) ? (t2 = t2.map((t3) => ("xor" !== t3.apply && "mix" !== t3.apply || (t3.params[0] = w(t3.params[0]).toRgb()), t3)), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (r2, i2, n2) => {
              let a2 = { r: this.bitmap.data[n2], g: this.bitmap.data[n2 + 1], b: this.bitmap.data[n2 + 2] };
              const o2 = (t3, e3) => this.constructor.limit255(a2[t3] + e3);
              t2.forEach((t3) => {
                if ("mix" === t3.apply)
                  a2 = De(a2, t3.params[0], t3.params[1]);
                else if ("tint" === t3.apply)
                  a2 = De(a2, { r: 255, g: 255, b: 255 }, t3.params[0]);
                else if ("shade" === t3.apply)
                  a2 = De(a2, { r: 0, g: 0, b: 0 }, t3.params[0]);
                else if ("xor" === t3.apply)
                  a2 = { r: a2.r ^ t3.params[0].r, g: a2.g ^ t3.params[0].g, b: a2.b ^ t3.params[0].b };
                else if ("red" === t3.apply)
                  a2.r = o2("r", t3.params[0]);
                else if ("green" === t3.apply)
                  a2.g = o2("g", t3.params[0]);
                else if ("blue" === t3.apply)
                  a2.b = o2("b", t3.params[0]);
                else {
                  if ("hue" === t3.apply && (t3.apply = "spin"), a2 = w(a2), !a2[t3.apply])
                    return f.call(this, "action " + t3.apply + " not supported", e2);
                  a2 = a2[t3.apply](...t3.params).toRgb();
                }
              }), this.bitmap.data[n2] = a2.r, this.bitmap.data[n2 + 1] = a2.g, this.bitmap.data[n2 + 2] = a2.b;
            }), h(e2) && e2.call(this, null, this), this) : f.call(this, "actions must be an array", e2);
          }
          Object.freeze({ LIGHTEN: "lighten", BRIGHTEN: "brighten", DARKEN: "darken", DESATURATE: "desaturate", SATURATE: "saturate", GREYSCALE: "greyscale", SPIN: "spin", HUE: "hue", MIX: "mix", TINT: "tint", SHADE: "shade", XOR: "xor", RED: "red", GREEN: "green", BLUE: "blue" });
          var Ne = __webpack_require__(8834).lW;
          function Fe(t2) {
            const e2 = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, r2, i2) {
              const n2 = e2[((3 & r2) << 2) + t3 % 4];
              this.bitmap.data[i2] = Math.min(this.bitmap.data[i2] + n2, 255), this.bitmap.data[i2 + 1] = Math.min(this.bitmap.data[i2 + 1] + n2, 255), this.bitmap.data[i2 + 2] = Math.min(this.bitmap.data[i2 + 2] + n2, 255);
            }), h(t2) && t2.call(this, null, this), this;
          }
          var je = __webpack_require__(8834).lW;
          function Ge(t2, e2, r2) {
            if ("boolean" != typeof t2 || "boolean" != typeof e2)
              return f.call(this, "horizontal and vertical must be Booleans", r2);
            const i2 = je.alloc(this.bitmap.data.length);
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(r3, n2, a2) {
              const o2 = t2 ? this.bitmap.width - 1 - r3 : r3, s2 = e2 ? this.bitmap.height - 1 - n2 : n2, h2 = this.bitmap.width * s2 + o2 << 2, f2 = this.bitmap.data.readUInt32BE(a2);
              i2.writeUInt32BE(f2, h2);
            }), this.bitmap.data = je.from(i2), h(r2) && r2.call(this, null, this), this;
          }
          function He() {
            const t2 = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(e2, r2, i2) {
              t2.r[this.bitmap.data[i2 + 0]]++, t2.g[this.bitmap.data[i2 + 1]]++, t2.b[this.bitmap.data[i2 + 2]]++;
            }), t2;
          }
          const We = function(t2, e2, r2) {
            return 255 * (t2 - e2) / (r2 - e2);
          }, qe = function(t2) {
            return [t2.findIndex((t3) => t3 > 0), 255 - t2.slice().reverse().findIndex((t3) => t3 > 0)];
          };
          var Ze = __webpack_require__(8058), Ye = __webpack_require__.n(Ze);
          function Ve(t2, e2) {
            let r2 = 0;
            for (let i2 = 0; i2 < e2.length; i2++)
              if (t2.chars[e2[i2]]) {
                const n2 = t2.kernings[e2[i2]] && t2.kernings[e2[i2]][e2[i2 + 1]] ? t2.kernings[e2[i2]][e2[i2 + 1]] : 0;
                r2 += (t2.chars[e2[i2]].xadvance || 0) + n2;
              }
            return r2;
          }
          function Xe(t2, e2, r2) {
            const i2 = e2.split(" "), n2 = [];
            let a2 = [], o2 = 0;
            return i2.forEach((e3) => {
              const i3 = [...a2, e3].join(" "), s2 = Ve(t2, i3);
              s2 <= r2 ? (s2 > o2 && (o2 = s2), a2.push(e3)) : (n2.push(a2), a2 = [e3]);
            }), n2.push(a2), { lines: n2, longestLine: o2 };
          }
          function Qe(t2, e2, r2) {
            const { lines: i2 } = Xe(t2, e2, r2);
            return i2.length * t2.common.lineHeight;
          }
          function Je(t2, e2, r2, i2, n2) {
            if (n2.width > 0 && n2.height > 0) {
              const a2 = e2.pages[n2.page];
              t2.blit(a2, r2 + n2.xoffset, i2 + n2.yoffset, n2.x, n2.y, n2.width, n2.height);
            }
            return t2;
          }
          function Ke(t2, e2, r2, i2, n2) {
            for (let a2 = 0; a2 < i2.length; a2++) {
              let o2;
              o2 = t2.chars[i2[a2]] ? i2[a2] : /\s/.test(i2[a2]) ? "" : "?";
              const s2 = t2.chars[o2] || {}, h2 = t2.kernings[o2];
              Je(this, t2, e2, r2, s2 || {}), e2 += (h2 && h2[i2[a2 + 1]] ? h2[i2[a2 + 1]] : 0) + (s2.xadvance || n2);
            }
          }
          const $e = "//../";
          function tr(t2, e2, r2, i2, n2, a2, o2) {
            this.widthOriginal = Math.abs(Math.floor(t2) || 0), this.heightOriginal = Math.abs(Math.floor(e2) || 0), this.targetWidth = Math.abs(Math.floor(r2) || 0), this.targetHeight = Math.abs(Math.floor(i2) || 0), this.colorChannels = n2 ? 4 : 3, this.interpolationPass = Boolean(a2), this.resizeCallback = "function" == typeof o2 ? o2 : function() {
            }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
          }
          tr.prototype.initialize = function() {
            if (!(this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0))
              throw new Error("Invalid settings specified for the resizer.");
            this.configurePasses();
          }, tr.prototype.configurePasses = function() {
            this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(true), this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(false), this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(true), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(false), this.resizeHeight = 4 === this.colorChannels ? this.resizeHeightRGBA : this.resizeHeightRGB));
          }, tr.prototype._resizeWidthInterpolatedRGBChannels = function(t2, e2) {
            const r2 = e2 ? 4 : 3, i2 = this.ratioWeightWidthPass, n2 = this.widthBuffer;
            let a2, o2, s2 = 0, h2 = 0, f2 = 0, u2 = 0, l2 = 0;
            for (a2 = 0; s2 < 1 / 3; a2 += r2, s2 += i2)
              for (h2 = a2, f2 = 0; h2 < this.widthPassResultSize; f2 += this.originalWidthMultipliedByChannels, h2 += this.targetWidthMultipliedByChannels)
                n2[h2] = t2[f2], n2[h2 + 1] = t2[f2 + 1], n2[h2 + 2] = t2[f2 + 2], e2 && (n2[h2 + 3] = t2[f2 + 3]);
            for (s2 -= 1 / 3, o2 = this.widthOriginal - 1; s2 < o2; a2 += r2, s2 += i2)
              for (l2 = s2 % 1, u2 = 1 - l2, h2 = a2, f2 = Math.floor(s2) * r2; h2 < this.widthPassResultSize; f2 += this.originalWidthMultipliedByChannels, h2 += this.targetWidthMultipliedByChannels)
                n2[h2 + 0] = t2[f2 + 0] * u2 + t2[f2 + r2 + 0] * l2, n2[h2 + 1] = t2[f2 + 1] * u2 + t2[f2 + r2 + 1] * l2, n2[h2 + 2] = t2[f2 + 2] * u2 + t2[f2 + r2 + 2] * l2, e2 && (n2[h2 + 3] = t2[f2 + 3] * u2 + t2[f2 + r2 + 3] * l2);
            for (o2 = this.originalWidthMultipliedByChannels - r2; a2 < this.targetWidthMultipliedByChannels; a2 += r2)
              for (h2 = a2, f2 = o2; h2 < this.widthPassResultSize; f2 += this.originalWidthMultipliedByChannels, h2 += this.targetWidthMultipliedByChannels)
                n2[h2] = t2[f2], n2[h2 + 1] = t2[f2 + 1], n2[h2 + 2] = t2[f2 + 2], e2 && (n2[h2 + 3] = t2[f2 + 3]);
            return n2;
          }, tr.prototype._resizeWidthRGBChannels = function(t2, e2) {
            const r2 = e2 ? 4 : 3, i2 = this.ratioWeightWidthPass, n2 = 1 / i2, a2 = this.originalWidthMultipliedByChannels - r2 + 1, o2 = this.targetWidthMultipliedByChannels - r2 + 1, s2 = this.outputWidthWorkBench, h2 = this.widthBuffer, f2 = this.outputWidthWorkBenchOpaquePixelsCount;
            let u2 = 0, l2 = 0, c2 = 0, d2 = 0, p2 = 0, m2 = 0, g2 = 0, b2 = 1, _2 = 0, y2 = 0, w2 = 0, v2 = 0;
            do {
              for (p2 = 0; p2 < this.originalHeightMultipliedByChannels; )
                s2[p2++] = 0, s2[p2++] = 0, s2[p2++] = 0, e2 && (s2[p2++] = 0, f2[p2 / r2 - 1] = 0);
              u2 = i2;
              do {
                for (l2 = 1 + c2 - d2, b2 = Math.min(u2, l2), p2 = 0, m2 = c2; p2 < this.originalHeightMultipliedByChannels; m2 += a2)
                  _2 = t2[m2], y2 = t2[++m2], w2 = t2[++m2], v2 = e2 ? t2[++m2] : 255, s2[p2++] += (v2 ? _2 : 0) * b2, s2[p2++] += (v2 ? y2 : 0) * b2, s2[p2++] += (v2 ? w2 : 0) * b2, e2 && (s2[p2++] += v2 * b2, f2[p2 / r2 - 1] += v2 ? b2 : 0);
                if (!(u2 >= l2)) {
                  d2 += u2;
                  break;
                }
                c2 += r2, d2 = c2, u2 -= l2;
              } while (u2 > 0 && c2 < this.originalWidthMultipliedByChannels);
              for (p2 = 0, m2 = g2; p2 < this.originalHeightMultipliedByChannels; m2 += o2)
                u2 = e2 ? f2[p2 / r2] : 1, b2 = e2 ? u2 ? 1 / u2 : 0 : n2, h2[m2] = s2[p2++] * b2, h2[++m2] = s2[p2++] * b2, h2[++m2] = s2[p2++] * b2, e2 && (h2[++m2] = s2[p2++] * n2);
              g2 += r2;
            } while (g2 < this.targetWidthMultipliedByChannels);
            return h2;
          }, tr.prototype._resizeHeightRGBChannels = function(t2, e2) {
            const r2 = this.ratioWeightHeightPass, i2 = 1 / r2, n2 = this.outputHeightWorkBench, a2 = this.heightBuffer, o2 = this.outputHeightWorkBenchOpaquePixelsCount;
            let s2 = 0, h2 = 0, f2 = 0, u2 = 0, l2 = 0, c2 = 0, d2 = 0, p2 = 1, m2 = 0, g2 = 0, b2 = 0, _2 = 0;
            do {
              for (l2 = 0; l2 < this.targetWidthMultipliedByChannels; )
                n2[l2++] = 0, n2[l2++] = 0, n2[l2++] = 0, e2 && (n2[l2++] = 0, o2[l2 / 4 - 1] = 0);
              s2 = r2;
              do {
                for (h2 = 1 + f2 - u2, p2 = Math.min(s2, h2), d2 = f2, l2 = 0; l2 < this.targetWidthMultipliedByChannels; )
                  m2 = t2[d2++], g2 = t2[d2++], b2 = t2[d2++], _2 = e2 ? t2[d2++] : 255, n2[l2++] += (_2 ? m2 : 0) * p2, n2[l2++] += (_2 ? g2 : 0) * p2, n2[l2++] += (_2 ? b2 : 0) * p2, e2 && (n2[l2++] += _2 * p2, o2[l2 / 4 - 1] += _2 ? p2 : 0);
                if (!(s2 >= h2)) {
                  u2 += s2;
                  break;
                }
                f2 = d2, u2 = f2, s2 -= h2;
              } while (s2 > 0 && f2 < this.widthPassResultSize);
              for (l2 = 0; l2 < this.targetWidthMultipliedByChannels; )
                s2 = e2 ? o2[l2 / 4] : 1, p2 = e2 ? s2 ? 1 / s2 : 0 : i2, a2[c2++] = Math.round(n2[l2++] * p2), a2[c2++] = Math.round(n2[l2++] * p2), a2[c2++] = Math.round(n2[l2++] * p2), e2 && (a2[c2++] = Math.round(n2[l2++] * i2));
            } while (c2 < this.finalResultSize);
            return a2;
          }, tr.prototype.resizeWidthInterpolatedRGB = function(t2) {
            return this._resizeWidthInterpolatedRGBChannels(t2, false);
          }, tr.prototype.resizeWidthInterpolatedRGBA = function(t2) {
            return this._resizeWidthInterpolatedRGBChannels(t2, true);
          }, tr.prototype.resizeWidthRGB = function(t2) {
            return this._resizeWidthRGBChannels(t2, false);
          }, tr.prototype.resizeWidthRGBA = function(t2) {
            return this._resizeWidthRGBChannels(t2, true);
          }, tr.prototype.resizeHeightInterpolated = function(t2) {
            const e2 = this.ratioWeightHeightPass, r2 = this.heightBuffer;
            let i2, n2 = 0, a2 = 0, o2 = 0, s2 = 0, h2 = 0, f2 = 0, u2 = 0;
            for (; n2 < 1 / 3; n2 += e2)
              for (o2 = 0; o2 < this.targetWidthMultipliedByChannels; )
                r2[a2++] = Math.round(t2[o2++]);
            for (n2 -= 1 / 3, i2 = this.heightOriginal - 1; n2 < i2; n2 += e2)
              for (u2 = n2 % 1, f2 = 1 - u2, s2 = Math.floor(n2) * this.targetWidthMultipliedByChannels, h2 = s2 + this.targetWidthMultipliedByChannels, o2 = 0; o2 < this.targetWidthMultipliedByChannels; ++o2)
                r2[a2++] = Math.round(t2[s2++] * f2 + t2[h2++] * u2);
            for (; a2 < this.finalResultSize; )
              for (o2 = 0, s2 = i2 * this.targetWidthMultipliedByChannels; o2 < this.targetWidthMultipliedByChannels; ++o2)
                r2[a2++] = Math.round(t2[s2++]);
            return r2;
          }, tr.prototype.resizeHeightRGB = function(t2) {
            return this._resizeHeightRGBChannels(t2, false);
          }, tr.prototype.resizeHeightRGBA = function(t2) {
            return this._resizeHeightRGBChannels(t2, true);
          }, tr.prototype.resize = function(t2) {
            this.resizeCallback(this.resizeHeight(this.resizeWidth(t2)));
          }, tr.prototype.bypassResizer = function(t2) {
            return t2;
          }, tr.prototype.initializeFirstPassBuffers = function(t2) {
            this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), t2 || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
          }, tr.prototype.initializeSecondPassBuffers = function(t2) {
            this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), t2 || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
          }, tr.prototype.generateFloatBuffer = function(t2) {
            try {
              return new Float32Array(t2);
            } catch (t3) {
              return [];
            }
          }, tr.prototype.generateFloat64Buffer = function(t2) {
            try {
              return new Float64Array(t2);
            } catch (t3) {
              return [];
            }
          }, tr.prototype.generateUint8Buffer = function(t2) {
            try {
              return new Uint8Array(t2);
            } catch (t3) {
              return [];
            }
          };
          const er = tr;
          var rr = __webpack_require__(8834).lW;
          const ir = { nearestNeighbor(t2, e2) {
            const r2 = t2.width, i2 = t2.height, n2 = e2.width, a2 = e2.height, o2 = t2.data, s2 = e2.data;
            for (let t3 = 0; t3 < a2; t3++)
              for (let e3 = 0; e3 < n2; e3++) {
                let h2 = 4 * (t3 * n2 + e3), f2 = 4 * (Math.floor(t3 * i2 / a2) * r2 + Math.floor(e3 * r2 / n2));
                s2[h2++] = o2[f2++], s2[h2++] = o2[f2++], s2[h2++] = o2[f2++], s2[h2++] = o2[f2++];
              }
          }, bilinearInterpolation(t2, e2) {
            const r2 = t2.width, i2 = t2.height, n2 = e2.width, a2 = e2.height, o2 = t2.data, s2 = e2.data, h2 = function(t3, e3, r3, i3, n3) {
              return e3 === i3 ? r3 : Math.round((t3 - e3) * n3 + (i3 - t3) * r3);
            }, f2 = function(t3, e3, i3, n3, a3, f3, u2, l2) {
              let c2 = 4 * (u2 * r2 + n3) + e3, d2 = 4 * (u2 * r2 + a3) + e3;
              const p2 = h2(i3, n3, o2[c2], a3, o2[d2]);
              if (l2 === u2)
                s2[t3 + e3] = p2;
              else {
                c2 = 4 * (l2 * r2 + n3) + e3, d2 = 4 * (l2 * r2 + a3) + e3;
                const m2 = h2(i3, n3, o2[c2], a3, o2[d2]);
                s2[t3 + e3] = h2(f3, u2, p2, l2, m2);
              }
            };
            for (let t3 = 0; t3 < a2; t3++)
              for (let e3 = 0; e3 < n2; e3++) {
                const o3 = 4 * (t3 * n2 + e3), s3 = e3 * r2 / n2, h3 = Math.floor(s3), u2 = Math.min(Math.ceil(s3), r2 - 1), l2 = t3 * i2 / a2, c2 = Math.floor(l2), d2 = Math.min(Math.ceil(l2), i2 - 1);
                f2(o3, 0, s3, h3, u2, l2, c2, d2), f2(o3, 1, s3, h3, u2, l2, c2, d2), f2(o3, 2, s3, h3, u2, l2, c2, d2), f2(o3, 3, s3, h3, u2, l2, c2, d2);
              }
          }, _interpolate2D(t2, e2, r2, i2) {
            const n2 = t2.data, a2 = e2.data, o2 = t2.width, s2 = t2.height, h2 = e2.width, f2 = e2.height, u2 = Math.max(1, Math.floor(o2 / h2)), l2 = h2 * u2, c2 = Math.max(1, Math.floor(s2 / f2)), d2 = f2 * c2, p2 = rr.alloc(l2 * s2 * 4);
            for (let t3 = 0; t3 < s2; t3++)
              for (let e3 = 0; e3 < l2; e3++) {
                const r3 = e3 * (o2 - 1) / l2, a3 = Math.floor(r3), s3 = r3 - a3, h3 = 4 * (t3 * o2 + a3), f3 = 4 * (t3 * l2 + e3);
                for (let t4 = 0; t4 < 4; t4++) {
                  const e4 = h3 + t4, r4 = a3 > 0 ? n2[e4 - 4] : 2 * n2[e4] - n2[e4 + 4], u3 = n2[e4], l3 = n2[e4 + 4], c3 = a3 < o2 - 2 ? n2[e4 + 8] : 2 * n2[e4 + 4] - n2[e4];
                  p2[f3 + t4] = i2(r4, u3, l3, c3, s3);
                }
              }
            const m2 = rr.alloc(l2 * d2 * 4);
            for (let t3 = 0; t3 < d2; t3++)
              for (let e3 = 0; e3 < l2; e3++) {
                const r3 = t3 * (s2 - 1) / d2, n3 = Math.floor(r3), a3 = r3 - n3, o3 = 4 * (n3 * l2 + e3), h3 = 4 * (t3 * l2 + e3);
                for (let t4 = 0; t4 < 4; t4++) {
                  const e4 = o3 + t4, r4 = n3 > 0 ? p2[e4 - 4 * l2] : 2 * p2[e4] - p2[e4 + 4 * l2], f3 = p2[e4], u3 = p2[e4 + 4 * l2], c3 = n3 < s2 - 2 ? p2[e4 + 8 * l2] : 2 * p2[e4 + 4 * l2] - p2[e4];
                  m2[h3 + t4] = i2(r4, f3, u3, c3, a3);
                }
              }
            const g2 = u2 * c2;
            if (g2 > 1)
              for (let t3 = 0; t3 < f2; t3++)
                for (let e3 = 0; e3 < h2; e3++) {
                  let r3 = 0, i3 = 0, n3 = 0, o3 = 0, s3 = 0;
                  for (let a3 = 0; a3 < c2; a3++) {
                    const h3 = t3 * c2 + a3;
                    for (let t4 = 0; t4 < u2; t4++) {
                      const a4 = 4 * (h3 * l2 + (e3 * u2 + t4)), f4 = m2[a4 + 3];
                      f4 && (r3 += m2[a4], i3 += m2[a4 + 1], n3 += m2[a4 + 2], s3++), o3 += f4;
                    }
                  }
                  const f3 = 4 * (t3 * h2 + e3);
                  a2[f3] = s3 ? Math.round(r3 / s3) : 0, a2[f3 + 1] = s3 ? Math.round(i3 / s3) : 0, a2[f3 + 2] = s3 ? Math.round(n3 / s3) : 0, a2[f3 + 3] = Math.round(o3 / g2);
                }
            else
              e2.data = m2;
          }, bicubicInterpolation(t2, e2, r2) {
            return this._interpolate2D(t2, e2, r2, function(t3, e3, r3, i2, n2) {
              const a2 = i2 - r3 - t3 + e3, o2 = t3 - e3 - a2, s2 = r3 - t3, h2 = e3;
              return Math.max(0, Math.min(255, a2 * (n2 * n2 * n2) + o2 * (n2 * n2) + s2 * n2 + h2));
            });
          }, hermiteInterpolation(t2, e2, r2) {
            return this._interpolate2D(t2, e2, r2, function(t3, e3, r3, i2, n2) {
              const a2 = e3, o2 = 0.5 * (r3 - t3), s2 = t3 - 2.5 * e3 + 2 * r3 - 0.5 * i2, h2 = 0.5 * (i2 - t3) + 1.5 * (e3 - r3);
              return Math.max(0, Math.min(255, Math.round(((h2 * n2 + s2) * n2 + o2) * n2 + a2)));
            });
          }, bezierInterpolation(t2, e2, r2) {
            return this._interpolate2D(t2, e2, r2, function(t3, e3, r3, i2, n2) {
              const a2 = 1 - n2, o2 = e3 * a2 * a2 * a2, s2 = 3 * (e3 + (r3 - t3) / 4) * a2 * a2 * n2, h2 = 3 * (r3 - (i2 - e3) / 4) * a2 * n2 * n2, f2 = r3 * n2 * n2 * n2;
              return Math.max(0, Math.min(255, Math.round(o2 + s2 + h2 + f2)));
            });
          } }, nr = ir;
          var ar = __webpack_require__(8834).lW, or = __webpack_require__(8834).lW;
          function sr(t2) {
            if (Math.abs(t2) % 90 != 0)
              throw new Error("Unsupported matrix rotation degree");
            if (t2 %= 360, 0 === Math.abs(t2))
              return;
            const e2 = this.bitmap.width, r2 = this.bitmap.height;
            let i2;
            switch (t2) {
              case 90:
              case -270:
                i2 = 90;
                break;
              case 180:
              case -180:
                i2 = 180;
                break;
              case 270:
              case -90:
                i2 = -90;
                break;
              default:
                throw new Error("Unsupported matrix rotation degree");
            }
            const n2 = 180 === i2 ? e2 : r2, a2 = 180 === i2 ? r2 : e2, o2 = or.alloc(this.bitmap.data.length);
            function s2(t3, e3) {
              return function(e4, r3) {
                return r3 * t3 + e4 << 2;
              };
            }
            const h2 = s2(e2), f2 = s2(n2);
            for (let t3 = 0; t3 < e2; t3++)
              for (let n3 = 0; n3 < r2; n3++) {
                const a3 = h2(t3, n3), s3 = this.bitmap.data.readUInt32BE(a3);
                let u2;
                switch (i2) {
                  case 90:
                    u2 = f2(n3, e2 - t3 - 1);
                    break;
                  case -90:
                    u2 = f2(r2 - n3 - 1, t3);
                    break;
                  case 180:
                    u2 = f2(e2 - t3 - 1, r2 - n3 - 1);
                    break;
                  default:
                    throw new Error("Unsupported matrix rotation angle");
                }
                o2.writeUInt32BE(s3, u2);
              }
            this.bitmap.data = o2, this.bitmap.width = n2, this.bitmap.height = a2;
          }
          function hr(t2, e2) {
            const r2 = (t2 %= 360) * Math.PI / 180, i2 = Math.cos(r2), n2 = Math.sin(r2);
            let a2 = this.bitmap.width, o2 = this.bitmap.height;
            if (true === e2 || "string" == typeof e2) {
              a2 = Math.ceil(Math.abs(this.bitmap.width * i2) + Math.abs(this.bitmap.height * n2)) + 1, o2 = Math.ceil(Math.abs(this.bitmap.width * n2) + Math.abs(this.bitmap.height * i2)) + 1, a2 % 2 != 0 && a2++, o2 % 2 != 0 && o2++;
              const t3 = this.cloneQuiet();
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t4, e3, r4) {
                this.bitmap.data.writeUInt32BE(this._background, r4);
              });
              const r3 = Math.max(a2, o2, this.bitmap.width, this.bitmap.height);
              this.resize(r3, r3, e2), this.blit(t3, this.bitmap.width / 2 - t3.bitmap.width / 2, this.bitmap.height / 2 - t3.bitmap.height / 2);
            }
            const s2 = this.bitmap.width, h2 = this.bitmap.height, f2 = or.alloc(this.bitmap.data.length);
            function u2(t3, e3) {
              return function(r3, i3) {
                return { x: r3 + t3, y: i3 + e3 };
              };
            }
            const l2 = u2(-s2 / 2, -h2 / 2), c2 = u2(s2 / 2 + 0.5, h2 / 2 + 0.5);
            for (let t3 = 1; t3 <= h2; t3++)
              for (let e3 = 1; e3 <= s2; e3++) {
                const r3 = l2(e3, t3), a3 = c2(i2 * r3.x - n2 * r3.y, i2 * r3.y + n2 * r3.x), o3 = s2 * (t3 - 1) + e3 - 1 << 2;
                if (a3.x >= 0 && a3.x < s2 && a3.y >= 0 && a3.y < h2) {
                  const t4 = (s2 * (0 | a3.y) + a3.x | 0) << 2, e4 = this.bitmap.data.readUInt32BE(t4);
                  f2.writeUInt32BE(e4, o3);
                } else
                  f2.writeUInt32BE(this._background, o3);
              }
            if (this.bitmap.data = f2, true === e2 || "string" == typeof e2) {
              const t3 = s2 / 2 - a2 / 2, e3 = h2 / 2 - o2 / 2;
              this.crop(t3, e3, a2, o2);
            }
          }
          const fr = [() => ({ blit(t2, e2, r2, i2, n2, a2, o2, s2) {
            if (!(t2 instanceof this.constructor))
              return f.call(this, "The source must be a Jimp image", s2);
            if ("number" != typeof e2 || "number" != typeof r2)
              return f.call(this, "x and y must be numbers", s2);
            if ("function" == typeof i2)
              s2 = i2, i2 = 0, n2 = 0, a2 = t2.bitmap.width, o2 = t2.bitmap.height;
            else {
              if (typeof i2 != typeof n2 || typeof n2 != typeof a2 || typeof a2 != typeof o2)
                return f.call(this, "srcx, srcy, srcw, srch must be numbers", s2);
              i2 = i2 || 0, n2 = n2 || 0, a2 = a2 || t2.bitmap.width, o2 = o2 || t2.bitmap.height;
            }
            e2 = Math.round(e2), r2 = Math.round(r2), i2 = Math.round(i2), n2 = Math.round(n2), a2 = Math.round(a2), o2 = Math.round(o2);
            const u2 = this.bitmap.width, l2 = this.bitmap.height, c2 = this;
            return t2.scanQuiet(i2, n2, a2, o2, function(t3, a3, o3) {
              const s3 = e2 + t3 - i2, h2 = r2 + a3 - n2;
              if (s3 >= 0 && h2 >= 0 && u2 - s3 > 0 && l2 - h2 > 0) {
                const t4 = c2.getPixelIndex(s3, h2), e3 = { r: this.bitmap.data[o3], g: this.bitmap.data[o3 + 1], b: this.bitmap.data[o3 + 2], a: this.bitmap.data[o3 + 3] }, r3 = { r: c2.bitmap.data[t4], g: c2.bitmap.data[t4 + 1], b: c2.bitmap.data[t4 + 2], a: c2.bitmap.data[t4 + 3] };
                c2.bitmap.data[t4] = (e3.a * (e3.r - r3.r) - r3.r + 255 >> 8) + r3.r, c2.bitmap.data[t4 + 1] = (e3.a * (e3.g - r3.g) - r3.g + 255 >> 8) + r3.g, c2.bitmap.data[t4 + 2] = (e3.a * (e3.b - r3.b) - r3.b + 255 >> 8) + r3.b, c2.bitmap.data[t4 + 3] = this.constructor.limit255(r3.a + e3.a);
              }
            }), h(s2) && s2.call(this, null, this), this;
          } }), () => ({ blur(t2, e2) {
            if ("number" != typeof t2)
              return f.call(this, "r must be a number", e2);
            if (t2 < 1)
              return f.call(this, "r must be greater than 0", e2);
            let r2, i2, n2, a2, o2, s2, u2, l2, c2, d2, p2, m2, g2, b2;
            const _2 = this.bitmap.width - 1, y2 = this.bitmap.height - 1, w2 = t2 + 1, v2 = Re[t2], x2 = Pe[t2], E2 = [], k2 = [], S2 = [], M2 = [], A2 = [], I2 = [];
            let T2 = 2;
            for (; T2-- > 0; ) {
              for (m2 = 0, g2 = 0, s2 = 0; s2 < this.bitmap.height; s2++) {
                for (r2 = this.bitmap.data[g2] * w2, i2 = this.bitmap.data[g2 + 1] * w2, n2 = this.bitmap.data[g2 + 2] * w2, a2 = this.bitmap.data[g2 + 3] * w2, u2 = 1; u2 <= t2; u2++)
                  l2 = g2 + ((u2 > _2 ? _2 : u2) << 2), r2 += this.bitmap.data[l2++], i2 += this.bitmap.data[l2++], n2 += this.bitmap.data[l2++], a2 += this.bitmap.data[l2];
                for (o2 = 0; o2 < this.bitmap.width; o2++)
                  E2[m2] = r2, k2[m2] = i2, S2[m2] = n2, M2[m2] = a2, 0 === s2 && (A2[o2] = ((l2 = o2 + w2) < _2 ? l2 : _2) << 2, I2[o2] = (l2 = o2 - t2) > 0 ? l2 << 2 : 0), c2 = g2 + A2[o2], d2 = g2 + I2[o2], r2 += this.bitmap.data[c2++] - this.bitmap.data[d2++], i2 += this.bitmap.data[c2++] - this.bitmap.data[d2++], n2 += this.bitmap.data[c2++] - this.bitmap.data[d2++], a2 += this.bitmap.data[c2] - this.bitmap.data[d2], m2++;
                g2 += this.bitmap.width << 2;
              }
              for (o2 = 0; o2 < this.bitmap.width; o2++) {
                for (p2 = o2, r2 = E2[p2] * w2, i2 = k2[p2] * w2, n2 = S2[p2] * w2, a2 = M2[p2] * w2, u2 = 1; u2 <= t2; u2++)
                  p2 += u2 > y2 ? 0 : this.bitmap.width, r2 += E2[p2], i2 += k2[p2], n2 += S2[p2], a2 += M2[p2];
                for (m2 = o2 << 2, s2 = 0; s2 < this.bitmap.height; s2++)
                  b2 = a2 * v2 >>> x2, this.bitmap.data[m2 + 3] = b2, b2 > 255 && (this.bitmap.data[m2 + 3] = 255), b2 > 0 ? (b2 = 255 / b2, this.bitmap.data[m2] = (r2 * v2 >>> x2) * b2, this.bitmap.data[m2 + 1] = (i2 * v2 >>> x2) * b2, this.bitmap.data[m2 + 2] = (n2 * v2 >>> x2) * b2) : (this.bitmap.data[m2 + 2] = 0, this.bitmap.data[m2 + 1] = 0, this.bitmap.data[m2] = 0), 0 === o2 && (A2[s2] = ((l2 = s2 + w2) < y2 ? l2 : y2) * this.bitmap.width, I2[s2] = (l2 = s2 - t2) > 0 ? l2 * this.bitmap.width : 0), c2 = o2 + A2[s2], d2 = o2 + I2[s2], r2 += E2[c2] - E2[d2], i2 += k2[c2] - k2[d2], n2 += S2[c2] - S2[d2], a2 += M2[c2] - M2[d2], m2 += this.bitmap.width << 2;
              }
            }
            return h(e2) && e2.call(this, null, this), this;
          } }), () => ({ circle() {
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 ? arguments[1] : void 0;
            "function" == typeof t2 && (e2 = t2, t2 = {});
            const r2 = t2.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2, i2 = "number" == typeof t2.x ? t2.x : this.bitmap.width / 2, n2 = "number" == typeof t2.y ? t2.y : this.bitmap.height / 2;
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, e3, a2) {
              const o2 = Math.sqrt(Math.pow(t3 - i2, 2) + Math.pow(e3 - n2, 2));
              r2 - o2 <= 0 ? this.bitmap.data[a2 + 3] = 0 : r2 - o2 < 1 && (this.bitmap.data[a2 + 3] = 255 * (r2 - o2));
            }), h(e2) && e2.call(this, null, this), this;
          } }), () => ({ brightness(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "val must be numbers", e2) : t2 < -1 || t2 > 1 ? f.call(this, "val must be a number between -1 and +1", e2) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(e3, r2, i2) {
              t2 < 0 ? (this.bitmap.data[i2] *= 1 + t2, this.bitmap.data[i2 + 1] *= 1 + t2, this.bitmap.data[i2 + 2] *= 1 + t2) : (this.bitmap.data[i2] += (255 - this.bitmap.data[i2]) * t2, this.bitmap.data[i2 + 1] += (255 - this.bitmap.data[i2 + 1]) * t2, this.bitmap.data[i2 + 2] += (255 - this.bitmap.data[i2 + 2]) * t2);
            }), h(e2) && e2.call(this, null, this), this);
          }, contrast(t2, e2) {
            if ("number" != typeof t2)
              return f.call(this, "val must be numbers", e2);
            if (t2 < -1 || t2 > 1)
              return f.call(this, "val must be a number between -1 and +1", e2);
            const r2 = (t2 + 1) / (1 - t2);
            function i2(t3) {
              return (t3 = Math.floor(r2 * (t3 - 127) + 127)) < 0 ? 0 : t3 > 255 ? 255 : t3;
            }
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, e3, r3) {
              this.bitmap.data[r3] = i2(this.bitmap.data[r3]), this.bitmap.data[r3 + 1] = i2(this.bitmap.data[r3 + 1]), this.bitmap.data[r3 + 2] = i2(this.bitmap.data[r3 + 2]);
            }), h(e2) && e2.call(this, null, this), this;
          }, posterize(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "n must be numbers", e2) : (t2 < 2 && (t2 = 2), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(e3, r2, i2) {
              this.bitmap.data[i2] = Math.floor(this.bitmap.data[i2] / 255 * (t2 - 1)) / (t2 - 1) * 255, this.bitmap.data[i2 + 1] = Math.floor(this.bitmap.data[i2 + 1] / 255 * (t2 - 1)) / (t2 - 1) * 255, this.bitmap.data[i2 + 2] = Math.floor(this.bitmap.data[i2 + 2] / 255 * (t2 - 1)) / (t2 - 1) * 255;
            }), h(e2) && e2.call(this, null, this), this);
          }, greyscale: Ue, grayscale: Ue, opacity(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "f must be a number", e2) : t2 < 0 || t2 > 1 ? f.call(this, "f must be a number from 0 to 1", e2) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(e3, r2, i2) {
              const n2 = this.bitmap.data[i2 + 3] * t2;
              this.bitmap.data[i2 + 3] = n2;
            }), h(e2) && e2.call(this, null, this), this);
          }, sepia(t2) {
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, e2, r2) {
              let i2 = this.bitmap.data[r2], n2 = this.bitmap.data[r2 + 1], a2 = this.bitmap.data[r2 + 2];
              i2 = 0.393 * i2 + 0.769 * n2 + 0.189 * a2, n2 = 0.349 * i2 + 0.686 * n2 + 0.168 * a2, a2 = 0.272 * i2 + 0.534 * n2 + 0.131 * a2, this.bitmap.data[r2] = i2 < 255 ? i2 : 255, this.bitmap.data[r2 + 1] = n2 < 255 ? n2 : 255, this.bitmap.data[r2 + 2] = a2 < 255 ? a2 : 255;
            }), h(t2) && t2.call(this, null, this), this;
          }, fade(t2, e2) {
            return "number" != typeof t2 ? f.call(this, "f must be a number", e2) : t2 < 0 || t2 > 1 ? f.call(this, "f must be a number from 0 to 1", e2) : (this.opacity(1 - t2), h(e2) && e2.call(this, null, this), this);
          }, convolution(t2, e2, r2) {
            "function" == typeof e2 && void 0 === r2 && (r2 = e2, e2 = null), e2 || (e2 = this.constructor.EDGE_EXTEND);
            const i2 = Oe.from(this.bitmap.data), n2 = t2.length, a2 = t2[0].length, o2 = Math.floor(n2 / 2), s2 = Math.floor(a2 / 2), f2 = -o2, u2 = -s2;
            let l2, c2, d2, p2, m2, g2, b2, _2, y2, w2;
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(r3, n3, a3) {
              p2 = 0, d2 = 0, c2 = 0;
              for (let i3 = f2; i3 <= o2; i3++)
                for (let a4 = u2; a4 <= s2; a4++)
                  _2 = r3 + a4, y2 = n3 + i3, l2 = t2[i3 + o2][a4 + s2], w2 = this.getPixelIndex(_2, y2, e2), -1 === w2 ? (b2 = 0, g2 = 0, m2 = 0) : (m2 = this.bitmap.data[w2 + 0], g2 = this.bitmap.data[w2 + 1], b2 = this.bitmap.data[w2 + 2]), c2 += l2 * m2, d2 += l2 * g2, p2 += l2 * b2;
              c2 < 0 && (c2 = 0), d2 < 0 && (d2 = 0), p2 < 0 && (p2 = 0), c2 > 255 && (c2 = 255), d2 > 255 && (d2 = 255), p2 > 255 && (p2 = 255), i2[a3 + 0] = c2, i2[a3 + 1] = d2, i2[a3 + 2] = p2;
            }), this.bitmap.data = i2, h(r2) && r2.call(this, null, this), this;
          }, opaque(t2) {
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, e2, r2) {
              this.bitmap.data[r2 + 3] = 255;
            }), h(t2) && t2.call(this, null, this), this;
          }, pixelate(t2, e2, r2, i2, n2, a2) {
            if ("function" == typeof e2)
              a2 = e2, n2 = null, i2 = null, r2 = null, e2 = null;
            else {
              if ("number" != typeof t2)
                return f.call(this, "size must be a number", a2);
              if (Ce(e2) && "number" != typeof e2)
                return f.call(this, "x must be a number", a2);
              if (Ce(r2) && "number" != typeof r2)
                return f.call(this, "y must be a number", a2);
              if (Ce(i2) && "number" != typeof i2)
                return f.call(this, "w must be a number", a2);
              if (Ce(n2) && "number" != typeof n2)
                return f.call(this, "h must be a number", a2);
            }
            const o2 = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 0.25, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
            e2 = e2 || 0, r2 = r2 || 0, i2 = Ce(i2) ? i2 : this.bitmap.width - e2, n2 = Ce(n2) ? n2 : this.bitmap.height - r2;
            const s2 = this.cloneQuiet();
            return this.scanQuiet(e2, r2, i2, n2, function(e3, r3, i3) {
              e3 = t2 * Math.floor(e3 / t2), r3 = t2 * Math.floor(r3 / t2);
              const n3 = Le(s2, o2, e3, r3);
              this.bitmap.data[i3] = n3[0], this.bitmap.data[i3 + 1] = n3[1], this.bitmap.data[i3 + 2] = n3[2];
            }), h(a2) && a2.call(this, null, this), this;
          }, convolute(t2, e2, r2, i2, n2, a2) {
            if (!Array.isArray(t2))
              return f.call(this, "the kernel must be an array", a2);
            if ("function" == typeof e2)
              a2 = e2, e2 = null, r2 = null, i2 = null, n2 = null;
            else {
              if (Ce(e2) && "number" != typeof e2)
                return f.call(this, "x must be a number", a2);
              if (Ce(r2) && "number" != typeof r2)
                return f.call(this, "y must be a number", a2);
              if (Ce(i2) && "number" != typeof i2)
                return f.call(this, "w must be a number", a2);
              if (Ce(n2) && "number" != typeof n2)
                return f.call(this, "h must be a number", a2);
            }
            const o2 = (t2.length - 1) / 2;
            e2 = Ce(e2) ? e2 : o2, r2 = Ce(r2) ? r2 : o2, i2 = Ce(i2) ? i2 : this.bitmap.width - e2, n2 = Ce(n2) ? n2 : this.bitmap.height - r2;
            const s2 = this.cloneQuiet();
            return this.scanQuiet(e2, r2, i2, n2, function(e3, r3, i3) {
              const n3 = Le(s2, t2, e3, r3);
              this.bitmap.data[i3] = this.constructor.limit255(n3[0]), this.bitmap.data[i3 + 1] = this.constructor.limit255(n3[1]), this.bitmap.data[i3 + 2] = this.constructor.limit255(n3[2]);
            }), h(a2) && a2.call(this, null, this), this;
          }, color: ze, colour: ze }), () => ({ contain(t2, e2, r2, i2, n2) {
            if ("number" != typeof t2 || "number" != typeof e2)
              return f.call(this, "w and h must be numbers", n2);
            "string" == typeof r2 && ("function" == typeof i2 && void 0 === n2 && (n2 = i2), i2 = r2, r2 = null), "function" == typeof r2 && (void 0 === n2 && (n2 = r2), i2 = null, r2 = null), "function" == typeof i2 && void 0 === n2 && (n2 = i2, i2 = null);
            const a2 = 7 & (r2 = r2 || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE), o2 = r2 >> 3;
            if ((0 === a2 || a2 & a2 - 1) && (0 === o2 || o2 & o2 - 1))
              return f.call(this, "only use one flag per alignment direction", n2);
            const s2 = a2 >> 1, u2 = o2 >> 1, l2 = t2 / e2 > this.bitmap.width / this.bitmap.height ? e2 / this.bitmap.height : t2 / this.bitmap.width, c2 = this.cloneQuiet().scale(l2, i2);
            return this.resize(t2, e2, i2), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, e3, r3) {
              this.bitmap.data.writeUInt32BE(this._background, r3);
            }), this.blit(c2, (this.bitmap.width - c2.bitmap.width) / 2 * s2, (this.bitmap.height - c2.bitmap.height) / 2 * u2), h(n2) && n2.call(this, null, this), this;
          } }), () => ({ cover(t2, e2, r2, i2, n2) {
            if ("number" != typeof t2 || "number" != typeof e2)
              return f.call(this, "w and h must be numbers", n2);
            r2 && "function" == typeof r2 && void 0 === n2 ? (n2 = r2, r2 = null, i2 = null) : "function" == typeof i2 && void 0 === n2 && (n2 = i2, i2 = null);
            const a2 = 7 & (r2 = r2 || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE), o2 = r2 >> 3;
            if ((0 === a2 || a2 & a2 - 1) && (0 === o2 || o2 & o2 - 1))
              return f.call(this, "only use one flag per alignment direction", n2);
            const s2 = a2 >> 1, u2 = o2 >> 1, l2 = t2 / e2 > this.bitmap.width / this.bitmap.height ? t2 / this.bitmap.width : e2 / this.bitmap.height;
            return this.scale(l2, i2), this.crop((this.bitmap.width - t2) / 2 * s2, (this.bitmap.height - e2) / 2 * u2, t2, e2), h(n2) && n2.call(this, null, this), this;
          } }), function(t2) {
            return t2("crop", function(t3, e2, r2, i2, n2) {
              if ("number" != typeof t3 || "number" != typeof e2)
                return f.call(this, "x and y must be numbers", n2);
              if ("number" != typeof r2 || "number" != typeof i2)
                return f.call(this, "w and h must be numbers", n2);
              if (t3 = Math.round(t3), e2 = Math.round(e2), r2 = Math.round(r2), i2 = Math.round(i2), 0 === t3 && r2 === this.bitmap.width) {
                const n3 = r2 * e2 + t3 << 2, a2 = n3 + (i2 * r2 << 2);
                this.bitmap.data = this.bitmap.data.slice(n3, a2);
              } else {
                const n3 = Ne.allocUnsafe(r2 * i2 * 4);
                let a2 = 0;
                this.scanQuiet(t3, e2, r2, i2, function(t4, e3, r3) {
                  const i3 = this.bitmap.data.readUInt32BE(r3, true);
                  n3.writeUInt32BE(i3, a2, true), a2 += 4;
                }), this.bitmap.data = n3;
              }
              return this.bitmap.width = r2, this.bitmap.height = i2, h(n2) && n2.call(this, null, this), this;
            }), { class: { autocrop() {
              const t3 = this.bitmap.width, e2 = this.bitmap.height;
              let r2, i2 = 0, n2 = 2e-4, a2 = true, o2 = false, s2 = { north: false, south: false, east: false, west: false };
              for (var f2 = arguments.length, u2 = new Array(f2), l2 = 0; l2 < f2; l2++)
                u2[l2] = arguments[l2];
              for (let t4 = 0, e3 = u2.length; t4 < e3; t4++)
                if ("number" == typeof u2[t4] && (n2 = u2[t4]), "boolean" == typeof u2[t4] && (a2 = u2[t4]), "function" == typeof u2[t4] && (r2 = u2[t4]), "object" == typeof u2[t4]) {
                  const e4 = u2[t4];
                  void 0 !== e4.tolerance && ({ tolerance: n2 } = e4), void 0 !== e4.cropOnlyFrames && ({ cropOnlyFrames: a2 } = e4), void 0 !== e4.cropSymmetric && ({ cropSymmetric: o2 } = e4), void 0 !== e4.leaveBorder && ({ leaveBorder: i2 } = e4), void 0 !== e4.ignoreSides && ({ ignoreSides: s2 } = e4);
                }
              let c2 = this.getPixelColor(0, 0);
              const d2 = this.constructor.intToRGBA(c2);
              let p2 = 0, m2 = 0, g2 = 0, b2 = 0;
              if (c2 = this.getPixelColor(0, 0), !s2.north)
                t:
                  for (let r3 = 0; r3 < e2 - 1; r3++) {
                    for (let e3 = 0; e3 < t3; e3++) {
                      const t4 = this.getPixelColor(e3, r3), i3 = this.constructor.intToRGBA(t4);
                      if (this.constructor.colorDiff(d2, i3) > n2)
                        break t;
                    }
                    p2++;
                  }
              if (c2 = this.getPixelColor(t3, 0), !s2.east)
                t:
                  for (let r3 = 0; r3 < t3 - 1; r3++) {
                    for (let t4 = 0 + p2; t4 < e2; t4++) {
                      const e3 = this.getPixelColor(r3, t4), i3 = this.constructor.intToRGBA(e3);
                      if (this.constructor.colorDiff(d2, i3) > n2)
                        break t;
                    }
                    m2++;
                  }
              if (c2 = this.getPixelColor(0, e2), !s2.south)
                t:
                  for (let r3 = e2 - 1; r3 >= p2 + 1; r3--) {
                    for (let e3 = t3 - m2 - 1; e3 >= 0; e3--) {
                      const t4 = this.getPixelColor(e3, r3), i3 = this.constructor.intToRGBA(t4);
                      if (this.constructor.colorDiff(d2, i3) > n2)
                        break t;
                    }
                    g2++;
                  }
              if (c2 = this.getPixelColor(t3, e2), !s2.west)
                t:
                  for (let r3 = t3 - 1; r3 >= 0 + m2 + 1; r3--) {
                    for (let t4 = e2 - 1; t4 >= 0 + p2; t4--) {
                      const e3 = this.getPixelColor(r3, t4), i3 = this.constructor.intToRGBA(e3);
                      if (this.constructor.colorDiff(d2, i3) > n2)
                        break t;
                    }
                    b2++;
                  }
              let _2 = false;
              if (b2 -= i2, m2 -= i2, p2 -= i2, g2 -= i2, o2) {
                const t4 = Math.min(m2, b2), e3 = Math.min(p2, g2);
                b2 = t4, m2 = t4, p2 = e3, g2 = e3;
              }
              b2 = b2 >= 0 ? b2 : 0, m2 = m2 >= 0 ? m2 : 0, p2 = p2 >= 0 ? p2 : 0, g2 = g2 >= 0 ? g2 : 0;
              const y2 = t3 - (b2 + m2), w2 = e2 - (g2 + p2);
              return _2 = a2 ? 0 !== m2 && 0 !== p2 && 0 !== b2 && 0 !== g2 : 0 !== m2 || 0 !== p2 || 0 !== b2 || 0 !== g2, _2 && this.crop(m2, p2, y2, w2), h(r2) && r2.call(this, null, this), this;
            } } };
          }, () => ({ displace(t2, e2, r2) {
            if ("object" != typeof t2 || t2.constructor !== this.constructor)
              return f.call(this, "The source must be a Jimp image", r2);
            if ("number" != typeof e2)
              return f.call(this, "factor must be a number", r2);
            const i2 = this.cloneQuiet();
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(r3, n2, a2) {
              let o2 = t2.bitmap.data[a2] / 256 * e2;
              o2 = Math.round(o2);
              const s2 = this.getPixelIndex(r3 + o2, n2);
              this.bitmap.data[s2] = i2.bitmap.data[a2], this.bitmap.data[s2 + 1] = i2.bitmap.data[a2 + 1], this.bitmap.data[s2 + 2] = i2.bitmap.data[a2 + 2];
            }), h(r2) && r2.call(this, null, this), this;
          } }), () => ({ dither565: Fe, dither16: Fe }), () => ({ fisheye() {
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { r: 2.5 }, e2 = arguments.length > 1 ? arguments[1] : void 0;
            "function" == typeof t2 && (e2 = t2, t2 = { r: 2.5 });
            const r2 = this.cloneQuiet(), { width: i2, height: n2 } = r2.bitmap;
            return r2.scanQuiet(0, 0, i2, n2, (e3, a2) => {
              const o2 = e3 / i2, s2 = a2 / n2, h2 = Math.sqrt(Math.pow(o2 - 0.5, 2) + Math.pow(s2 - 0.5, 2)), f2 = 2 * Math.pow(h2, t2.r), u2 = (o2 - 0.5) / h2, l2 = (s2 - 0.5) / h2, c2 = Math.round((f2 * u2 + 0.5) * i2), d2 = Math.round((f2 * l2 + 0.5) * n2), p2 = r2.getPixelColor(c2, d2);
              this.setPixelColor(p2, e3, a2);
            }), this.setPixelColor(r2.getPixelColor(i2 / 2, n2 / 2), i2 / 2, n2 / 2), h(e2) && e2.call(this, null, this), this;
          } }), () => ({ flip: Ge, mirror: Ge }), () => ({ gaussian(t2, e2) {
            if ("number" != typeof t2)
              return f.call(this, "r must be a number", e2);
            if (t2 < 1)
              return f.call(this, "r must be greater than 0", e2);
            const r2 = Math.ceil(2.57 * t2), i2 = 2 * r2 + 1, n2 = t2 * t2 * 2, a2 = n2 * Math.PI, o2 = [];
            for (let t3 = 0; t3 < i2; t3++) {
              o2[t3] = [];
              for (let e3 = 0; e3 < i2; e3++) {
                const i3 = (e3 - r2) ** 2 + (t3 - r2) ** 2;
                o2[t3][e3] = Math.exp(-i3 / n2) / a2;
              }
            }
            for (let t3 = 0; t3 < this.bitmap.height; t3++)
              for (let e3 = 0; e3 < this.bitmap.width; e3++) {
                let n3 = 0, a3 = 0, s2 = 0, h2 = 0, f2 = 0;
                for (let u2 = 0; u2 < i2; u2++) {
                  for (let l3 = 0; l3 < i2; l3++) {
                    const i3 = Math.min(this.bitmap.width - 1, Math.max(0, l3 + e3 - r2)), c2 = Math.min(this.bitmap.height - 1, Math.max(0, u2 + t3 - r2)), d2 = o2[u2][l3], p2 = c2 * this.bitmap.width + i3 << 2;
                    n3 += this.bitmap.data[p2] * d2, a3 += this.bitmap.data[p2 + 1] * d2, s2 += this.bitmap.data[p2 + 2] * d2, h2 += this.bitmap.data[p2 + 3] * d2, f2 += d2;
                  }
                  const l2 = t3 * this.bitmap.width + e3 << 2;
                  this.bitmap.data[l2] = Math.round(n3 / f2), this.bitmap.data[l2 + 1] = Math.round(a3 / f2), this.bitmap.data[l2 + 2] = Math.round(s2 / f2), this.bitmap.data[l2 + 3] = Math.round(h2 / f2);
                }
              }
            return h(e2) && e2.call(this, null, this), this;
          } }), () => ({ invert(t2) {
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, e2, r2) {
              this.bitmap.data[r2] = 255 - this.bitmap.data[r2], this.bitmap.data[r2 + 1] = 255 - this.bitmap.data[r2 + 1], this.bitmap.data[r2 + 2] = 255 - this.bitmap.data[r2 + 2];
            }), h(t2) && t2.call(this, null, this), this;
          } }), () => ({ mask(t2) {
            let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i2 = arguments.length > 3 ? arguments[3] : void 0;
            if (!(t2 instanceof this.constructor))
              return f.call(this, "The source must be a Jimp image", i2);
            if ("number" != typeof e2 || "number" != typeof r2)
              return f.call(this, "x and y must be numbers", i2);
            e2 = Math.round(e2), r2 = Math.round(r2);
            const n2 = this.bitmap.width, a2 = this.bitmap.height, o2 = this;
            return t2.scanQuiet(0, 0, t2.bitmap.width, t2.bitmap.height, function(t3, i3, s2) {
              const h2 = e2 + t3, f2 = r2 + i3;
              if (h2 >= 0 && f2 >= 0 && h2 < n2 && f2 < a2) {
                const t4 = o2.getPixelIndex(h2, f2), { data: e3 } = this.bitmap, r3 = (e3[s2 + 0] + e3[s2 + 1] + e3[s2 + 2]) / 3;
                o2.bitmap.data[t4 + 3] *= r3 / 255;
              }
            }), h(i2) && i2.call(this, null, this), this;
          } }), () => ({ normalize(t2) {
            const e2 = He.call(this), r2 = { r: qe(e2.r), g: qe(e2.g), b: qe(e2.b) };
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(t3, e3, i2) {
              const n2 = this.bitmap.data[i2 + 0], a2 = this.bitmap.data[i2 + 1], o2 = this.bitmap.data[i2 + 2];
              this.bitmap.data[i2 + 0] = We(n2, r2.r[0], r2.r[1]), this.bitmap.data[i2 + 1] = We(a2, r2.g[0], r2.g[1]), this.bitmap.data[i2 + 2] = We(o2, r2.b[0], r2.b[1]);
            }), h(t2) && t2.call(this, null, this), this;
          } }), () => ({ constants: { measureText: Ve, measureTextHeight: Qe, FONT_SANS_8_BLACK: a().join($e, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"), FONT_SANS_10_BLACK: a().join($e, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"), FONT_SANS_12_BLACK: a().join($e, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"), FONT_SANS_14_BLACK: a().join($e, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"), FONT_SANS_16_BLACK: a().join($e, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"), FONT_SANS_32_BLACK: a().join($e, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"), FONT_SANS_64_BLACK: a().join($e, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"), FONT_SANS_128_BLACK: a().join($e, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"), FONT_SANS_8_WHITE: a().join($e, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"), FONT_SANS_16_WHITE: a().join($e, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"), FONT_SANS_32_WHITE: a().join($e, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"), FONT_SANS_64_WHITE: a().join($e, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"), FONT_SANS_128_WHITE: a().join($e, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"), loadFont(t2, e2) {
            return "string" != typeof t2 ? f.call(this, "file must be a string", e2) : new Promise((r2, i2) => {
              e2 = e2 || function(t3, e3) {
                t3 ? i2(t3) : r2(e3);
              }, Ye()(t2, (r3, i3) => {
                const n2 = {}, o2 = {};
                if (r3)
                  return f.call(this, r3, e2);
                for (let t3 = 0; t3 < i3.chars.length; t3++)
                  n2[String.fromCharCode(i3.chars[t3].id)] = i3.chars[t3];
                for (let t3 = 0; t3 < i3.kernings.length; t3++) {
                  const e3 = String.fromCharCode(i3.kernings[t3].first);
                  o2[e3] = o2[e3] || {}, o2[e3][String.fromCharCode(i3.kernings[t3].second)] = i3.kernings[t3].amount;
                }
                (function(t3, e3, r4) {
                  const i4 = r4.map((r5) => t3.read(e3 + "/" + r5));
                  return Promise.all(i4);
                })(this, a().dirname(t2), i3.pages).then((t3) => {
                  e2(null, { chars: n2, kernings: o2, pages: t3, common: i3.common, info: i3.info });
                });
              });
            });
          } }, class: { print(t2, e2, r2, i2, n2, a2, o2) {
            if ("function" == typeof n2 && void 0 === o2 && (o2 = n2, n2 = 1 / 0), void 0 === n2 && (n2 = 1 / 0), "function" == typeof a2 && void 0 === o2 && (o2 = a2, a2 = 1 / 0), void 0 === a2 && (a2 = 1 / 0), "object" != typeof t2)
              return f.call(this, "font must be a Jimp loadFont", o2);
            if ("number" != typeof e2 || "number" != typeof r2 || "number" != typeof n2)
              return f.call(this, "x, y and maxWidth must be numbers", o2);
            if ("number" != typeof n2)
              return f.call(this, "maxWidth must be a number", o2);
            if ("number" != typeof a2)
              return f.call(this, "maxHeight must be a number", o2);
            let s2, u2;
            "object" == typeof i2 && null !== i2.text && void 0 !== i2.text ? (s2 = i2.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT, u2 = i2.alignmentY || this.constructor.VERTICAL_ALIGN_TOP, { text: i2 } = i2) : (s2 = this.constructor.HORIZONTAL_ALIGN_LEFT, u2 = this.constructor.VERTICAL_ALIGN_TOP, i2 = i2.toString()), a2 !== 1 / 0 && u2 === this.constructor.VERTICAL_ALIGN_BOTTOM ? r2 += a2 - Qe(t2, i2, n2) : a2 !== 1 / 0 && u2 === this.constructor.VERTICAL_ALIGN_MIDDLE && (r2 += a2 / 2 - Qe(t2, i2, n2) / 2);
            const l2 = Object.entries(t2.chars)[0][1].xadvance, { lines: c2, longestLine: d2 } = Xe(t2, i2, n2);
            return c2.forEach((i3) => {
              const a3 = i3.join(" "), o3 = function(t3, e3, r3, i4, n3) {
                return n3 === t3.HORIZONTAL_ALIGN_LEFT ? 0 : n3 === t3.HORIZONTAL_ALIGN_CENTER ? (i4 - Ve(e3, r3)) / 2 : i4 - Ve(e3, r3);
              }(this.constructor, t2, a3, n2, s2);
              Ke.call(this, t2, e2 + o3, r2, a3, l2), r2 += t2.common.lineHeight;
            }), h(o2) && o2.call(this, null, this, { x: e2 + d2, y: r2 }), this;
          } } }), () => ({ constants: { RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor", RESIZE_BILINEAR: "bilinearInterpolation", RESIZE_BICUBIC: "bicubicInterpolation", RESIZE_HERMITE: "hermiteInterpolation", RESIZE_BEZIER: "bezierInterpolation" }, class: { resize(t2, e2, r2, i2) {
            if ("number" != typeof t2 || "number" != typeof e2)
              return f.call(this, "w and h must be numbers", i2);
            if ("function" == typeof r2 && void 0 === i2 && (i2 = r2, r2 = null), t2 === this.constructor.AUTO && e2 === this.constructor.AUTO)
              return f.call(this, "w and h cannot both be set to auto", i2);
            if (t2 === this.constructor.AUTO && (t2 = this.bitmap.width * (e2 / this.bitmap.height)), e2 === this.constructor.AUTO && (e2 = this.bitmap.height * (t2 / this.bitmap.width)), t2 < 0 || e2 < 0)
              return f.call(this, "w and h must be positive numbers", i2);
            if (t2 = Math.round(t2) || 1, e2 = Math.round(e2) || 1, "function" == typeof nr[r2]) {
              const i3 = { data: ar.alloc(t2 * e2 * 4), width: t2, height: e2 };
              nr[r2](this.bitmap, i3), this.bitmap = i3;
            } else {
              const r3 = this;
              new er(this.bitmap.width, this.bitmap.height, t2, e2, true, true, (i3) => {
                r3.bitmap.data = ar.from(i3), r3.bitmap.width = t2, r3.bitmap.height = e2;
              }).resize(this.bitmap.data);
            }
            return h(i2) && i2.call(this, null, this), this;
          } } }), () => ({ rotate(t2, e2, r2) {
            return null == e2 && (e2 = true), "function" == typeof e2 && void 0 === r2 && (r2 = e2, e2 = true), "number" != typeof t2 ? f.call(this, "deg must be a number", r2) : "boolean" != typeof e2 && "string" != typeof e2 ? f.call(this, "mode must be a boolean or a string", r2) : (0 === Math.abs(t2 % 90) ? sr.call(this, t2) : hr.call(this, t2, e2, r2), h(r2) && r2.call(this, null, this), this);
          } }), () => ({ scale(t2, e2, r2) {
            if ("number" != typeof t2)
              return f.call(this, "f must be a number", r2);
            if (t2 < 0)
              return f.call(this, "f must be a positive number", r2);
            "function" == typeof e2 && void 0 === r2 && (r2 = e2, e2 = null);
            const i2 = this.bitmap.width * t2, n2 = this.bitmap.height * t2;
            return this.resize(i2, n2, e2), h(r2) && r2.call(this, null, this), this;
          }, scaleToFit(t2, e2, r2, i2) {
            if ("number" != typeof t2 || "number" != typeof e2)
              return f.call(this, "w and h must be numbers", i2);
            "function" == typeof r2 && void 0 === i2 && (i2 = r2, r2 = null);
            const n2 = t2 / e2 > this.bitmap.width / this.bitmap.height ? e2 / this.bitmap.height : t2 / this.bitmap.width;
            return this.scale(n2, r2), h(i2) && i2.call(this, null, this), this;
          } }), () => ({ shadow() {
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e2 = arguments.length > 1 ? arguments[1] : void 0;
            "function" == typeof t2 && (e2 = t2, t2 = {});
            const { opacity: r2 = 0.7, size: i2 = 1.1, x: n2 = -25, y: a2 = 25, blur: o2 = 5 } = t2, s2 = this.clone(), f2 = this.clone();
            return f2.scan(0, 0, f2.bitmap.width, f2.bitmap.height, (t3, e3, i3) => {
              f2.bitmap.data[i3] = 0, f2.bitmap.data[i3 + 1] = 0, f2.bitmap.data[i3 + 2] = 0, f2.bitmap.data[i3 + 3] = f2.constructor.limit255(f2.bitmap.data[i3 + 3] * r2), this.bitmap.data[i3] = 0, this.bitmap.data[i3 + 1] = 0, this.bitmap.data[i3 + 2] = 0, this.bitmap.data[i3 + 3] = 0;
            }), f2.resize(f2.bitmap.width * i2, f2.bitmap.height * i2).blur(o2), this.composite(f2, n2, a2), this.composite(s2, 0, 0), h(e2) && e2.call(this, null, this), this;
          } }), () => ({ threshold(t2, e2) {
            let { max: r2, replace: i2 = 255, autoGreyscale: n2 = true } = t2;
            return "number" != typeof r2 ? f.call(this, "max must be a number", e2) : "number" != typeof i2 ? f.call(this, "replace must be a number", e2) : "boolean" != typeof n2 ? f.call(this, "autoGreyscale must be a boolean", e2) : (r2 = this.constructor.limit255(r2), i2 = this.constructor.limit255(i2), n2 && this.greyscale(), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (t3, e3, n3) => {
              const a2 = this.bitmap.data[n3] < r2 ? this.bitmap.data[n3] : i2;
              this.bitmap.data[n3] = a2, this.bitmap.data[n3 + 1] = a2, this.bitmap.data[n3 + 2] = a2;
            }), h(e2) && e2.call(this, null, this), this);
          } })];
          !function(t2) {
            let e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : he;
            const r2 = { hasAlpha: {}, encoders: {}, decoders: {}, class: {}, constants: {} };
            function i2(t3) {
              Object.entries(t3).forEach((t4) => {
                let [e3, i3] = t4;
                r2[e3] = { ...r2[e3], ...i3 };
              });
            }
            t2.types && (t2.types.forEach(function(t3) {
              const e3 = t3();
              Array.isArray(e3.mime) ? Dt(...e3.mime) : Object.entries(e3.mime).forEach((t4) => Dt(...t4)), delete e3.mime, i2(e3);
            }), e2.decoders = { ...e2.decoders, ...r2.decoders }, e2.encoders = { ...e2.encoders, ...r2.encoders }, e2.hasAlpha = { ...e2.hasAlpha, ...r2.hasAlpha }), t2.plugins && t2.plugins.forEach(function(t3) {
              const e3 = t3(se) || {};
              e3.class || e3.constants ? i2(e3) : i2({ class: e3 });
            }), ae(r2.class, e2), ne(r2.constants, e2);
          }({ types: [() => (0, fe.Ee)(de(), ge(), { mime: { [ye]: ["bmp"] }, constants: { MIME_BMP: ye, MIME_X_MS_BMP: we }, decoders: { [ye]: ve, [we]: ve }, encoders: { [ye]: xe, [we]: xe } }, { mime: { [Me]: ["tiff", "tif"] }, constants: { MIME_TIFF: Me }, decoders: { [Me]: (t2) => {
            const e2 = ke().decode(t2), r2 = e2[0];
            e2.forEach((e3) => {
              ke().decodeImage(t2, e3);
            });
            const i2 = ke().toRGBA8(r2);
            return { data: Se.from(i2), width: r2.t256[0], height: r2.t257[0] };
          } }, encoders: { [Me]: (t2) => {
            const e2 = ke().encodeImage(t2.bitmap.data, t2.bitmap.width, t2.bitmap.height);
            return Se.from(e2);
          } } }, { mime: { [Be]: ["gif"] }, constants: { MIME_GIF: Be }, decoders: { [Be]: (t2) => {
            const e2 = new Ae.N(t2), r2 = Te.alloc(e2.width * e2.height * 4);
            return e2.decodeAndBlitFrameRGBA(0, r2), { data: r2, width: e2.width, height: e2.height };
          } }, encoders: { [Be]: (t2) => {
            const e2 = new Ie.BitmapImage(t2.bitmap);
            Ie.GifUtil.quantizeDekker(e2, 256);
            const r2 = new Ie.GifFrame(e2);
            return new Ie.GifCodec().encodeGif([r2], {}).then((t3) => t3.buffer);
          } } })], plugins: [(t2) => {
            const e2 = fr.map((e3) => {
              let r2 = e3(t2) || {};
              return r2.class || r2.constants || (r2 = { class: r2 }), r2;
            });
            return (0, fe.Ee)(...e2);
          }] });
        })();
      })();
    }
  });

  // node_modules/@xenova/transformers/src/processors.js
  var require_processors = __commonJS({
    "node_modules/@xenova/transformers/src/processors.js"(exports2, module2) {
      var {
        Callable,
        fetchJSON
      } = require_utils();
      var FFT = require_fft();
      var { Tensor, transpose, cat } = require_tensor_utils();
      var _Jimp = require_jimp();
      var Jimp = typeof self !== "undefined" ? self.Jimp || _Jimp : _Jimp;
      var B64_STRING = /^data:image\/\w+;base64,/;
      var AutoProcessor = class {
        // Helper class to determine model type from config
        static async from_pretrained(modelPath, progressCallback = null) {
          let preprocessorConfig = await fetchJSON(modelPath, "preprocessor_config.json", progressCallback);
          let processor_class;
          let feature_extractor;
          switch (preprocessorConfig.feature_extractor_type) {
            case "WhisperFeatureExtractor":
              feature_extractor = new WhisperFeatureExtractor(preprocessorConfig);
              break;
            case "ViTFeatureExtractor":
              feature_extractor = new ViTFeatureExtractor(preprocessorConfig);
              break;
            default:
              if (preprocessorConfig.size !== void 0) {
                feature_extractor = new ViTFeatureExtractor(preprocessorConfig);
              } else {
                throw new Error(`Unknown Feature Extractor type: ${preprocessorConfig.feature_extractor_type}`);
              }
          }
          switch (preprocessorConfig.processor_class) {
            case "WhisperProcessor":
              processor_class = WhisperProcessor;
              break;
            default:
              processor_class = Processor;
          }
          return new processor_class(feature_extractor);
        }
      };
      var FeatureExtractor = class extends Callable {
        constructor(config) {
          super();
          this.config = config;
        }
      };
      var ViTFeatureExtractor = class extends FeatureExtractor {
        constructor(config) {
          super(config);
          this.image_mean = this.config.image_mean;
          if (!Array.isArray(this.image_mean)) {
            this.image_mean = new Array(3).fill(this.image_mean);
          }
          this.image_std = this.config.image_std;
          if (!Array.isArray(this.image_std)) {
            this.image_std = new Array(3).fill(this.image_std);
          }
          this.do_rescale = this.config.do_rescale ?? true;
          this.do_normalize = this.config.do_normalize;
          this.do_resize = this.config.do_resize;
          this.size = this.config.size;
        }
        async preprocess(url) {
          let imgToLoad = url;
          if (B64_STRING.test(url)) {
            imgToLoad = imgToLoad.replace(B64_STRING, "");
            if (typeof Buffer !== "undefined") {
              imgToLoad = Buffer.from(imgToLoad, "base64");
            } else {
              let bytes = atob(imgToLoad);
              imgToLoad = new Uint8Array(new ArrayBuffer(bytes.length));
              for (let i = 0; i < bytes.length; i++) {
                imgToLoad[i] = bytes.charCodeAt(i);
              }
            }
          }
          let image = await Jimp.read(imgToLoad);
          if (this.do_resize) {
            image = image.resize(this.size, this.size);
          }
          const data = image.bitmap.data;
          let convData = new Float32Array(data.length * 3 / 4);
          let outIndex = 0;
          for (let i = 0; i < data.length; i += 4) {
            for (let j = 0; j < 3; ++j) {
              convData[outIndex++] = data[i + j];
            }
          }
          if (this.do_rescale) {
            for (let i = 0; i < convData.length; ++i) {
              convData[i] = convData[i] / 255;
            }
          }
          if (this.do_normalize) {
            for (let i = 0; i < convData.length; i += 3) {
              for (let j = 0; j < 3; ++j) {
                convData[i + j] = (convData[i + j] - this.image_mean[j]) / this.image_std[j];
              }
            }
          }
          let img = new Tensor("float32", convData, [this.size, this.size, 3]);
          let transposed = transpose(img, [2, 0, 1]);
          return transposed;
        }
        async _call(urls) {
          if (!Array.isArray(urls)) {
            urls = [urls];
          }
          let images = await Promise.all(urls.map((x) => this.preprocess(x)));
          images.forEach((x) => x.dims = [1, ...x.dims]);
          images = cat(images);
          return {
            pixel_values: images
          };
        }
      };
      var WhisperFeatureExtractor = class extends FeatureExtractor {
        calcOffset(i, w) {
          return Math.abs((i + w) % (2 * w) - w);
        }
        padReflect(array, left, right) {
          const padded = new Float32Array(array.length + left + right);
          const w = array.length - 1;
          for (let i = 0; i < array.length; ++i) {
            padded[left + i] = array[i];
          }
          for (let i = 1; i <= left; ++i) {
            padded[left - i] = array[this.calcOffset(i, w)];
          }
          for (let i = 1; i <= right; ++i) {
            padded[w + left + i] = array[this.calcOffset(w - i, w)];
          }
          return padded;
        }
        stft(frames, window2) {
          const fft_size = this.config.n_fft;
          const a = 2 * (fft_size - 1);
          const b = 2 * (2 * fft_size - 1);
          const nextP2 = 2 ** Math.ceil(Math.log2(b));
          const num_fft_bins = fft_size + 2;
          const data = new Float32Array(num_fft_bins * frames.length);
          const chirp = new Float32Array(b);
          const ichirp = new Float32Array(nextP2);
          const buffer1 = new Float32Array(nextP2);
          const buffer2 = new Float32Array(nextP2);
          const outBuffer = new Float32Array(nextP2);
          const outBuffer2 = new Float32Array(nextP2);
          const outBuffer3 = new Float32Array(nextP2);
          const theta = -2 * Math.PI / fft_size;
          const baseR = Math.cos(theta);
          const baseI = Math.sin(theta);
          for (let i = 0; i < b >> 1; ++i) {
            const e = (i + 1 - fft_size) ** 2 / 2;
            const result_mod = Math.sqrt(baseR ** 2 + baseI ** 2) ** e;
            const result_arg = e * Math.atan2(baseI, baseR);
            let i2 = 2 * i;
            chirp[i2] = result_mod * Math.cos(result_arg);
            chirp[i2 + 1] = result_mod * Math.sin(result_arg);
            ichirp[i2] = chirp[i2];
            ichirp[i2 + 1] = -chirp[i2 + 1];
          }
          const slicedChirp = chirp.subarray(a, b);
          const f = new FFT(nextP2 >> 1);
          f.transform(outBuffer, ichirp);
          for (let i in frames) {
            const frame = frames[i];
            for (let j = 0; j < slicedChirp.length; j += 2) {
              const j2 = j + 1;
              const j3 = j >> 1;
              const a_real = frame[j3] * window2[j3];
              buffer1[j] = a_real * slicedChirp[j];
              buffer1[j2] = a_real * slicedChirp[j2];
            }
            f.transform(outBuffer2, buffer1);
            for (let j = 0; j < outBuffer.length; j += 2) {
              const j2 = j + 1;
              buffer2[j] = outBuffer2[j] * outBuffer[j] - outBuffer2[j2] * outBuffer[j2];
              buffer2[j2] = outBuffer2[j] * outBuffer[j2] + outBuffer2[j2] * outBuffer[j];
            }
            f.inverseTransform(outBuffer3, buffer2);
            const offset = i * num_fft_bins;
            for (let j = 0; j < num_fft_bins; j += 2) {
              const a_real = outBuffer3[j + a];
              const a_imag = outBuffer3[j + a + 1];
              const b_real = slicedChirp[j];
              const b_imag = slicedChirp[j + 1];
              const o1 = offset + j;
              data[o1] = a_real * b_real - a_imag * b_imag;
              data[o1 + 1] = a_real * b_imag + a_imag * b_real;
            }
          }
          return {
            data,
            dims: [frames.length, num_fft_bins]
            // [3001, 402]
          };
        }
        fram_wave(waveform, center = true) {
          const frames = [];
          const half_window = Math.floor((this.config.n_fft - 1) / 2) + 1;
          const waveformLength = waveform.length;
          for (let i = 0; i < waveformLength + 1; i += this.config.hop_length) {
            let frame;
            if (center) {
              let frameStart = i > half_window ? i - half_window : 0;
              let frameEnd = i < waveformLength - half_window ? i + half_window : waveformLength;
              frame = waveform.subarray(frameStart, frameEnd);
              if (frameStart === 0) {
                frame = this.padReflect(
                  frame,
                  -i + half_window,
                  0
                );
              } else if (frameEnd === waveformLength) {
                frame = this.padReflect(
                  frame,
                  0,
                  i - waveformLength + half_window
                );
              }
            } else {
              frame = new Float32Array(this.config.n_fft);
              const frameArray = waveform.subarray(i, i + this.config.n_fft);
              if (frameWidth < this.config.n_fft) {
                frame.set(frameArray);
                frame.fill(0, frameWidth, this.config.n_fft);
              } else {
                frame = frameArray;
              }
            }
            frames.push(frame);
          }
          return frames;
        }
        hanning(M) {
          if (M < 1) {
            return [];
          }
          if (M === 1) {
            return [1];
          }
          const denom = M - 1;
          const cos_vals = new Float32Array(denom);
          for (let i = 0; i < denom; ++i) {
            const n = 2 * i - M + 1;
            cos_vals[i] = 0.5 + 0.5 * Math.cos(Math.PI * n / denom);
          }
          return cos_vals;
        }
        _extract_fbank_features(waveform) {
          const buffer = new Float32Array(this.config.n_samples);
          buffer.set(waveform);
          const window2 = this.hanning(this.config.n_fft + 1);
          const frames = this.fram_wave(buffer);
          const stft = this.stft(frames, window2);
          const stftData = stft.data;
          const d1 = stft.dims[0] - 1;
          const d2 = stft.dims[1] >> 1;
          const magnitudes = new Float32Array(d1 * d2);
          for (let i = 0; i < d1; ++i) {
            for (let j = 0; j < d2; ++j) {
              let outOffset = i * d2 + j;
              let inOffset = outOffset << 1;
              let magnitude = stftData[inOffset] ** 2 + stftData[inOffset + 1] ** 2;
              magnitudes[outOffset] = magnitude;
            }
          }
          const mel_filters = this.config.mel_filters;
          const num_mel_filters = mel_filters.length;
          const mel_spec = new Float32Array(num_mel_filters * d1);
          let mIndex = 0;
          for (let i = 0; i < num_mel_filters; ++i) {
            const mel_filter = mel_filters[i];
            for (let j = 0; j < d1; ++j) {
              let sum = 0;
              for (let k = 0; k < d2; ++k) {
                sum += mel_filter[k] * magnitudes[j * d2 + k];
              }
              mel_spec[mIndex++] = sum;
            }
          }
          const a_min = 1e-10;
          const log_spec = new Float32Array(mel_spec.length);
          let maxLogSpec = 0;
          for (let i = 0; i < mel_spec.length; i++) {
            const clipped = Math.max(a_min, mel_spec[i]);
            const log10 = Math.log10(clipped);
            log_spec[i] = log10;
            maxLogSpec = Math.max(log10, maxLogSpec);
          }
          for (let i = 0; i < log_spec.length; i++) {
            log_spec[i] = Math.max(log_spec[i], maxLogSpec - 8);
            log_spec[i] = (log_spec[i] + 4) / 4;
          }
          return {
            data: log_spec,
            dims: [num_mel_filters, d1]
          };
        }
        async _call(audio) {
          if (audio.length > this.config.n_samples) {
            console.warn(
              "Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."
            );
          }
          let waveform = audio.slice(0, this.config.n_samples);
          let features = this._extract_fbank_features(waveform);
          return {
            input_features: new Tensor(
              "float32",
              features.data,
              [1, ...features.dims]
            )
          };
        }
      };
      var Processor = class extends Callable {
        constructor(feature_extractor) {
          super();
          this.feature_extractor = feature_extractor;
        }
        async _call(input) {
          return await this.feature_extractor(input);
        }
      };
      var WhisperProcessor = class extends Processor {
        async _call(audio) {
          return await this.feature_extractor(audio);
        }
      };
      module2.exports = {
        AutoProcessor
      };
    }
  });

  // node_modules/@xenova/transformers/src/pipelines.js
  var require_pipelines = __commonJS({
    "node_modules/@xenova/transformers/src/pipelines.js"(exports2, module2) {
      var {
        Callable,
        softmax,
        getTopItems,
        cos_sim,
        pathJoin,
        isString,
        getFile
      } = require_utils();
      var {
        AutoTokenizer
      } = require_tokenizers();
      var {
        AutoModel,
        AutoModelForSequenceClassification,
        AutoModelForQuestionAnswering,
        AutoModelForMaskedLM,
        AutoModelForSeq2SeqLM,
        AutoModelForCausalLM,
        AutoModelForVision2Seq,
        AutoModelForImageClassification
      } = require_models();
      var {
        AutoProcessor
      } = require_processors();
      var {
        env
      } = require_env();
      var { Tensor } = require_tensor_utils();
      var Pipeline = class extends Callable {
        constructor(task, tokenizer, model) {
          super();
          this.task = task;
          this.tokenizer = tokenizer;
          this.model = model;
        }
        async dispose() {
          return await this.model.dispose();
        }
        async _call(texts) {
          let inputs = this.tokenizer(texts, {
            padding: true,
            truncation: true
          });
          let outputs = await this.model(inputs);
          return [inputs, outputs];
        }
      };
      var TextClassificationPipeline = class extends Pipeline {
        async _call(texts, {
          topk = 1
        } = {}) {
          let [inputs, outputs] = await super._call(texts);
          let id2label = this.model.config.id2label;
          let toReturn = [];
          for (let batch of outputs.logits) {
            let scores = getTopItems(softmax(batch.data), topk);
            let vals = scores.map(function(x) {
              return {
                label: id2label[x[0]],
                score: x[1]
              };
            });
            if (topk === 1) {
              toReturn.push(...vals);
            } else {
              toReturn.push(vals);
            }
          }
          return Array.isArray(texts) || topk === 1 ? toReturn : toReturn[0];
        }
      };
      var QuestionAnsweringPipeline = class extends Pipeline {
        async _call(question, context, {
          topk = 1
        } = {}) {
          let inputs = this.tokenizer(question, {
            text_pair: context
          });
          let output = await this.model(inputs);
          let toReturn = [];
          for (let j = 0; j < output.start_logits.dims[0]; ++j) {
            let ids = inputs.input_ids.get(j);
            let sepIndex = ids.indexOf(this.tokenizer.sep_token_id);
            let s1 = Array.from(softmax(output.start_logits.get(j).data)).map((x, i) => [x, i]).filter((x) => x[1] > sepIndex);
            let e1 = Array.from(softmax(output.end_logits.get(j).data)).map((x, i) => [x, i]).filter((x) => x[1] > sepIndex);
            let options = product(s1, e1).filter((x) => x[0][1] <= x[1][1]).map((x) => [x[0][1], x[1][1], x[0][0] * x[1][0]]).sort((a, b) => b[2] - a[2]);
            for (let k = 0; k < Math.min(options.length, topk); ++k) {
              let [start, end, score] = options[k];
              let answer_tokens = [...ids].slice(start, end + 1);
              let answer = this.tokenizer.decode(answer_tokens, {
                skip_special_tokens: true
              });
              toReturn.push({
                answer,
                score
              });
            }
          }
          return topk === 1 ? toReturn[0] : toReturn;
        }
      };
      var FillMaskPipeline = class extends Pipeline {
        async _call(texts, {
          topk = 5
        } = {}) {
          let [inputs, outputs] = await super._call(texts);
          let tokenizer = this.tokenizer;
          let toReturn = [];
          for (let i = 0; i < inputs.input_ids.dims[0]; ++i) {
            let ids = inputs.input_ids.get(i);
            let mask_token_index = ids.indexOf(this.tokenizer.mask_token_id);
            if (mask_token_index === -1) {
              throw Error(`Mask token (${tokenizer.mask_token}) not found in text.`);
            }
            let logits = outputs.logits.get(i);
            let itemLogits = logits.get(mask_token_index);
            let scores = getTopItems(softmax(itemLogits.data), topk);
            toReturn.push(scores.map((x) => {
              let sequence = [...ids];
              sequence[mask_token_index] = x[0];
              return {
                score: x[1],
                token: x[0],
                token_str: tokenizer.model.vocab[x[0]],
                sequence: tokenizer.decode(sequence, { skip_special_tokens: true })
              };
            }));
          }
          return Array.isArray(texts) ? toReturn : toReturn[0];
        }
      };
      var Text2TextGenerationPipeline = class extends Pipeline {
        _key = null;
        async _call(texts, generate_kwargs = {}) {
          if (!Array.isArray(texts)) {
            texts = [texts];
          }
          if (this.model.config.prefix) {
            texts = texts.map((x) => this.model.config.prefix + x);
          }
          let task_specific_params = this.model.config.task_specific_params;
          if (task_specific_params && task_specific_params[this.task]) {
            if (task_specific_params[this.task].prefix) {
              texts = texts.map((x) => task_specific_params[this.task].prefix + x);
            }
          }
          let input_ids = this.tokenizer(texts, {
            padding: true,
            truncation: true
          }).input_ids;
          let outputTokenIds = (await this.model.generate(input_ids, generate_kwargs)).flat();
          let toReturn = this.tokenizer.batch_decode(outputTokenIds, {
            skip_special_tokens: true
          });
          if (this._key !== null) {
            toReturn = toReturn.map((text) => {
              return this._key === null ? text : { [this._key]: text };
            });
          }
          return toReturn;
        }
      };
      var SummarizationPipeline = class extends Text2TextGenerationPipeline {
        _key = "summary_text";
      };
      var TranslationPipeline = class extends Text2TextGenerationPipeline {
        _key = "translation_text";
      };
      var TextGenerationPipeline = class extends Pipeline {
        async _call(texts, generate_kwargs = {}) {
          let stringInput = typeof texts === "string" || texts instanceof String;
          if (stringInput) {
            texts = [texts];
          }
          this.tokenizer.padding_side = "left";
          let inputs = this.tokenizer(texts, {
            padding: true,
            truncation: true
          });
          let input_ids = inputs.input_ids;
          let attention_mask = inputs.attention_mask;
          let outputTokenIds = await this.model.generate(input_ids, generate_kwargs, null, {
            inputs_attention_mask: attention_mask
          });
          let toReturn = outputTokenIds.map((outTokens, i) => {
            let startText = texts[i].trim();
            let decoded = this.tokenizer.batch_decode(outTokens, {
              skip_special_tokens: true
            }).map((x) => {
              return {
                generated_text: startText + x
              };
            });
            return decoded;
          });
          return stringInput && toReturn.length === 1 ? toReturn[0] : toReturn;
        }
      };
      var EmbeddingsPipeline = class extends Pipeline {
        // Should only be used with sentence-transformers
        // If you want to get the raw outputs from the model,
        // use `AutoModel.from_pretrained(...)`
        _mean_pooling(last_hidden_state, attention_mask) {
          let shape = [last_hidden_state.dims[0], last_hidden_state.dims[2]];
          let returnedData = new last_hidden_state.data.constructor(shape[0] * shape[1]);
          let [batchSize, seqLength, embedDim] = last_hidden_state.dims;
          let outIndex = 0;
          for (let i = 0; i < batchSize; ++i) {
            let offset = i * embedDim * seqLength;
            for (let k = 0; k < embedDim; ++k) {
              let sum = 0;
              let count = 0;
              let attnMaskOffset = i * seqLength;
              let offset2 = offset + k;
              for (let j = 0; j < seqLength; ++j) {
                let attn = Number(attention_mask.data[attnMaskOffset + j]);
                count += attn;
                sum += last_hidden_state.data[offset2 + j * embedDim] * attn;
              }
              let avg = sum / count;
              returnedData[outIndex++] = avg;
            }
          }
          return new Tensor(
            last_hidden_state.type,
            returnedData,
            shape
          );
        }
        _normalize(tensor) {
          for (let batch of tensor) {
            let norm = Math.sqrt(batch.data.reduce((a, b) => a + b * b));
            for (let i = 0; i < batch.data.length; ++i) {
              batch.data[i] /= norm;
            }
          }
          return tensor;
        }
        async _call(texts) {
          let [inputs, outputs] = await super._call(texts);
          return this._normalize(this._mean_pooling(outputs.last_hidden_state, inputs.attention_mask));
        }
        cos_sim(arr1, arr2) {
          return cos_sim(arr1, arr2);
        }
      };
      var AutomaticSpeechRecognitionPipeline = class extends Pipeline {
        constructor(task, tokenizer, model, processor) {
          super(task, tokenizer, model);
          this.processor = processor;
        }
        async _preprocess(audio, sampling_rate) {
          if (isString(audio)) {
            if (typeof AudioContext === "undefined") {
              throw Error(
                "Unable to load audio from path/URL since `AudioContext` is not available in your environment. As a result, audio data must be passed directly to the processor. If you are running in node.js, you can use an external library (e.g., https://github.com/audiojs/web-audio-api) to do this."
              );
            }
            const response = await (await getFile(audio)).arrayBuffer();
            const audioCTX = new AudioContext({ sampleRate: sampling_rate });
            const decoded = await audioCTX.decodeAudioData(response);
            const SCALING_FACTOR = Math.sqrt(2);
            let left = decoded.getChannelData(0);
            let right = decoded.getChannelData(1);
            audio = new Float32Array(left.length);
            for (let i = 0; i < decoded.length; i++) {
              audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;
            }
          }
          return audio;
        }
        async _call(audio, kwargs = {}) {
          let return_timestamps = kwargs.return_timestamps ?? false;
          let chunk_length_s = kwargs.chunk_length_s ?? 0;
          let stride_length_s = kwargs.stride_length_s ?? null;
          let chunk_callback = kwargs.chunk_callback ?? null;
          let force_full_sequences = kwargs.force_full_sequences ?? false;
          let single = !Array.isArray(audio);
          if (single) {
            audio = [audio];
          }
          const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
          const time_precision = this.processor.feature_extractor.config.chunk_length / this.model.config.max_source_positions;
          let toReturn = [];
          for (let aud of audio) {
            aud = await this._preprocess(aud, sampling_rate);
            let chunks = [];
            if (chunk_length_s > 0) {
              if (stride_length_s === null) {
                stride_length_s = chunk_length_s / 6;
              } else if (chunk_length_s <= stride_length_s) {
                throw Error("`chunk_length_s` must be larger than `stride_length_s`.");
              }
              const window2 = sampling_rate * chunk_length_s;
              const stride = sampling_rate * stride_length_s;
              const jump = window2 - 2 * stride;
              let offset = 0;
              while (offset < aud.length) {
                let subarr = aud.subarray(offset, offset + window2);
                let feature = await this.processor(subarr);
                let isFirst = offset === 0;
                let isLast = offset + jump >= aud.length;
                chunks.push({
                  stride: [
                    subarr.length,
                    isFirst ? 0 : stride,
                    isLast ? 0 : stride
                  ],
                  input_features: feature.input_features,
                  is_last: isLast
                });
                offset += jump;
              }
            } else {
              chunks = [{
                stride: [aud.length, 0, 0],
                input_features: (await this.processor(aud)).input_features,
                is_last: true
              }];
            }
            for (let chunk of chunks) {
              let data = await this.model.generate(chunk.input_features, kwargs);
              chunk.tokens = data[0].flat();
              chunk.stride = chunk.stride.map((x) => x / sampling_rate);
              if (chunk_callback !== null) {
                chunk_callback(chunk);
              }
            }
            let [full_text, optional] = this.tokenizer._decode_asr(chunks, {
              time_precision,
              return_timestamps,
              force_full_sequences
            });
            toReturn.push({ text: full_text, ...optional });
          }
          return single ? toReturn[0] : toReturn;
        }
      };
      var ImageToTextPipeline = class extends Pipeline {
        constructor(task, tokenizer, model, processor) {
          super(task, tokenizer, model);
          this.processor = processor;
        }
        async _call(images, generate_kwargs = {}) {
          let pixel_values = (await this.processor(images)).pixel_values;
          let toReturn = [];
          for (let batch of pixel_values) {
            batch.dims = [1, ...batch.dims];
            let output = (await this.model.generate(batch, generate_kwargs)).flat();
            let decoded = this.tokenizer.batch_decode(output, {
              skip_special_tokens: true
            }).map((x) => {
              return { generated_text: x.trim() };
            });
            toReturn.push(decoded);
          }
          return Array.isArray(images) ? toReturn : toReturn[0];
        }
      };
      var ImageClassificationPipeline = class extends Pipeline {
        constructor(task, model, processor) {
          super(task, null, model);
          this.processor = processor;
        }
        async _call(images, {
          topk = 1
        } = {}) {
          let inputs = await this.processor(images);
          let output = await this.model(inputs);
          let id2label = this.model.config.id2label;
          let toReturn = [];
          for (let batch of output.logits) {
            let scores = getTopItems(softmax(batch.data), topk);
            let vals = scores.map(function(x) {
              return {
                label: id2label[x[0]],
                score: x[1]
              };
            });
            if (topk === 1) {
              toReturn.push(...vals);
            } else {
              toReturn.push(vals);
            }
          }
          return Array.isArray(images) || topk === 1 ? toReturn : toReturn[0];
        }
      };
      var ZeroShotImageClassificationPipeline = class extends Pipeline {
        constructor(task, tokenizer, model, processor) {
          super(task, tokenizer, model);
          this.processor = processor;
        }
        async _call(images, candidate_labels, {
          hypothesis_template = "This is a photo of {}"
        } = {}) {
          let texts = candidate_labels.map(
            (x) => hypothesis_template.replace("{}", x)
          );
          let text_inputs = this.tokenizer(texts, {
            padding: true,
            truncation: true
          });
          let image_inputs = await this.processor(images);
          let output = await this.model({ ...text_inputs, ...image_inputs });
          let toReturn = [];
          for (let batch of output.logits_per_image) {
            let probs = softmax(batch.data);
            toReturn.push([...probs].map((x, i) => {
              return {
                score: x,
                label: candidate_labels[i]
              };
            }));
          }
          return Array.isArray(images) ? toReturn : toReturn[0];
        }
      };
      var SUPPORTED_TASKS = {
        "text-classification": {
          "tokenizer": AutoTokenizer,
          "pipeline": TextClassificationPipeline,
          "model": AutoModelForSequenceClassification,
          "default": {
            "model": "distilbert-base-uncased-finetuned-sst-2-english"
          },
          "type": "text"
        },
        "question-answering": {
          "tokenizer": AutoTokenizer,
          "pipeline": QuestionAnsweringPipeline,
          "model": AutoModelForQuestionAnswering,
          "default": {
            "model": "distilbert-base-cased-distilled-squad"
          },
          "type": "text"
        },
        "fill-mask": {
          "tokenizer": AutoTokenizer,
          "pipeline": FillMaskPipeline,
          "model": AutoModelForMaskedLM,
          "default": {
            "model": "bert-base-uncased"
          },
          "type": "text"
        },
        "summarization": {
          "tokenizer": AutoTokenizer,
          "pipeline": SummarizationPipeline,
          "model": AutoModelForSeq2SeqLM,
          "default": {
            "model": "sshleifer/distilbart-cnn-6-6"
          },
          "type": "text"
        },
        "translation": {
          "tokenizer": AutoTokenizer,
          "pipeline": TranslationPipeline,
          "model": AutoModelForSeq2SeqLM,
          "default": {
            "model": "t5-small"
          },
          "type": "text"
        },
        "text2text-generation": {
          "tokenizer": AutoTokenizer,
          "pipeline": Text2TextGenerationPipeline,
          "model": AutoModelForSeq2SeqLM,
          "default": {
            "model": "google/flan-t5-small"
          },
          "type": "text"
        },
        "text-generation": {
          "tokenizer": AutoTokenizer,
          "pipeline": TextGenerationPipeline,
          "model": AutoModelForCausalLM,
          "default": {
            "model": "gpt2"
          },
          "type": "text"
        },
        "automatic-speech-recognition": {
          "tokenizer": AutoTokenizer,
          "pipeline": AutomaticSpeechRecognitionPipeline,
          "model": AutoModelForSeq2SeqLM,
          "processor": AutoProcessor,
          "default": {
            "model": "openai/whisper-tiny.en"
          },
          "type": "multimodal"
        },
        "image-to-text": {
          "tokenizer": AutoTokenizer,
          "pipeline": ImageToTextPipeline,
          "model": AutoModelForVision2Seq,
          "processor": AutoProcessor,
          "default": {
            "model": "nlpconnect/vit-gpt2-image-captioning"
          },
          "type": "multimodal"
        },
        "image-classification": {
          // no tokenizer
          "pipeline": ImageClassificationPipeline,
          "model": AutoModelForImageClassification,
          "processor": AutoProcessor,
          "default": {
            "model": "google/vit-base-patch16-224"
          },
          "type": "multimodal"
        },
        "zero-shot-image-classification": {
          // no tokenizer
          "tokenizer": AutoTokenizer,
          "pipeline": ZeroShotImageClassificationPipeline,
          "model": AutoModel,
          "processor": AutoProcessor,
          "default": {
            "model": "openai/clip-vit-base-patch32"
          },
          "type": "multimodal"
        },
        // This task is not supported in HuggingFace transformers, but serves as a useful interface
        // for dealing with sentence-transformers (https://huggingface.co/sentence-transformers)
        "embeddings": {
          "tokenizer": AutoTokenizer,
          "pipeline": EmbeddingsPipeline,
          "model": AutoModel,
          "default": {
            "model": "sentence-transformers/all-MiniLM-L6-v2"
          },
          "type": "text"
        }
      };
      var TASK_NAME_MAPPING = {
        // Fix mismatch between pipeline's task name and exports (folder name)
        "text-classification": "sequence-classification",
        "embeddings": "default",
        "fill-mask": "masked-lm",
        "text2text-generation": "seq2seq-lm-with-past",
        "summarization": "seq2seq-lm-with-past",
        "text-generation": "causal-lm-with-past",
        "automatic-speech-recognition": "speech2seq-lm-with-past",
        "image-to-text": "vision2seq-lm-with-past",
        "zero-shot-image-classification": "default"
      };
      var TASK_PREFIX_MAPPING = {
        // if task starts with one of these, set the corresponding folder name
        "translation": "seq2seq-lm-with-past"
      };
      var TASK_ALIASES = {
        "sentiment-analysis": "text-classification",
        "ner": "token-classification",
        "vqa": "visual-question-answering"
      };
      async function pipeline2(task, model = null, {
        progress_callback = null
      } = {}) {
        task = TASK_ALIASES[task] ?? task;
        let pipelineInfo = SUPPORTED_TASKS[task.split("_", 1)[0]];
        if (!pipelineInfo) {
          throw Error(`Unsupported pipeline: ${task}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`);
        }
        if (!model) {
          model = pipelineInfo.default.model;
          console.log(`No model specified. Using default model: "${model}".`);
        }
        let suffix = TASK_NAME_MAPPING[task];
        if (!suffix) {
          for (const [prefix, mapping] of Object.entries(TASK_PREFIX_MAPPING)) {
            if (task.startsWith(prefix)) {
              suffix = mapping;
              break;
            }
          }
        }
        if (!suffix) {
          suffix = task;
        }
        model = pathJoin(
          env.remoteModels ? env.remoteURL : env.localURL,
          // host prefix
          model,
          // model name
          suffix
          // task suffix
        );
        let tokenizerClass = pipelineInfo.tokenizer;
        let modelClass = pipelineInfo.model;
        let pipelineClass = pipelineInfo.pipeline;
        let processorClass = pipelineInfo.processor;
        let promises = [];
        if (tokenizerClass) {
          promises.push(
            AutoTokenizer.from_pretrained(model, progress_callback)
          );
        }
        if (modelClass) {
          promises.push(
            modelClass.from_pretrained(model, progress_callback)
          );
        }
        if (processorClass) {
          promises.push(
            processorClass.from_pretrained(model, progress_callback)
          );
        }
        let items = await Promise.all(promises);
        return new pipelineClass(task, ...items);
      }
      function product(...a) {
        return a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e])));
      }
      module2.exports = {
        pipeline: pipeline2
      };
    }
  });

  // node_modules/@xenova/transformers/src/transformers.js
  var require_transformers = __commonJS({
    "node_modules/@xenova/transformers/src/transformers.js"(exports2, module2) {
      var {
        AutoTokenizer,
        BertTokenizer,
        DistilBertTokenizer,
        T5Tokenizer,
        GPT2Tokenizer
      } = require_tokenizers();
      var {
        AutoModel,
        AutoModelForSequenceClassification,
        AutoModelForSeq2SeqLM,
        AutoModelForCausalLM,
        AutoModelForMaskedLM,
        AutoModelForQuestionAnswering,
        AutoModelForVision2Seq,
        AutoModelForImageClassification,
        T5ForConditionalGeneration
      } = require_models();
      var {
        AutoProcessor
      } = require_processors();
      var {
        pipeline: pipeline2
      } = require_pipelines();
      var { env } = require_env();
      var moduleExports = {
        // Tokenizers
        AutoTokenizer,
        BertTokenizer,
        DistilBertTokenizer,
        T5Tokenizer,
        GPT2Tokenizer,
        // Models
        AutoModel,
        AutoModelForSeq2SeqLM,
        AutoModelForSequenceClassification,
        AutoModelForCausalLM,
        AutoModelForMaskedLM,
        AutoModelForQuestionAnswering,
        AutoModelForVision2Seq,
        AutoModelForImageClassification,
        T5ForConditionalGeneration,
        // Processors
        AutoProcessor,
        // other
        pipeline: pipeline2,
        // environment variables
        env
      };
      if (typeof self !== "undefined") {
        Object.assign(self, moduleExports);
      }
      module2.exports = moduleExports;
    }
  });

  // ns-hugo:/home/runner/work/j0rd1smit.github.io/j0rd1smit.github.io/assets/js/modelFactories.js
  var import_transformers = __toESM(require_transformers());
  function createModelLoader(model_name) {
    let model = null;
    const load_model = async ({ progress_callback = void 0 }) => {
      if (model === null) {
        model = await (0, import_transformers.pipeline)("automatic-speech-recognition", model_name, {
          progress_callback
        });
      }
      return model;
    };
    return load_model;
  }

  // ns-hugo:/home/runner/work/j0rd1smit.github.io/j0rd1smit.github.io/assets/js/utils.js
  var MessageTypes = {
    DOWNLOADING: "DOWNLOADING",
    LOADING: "LOADING",
    RESULT: "RESULT",
    RESULT_PARTIAL: "RESULT_PARTIAL",
    INFERENCE_REQUEST: "INFERENCE_REQUEST",
    INFERENCE_DONE: "INFERENCE_DONE"
  };
  var ModelNames = {
    WHISPER_TINY_EN: "openai/whisper-tiny.en",
    WHISPER_TINY: "openai/whisper-tiny",
    WHISPER_BASE: "openai/whisper-base",
    WHISPER_BASE_EN: "openai/whisper-base.en",
    WHISPER_SMALL: "openai/whisper-small",
    WHISPER_SMALL_EN: "openai/whisper-small.en"
  };

  // <stdin>
  var modelLoaders = {};
  for (const model_name of Object.values(ModelNames)) {
    modelLoaders[model_name] = createModelLoader(model_name);
  }
  self.addEventListener("message", async (event) => {
    const { type, audio, model_name } = event.data;
    if (type === MessageTypes.INFERENCE_REQUEST) {
      await transcribe(audio, model_name);
    }
  });
  async function transcribe(audio, model_name) {
    sendLoadingMessage("loading", "");
    if (!modelLoaders[model_name]) {
      console.log("Model not found");
      sendLoadingMessage("error", "Model not found");
      return;
    }
    const pipeline2 = await modelLoaders[model_name]({
      callback_function: load_model_callback
    });
    sendLoadingMessage("success");
    const stride_length_s = 5;
    const generationTracker = new GenerationTracker(pipeline2, stride_length_s);
    await pipeline2(audio, {
      top_k: 0,
      // TODO: make this configurable via request
      do_sample: false,
      // TODO: make this configurable via request
      chunk_length_s: 30,
      // TODO: make this configurable via request
      stride_length_s,
      // TODO: make this configurable via request
      return_timestamps: true,
      callback_function: generationTracker.callbackFunction.bind(generationTracker),
      chunk_callback: generationTracker.chunkCallback.bind(generationTracker)
    });
    generationTracker.sendFinalResult();
  }
  async function load_model_callback(data) {
    const { status } = data;
    if (status === "progress") {
      const { file, progress, loaded, total } = data;
      sendDownloadingMessage(file, progress, loaded, total);
    }
    if (status === "done") {
    }
    if (status === "loaded") {
    }
  }
  function sendLoadingMessage(status, message) {
    self.postMessage({
      type: MessageTypes.LOADING,
      status,
      message
    });
  }
  function sendDownloadingMessage(file, progress, loaded, total) {
    self.postMessage({
      type: MessageTypes.DOWNLOADING,
      file,
      progress,
      loaded,
      total
    });
  }
  var GenerationTracker = class {
    constructor(pipeline2, stride_length_s) {
      this.pipeline = pipeline2;
      this.stride_length_s = stride_length_s;
      this.chunks = [];
      this.time_precision = pipeline2.processor.feature_extractor.config.chunk_length / pipeline2.model.config.max_source_positions;
      this.processed_chunks = [];
      this.callbackFunctionCounter = 0;
    }
    sendFinalResult() {
      self.postMessage({ type: MessageTypes.INFERENCE_DONE });
    }
    callbackFunction(beams) {
      this.callbackFunctionCounter += 1;
      if (this.callbackFunctionCounter % 10 !== 0) {
        return;
      }
      const bestBeam = beams[0];
      let text = this.pipeline.tokenizer.decode(bestBeam.output_token_ids, {
        skip_special_tokens: true
      });
      const result = {
        text,
        start: this.getLastChuckTimestamp(),
        end: void 0
      };
      createPartialResultMessage(result);
    }
    chunkCallback(data) {
      this.chunks.push(data);
      const [text, { chunks }] = this.pipeline.tokenizer._decode_asr(
        this.chunks,
        {
          time_precision: this.time_precision,
          return_timestamps: true,
          force_full_sequences: false
        }
      );
      this.processed_chunks = chunks.map(
        (chunk, index) => this.processChunk(chunk, index)
      );
      createResultMessage(
        this.processed_chunks,
        false,
        this.getLastChuckTimestamp()
      );
    }
    getLastChuckTimestamp() {
      if (this.processed_chunks.length === 0) {
        return 0;
      }
      return this.processed_chunks[this.processed_chunks.length - 1].end;
    }
    processChunk(chunk, index) {
      const { text, timestamp } = chunk;
      const [start, end] = timestamp;
      return {
        index,
        text: `${text.trim()} `,
        start: Math.round(start),
        end: Math.round(end) || Math.round(start + 0.9 * this.stride_length_s)
      };
    }
  };
  function createResultMessage(results, isDone, completedUntilTimestamp) {
    self.postMessage({
      type: MessageTypes.RESULT,
      results,
      isDone,
      completedUntilTimestamp
    });
  }
  function createPartialResultMessage(result) {
    self.postMessage({
      type: MessageTypes.RESULT_PARTIAL,
      result
    });
  }
})();
/*! Bundled license information:

onnxruntime-common/dist/ort-common.node.js:
  (*!
   * ONNX Runtime Common v1.14.0
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

onnxruntime-web/dist/ort-web.min.js:
  (*!
  * ONNX Runtime Web v1.14.0
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
  *)

jimp/browser/lib/jimp.js:
  (*! For license information please see jimp.js.LICENSE.txt *)
*/
